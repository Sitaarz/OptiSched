import {
  ActionSheetComponent,
  ActionSheetTemplateDirective,
  ComboBoxComponent,
  DropDownListComponent,
  ItemTemplateDirective,
  MultiSelectComponent,
  TagTemplateDirective
} from "./chunk-CHRFS7SS.js";
import {
  CheckBoxDirective,
  DatePipe,
  FormFieldComponent,
  IntlService,
  NumericTextBoxComponent,
  NumericTextBoxCustomMessagesComponent,
  TextAreaDirective,
  TextBoxDirective,
  drawDOM,
  exportPDF,
  formatDate,
  localeData,
  parseDate
} from "./chunk-PBZYNHK2.js";
import {
  DialogActionsComponent,
  DialogCloseResult,
  DialogComponent,
  DialogContainerService,
  DialogService,
  WindowContainerService,
  WindowService
} from "./chunk-GDCJZ25Z.js";
import {
  ButtonComponent,
  ButtonGroupComponent,
  IconWrapperComponent,
  IconsService,
  PopupService,
  arrowRotateCwIcon,
  arrowsNoRepeatIcon,
  calendarIcon,
  cancelOutlineIcon,
  caretAltDownIcon,
  caretAltLeftIcon,
  caretAltRightIcon,
  caretAltUpIcon,
  chevronLeftIcon,
  chevronRightIcon,
  clockIcon,
  filePdfIcon,
  moreHorizontalIcon,
  saveIcon,
  xIcon
} from "./chunk-32QUGPVL.js";
import {
  LabelComponent,
  LabelDirective
} from "./chunk-OEAX2JFW.js";
import {
  Draggable,
  EventsOutsideAngularDirective,
  KENDO_TOGGLEBUTTONTABSTOP,
  KendoInput,
  Keys,
  MultiTabStop,
  PreventableEvent,
  ResizeBatchService,
  ResizeSensorComponent,
  ScrollbarWidthService,
  ToggleButtonTabStopDirective,
  WatermarkOverlayComponent,
  anyChanged,
  closest,
  focusableSelector,
  guid,
  hasObservers,
  isChanged,
  isControlRequired,
  isDocumentAvailable,
  isObject,
  isObjectPresent,
  isVisible,
  parseAttributes,
  removeHTMLAttributes,
  scrollbarWidth,
  setHTMLAttributes,
  shouldShowValidationUI,
  touchEnabled
} from "./chunk-UUWMJWY3.js";
import {
  ComponentMessages,
  L10N_PREFIX,
  LocalizationService,
  MessageService,
  RTL,
  validatePackage
} from "./chunk-ONV4WVAN.js";
import "./chunk-B3XE4SGL.js";
import "./chunk-TN5QDVQY.js";
import "./chunk-C5FS34BJ.js";
import {
  CheckboxControlValueAccessor,
  DefaultValueAccessor,
  FormControl,
  FormControlDirective,
  FormControlName,
  FormGroup,
  FormGroupDirective,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgControlStatus,
  NgControlStatusGroup,
  ReactiveFormsModule,
  ɵNgNoValidate
} from "./chunk-EILFQ5RU.js";
import {
  AsyncPipe,
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgTemplateOutlet
} from "./chunk-TMDM6YRL.js";
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  LOCALE_ID,
  NgModule,
  NgZone,
  Optional,
  Output,
  Pipe,
  Renderer2,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  forwardRef,
  isDevMode,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-MFMOEI5T.js";
import {
  BehaviorSubject,
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  __assign,
  __export,
  __extends,
  __spreadProps,
  __spreadValues,
  animationFrameScheduler,
  auditTime,
  buffer,
  combineLatest,
  debounceTime,
  distinctUntilChanged,
  filter,
  from,
  fromEvent,
  interval,
  map,
  merge,
  of,
  scan,
  switchMap,
  take,
  takeWhile,
  tap
} from "./chunk-Z6FPT5ZN.js";

// node_modules/@progress/kendo-date-math/dist/es/clone-date.js
var cloneDate = function(date) {
  return date ? new Date(date.getTime()) : null;
};

// node_modules/@progress/kendo-date-math/dist/es/adjust-dst.js
var adjustDST = function(date, hour) {
  var newDate = cloneDate(date);
  if (hour === 0 && newDate.getHours() === 23) {
    newDate.setHours(newDate.getHours() + 2);
  }
  return newDate;
};

// node_modules/@progress/kendo-date-math/dist/es/add-days.js
var addDays = function(date, offset2) {
  var newDate = cloneDate(date);
  newDate.setDate(newDate.getDate() + offset2);
  return adjustDST(newDate, date.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/create-date.js
var createDate = function(year, month, day, hours, minutes, seconds, milliseconds) {
  if (hours === void 0) {
    hours = 0;
  }
  if (minutes === void 0) {
    minutes = 0;
  }
  if (seconds === void 0) {
    seconds = 0;
  }
  if (milliseconds === void 0) {
    milliseconds = 0;
  }
  var date = new Date(year, month, day, hours, minutes, seconds, milliseconds);
  if (year > -1 && year < 100) {
    date.setFullYear(date.getFullYear() - 1900);
  }
  return adjustDST(date, hours);
};

// node_modules/@progress/kendo-date-math/dist/es/last-day-of-month.js
var lastDayOfMonth = function(date) {
  var newDate = createDate(date.getFullYear(), date.getMonth() + 1, 1, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
  return addDays(newDate, -1);
};

// node_modules/@progress/kendo-date-math/dist/es/add-months.js
var MONTHS_LENGTH = 12;
var normalize = function(date, expectedMonth) {
  return date.getMonth() !== expectedMonth ? lastDayOfMonth(addMonths(date, -1)) : date;
};
var addMonths = function(date, offset2) {
  var newDate = cloneDate(date);
  var diff2 = (newDate.getMonth() + offset2) % MONTHS_LENGTH;
  var expectedMonth = (MONTHS_LENGTH + diff2) % MONTHS_LENGTH;
  newDate.setMonth(newDate.getMonth() + offset2);
  return normalize(adjustDST(newDate, date.getHours()), expectedMonth);
};

// node_modules/@progress/kendo-date-math/dist/es/set-year.js
var setYear = function(value2, year) {
  var month = value2.getMonth();
  var candidate = createDate(year, month, value2.getDate(), value2.getHours(), value2.getMinutes(), value2.getSeconds(), value2.getMilliseconds());
  return candidate.getMonth() === month ? candidate : lastDayOfMonth(addMonths(candidate, -1));
};

// node_modules/@progress/kendo-date-math/dist/es/add-years.js
var addYears = function(value2, offset2) {
  return adjustDST(setYear(value2, value2.getFullYear() + offset2), value2.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/add-centuries.js
var addCenturies = function(value2, offset2) {
  return addYears(value2, 100 * offset2);
};

// node_modules/@progress/kendo-date-math/dist/es/add-decades.js
var addDecades = function(value2, offset2) {
  return addYears(value2, 10 * offset2);
};

// node_modules/@progress/kendo-date-math/dist/es/add-weeks.js
var addWeeks = function(date, offset2) {
  return addDays(date, offset2 * 7);
};

// node_modules/@progress/kendo-date-math/dist/es/constants.js
var MS_PER_MINUTE = 6e4;
var MS_PER_HOUR = 36e5;
var MS_PER_DAY = 864e5;

// node_modules/@progress/kendo-date-math/dist/es/direction.enum.js
var Direction;
(function(Direction3) {
  Direction3[Direction3["Forward"] = 1] = "Forward";
  Direction3[Direction3["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));

// node_modules/@progress/kendo-date-math/dist/es/day-of-week.js
var dayOfWeek = function(date, weekDay, direction) {
  if (direction === void 0) {
    direction = Direction.Forward;
  }
  var newDate = cloneDate(date);
  var newDay = (weekDay - newDate.getDay() + 7 * direction) % 7;
  newDate.setDate(newDate.getDate() + newDay);
  return adjustDST(newDate, date.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/day.enum.js
var Day;
(function(Day2) {
  Day2[Day2["Sunday"] = 0] = "Sunday";
  Day2[Day2["Monday"] = 1] = "Monday";
  Day2[Day2["Tuesday"] = 2] = "Tuesday";
  Day2[Day2["Wednesday"] = 3] = "Wednesday";
  Day2[Day2["Thursday"] = 4] = "Thursday";
  Day2[Day2["Friday"] = 5] = "Friday";
  Day2[Day2["Saturday"] = 6] = "Saturday";
})(Day || (Day = {}));

// node_modules/@progress/kendo-date-math/dist/es/normalize-year.js
var normalizeYear = function(value2, year) {
  return setYear(value2, year(value2.getFullYear()));
};

// node_modules/@progress/kendo-date-math/dist/es/first-decade-of-century.js
var firstDecadeOfCentury = function(value2) {
  return normalizeYear(value2, function(y) {
    return y - y % 100;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-centuries.js
var durationInCenturies = function(start, end) {
  return (firstDecadeOfCentury(end).getFullYear() - firstDecadeOfCentury(start).getFullYear()) / 100;
};

// node_modules/@progress/kendo-date-math/dist/es/first-year-of-decade.js
var firstYearOfDecade = function(value2) {
  return normalizeYear(value2, function(y) {
    return y - y % 10;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-decades.js
var durationInDecades = function(start, end) {
  return (firstYearOfDecade(end).getFullYear() - firstYearOfDecade(start).getFullYear()) / 10;
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-months.js
var durationInMonths = function(start, end) {
  return (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-years.js
var durationInYears = function(start, end) {
  return end.getFullYear() - start.getFullYear();
};

// node_modules/@progress/kendo-date-math/dist/es/first-day-in-week.js
var firstDayInWeek = function(date, weekStartDay) {
  if (weekStartDay === void 0) {
    weekStartDay = Day.Sunday;
  }
  var first = cloneDate(date);
  while (first.getDay() !== weekStartDay) {
    first.setDate(first.getDate() - 1);
  }
  return first;
};

// node_modules/@progress/kendo-date-math/dist/es/first-day-of-month.js
var firstDayOfMonth = function(date) {
  return createDate(date.getFullYear(), date.getMonth(), 1, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
};

// node_modules/@progress/kendo-date-math/dist/es/set-month.js
var setMonth = function(value2, month) {
  var day = value2.getDate();
  var candidate = createDate(value2.getFullYear(), month, day, value2.getHours(), value2.getMinutes(), value2.getSeconds(), value2.getMilliseconds());
  return candidate.getDate() === day ? candidate : lastDayOfMonth(addMonths(candidate, -1));
};

// node_modules/@progress/kendo-date-math/dist/es/first-month-of-year.js
var firstMonthOfYear = function(value2) {
  return setMonth(value2, 0);
};

// node_modules/@progress/kendo-date-math/dist/es/get-date.js
var getDate = function(date) {
  return createDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
};

// node_modules/@progress/kendo-date-math/dist/es/is-equal.js
var isEqual = function(candidate, expected) {
  if (!candidate && !expected) {
    return true;
  }
  return candidate && expected && candidate.getTime() === expected.getTime();
};

// node_modules/@progress/kendo-date-math/dist/es/is-equal-date.js
var isEqualDate = function(candidate, expected) {
  if (!candidate && !expected) {
    return true;
  }
  return candidate && expected && isEqual(getDate(candidate), getDate(expected));
};

// node_modules/@progress/kendo-date-math/dist/es/last-decade-of-century.js
var lastDecadeOfCentury = function(value2) {
  return normalizeYear(value2, function(y) {
    return y - y % 100 + 90;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/last-month-of-year.js
var lastMonthOfYear = function(value2) {
  return setMonth(value2, 11);
};

// node_modules/@progress/kendo-date-math/dist/es/last-year-of-decade.js
var lastYearOfDecade = function(value2) {
  return normalizeYear(value2, function(y) {
    return y - y % 10 + 9;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/prev-day-of-week.js
var prevDayOfWeek = function(date, weekDay) {
  return dayOfWeek(date, weekDay, Direction.Backward);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/timezones.js
var timezones = {
  rules: {},
  titles: {},
  zones: {}
};

// node_modules/@progress/kendo-date-math/dist/es/tz/rule-to-date.js
var MONTHS = {
  Jan: 0,
  Feb: 1,
  Mar: 2,
  Apr: 3,
  May: 4,
  Jun: 5,
  Jul: 6,
  Aug: 7,
  Sep: 8,
  Oct: 9,
  Nov: 10,
  Dec: 11
};
var DAYS = {
  Sun: 0,
  Mon: 1,
  Tue: 2,
  Wed: 3,
  Thu: 4,
  Fri: 5,
  Sat: 6
};
var MS_PER_MINUTE2 = 6e4;
var ruleToDate = function(year, rule, zoneOffset) {
  var month = rule[3];
  var on = rule[4];
  var time = rule[5];
  var date;
  var ruleOffset = time[3] === "u" ? -zoneOffset * MS_PER_MINUTE2 : 0;
  if (!isNaN(on)) {
    date = new Date(Date.UTC(year, MONTHS[month], on, time[0], time[1], time[2]) + ruleOffset);
  } else if (on.indexOf("last") === 0) {
    date = new Date(Date.UTC(year, MONTHS[month] + 1, 1, time[0] - 24, time[1], time[2]) + ruleOffset);
    var targetDay = DAYS[on.substr(4, 3)];
    var ourDay = date.getUTCDay();
    date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));
  } else if (on.indexOf(">=") >= 0) {
    date = new Date(Date.UTC(year, MONTHS[month], on.substr(5), time[0], time[1], time[2], 0) + ruleOffset);
    var targetDay = DAYS[on.substr(0, 3)];
    var ourDay = date.getUTCDay();
    date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));
  }
  return date;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/find-rule.js
var CURRENT_UTC_TIME = (/* @__PURE__ */ new Date()).getTime();
var findRule = function(zoneRule, utcTime, zoneOffset) {
  if (utcTime === void 0) {
    utcTime = CURRENT_UTC_TIME;
  }
  if (zoneOffset === void 0) {
    zoneOffset = 0;
  }
  var rules = timezones.rules[zoneRule];
  if (!rules) {
    var time = zoneRule.split(":");
    var offset2 = 0;
    if (time.length > 1) {
      offset2 = time[0] * 60 + Number(time[1]);
    }
    return [-1e6, "max", "-", "Jan", 1, [0, 0, 0], offset2, "-"];
  }
  var year = new Date(utcTime).getUTCFullYear();
  rules = rules.filter(function(currentRule) {
    var from2 = currentRule[0];
    var to = currentRule[1];
    return from2 <= year && (to >= year || from2 === year && to === "only" || to === "max");
  });
  rules.push(utcTime);
  rules.sort(function(a, b) {
    if (typeof a !== "number") {
      a = Number(ruleToDate(year, a, zoneOffset));
    }
    if (typeof b !== "number") {
      b = Number(ruleToDate(year, b, zoneOffset));
    }
    return a - b;
  });
  var rule = rules[rules.indexOf(utcTime) - 1] || rules[rules.length - 1];
  return isNaN(rule) ? rule : null;
};

// node_modules/@progress/kendo-date-math/dist/es/errors.js
var NO_TZ_INFO = "The required {0} timezone information is not provided!";
var formatRegExp = /\{(\d+)}?\}/g;
var flatten = function(arr) {
  return arr.reduce(function(a, b) {
    return a.concat(b);
  }, []);
};
var formatMessage = function(message) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var flattenValues = flatten(values);
  return message.replace(formatRegExp, function(_, index) {
    return flattenValues[parseInt(index, 10)];
  });
};

// node_modules/@progress/kendo-date-math/dist/es/tz/get-zone.js
var getZoneRules = function(timezone) {
  var zones = timezones.zones;
  if (!zones) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  var zoneRules = zones[timezone];
  var result = typeof zoneRules === "string" ? zones[zoneRules] : zoneRules;
  if (!result) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  return result;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/find-zone.js
var findZone = function(timezone, utcTime) {
  if (utcTime === void 0) {
    utcTime = (/* @__PURE__ */ new Date()).getTime();
  }
  if (timezone === "Etc/UTC" || timezone === "Etc/GMT") {
    return [0, "-", "UTC", null];
  }
  var zoneRules = getZoneRules(timezone);
  var idx2 = zoneRules.length - 1;
  for (; idx2 >= 0; idx2--) {
    var until = zoneRules[idx2][3];
    if (until && utcTime > until) {
      break;
    }
  }
  var zone = zoneRules[idx2 + 1];
  if (!zone) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  return zone;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/zone-and-rule.js
var zoneAndRule = function(timezone, date) {
  var utcTime = date.getTime();
  var zone = findZone(timezone, utcTime);
  return {
    rule: findRule(zone[1], utcTime, zone[0]),
    zone
  };
};

// node_modules/@progress/kendo-date-math/dist/es/tz/pad-number.js
var padNumber = function(num, len) {
  if (len === void 0) {
    len = 2;
  }
  var sign = num < 0 ? "-" : "";
  return sign + new Array(len).concat([Math.abs(num)]).join("0").slice(-len);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/abbr-timezone.js
var abbrTimezone = function(timezone, date) {
  if (date === void 0) {
    date = /* @__PURE__ */ new Date();
  }
  if (timezone === "Etc/UTC") {
    return "UTC";
  }
  if (timezone === "Etc/GMT") {
    return "GMT";
  }
  if (timezone === "") {
    return "";
  }
  var _a2 = zoneAndRule(timezone, date), zone = _a2.zone, rule = _a2.rule;
  var base = zone[2];
  if (base.indexOf("/") >= 0) {
    return base.split("/")[rule && +rule[6] ? 1 : 0];
  } else if (base.indexOf("%s") >= 0) {
    return base.replace("%s", !rule || rule[7] === "-" ? "" : rule[7]);
  } else if (base.indexOf("%z") >= 0) {
    var hours = -1 * Math.trunc(zone[0] / 60);
    var hoursPart = padNumber(hours, 2);
    var signPart = hours > 0 ? "+" : "";
    var minutes = Math.abs(Math.trunc(zone[0] % 60));
    var minutesPart = minutes === 0 ? "" : padNumber(minutes, 2);
    return base.replace("%z", "" + signPart + hoursPart + minutesPart);
  }
  return base;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/offset.js
var offset = function(timezone, date) {
  if (date === void 0) {
    date = /* @__PURE__ */ new Date();
  }
  if (timezone === "Etc/UTC" || timezone === "Etc/GMT") {
    return 0;
  }
  if (timezone === "") {
    return date.getTimezoneOffset();
  }
  var _a2 = zoneAndRule(timezone, date), rule = _a2.rule, zone = _a2.zone;
  return parseFloat(rule ? zone[0] - rule[6] : zone[0]);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/timezone-names.js
var timezoneNames = function() {
  return Object.keys(timezones.zones);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/to-local-date.js
function toLocalDate(date) {
  return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
}

// node_modules/@progress/kendo-date-math/dist/es/tz/zoned-date.js
var addMinutes = function(date, minutes) {
  return new Date(date.getTime() + minutes * MS_PER_MINUTE);
};
var addHours = function(date, hours) {
  return new Date(date.getTime() + hours * MS_PER_HOUR);
};
var dayAbbr = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var monthAbbr = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var datePrefix = function(utcDate) {
  return dayAbbr[utcDate.getUTCDay()] + " " + monthAbbr[utcDate.getUTCMonth()];
};
function isZoneMissingHour(date, timezone) {
  var currentOffset = offset(timezone, date);
  var prevHour = addHours(date, -1);
  var prevOffset = offset(timezone, prevHour);
  return currentOffset < prevOffset;
}
function shiftZoneMissingHour(utcDate, timezone) {
  var dstOffset = isZoneMissingHour(utcDate, timezone) ? 1 : 0;
  return addHours(utcDate, dstOffset);
}
function convertTimezoneUTC(utcLocal, fromTimezone, toTimezone) {
  if (fromTimezone === toTimezone) {
    return utcLocal;
  }
  var fromOffset = offset(fromTimezone, utcLocal);
  var toOffset = offset(toTimezone, utcLocal);
  var baseDiff = fromOffset - toOffset;
  var midDate = addMinutes(utcLocal, baseDiff);
  var midOffset = offset(toTimezone, midDate);
  var dstDiff = toOffset - midOffset;
  return addMinutes(utcLocal, baseDiff + dstDiff);
}
function formatOffset(tzOffset) {
  var sign = tzOffset <= 0 ? "+" : "-";
  var value2 = Math.abs(tzOffset);
  var hours = padNumber(Math.floor(value2 / 60));
  var minutes = padNumber(value2 % 60);
  return "GMT" + sign + hours + minutes;
}
var ZonedDate = (
  /** @class */
  function() {
    function ZonedDate2(utcDate, timezone) {
      this._utcDate = cloneDate(utcDate);
      this.timezone = timezone;
      var tzOffset = offset(timezone, utcDate);
      this.timezoneOffset = tzOffset;
      var localDate = shiftZoneMissingHour(utcDate, timezone);
      this._localDate = convertTimezoneUTC(localDate, timezone, "Etc/UTC");
    }
    Object.defineProperty(ZonedDate2.prototype, "cachedLocalDate", {
      /**
       * Returns a cached local date that denotes the exact time in the set timezone.
       *
       * @return Date - A local date that denotes the exact time in the set timezone.
       *
       * This property is an alternative to `toLocalDate()` that returns a cached value instead of cloning it.
       *
       * > Modifying the returned instance will corrupt the `ZonedDate` state.
       */
      get: function() {
        return this._localDate;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZonedDate2.prototype, "cachedUTCDate", {
      /**
       * Returns a cached `Date` instance with UTC date parts that are set to the local time in the set timezone.
       *
       * @returns Date - A `Date` with UTC date parts that are set to the local time in the set timezone.
       *
       * This property is an alternative to `toUTCDate()` that returns a cached value instead of cloning it.
       *
       * > Modifying the returned instance will corrupt the `ZonedDate` state.
       */
      get: function() {
        return this._utcDate;
      },
      enumerable: true,
      configurable: true
    });
    ZonedDate2.fromLocalDate = function(date, timezone) {
      if (timezone === void 0) {
        timezone = "";
      }
      var utcDate = convertTimezoneUTC(date, "Etc/UTC", timezone);
      var shiftZone = isZoneMissingHour(utcDate, timezone);
      var zoneOffset = offset(timezone, utcDate);
      var fixedOffset = 0;
      if (shiftZone) {
        fixedOffset = zoneOffset > 0 ? -1 : 1;
      }
      var adjDate = addHours(utcDate, fixedOffset);
      return ZonedDate2.fromUTCDate(adjDate, timezone);
    };
    ZonedDate2.fromUTCDate = function(utcDate, timezone) {
      if (timezone === void 0) {
        timezone = "";
      }
      return new ZonedDate2(utcDate, timezone);
    };
    ZonedDate2.prototype.toLocalDate = function() {
      return cloneDate(this._localDate);
    };
    ZonedDate2.prototype.toUTCDate = function() {
      return cloneDate(this._utcDate);
    };
    ZonedDate2.prototype.toTimezone = function(toTimezone) {
      if (this.timezone === toTimezone) {
        return this.clone();
      }
      var tzOffset = offset(this.timezone, this._utcDate);
      var date = addMinutes(this._utcDate, tzOffset);
      return ZonedDate2.fromLocalDate(date, toTimezone);
    };
    ZonedDate2.prototype.clone = function() {
      return ZonedDate2.fromUTCDate(this._utcDate, this.timezone);
    };
    ZonedDate2.prototype.addDays = function(days) {
      var newDate = new Date(this._utcDate.getTime());
      newDate.setUTCDate(newDate.getUTCDate() + days);
      return ZonedDate2.fromUTCDate(newDate, this.timezone);
    };
    ZonedDate2.prototype.addTime = function(milliseconds) {
      var utcDate = new Date(this._utcDate.getTime());
      var utcMid = shiftZoneMissingHour(utcDate, this.timezone);
      utcMid.setTime(utcMid.getTime() + milliseconds);
      var utcResult = shiftZoneMissingHour(utcMid, this.timezone);
      return ZonedDate2.fromUTCDate(utcResult, this.timezone);
    };
    ZonedDate2.prototype.stripTime = function() {
      var date = this._utcDate;
      var ticks = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
      return ZonedDate2.fromUTCDate(new Date(ticks), this.timezone);
    };
    ZonedDate2.prototype.getTime = function() {
      return this._localDate.getTime();
    };
    ZonedDate2.prototype.getTimezoneOffset = function() {
      return this.timezoneOffset;
    };
    ZonedDate2.prototype.getFullYear = function() {
      return this._utcDate.getUTCFullYear();
    };
    ZonedDate2.prototype.getMonth = function() {
      return this._utcDate.getUTCMonth();
    };
    ZonedDate2.prototype.getDate = function() {
      return this._utcDate.getUTCDate();
    };
    ZonedDate2.prototype.getDay = function() {
      return this._utcDate.getUTCDay();
    };
    ZonedDate2.prototype.getHours = function() {
      return this._utcDate.getUTCHours();
    };
    ZonedDate2.prototype.getMinutes = function() {
      return this._utcDate.getUTCMinutes();
    };
    ZonedDate2.prototype.getSeconds = function() {
      return this._utcDate.getUTCSeconds();
    };
    ZonedDate2.prototype.getMilliseconds = function() {
      return this._utcDate.getUTCMilliseconds();
    };
    ZonedDate2.prototype.getUTCDate = function() {
      return this._localDate.getUTCDate();
    };
    ZonedDate2.prototype.getUTCDay = function() {
      return this._localDate.getUTCDay();
    };
    ZonedDate2.prototype.getUTCFullYear = function() {
      return this._localDate.getUTCFullYear();
    };
    ZonedDate2.prototype.getUTCHours = function() {
      return this._localDate.getUTCHours();
    };
    ZonedDate2.prototype.getUTCMilliseconds = function() {
      return this._localDate.getUTCMilliseconds();
    };
    ZonedDate2.prototype.getUTCMinutes = function() {
      return this._localDate.getUTCMinutes();
    };
    ZonedDate2.prototype.getUTCMonth = function() {
      return this._localDate.getUTCMonth();
    };
    ZonedDate2.prototype.getUTCSeconds = function() {
      return this._localDate.getUTCSeconds();
    };
    ZonedDate2.prototype.setTime = function(time) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMilliseconds = function(ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMilliseconds = function(ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setSeconds = function(sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCSeconds = function(sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMinutes = function(min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMinutes = function(min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setHours = function(hours, min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCHours = function(hours, min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setDate = function(date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCDate = function(date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMonth = function(month, date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMonth = function(month, date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setFullYear = function(year, month, date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCFullYear = function(year, month, date) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.toISOString = function() {
      return this._localDate.toISOString();
    };
    ZonedDate2.prototype.toJSON = function() {
      return this._localDate.toJSON();
    };
    ZonedDate2.prototype.toString = function() {
      var dateString = datePrefix(this._utcDate);
      var timeString = this.toTimeString();
      return dateString + " " + this.getDate() + " " + this.getFullYear() + " " + timeString;
    };
    ZonedDate2.prototype.toDateString = function() {
      return toLocalDate(this._utcDate).toDateString();
    };
    ZonedDate2.prototype.toTimeString = function() {
      var hours = padNumber(this.getHours());
      var minutes = padNumber(this.getMinutes());
      var seconds = padNumber(this.getSeconds());
      var time = hours + ":" + minutes + ":" + seconds;
      var tzOffset = formatOffset(this.timezoneOffset);
      var abbrev = abbrTimezone(this.timezone, this._utcDate);
      if (abbrev) {
        abbrev = " (" + abbrev + ")";
      }
      return time + " " + tzOffset + abbrev;
    };
    ZonedDate2.prototype.toLocaleString = function(locales, options) {
      return this._localDate.toLocaleString(locales, options);
    };
    ZonedDate2.prototype.toLocaleDateString = function(locales, options) {
      return this._localDate.toLocaleDateString(locales, options);
    };
    ZonedDate2.prototype.toLocaleTimeString = function(locales, options) {
      return this._localDate.toLocaleTimeString(locales, options);
    };
    ZonedDate2.prototype.toUTCString = function() {
      return this.toTimezone("Etc/UTC").toString();
    };
    ZonedDate2.prototype[Symbol.toPrimitive] = function(hint) {
      if (hint === "string" || hint === "default") {
        return this.toString();
      }
      return this._localDate.getTime();
    };
    ZonedDate2.prototype.valueOf = function() {
      return this.getTime();
    };
    ZonedDate2.prototype.getVarDate = function() {
      throw new Error("Not implemented.");
    };
    ZonedDate2.prototype.format = function(_) {
      throw new Error("Not implemented.");
    };
    ZonedDate2.prototype.formatUTC = function(_) {
      throw new Error("Not implemented.");
    };
    return ZonedDate2;
  }()
);

// node_modules/@progress/kendo-date-math/dist/es/week-in-year.js
var moveDateToWeekStart = function(date, weekStartDay) {
  if (weekStartDay !== Day.Monday) {
    return addDays(prevDayOfWeek(date, weekStartDay), 4);
  }
  return addDays(date, 4 - (date.getDay() || 7));
};
var calcWeekInYear = function(date, weekStartDay) {
  var firstWeekInYear = createDate(date.getFullYear(), 0, 1, -6);
  var newDate = moveDateToWeekStart(date, weekStartDay);
  var diffInMS = newDate.getTime() - firstWeekInYear.getTime();
  var days = Math.floor(diffInMS / MS_PER_DAY);
  return 1 + Math.floor(days / 7);
};
var weekInYear = function(date, weekStartDay) {
  if (weekStartDay === void 0) {
    weekStartDay = Day.Monday;
  }
  date = getDate(date);
  var prevWeekDate = addDays(date, -7);
  var nextWeekDate = addDays(date, 7);
  var weekNumber = calcWeekInYear(date, weekStartDay);
  if (weekNumber === 0) {
    return calcWeekInYear(prevWeekDate, weekStartDay) + 1;
  }
  if (weekNumber === 53 && calcWeekInYear(nextWeekDate, weekStartDay) > 1) {
    return 1;
  }
  return weekNumber;
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/mask.js
var Mask = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mask2() {
      this.symbols = "";
      this.partMap = [];
    }
    return Mask2;
  }()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/constants.js
var Constants = {
  formatSeparator: "_",
  twoDigitYearMax: 68,
  defaultDateFormat: "d",
  defaultLocaleId: "en"
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/key.js
var Key = {
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  TAB: "Tab",
  ENTER: "Enter",
  ESCAPE: "Escape",
  ARROW_LEFT: "ArrowLeft",
  ARROW_UP: "ArrowUp",
  ARROW_RIGHT: "ArrowRight",
  ARROW_DOWN: "ArrowDown",
  SPACE: " ",
  END: "End",
  HOME: "Home",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/utils.js
var padZero = function(length2) {
  return new Array(Math.max(length2, 0)).fill("0").join("");
};
var unpadZero = function(value2) {
  return value2.replace(/^0*/, "");
};
var approximateStringMatching = function(_a2) {
  var oldText = _a2.oldText, newText = _a2.newText, formatPattern = _a2.formatPattern, selectionStart = _a2.selectionStart, isInCaretMode = _a2.isInCaretMode, keyEvent = _a2.keyEvent;
  var oldIndex = selectionStart + oldText.length - newText.length;
  var oldTextSeparator = oldText[oldIndex];
  var oldSegmentText = oldText.substring(0, oldIndex);
  var newSegmentText = newText.substring(0, selectionStart);
  var diff2 = [];
  if (oldSegmentText === newSegmentText && selectionStart > 0) {
    diff2.push([formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]);
    return diff2;
  }
  if (oldSegmentText.indexOf(newSegmentText) === 0 && isInCaretMode && (keyEvent.key === Key.DELETE || keyEvent.key === Key.BACKSPACE) || oldSegmentText.indexOf(newSegmentText) === 0 && !isInCaretMode && (newSegmentText.length === 0 || formatPattern[newSegmentText.length - 1] !== formatPattern[newSegmentText.length])) {
    var deletedSymbol = "";
    if (!isInCaretMode && newSegmentText.length === 1) {
      diff2.push([formatPattern[0], newSegmentText[0]]);
    }
    for (var i = newSegmentText.length; i < oldSegmentText.length; i++) {
      if (formatPattern[i] !== deletedSymbol && formatPattern[i] !== Constants.formatSeparator) {
        deletedSymbol = formatPattern[i];
        diff2.push([deletedSymbol, ""]);
      }
    }
    return diff2;
  }
  if (isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator) || !isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator)) {
    var symbol = formatPattern[0];
    for (var i = Math.max(0, oldSegmentText.length - 1); i < formatPattern.length; i++) {
      if (formatPattern[i] !== Constants.formatSeparator) {
        symbol = formatPattern[i];
        break;
      }
    }
    return [[symbol, newSegmentText[selectionStart - 1]]];
  }
  if (newSegmentText[newSegmentText.length - 1] === " " || newSegmentText[newSegmentText.length - 1] === oldTextSeparator && formatPattern[oldIndex] === "_") {
    return [[formatPattern[selectionStart - 1], Constants.formatSeparator]];
  }
  var result = [[formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]];
  return result;
};
var dateSymbolMap = function(map3, part) {
  map3[part.pattern[0]] = part.type;
  return map3;
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/utils.js
var dateSetter = function(method) {
  return function(date, value2) {
    var clone2 = cloneDate(date);
    clone2[method](value2);
    return clone2;
  };
};
var isPresent = function(value2) {
  return value2 !== void 0 && value2 !== null;
};
var isDocumentAvailable2 = function() {
  return !!document;
};
var isNumber = function(value2) {
  return isPresent(value2) && typeof value2 === "number" && !Number.isNaN(value2);
};
var parseToInt = function(value2) {
  return parseInt(value2, 10);
};
var isParseableToInt = function(value2) {
  return isNumber(parseToInt(value2)) && /^[0-9]+$/.test(value2);
};
var clamp = function(value2, min, max) {
  return Math.min(max, Math.max(min, value2));
};
var extend = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return Object.assign.apply(Object, args);
};
var isFunction = function(fn) {
  return typeof fn === "function";
};
var cropTwoDigitYear = function(date) {
  if (!isPresent(date) || isNaN(date.getTime())) {
    return 0;
  }
  return Number(date.getFullYear().toString().slice(-2));
};
var setYears = dateSetter("setFullYear");
var millisecondDigitsInFormat = function(format) {
  var result = format && format.match(/S+(\1)/);
  return result ? result[0].length : 0;
};
var millisecondStepFor = function(digits) {
  return Math.pow(10, 3 - digits);
};
var areDatePartsEqualTo = function(date, year, month, day, hour, minutes, seconds, milliseconds) {
  if (date && date.getFullYear() === year && date.getMonth() === month && date.getDate() === day && date.getHours() === hour && date.getMinutes() === minutes && date.getSeconds() === seconds && date.getMilliseconds() === milliseconds) {
    return true;
  }
  return false;
};
var isValidDate = function(value2) {
  return isPresent(value2) && value2.getTime && isNumber(value2.getTime());
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/dateobject.js
var MONTH_INDEX_FEBRUARY = 1;
var DEFAULT_LEAP_YEAR = 2e3;
var PREVIOUS_CENTURY_BASE = 1900;
var CURRENT_CENTURY_BASE = 2e3;
var SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;
var MONTH_PART_WITH_WORDS_THRESHOLD = 2;
var MONTH_SYMBOL = "M";
var JS_MONTH_OFFSET = 1;
var DateObject = (
  /** @class */
  function() {
    function DateObject2(_a2) {
      var intlService = _a2.intlService, formatPlaceholder = _a2.formatPlaceholder, format = _a2.format, _b = _a2.cycleTime, cycleTime = _b === void 0 ? false : _b, _c = _a2.twoDigitYearMax, twoDigitYearMax = _c === void 0 ? Constants.twoDigitYearMax : _c, _d = _a2.value, value2 = _d === void 0 ? null : _d, _e = _a2.autoCorrectParts, autoCorrectParts = _e === void 0 ? true : _e, _f = _a2.toggleDayPeriod, toggleDayPeriod = _f === void 0 ? false : _f;
      this.year = true;
      this.month = true;
      this.date = true;
      this.hours = true;
      this.minutes = true;
      this.seconds = true;
      this.milliseconds = true;
      this.dayperiod = true;
      this.leadingZero = null;
      this.typedMonthPart = "";
      this.knownParts = "adHhmMsEyS";
      this.symbols = {
        "E": "E",
        "H": "H",
        "M": "M",
        "a": "a",
        "d": "d",
        "h": "h",
        "m": "m",
        "s": "s",
        "y": "y",
        "S": "S"
      };
      this._value = this.getDefaultDate();
      this.cycleTime = false;
      this._partiallyInvalidDate = {
        startDate: null,
        invalidDateParts: {
          "E": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "H": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "M": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "a": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "d": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "h": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "m": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "s": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "y": {
            value: null,
            date: null,
            startDateOffset: 0
          },
          "S": {
            value: null,
            date: null,
            startDateOffset: 0
          }
        }
      };
      this.setOptions({
        intlService,
        formatPlaceholder,
        format,
        cycleTime,
        twoDigitYearMax,
        value: value2,
        autoCorrectParts,
        toggleDayPeriod
      });
      if (!value2) {
        this._value = this.getDefaultDate();
        var sampleFormat = this.dateFormatString(this.value, this.format).symbols;
        for (var i = 0; i < sampleFormat.length; i++) {
          this.setExisting(sampleFormat[i], false);
        }
      } else {
        this._value = cloneDate(value2);
      }
    }
    Object.defineProperty(DateObject2.prototype, "value", {
      get: function() {
        return this._value;
      },
      set: function(value2) {
        if (value2 && !(value2 instanceof Date)) {
          return;
        }
        this._value = value2;
        this.resetInvalidDate();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateObject2.prototype, "localeId", {
      get: function() {
        var localeId = Constants.defaultLocaleId;
        var cldrKeys = Object.keys(this.intl.cldr);
        for (var i = 0; i < cldrKeys.length; i++) {
          var key = cldrKeys[i];
          var value2 = this.intl.cldr[key];
          if (value2.name && value2.calendar && value2.numbers && value2.name !== Constants.defaultLocaleId) {
            localeId = value2.name;
            break;
          }
        }
        return localeId;
      },
      enumerable: true,
      configurable: true
    });
    DateObject2.prototype.setOptions = function(options) {
      this.intl = options.intlService;
      this.formatPlaceholder = options.formatPlaceholder || "wide";
      this.format = options.format;
      this.cycleTime = options.cycleTime;
      this.monthNames = this.allFormattedMonths(this.localeId);
      this.dayPeriods = this.allDayPeriods(this.localeId);
      this.twoDigitYearMax = options.twoDigitYearMax;
      this.autoCorrectParts = options.autoCorrectParts;
      this.toggleDayPeriod = options.toggleDayPeriod;
    };
    DateObject2.prototype.setValue = function(value2) {
      if (!value2) {
        this._value = this.getDefaultDate();
        this.modifyExisting(false);
      } else if (!isEqual(value2, this._value)) {
        this._value = cloneDate(value2);
        this.modifyExisting(true);
      }
      this.resetInvalidDate();
    };
    DateObject2.prototype.hasValue = function() {
      var _this = this;
      var pred = function(a, p) {
        return a || p.type !== "literal" && p.type !== "dayperiod" && _this.getExisting(p.pattern[0]);
      };
      return this.intl.splitDateFormat(this.format, this.localeId).reduce(pred, false);
    };
    DateObject2.prototype.getValue = function() {
      for (var i = 0; i < this.knownParts.length; i++) {
        if (!this.getExisting(this.knownParts[i])) {
          return null;
        }
      }
      return cloneDate(this.value);
    };
    DateObject2.prototype.createDefaultDate = function() {
      return createDate(DEFAULT_LEAP_YEAR, 0, 31);
    };
    DateObject2.prototype.getDefaultDate = function() {
      return getDate(this.createDefaultDate());
    };
    DateObject2.prototype.getFormattedDate = function(format) {
      return this.intl.formatDate(this.getValue(), format, this.localeId);
    };
    DateObject2.prototype.getTextAndFormat = function(customFormat) {
      if (customFormat === void 0) {
        customFormat = "";
      }
      var format = customFormat || this.format;
      var text = this.intl.formatDate(this.value, format, this.localeId);
      var mask = this.dateFormatString(this.value, format);
      if (!this.autoCorrectParts && this._partiallyInvalidDate.startDate) {
        var partiallyInvalidText = "";
        var formattedDate = this.intl.formatDate(this.value, format, this.localeId);
        var formattedDates = this.getFormattedInvalidDates(format);
        for (var i = 0; i < formattedDate.length; i++) {
          var symbol = mask.symbols[i];
          if (mask.partMap[i].type === "literal") {
            partiallyInvalidText += text[i];
          } else if (this.getInvalidDatePartValue(symbol)) {
            var partsForSegment = this.getPartsForSegment(mask, i);
            if (symbol === "M") {
              var datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
              if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {
                partiallyInvalidText += formattedDates[symbol][i];
              } else {
                if (this.getInvalidDatePartValue(symbol)) {
                  var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                  partiallyInvalidText += formattedDatePart;
                  i += partsForSegment.length - 1;
                } else {
                  partiallyInvalidText += formattedDates[symbol][i];
                }
              }
            } else {
              if (this.getInvalidDatePartValue(symbol)) {
                var datePartText = this.getInvalidDatePartValue(symbol).toString();
                var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                partiallyInvalidText += formattedDatePart;
                i += partsForSegment.length - 1;
              } else {
                partiallyInvalidText += formattedDates[symbol][i];
              }
            }
          } else {
            partiallyInvalidText += text[i];
          }
        }
        text = partiallyInvalidText;
      }
      var result = this.merge(text, mask);
      return result;
    };
    DateObject2.prototype.getFormattedInvalidDates = function(customFormat) {
      var _this = this;
      if (customFormat === void 0) {
        customFormat = "";
      }
      var format = customFormat || this.format;
      var formattedDatesForSymbol = {
        "E": "",
        "H": "",
        "M": "",
        "a": "",
        "d": "",
        "h": "",
        "m": "",
        "s": "",
        "y": "",
        "S": ""
      };
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        var date = _this.getInvalidDatePart(key).date;
        if (date) {
          var formattedInvalidDate = _this.intl.formatDate(date, format, _this.localeId);
          formattedDatesForSymbol[key] = formattedInvalidDate;
        }
      });
      return formattedDatesForSymbol;
    };
    DateObject2.prototype.modifyExisting = function(value2) {
      var sampleFormat = this.dateFormatString(this.value, this.format).symbols;
      for (var i = 0; i < sampleFormat.length; i++) {
        this.setExisting(sampleFormat[i], value2);
      }
    };
    DateObject2.prototype.getExisting = function(symbol) {
      switch (symbol) {
        case "y":
          return this.year;
        case "M":
        case "L":
          return this.month;
        case "d":
          return this.date;
        case "E":
          return this.date && this.month && this.year;
        case "h":
        case "H":
          return this.hours;
        case "t":
        case "a":
          return this.dayperiod;
        case "m":
          return this.minutes;
        case "s":
          return this.seconds;
        case "S":
          return this.milliseconds;
        default:
          return true;
      }
    };
    DateObject2.prototype.setExisting = function(symbol, value2) {
      switch (symbol) {
        case "y":
          this.year = value2;
          if (value2 === false) {
            this._value.setFullYear(DEFAULT_LEAP_YEAR);
          }
          break;
        case "M":
          this.month = value2;
          if (value2 === false) {
            if (this.autoCorrectParts) {
              this._value.setMonth(0);
            }
          }
          break;
        case "d":
          this.date = value2;
          break;
        case "h":
        case "H":
          this.hours = value2;
          break;
        case "t":
        case "a":
          this.dayperiod = value2;
          break;
        case "m":
          this.minutes = value2;
          break;
        case "s":
          this.seconds = value2;
          break;
        case "S":
          this.milliseconds = value2;
          break;
        default:
          break;
      }
      if (this.getValue()) {
        this.resetInvalidDate();
      }
    };
    DateObject2.prototype.modifyPart = function(symbol, offset2) {
      if (!isPresent(symbol) || !isPresent(offset2) || offset2 === 0) {
        return;
      }
      var newValue = cloneDate(this.value);
      var timeModified = false;
      var invalidDateFound;
      var isMonth = symbol === "M";
      var isDay = symbol === "d" || symbol === "E";
      var symbolExists = this.getExisting(symbol);
      if (!this.autoCorrectParts && (isDay || isMonth)) {
        var invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};
        var invalidDatePartValue = this.getInvalidDatePartValue(symbol);
        var year = invalidDateParts.y.value || newValue.getFullYear();
        var month = invalidDateParts.M.value || newValue.getMonth();
        var day = invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();
        var hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();
        var minutes = invalidDateParts.m.value || newValue.getMinutes();
        var seconds = invalidDateParts.s.value || newValue.getSeconds();
        var milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();
        switch (symbol) {
          case "y":
            year += offset2;
            break;
          case "M":
            month += offset2;
            break;
          case "d":
          case "E":
            day += offset2;
            break;
          default:
            break;
        }
        if (symbol === "M") {
          if (month < 0 || month > 11) {
            if (symbolExists) {
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return;
            }
          }
          if (!symbolExists) {
            if (month < 0) {
              month = clamp(11 + (month % 11 + 1), 0, 11);
            } else {
              var monthValue = isPresent(invalidDatePartValue) ? month : (offset2 - JS_MONTH_OFFSET) % 12;
              month = clamp(monthValue, 0, 11);
            }
            month = clamp(month, 0, 11);
          }
          month = clamp(month, 0, 11);
        } else if (symbol === "d") {
          if (symbolExists) {
            if (day <= 0 || day > 31) {
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return;
            }
          } else if (!symbolExists) {
            if (isPresent(invalidDatePartValue)) {
              if (day <= 0 || day > 31) {
                this.setExisting(symbol, false);
                this.resetInvalidDateSymbol(symbol);
                return;
              }
            }
            if (offset2 < 0) {
              var dayValue = isPresent(invalidDatePartValue) ? day : 1 + (31 - Math.abs(offset2 % 31));
              day = clamp(dayValue, 1, 31);
            } else {
              var dayValue = isPresent(invalidDatePartValue) ? day : offset2 % 31;
              day = clamp(dayValue, 1, 31);
            }
            day = clamp(day, 1, 31);
          }
        }
        var dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);
        var newValueCandidate = isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) : null;
        var dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);
        if (this.getValue() && areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds)) {
          newValue = cloneDate(dateCandidate);
          this.markDatePartsAsExisting();
        } else if (isMonth && newValueCandidate) {
          if (newValueCandidate.getMonth() === month) {
            if (this.getExisting("d")) {
              if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
              } else {
                invalidDateFound = true;
                this.setInvalidDatePart(symbol, {
                  value: month,
                  date: cloneDate(newValueCandidate),
                  startDateOffset: offset2,
                  startDate: cloneDate(this.value)
                });
                this.setExisting(symbol, false);
              }
            } else if (dateCandidateExists) {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(dateCandidate);
              if (this.getExisting("M") && this.getExisting("y")) {
                this.setExisting("d", true);
                this.resetInvalidDateSymbol("d");
              }
            } else {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(newValueCandidate);
            }
          } else {
            invalidDateFound = true;
            this.setInvalidDatePart(symbol, {
              value: month,
              date: cloneDate(newValueCandidate),
              startDateOffset: offset2,
              startDate: cloneDate(this.value)
            });
            this.setExisting(symbol, false);
          }
        } else if (isDay && newValueCandidate) {
          if (newValueCandidate.getDate() === day) {
            if (this.getExisting("M")) {
              if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
              } else {
                invalidDateFound = true;
                this.setInvalidDatePart(symbol, {
                  value: day,
                  date: cloneDate(newValueCandidate),
                  startDateOffset: offset2,
                  startDate: cloneDate(this.value)
                });
                this.setExisting(symbol, false);
              }
            } else if (dateCandidateExists) {
              newValue = cloneDate(dateCandidate);
              this.resetInvalidDateSymbol(symbol);
              if (this.getExisting("d") && this.getExisting("y")) {
                this.setExisting("M", true);
                this.resetInvalidDateSymbol("M");
              }
            } else {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(newValueCandidate);
            }
          } else {
            invalidDateFound = true;
            this.setInvalidDatePart(symbol, {
              value: day,
              date: cloneDate(this.value),
              startDateOffset: offset2,
              startDate: cloneDate(this.value)
            });
            this.setExisting(symbol, false);
          }
        }
      } else {
        switch (symbol) {
          case "y":
            newValue.setFullYear(newValue.getFullYear() + offset2);
            break;
          case "M":
            newValue = addMonths(this.value, offset2);
            break;
          case "d":
          case "E":
            newValue.setDate(newValue.getDate() + offset2);
            break;
          case "h":
          case "H":
            newValue.setHours(newValue.getHours() + offset2);
            timeModified = true;
            break;
          case "m":
            newValue.setMinutes(newValue.getMinutes() + offset2);
            timeModified = true;
            break;
          case "s":
            newValue.setSeconds(newValue.getSeconds() + offset2);
            timeModified = true;
            break;
          case "S":
            newValue.setMilliseconds(newValue.getMilliseconds() + offset2);
            break;
          case "a":
            var hours = newValue.getHours();
            if (this.toggleDayPeriod) {
              newValue.setHours(hours >= 12 ? hours - 12 : hours + 12);
            } else {
              newValue.setHours(newValue.getHours() + 12 * offset2);
            }
            timeModified = true;
            break;
          default:
            break;
        }
      }
      if (this.shouldNormalizeCentury()) {
        newValue = this.normalizeCentury(newValue);
      }
      if (timeModified && !this.cycleTime && newValue.getDate() !== this._value.getDate()) {
      }
      if (!invalidDateFound) {
        this.setExisting(symbol, true);
        this._value = newValue;
        if (this.getValue()) {
          this.resetInvalidDate();
        }
      }
    };
    DateObject2.prototype.parsePart = function(_a2) {
      var symbol = _a2.symbol, currentChar = _a2.currentChar, resetSegmentValue = _a2.resetSegmentValue, cycleSegmentValue = _a2.cycleSegmentValue, rawInputValue = _a2.rawTextValue, isDeleting = _a2.isDeleting, originalFormat = _a2.originalFormat;
      var isInCaretMode = !cycleSegmentValue;
      var dateParts = this.dateFormatString(this.value, this.format);
      var datePartsLiterals = dateParts.partMap.filter(function(x) {
        return x.type === "literal";
      }).map(function(x, index) {
        return {
          datePartIndex: index,
          type: x.type,
          pattern: x.pattern,
          literal: ""
        };
      });
      var flatDateParts = dateParts.partMap.map(function(x) {
        return {
          type: x.type,
          pattern: x.pattern,
          text: ""
        };
      });
      for (var i = 0; i < datePartsLiterals.length; i++) {
        var datePart = datePartsLiterals[i];
        for (var j = 0; j < datePart.pattern.length; j++) {
          if (datePartsLiterals[i + j]) {
            datePartsLiterals[i + j].literal = datePart.pattern[j];
          }
        }
        i += datePart.pattern.length - 1;
      }
      for (var i = 0; i < flatDateParts.length; i++) {
        var datePart = flatDateParts[i];
        for (var j = 0; j < datePart.pattern.length; j++) {
          if (flatDateParts[i + j]) {
            flatDateParts[i + j].text = datePart.pattern[j];
          }
        }
        i += datePart.pattern.length - 1;
      }
      var shouldResetPart = isInCaretMode && symbol === "M" && dateParts.partMap.filter(function(x) {
        return x.type === "month";
      }).some(function(x) {
        return x.pattern.length > MONTH_PART_WITH_WORDS_THRESHOLD;
      });
      var parseResult = {
        value: null,
        switchToNext: false,
        resetPart: shouldResetPart,
        hasInvalidDatePart: false
      };
      if (!currentChar) {
        if (isInCaretMode) {
          for (var i = 0; i < datePartsLiterals.length; i++) {
            var literal = datePartsLiterals[i].literal;
            var rawValueStartsWithLiteral = rawInputValue.startsWith(literal);
            var rawValueEndsWithLiteral = rawInputValue.endsWith(literal);
            var rawValueHasConsecutiveLiterals = rawInputValue.indexOf(literal + literal) >= 0;
            if (rawValueStartsWithLiteral || rawValueEndsWithLiteral || rawValueHasConsecutiveLiterals) {
              this.resetLeadingZero();
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return extend(parseResult, {
                value: null,
                switchToNext: false
              });
            }
          }
        } else {
          this.resetLeadingZero();
          this.setExisting(symbol, false);
          this.resetInvalidDateSymbol(symbol);
          return extend(parseResult, {
            value: null,
            switchToNext: false
          });
        }
      }
      var baseDate = this.intl.formatDate(this.value, this.format, this.localeId);
      var baseFormat = dateParts.symbols;
      var replaced = false;
      var prefix = "";
      var current = "";
      var datePartText = "";
      var basePrefix = "";
      var baseSuffix = "";
      var suffix = "";
      var convertedBaseFormat = "";
      for (var i = 0; i < flatDateParts.length; i++) {
        convertedBaseFormat += flatDateParts[i].text;
      }
      var hasFixedFormat = this.format === baseFormat || this.format === convertedBaseFormat || this.format === originalFormat || this.format.length === originalFormat.length;
      var datePartStartIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).indexOf(symbol);
      var datePartEndIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).lastIndexOf(symbol);
      var segmentLength = datePartEndIndex - datePartStartIndex + 1;
      var formatToTextLengthDiff = originalFormat.length - rawInputValue.length;
      if (isInCaretMode || !isInCaretMode && !this.autoCorrectParts) {
        for (var i = 0; i < baseDate.length; i++) {
          if (baseFormat[i] === symbol) {
            var existing = this.getExisting(symbol);
            current += existing ? baseDate[i] : "0";
            if (formatToTextLengthDiff > 0) {
              if (datePartText.length + formatToTextLengthDiff < segmentLength) {
                datePartText += rawInputValue[i] || "";
              }
            } else {
              datePartText += rawInputValue[i] || "";
            }
            replaced = true;
          } else if (!replaced) {
            prefix += baseDate[i];
            basePrefix += baseDate[i];
          } else {
            suffix += baseDate[i];
            baseSuffix += baseDate[i];
          }
        }
        if (hasFixedFormat) {
          if (convertedBaseFormat.length < rawInputValue.length) {
            datePartText += currentChar;
          } else if (!isDeleting && originalFormat.length > rawInputValue.length) {
          }
          if (datePartText.length > segmentLength) {
            return extend(parseResult, {
              value: null,
              switchToNext: false
            });
          }
        }
        if (!hasFixedFormat || hasFixedFormat && !this.autoCorrectParts) {
          current = "";
          datePartText = "";
          prefix = "";
          suffix = "";
          replaced = false;
          for (var i = 0; i < originalFormat.length; i++) {
            if (originalFormat[i] === symbol) {
              var existing = this.getExisting(symbol);
              current += existing ? baseDate[i] || "" : "0";
              if (formatToTextLengthDiff > 0) {
                if (datePartText.length + formatToTextLengthDiff < segmentLength) {
                  datePartText += rawInputValue[i] || "";
                }
              } else {
                datePartText += rawInputValue[i] || "";
              }
              replaced = true;
            } else if (!replaced) {
              prefix += rawInputValue[i] || "";
            } else {
              suffix += rawInputValue[i - formatToTextLengthDiff] || "";
            }
          }
          if (originalFormat.length < rawInputValue.length) {
            datePartText += currentChar;
          }
        }
      }
      if (!isInCaretMode) {
        if (this.autoCorrectParts) {
          current = "";
          datePartText = "";
          prefix = "";
          suffix = "";
          replaced = false;
          for (var i = 0; i < baseDate.length; i++) {
            if (baseFormat[i] === symbol) {
              var existing = this.getExisting(symbol);
              current += existing ? baseDate[i] : "0";
              replaced = true;
            } else if (!replaced) {
              prefix += baseDate[i];
            } else {
              suffix += baseDate[i];
            }
          }
        } else {
          current = resetSegmentValue ? datePartText : current;
        }
      }
      var parsedDate = null;
      var month = this.matchMonth(currentChar);
      var dayPeriod = this.matchDayPeriod(currentChar, symbol);
      var isZeroCurrentChar = currentChar === "0";
      var leadingZero = this.leadingZero || {};
      if (isZeroCurrentChar) {
        if (datePartText === "0") {
          datePartText = current;
        }
        var valueNumber = parseToInt(resetSegmentValue ? currentChar : (isInCaretMode ? datePartText : current) + currentChar);
        if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol)) {
          this.incrementLeadingZero(symbol);
        }
      } else {
        this.resetLeadingZero();
      }
      var partPattern = this.partPattern(dateParts.partMap, symbol);
      var patternValue = partPattern ? partPattern.pattern : null;
      var patternLength = this.patternLength(patternValue) || patternValue.length;
      if (isInCaretMode) {
        if (isDeleting && !datePartText) {
          this.setExisting(symbol, false);
          return extend(parseResult, {
            value: null,
            switchToNext: false
          });
        }
      }
      var currentMaxLength = current.length - 3;
      var tryParse = true;
      var middle = isInCaretMode ? datePartText : current;
      for (var i = Math.max(0, currentMaxLength); i <= current.length; i++) {
        if (!tryParse) {
          break;
        }
        middle = resetSegmentValue ? currentChar : isInCaretMode ? datePartText : current.substring(i) + currentChar;
        if (isInCaretMode || !this.autoCorrectParts) {
          tryParse = false;
          middle = unpadZero(middle);
          middle = padZero(patternLength - middle.length) + middle;
        }
        var middleNumber = parseInt(middle, 10);
        var candidateDateString = prefix + middle + suffix;
        parsedDate = this.intl.parseDate(candidateDateString, this.format, this.localeId);
        var autoCorrectedPrefixAndSuffix = false;
        if (isInCaretMode && !isValidDate(parsedDate)) {
          if (this.autoCorrectParts) {
            parsedDate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);
            autoCorrectedPrefixAndSuffix = true;
          }
        }
        var isCurrentCharParsable = !isNaN(parseInt(currentChar, 10)) || isInCaretMode && isDeleting && currentChar === "";
        if (!parsedDate && !isNaN(middleNumber) && isCurrentCharParsable && this.autoCorrectParts) {
          if (symbol === MONTH_SYMBOL && !month) {
            var monthNumber = middleNumber - JS_MONTH_OFFSET;
            if (monthNumber > -1 && monthNumber < 12) {
              parsedDate = cloneDate(this.value);
              parsedDate.setMonth(monthNumber);
              if (parsedDate.getMonth() !== monthNumber) {
                parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));
              }
            }
          }
          if (symbol === "y") {
            parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);
            if ((isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) && this.date && parsedDate.getDate() !== this.value.getDate()) {
              parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));
            }
          }
        }
        if (isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) {
          var peekResult = this.isPeekDateOverflowingDatePart({
            useBasePrefixAndSuffix: autoCorrectedPrefixAndSuffix,
            middle,
            patternValue,
            basePrefix,
            baseSuffix,
            prefix,
            suffix,
            symbol,
            patternLength,
            leadingZero
          });
          var switchToNext = peekResult.switchToNext;
          if (this.shouldNormalizeCentury()) {
            parsedDate = this.normalizeCentury(parsedDate);
          }
          if (symbol === "H" && parsedDate.getHours() >= 12) {
            this.setExisting("a", true);
          }
          this._value = parsedDate;
          this.setExisting(symbol, true);
          this.resetInvalidDateSymbol(symbol);
          if (!this.autoCorrectParts) {
            if (symbol === "M") {
              if (this.getExisting("M") && this.getExisting("y")) {
                this.setExisting("d", true);
                this.resetInvalidDateSymbol("d");
              }
            } else if (symbol === "d") {
              if (this.getExisting("d") && this.getExisting("y")) {
                this.setExisting("M", true);
                this.resetInvalidDateSymbol("M");
              }
            }
            if (!this.hasInvalidDatePart()) {
              this.markDatePartsAsExisting();
              if (!peekResult.peekedDate && peekResult.switchToNext && !this.autoCorrectParts) {
                if (symbol === "M") {
                } else if (symbol === "d") {
                  if (peekResult.parsedPeekedValue === 30 && this.value.getMonth() === MONTH_INDEX_FEBRUARY) {
                    switchToNext = false;
                  }
                }
              }
            }
          }
          return extend(parseResult, {
            value: this.value,
            switchToNext
          });
        }
      }
      if (month) {
        parsedDate = this.intl.parseDate(prefix + month + suffix, this.format, this.localeId);
        if (parsedDate) {
          this._value = parsedDate;
          this.setExisting(symbol, true);
          return extend(parseResult, {
            value: this.value,
            switchToNext: false
          });
        }
      }
      if (dayPeriod) {
        parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format) || this.intl.parseDate(basePrefix + dayPeriod + baseSuffix, this.format);
        if (parsedDate) {
          this._value = parsedDate;
          this.setExisting(symbol, true);
          return extend(parseResult, {
            value: this.value,
            switchToNext: true
          });
        }
      }
      if (isZeroCurrentChar) {
        this.setExisting(symbol, false);
      }
      if (!this.autoCorrectParts) {
        var datePartValue = void 0;
        var textToParse = isInCaretMode ? datePartText : middle;
        var parsedValue = parseToInt(textToParse);
        if (isNumber(parsedValue) && isParseableToInt(textToParse)) {
          if (symbol === "d" && (parsedValue <= 0 || parsedValue > 31) || symbol === "M" && (parsedValue <= 0 || parsedValue > 11)) {
            if (isInCaretMode) {
              return extend(parseResult, {
                value: null,
                switchToNext: false
              });
            } else {
              textToParse = currentChar;
              parsedValue = parseToInt(textToParse);
            }
          }
          if (!isNumber(parsedValue) || !isParseableToInt(textToParse)) {
            return extend(parseResult, {
              value: null,
              switchToNext: false
            });
          }
          datePartValue = symbol === "M" ? parsedValue - JS_MONTH_OFFSET : parsedValue;
          var isMonth = symbol === "M";
          var isDay = symbol === "d";
          var newValue = cloneDate(this._value);
          var invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};
          var year = invalidDateParts.y.value || newValue.getFullYear();
          var month_1 = isMonth ? datePartValue : invalidDateParts.M.value || newValue.getMonth();
          var day = isDay ? datePartValue : invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();
          var hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();
          var minutes = invalidDateParts.m.value || newValue.getMinutes();
          var seconds = invalidDateParts.s.value || newValue.getSeconds();
          var milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();
          var dateCandidate = createDate(year, month_1, day, hour, minutes, seconds, milliseconds);
          var dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month_1, day, hour, minutes, seconds, milliseconds);
          var newValueCandidate = isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month_1 : day) : null;
          var invalidDateFound = false;
          if (isMonth && newValueCandidate) {
            if (newValueCandidate.getMonth() === month_1) {
              if (this.getExisting("d")) {
                if (dateCandidateExists) {
                  newValue = cloneDate(dateCandidate);
                  this.resetInvalidDateSymbol(symbol);
                } else {
                  invalidDateFound = true;
                  this.setInvalidDatePart(symbol, {
                    value: month_1,
                    date: cloneDate(newValueCandidate),
                    startDate: cloneDate(this.value)
                  });
                  this.setExisting(symbol, false);
                }
              } else if (dateCandidateExists) {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(dateCandidate);
                if (this.getExisting("M") && this.getExisting("y")) {
                  this.setExisting("d", true);
                  this.resetInvalidDateSymbol("d");
                }
              } else {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(newValueCandidate);
              }
            } else {
              invalidDateFound = true;
              this.setInvalidDatePart(symbol, {
                value: month_1,
                date: cloneDate(newValueCandidate),
                startDate: cloneDate(this.value)
              });
              this.setExisting(symbol, false);
            }
          } else if (isDay && newValueCandidate) {
            if (newValueCandidate.getDate() === day) {
              if (this.getExisting("M")) {
                if (dateCandidateExists) {
                  newValue = cloneDate(dateCandidate);
                  this.resetInvalidDateSymbol(symbol);
                } else {
                  invalidDateFound = true;
                  this.setInvalidDatePart(symbol, {
                    value: day,
                    date: cloneDate(newValueCandidate),
                    startDate: cloneDate(this.value)
                  });
                  this.setExisting(symbol, false);
                }
              } else if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
                if (this.getExisting("d") && this.getExisting("y")) {
                  this.setExisting("M", true);
                  this.resetInvalidDateSymbol("M");
                }
              } else {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(newValueCandidate);
              }
            } else {
              invalidDateFound = true;
              this.setInvalidDatePart(symbol, {
                value: day,
                date: cloneDate(this.value),
                startDate: cloneDate(this.value)
              });
              this.setExisting(symbol, false);
            }
          }
          if (!invalidDateFound) {
            this.setExisting(symbol, true);
            if (isInCaretMode && !isValidDate(parsedDate)) {
              var valueCandidate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);
              if (isValidDate(valueCandidate)) {
                this._value = valueCandidate;
              }
            } else {
              this._value = newValue;
            }
            if (this.getValue()) {
              this.resetInvalidDate();
            }
          }
          var switchToNext = false;
          if (symbol === "M") {
            if (parsedValue >= 2 || textToParse.length >= 2) {
              switchToNext = true;
            } else {
              switchToNext = false;
            }
          } else {
            if (hasFixedFormat) {
              var peekDateSwitchToNext = this.isPeekDateOverflowingDatePart({
                useBasePrefixAndSuffix: !this.autoCorrectParts,
                middle,
                patternValue,
                basePrefix,
                baseSuffix,
                prefix,
                suffix,
                symbol,
                patternLength,
                leadingZero
              }).switchToNext;
              switchToNext = peekDateSwitchToNext;
            } else {
              switchToNext = textToParse.length > segmentLength;
            }
          }
          return extend(parseResult, {
            value: null,
            switchToNext,
            hasInvalidDatePart: invalidDateFound
          });
        }
      }
      return extend(parseResult, {
        value: null,
        switchToNext: false
      });
    };
    DateObject2.prototype.symbolMap = function(symbol) {
      return this.intl.splitDateFormat(this.format, this.localeId).reduce(dateSymbolMap, {})[symbol];
    };
    DateObject2.prototype.resetLeadingZero = function() {
      var hasLeadingZero = this.leadingZero !== null;
      this.setLeadingZero(null);
      return hasLeadingZero;
    };
    DateObject2.prototype.setLeadingZero = function(leadingZero) {
      this.leadingZero = leadingZero;
    };
    DateObject2.prototype.getLeadingZero = function() {
      return this.leadingZero || {};
    };
    DateObject2.prototype.normalizeCentury = function(date) {
      if (!isPresent(date)) {
        return date;
      }
      var twoDigitYear = cropTwoDigitYear(date);
      var centuryBase = this.getNormalizedCenturyBase(twoDigitYear);
      var normalizedDate = setYears(date, centuryBase + twoDigitYear);
      return normalizedDate;
    };
    DateObject2.prototype.incrementLeadingZero = function(symbol) {
      var leadingZero = this.leadingZero || {};
      leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;
      this.leadingZero = leadingZero;
    };
    DateObject2.prototype.isAbbrMonth = function(parts, symbol) {
      var pattern = this.partPattern(parts, symbol);
      return pattern.type === "month" && pattern.names;
    };
    DateObject2.prototype.partPattern = function(parts, symbol) {
      return parts.filter(function(part) {
        return part.pattern.indexOf(symbol) !== -1;
      })[0];
    };
    DateObject2.prototype.peek = function(value2, pattern) {
      var peekValue = value2.replace(/^0*/, "") + "0";
      return padZero(pattern.length - peekValue.length) + peekValue;
    };
    DateObject2.prototype.matchMonth = function(typedChar) {
      this.typedMonthPart += typedChar.toLowerCase();
      if (this.monthNames.length === 0) {
        return "";
      }
      while (this.typedMonthPart.length > 0) {
        for (var i = 0; i < this.monthNames.length; i++) {
          if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {
            return this.monthNames[i];
          }
        }
        var monthAsNum = parseInt(this.typedMonthPart, 10);
        if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart) {
          return this.monthNames[monthAsNum - 1];
        }
        this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);
      }
      return "";
    };
    DateObject2.prototype.matchDayPeriod = function(typedChar, symbol) {
      var lowerChart = typedChar.toLowerCase();
      if (symbol === "a" && this.dayPeriods) {
        if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {
          return this.dayPeriods.am;
        } else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {
          return this.dayPeriods.pm;
        }
      }
      return "";
    };
    DateObject2.prototype.allFormattedMonths = function(locale) {
      if (locale === void 0) {
        locale = "en";
      }
      var dateFormatParts = this.intl.splitDateFormat(this.format, this.localeId);
      for (var i = 0; i < dateFormatParts.length; i++) {
        if (dateFormatParts[i].type === "month" && dateFormatParts[i].names) {
          return this.intl.dateFormatNames(locale, dateFormatParts[i].names);
        }
      }
      return [];
    };
    DateObject2.prototype.allDayPeriods = function(locale) {
      if (locale === void 0) {
        locale = "en";
      }
      var dateFormatParts = this.intl.splitDateFormat(this.format);
      for (var i = 0; i < dateFormatParts.length; i++) {
        if (dateFormatParts[i].type === "dayperiod" && dateFormatParts[i].names) {
          return this.intl.dateFormatNames(locale, dateFormatParts[i].names);
        }
      }
      return null;
    };
    DateObject2.prototype.patternLength = function(pattern) {
      if (pattern[0] === "y") {
        return 4;
      }
      if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {
        return 2;
      }
      return 0;
    };
    DateObject2.prototype.dateFormatString = function(date, format) {
      var dateFormatParts = this.intl.splitDateFormat(format, this.localeId);
      var parts = [];
      var partMap = [];
      for (var i = 0; i < dateFormatParts.length; i++) {
        var partLength = this.intl.formatDate(date, {
          pattern: dateFormatParts[i].pattern
        }, this.localeId).length;
        while (partLength > 0) {
          parts.push(this.symbols[dateFormatParts[i].pattern[0]] || Constants.formatSeparator);
          partMap.push(dateFormatParts[i]);
          partLength--;
        }
      }
      var returnValue = new Mask();
      returnValue.symbols = parts.join("");
      returnValue.partMap = partMap;
      return returnValue;
    };
    DateObject2.prototype.merge = function(text, mask) {
      var resultText = "";
      var resultFormat = "";
      var format = mask.symbols;
      var processTextSymbolsEnded = false;
      var ignoreFormatSymbolsCount = 0;
      var formattedDates = this.getFormattedInvalidDates(format);
      for (var formatSymbolIndex = format.length - 1; formatSymbolIndex >= 0; formatSymbolIndex--) {
        var partsForSegment = this.getPartsForSegment(mask, formatSymbolIndex);
        if (this.knownParts.indexOf(format[formatSymbolIndex]) === -1 || this.getExisting(format[formatSymbolIndex])) {
          if (this.autoCorrectParts) {
            resultText = text[formatSymbolIndex] + resultText;
          } else {
            if (text.length !== format.length) {
              if (processTextSymbolsEnded) {
                resultText = text[formatSymbolIndex] + resultText;
              } else if (ignoreFormatSymbolsCount > 0) {
                resultText = text[formatSymbolIndex] + resultText;
                ignoreFormatSymbolsCount--;
                if (ignoreFormatSymbolsCount <= 0) {
                  processTextSymbolsEnded = true;
                }
              } else {
                resultText = (text[formatSymbolIndex + text.length - format.length] || "") + resultText;
              }
            } else {
              resultText = text[formatSymbolIndex] + resultText;
            }
          }
          resultFormat = format[formatSymbolIndex] + resultFormat;
        } else {
          var symbol = format[formatSymbolIndex];
          var formatSymbolIndexModifier = 0;
          if (this.autoCorrectParts || !this.autoCorrectParts && !this.getInvalidDatePartValue(symbol)) {
            while (formatSymbolIndex >= 0 && symbol === format[formatSymbolIndex]) {
              formatSymbolIndex--;
            }
            formatSymbolIndex++;
          }
          if (this.leadingZero && this.leadingZero[symbol]) {
            resultText = "0" + resultText;
          } else {
            if (!this.autoCorrectParts && this.getInvalidDatePartValue(symbol)) {
              var datePartText = this.getInvalidDatePartValue(symbol).toString();
              if (symbol === "M") {
                datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {
                  resultText = formattedDates[symbol][formatSymbolIndex] + resultText;
                } else {
                  datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                  var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                  resultText = formattedDatePart + resultText;
                  formatSymbolIndexModifier = partsForSegment.length - 1;
                  ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;
                }
              } else {
                var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                resultText = formattedDatePart + resultText;
                formatSymbolIndexModifier = partsForSegment.length - 1;
                ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;
              }
            } else {
              resultText = this.dateFieldName(mask.partMap[formatSymbolIndex]) + resultText;
            }
          }
          while (resultFormat.length < resultText.length) {
            resultFormat = format[formatSymbolIndex] + resultFormat;
          }
          if (formatSymbolIndexModifier !== 0) {
            formatSymbolIndex = formatSymbolIndex - formatSymbolIndexModifier + (text.length - format.length);
          }
        }
      }
      return {
        text: resultText,
        format: resultFormat
      };
    };
    DateObject2.prototype.dateFieldName = function(part) {
      var formatPlaceholder = this.formatPlaceholder || "wide";
      if (formatPlaceholder[part.type]) {
        return formatPlaceholder[part.type];
      }
      if (formatPlaceholder === "formatPattern") {
        return part.pattern;
      }
      return this.intl.dateFieldName(Object.assign(part, {
        nameType: formatPlaceholder
      }));
    };
    DateObject2.prototype.getNormalizedCenturyBase = function(twoDigitYear) {
      return twoDigitYear > this.twoDigitYearMax ? PREVIOUS_CENTURY_BASE : CURRENT_CENTURY_BASE;
    };
    DateObject2.prototype.shouldNormalizeCentury = function() {
      return this.intl.splitDateFormat(this.format).some(function(part) {
        return part.pattern === "yy";
      });
    };
    DateObject2.prototype.resetInvalidDate = function() {
      var _this = this;
      this._partiallyInvalidDate.startDate = null;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        _this.resetInvalidDatePart(key);
      });
    };
    DateObject2.prototype.resetInvalidDateSymbol = function(symbol) {
      var _this = this;
      this.resetInvalidDatePart(symbol);
      var shouldResetInvalidDate = true;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        if (_this._partiallyInvalidDate.invalidDateParts[key] && isPresent(_this._partiallyInvalidDate.invalidDateParts[key].value)) {
          shouldResetInvalidDate = false;
        }
      });
      if (shouldResetInvalidDate) {
        this.resetInvalidDate();
      }
    };
    DateObject2.prototype.resetInvalidDatePart = function(symbol) {
      if (this._partiallyInvalidDate.invalidDateParts[symbol]) {
        this._partiallyInvalidDate.invalidDateParts[symbol] = {
          value: null,
          date: null,
          startDateOffset: 0
        };
      }
    };
    DateObject2.prototype.getInvalidDatePart = function(symbol) {
      var invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];
      return invalidDatePart || {};
    };
    DateObject2.prototype.getInvalidDatePartValue = function(symbol) {
      var invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];
      return (invalidDatePart || {}).value;
    };
    DateObject2.prototype.setInvalidDatePart = function(symbol, _a2) {
      var _b = _a2.value, value2 = _b === void 0 ? null : _b, _c = _a2.date, date = _c === void 0 ? null : _c, _d = _a2.startDateOffset, startDateOffset = _d === void 0 ? 0 : _d, _e = _a2.startDate, startDate = _e === void 0 ? null : _e;
      if (this._partiallyInvalidDate.invalidDateParts[symbol]) {
        this._partiallyInvalidDate.invalidDateParts[symbol].value = value2;
        this._partiallyInvalidDate.invalidDateParts[symbol].date = date;
        this._partiallyInvalidDate.invalidDateParts[symbol].startDateOffset = startDateOffset;
        this._partiallyInvalidDate.startDate = startDate;
      }
    };
    DateObject2.prototype.hasInvalidDatePart = function() {
      var _this = this;
      var hasInvalidDatePart = false;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        if (_this._partiallyInvalidDate.invalidDateParts[key] && isPresent(_this._partiallyInvalidDate.invalidDateParts[key].value)) {
          hasInvalidDatePart = true;
        }
      });
      return hasInvalidDatePart;
    };
    DateObject2.prototype.modifyDateSymbolWithOffset = function(date, symbol, offset2) {
      var newValue = cloneDate(date);
      var timeModified = false;
      switch (symbol) {
        case "y":
          newValue.setFullYear(newValue.getFullYear() + offset2);
          break;
        case "M":
          newValue = addMonths(this.value, offset2);
          break;
        case "d":
        case "E":
          newValue.setDate(newValue.getDate() + offset2);
          break;
        case "h":
        case "H":
          newValue.setHours(newValue.getHours() + offset2);
          timeModified = true;
          break;
        case "m":
          newValue.setMinutes(newValue.getMinutes() + offset2);
          timeModified = true;
          break;
        case "s":
          newValue.setSeconds(newValue.getSeconds() + offset2);
          timeModified = true;
          break;
        case "S":
          newValue.setMilliseconds(newValue.getMilliseconds() + offset2);
          break;
        case "a":
          newValue.setHours(newValue.getHours() + 12 * offset2);
          timeModified = true;
          break;
        default:
          break;
      }
      return {
        date: newValue,
        timeModified
      };
    };
    DateObject2.prototype.modifyDateSymbolWithValue = function(date, symbol, value2) {
      var newValue = cloneDate(date);
      switch (symbol) {
        case "y":
          newValue.setFullYear(value2);
          break;
        case "M":
          newValue = addMonths(date, value2 - date.getMonth());
          break;
        case "d":
        case "E":
          newValue.setDate(value2);
          break;
        case "h":
        case "H":
          newValue.setHours(value2);
          break;
        case "m":
          newValue.setMinutes(value2);
          break;
        case "s":
          newValue.setSeconds(value2);
          break;
        case "S":
          newValue.setMilliseconds(value2);
          break;
        case "a":
          newValue.setHours(value2);
          break;
        default:
          break;
      }
      return newValue;
    };
    DateObject2.prototype.markDatePartsAsExisting = function() {
      this.modifyExisting(true);
    };
    DateObject2.prototype.getPartsForSegment = function(mask, partIndex) {
      var segmentPart = mask.partMap[partIndex];
      var partsForSegment = [];
      for (var maskPartIndex = partIndex; maskPartIndex < mask.partMap.length; maskPartIndex++) {
        var part = mask.partMap[maskPartIndex];
        if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {
          partsForSegment.push(part);
        } else {
          break;
        }
      }
      for (var maskPartIndex = partIndex - 1; maskPartIndex >= 0; maskPartIndex--) {
        var part = mask.partMap[maskPartIndex];
        if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {
          partsForSegment.unshift(part);
        } else {
          break;
        }
      }
      return partsForSegment;
    };
    DateObject2.prototype.isPeekDateOverflowingDatePart = function(_a2) {
      var useBasePrefixAndSuffix = _a2.useBasePrefixAndSuffix, middle = _a2.middle, patternValue = _a2.patternValue, basePrefix = _a2.basePrefix, baseSuffix = _a2.baseSuffix, prefix = _a2.prefix, suffix = _a2.suffix, symbol = _a2.symbol, patternLength = _a2.patternLength, leadingZero = _a2.leadingZero;
      var peekedValue = this.peek(middle, patternValue);
      var peekedDateString = useBasePrefixAndSuffix ? "" + basePrefix + peekedValue + baseSuffix : "" + prefix + peekedValue + suffix;
      var peekedDate = this.intl.parseDate(peekedDateString, this.format, this.localeId);
      var leadingZeroOffset = (this.leadingZero || {})[symbol] || 0;
      var patternSatisfied = leadingZeroOffset + unpadZero(middle).length >= patternLength;
      var parsedPeekedValue = parseToInt(peekedValue);
      if (symbol === "M") {
      } else if (symbol === "d") {
      }
      var switchToNext = peekedDate === null || (leadingZero[symbol] ? patternValue.length <= middle.length : patternSatisfied);
      return {
        peekedDate,
        peekedDateString,
        peekedValue,
        parsedPeekedValue,
        switchToNext
      };
    };
    return DateObject2;
  }()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/keycode.js
var KeyCode = {
  BACKSPACE: 8,
  DELETE: 46,
  TAB: 9,
  ENTER: 13,
  ESCAPE: 27,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  SPACE: 32,
  END: 35,
  HOME: 36,
  PAGE_UP: 33,
  PAGE_DOWN: 34
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/observable.js
var defaultOptions = {
  events: {}
};
var Observable2 = (
  /** @class */
  function() {
    function Observable3(options) {
      this.options = extend({}, defaultOptions, options);
    }
    Observable3.prototype.destroy = function() {
    };
    Observable3.prototype.trigger = function(eventName, args) {
      if (args === void 0) {
        args = {};
      }
      var eventData = {
        defaultPrevented: false,
        preventDefault: function() {
          eventData.defaultPrevented = true;
        }
      };
      if (isFunction(this.options.events[eventName])) {
        this.options.events[eventName](extend(eventData, args, {
          sender: this
        }));
        return eventData.defaultPrevented;
      }
      return false;
    };
    return Observable3;
  }()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/interaction-mode.js
var DateInputInteractionMode;
(function(DateInputInteractionMode2) {
  DateInputInteractionMode2["None"] = "none";
  DateInputInteractionMode2["Caret"] = "caret";
  DateInputInteractionMode2["Selection"] = "selection";
})(DateInputInteractionMode || (DateInputInteractionMode = {}));

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/dateinput.js
var _a;
var DEFAULT_SEGMENT_STEP = 1;
var DRAG_START = "dragStart";
var DROP = "drop";
var TOUCH_START = "touchstart";
var MOUSE_DOWN = "mousedown";
var MOUSE_UP = "mouseup";
var CLICK = "click";
var INPUT = "input";
var KEY_DOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var PASTE = "paste";
var MOUSE_SCROLL = "DOMMouseScroll";
var MOUSE_WHEEL = "mousewheel";
var VALUE_CHANGE = "valueChange";
var INPUT_END = "inputEnd";
var BLUR_END = "blurEnd";
var FOCUS_END = "focusEnd";
var CHANGE = "change";
var defaultDateInputOptions = {
  format: "d",
  hasPlaceholder: false,
  placeholder: null,
  cycleTime: true,
  locale: null,
  steps: {
    millisecond: DEFAULT_SEGMENT_STEP,
    second: DEFAULT_SEGMENT_STEP,
    minute: DEFAULT_SEGMENT_STEP,
    hour: DEFAULT_SEGMENT_STEP,
    day: DEFAULT_SEGMENT_STEP,
    month: DEFAULT_SEGMENT_STEP,
    year: DEFAULT_SEGMENT_STEP
  },
  formatPlaceholder: null,
  events: (_a = {}, _a[VALUE_CHANGE] = null, _a[INPUT] = null, _a[INPUT_END] = null, _a[FOCUS] = null, _a[FOCUS_END] = null, _a[BLUR] = null, _a[BLUR_END] = null, _a[KEY_DOWN] = null, _a[MOUSE_WHEEL] = null, _a[CHANGE] = null, _a),
  selectNearestSegmentOnFocus: false,
  selectPreviousSegmentOnBackspace: false,
  enableMouseWheel: false,
  allowCaretMode: false,
  autoSwitchParts: true,
  autoSwitchKeys: [],
  twoDigitYearMax: Constants.twoDigitYearMax,
  autoCorrectParts: true,
  autoFill: false,
  toggleDayPeriod: false
};
var DateInput = (
  /** @class */
  function(_super) {
    __extends(DateInput2, _super);
    function DateInput2(element, options) {
      var _this = _super.call(this, options) || this;
      _this.dateObject = null;
      _this.currentText = "";
      _this.currentFormat = "";
      _this.interactionMode = DateInputInteractionMode.None;
      _this.previousElementSelection = {
        start: 0,
        end: 0
      };
      _this.init(element, options);
      return _this;
    }
    Object.defineProperty(DateInput2.prototype, "value", {
      get: function() {
        return this.dateObject && this.dateObject.getValue();
      },
      enumerable: true,
      configurable: true
    });
    DateInput2.prototype.init = function(element, options) {
      var dateValue = isValidDate(this.options.value) ? cloneDate(this.options.value) : new Date(options.formattedValue);
      if (!isValidDate(dateValue)) {
        dateValue = null;
      }
      this.element = element;
      this.options = extend({}, defaultDateInputOptions, options, {
        steps: __assign({}, defaultDateInputOptions.steps, options.steps)
      });
      this.intl = this.options.intlService;
      this.dateObject = this.createDateObject();
      this.dateObject.setValue(dateValue);
      this.setTextAndFormat();
      this.bindEvents();
      this.resetSegmentValue = true;
      this.interactionMode = DateInputInteractionMode.None;
      this.forceUpdate();
    };
    DateInput2.prototype.destroy = function() {
      this.unbindEvents();
      this.dateObject = null;
      _super.prototype.destroy.call(this);
    };
    DateInput2.prototype.bindEvents = function() {
      this.onElementDragStart = this.onElementDragStart.bind(this);
      this.element.addEventListener(DRAG_START, this.onElementDragStart);
      this.onElementDrop = this.onElementDrop.bind(this);
      this.element.addEventListener(DROP, this.onElementDrop);
      this.onElementClick = this.onElementClick.bind(this);
      this.element.addEventListener(CLICK, this.onElementClick);
      this.onElementMouseDown = this.onElementMouseDown.bind(this);
      this.element.addEventListener(MOUSE_DOWN, this.onElementMouseDown);
      this.element.addEventListener(TOUCH_START, this.onElementMouseDown);
      this.onElementMouseUp = this.onElementMouseUp.bind(this);
      this.element.addEventListener(MOUSE_UP, this.onElementMouseUp);
      this.onElementInput = this.onElementInput.bind(this);
      this.element.addEventListener(INPUT, this.onElementInput);
      this.onElementKeyDown = this.onElementKeyDown.bind(this);
      this.element.addEventListener(KEY_DOWN, this.onElementKeyDown);
      this.onElementFocus = this.onElementFocus.bind(this);
      this.element.addEventListener(FOCUS, this.onElementFocus);
      this.onElementBlur = this.onElementBlur.bind(this);
      this.element.addEventListener(BLUR, this.onElementBlur);
      this.onElementChange = this.onElementChange.bind(this);
      this.element.addEventListener(CHANGE, this.onElementChange);
      this.onElementPaste = this.onElementPaste.bind(this);
      this.element.addEventListener(PASTE, this.onElementPaste);
      this.onElementMouseWheel = this.onElementMouseWheel.bind(this);
      this.element.addEventListener(MOUSE_SCROLL, this.onElementMouseWheel);
      this.element.addEventListener(MOUSE_WHEEL, this.onElementMouseWheel);
    };
    DateInput2.prototype.unbindEvents = function() {
      this.element.removeEventListener(DRAG_START, this.onElementDragStart);
      this.element.removeEventListener(DROP, this.onElementDrop);
      this.element.removeEventListener(TOUCH_START, this.onElementMouseDown);
      this.element.removeEventListener(MOUSE_DOWN, this.onElementMouseDown);
      this.element.removeEventListener(MOUSE_UP, this.onElementMouseUp);
      this.element.removeEventListener(CLICK, this.onElementClick);
      this.element.removeEventListener(INPUT, this.onElementInput);
      this.element.removeEventListener(KEY_DOWN, this.onElementKeyDown);
      this.element.removeEventListener(FOCUS, this.onElementFocus);
      this.element.removeEventListener(BLUR, this.onElementBlur);
      this.element.removeEventListener(CHANGE, this.onElementChange);
      this.element.removeEventListener(PASTE, this.onElementPaste);
      this.element.removeEventListener(MOUSE_SCROLL, this.onElementMouseWheel);
      this.element.removeEventListener(MOUSE_WHEEL, this.onElementMouseWheel);
    };
    DateInput2.prototype.setOptions = function(options, refresh) {
      if (refresh === void 0) {
        refresh = false;
      }
      this.options = extend({}, this.options, options, {
        steps: __assign({}, defaultDateInputOptions.steps, options.steps)
      });
      this.setDateObjectOptions();
      if (refresh) {
        this.unbindEvents();
        this.init(this.element, this.options);
      }
    };
    DateInput2.prototype.setDateObjectOptions = function() {
      if (this.dateObject) {
        var newOptions = this.getDateObjectOptions();
        this.dateObject.setOptions(newOptions);
      }
    };
    DateInput2.prototype.resetLocale = function() {
      this.unbindEvents();
      this.init(this.element, this.options);
    };
    DateInput2.prototype.isInCaretMode = function() {
      return this.interactionMode === DateInputInteractionMode.Caret;
    };
    DateInput2.prototype.focus = function() {
      this.element.focus();
      if (this.options.selectNearestSegmentOnFocus) {
        this.selectNearestSegment(0);
      }
    };
    DateInput2.prototype.onElementDragStart = function(e) {
      e.preventDefault();
    };
    DateInput2.prototype.onElementDrop = function(e) {
      e.preventDefault();
    };
    DateInput2.prototype.onElementMouseDown = function() {
      this.mouseDownStarted = true;
      this.focusedPriorToMouseDown = this.isActive;
    };
    DateInput2.prototype.onElementMouseUp = function(e) {
      this.mouseDownStarted = false;
      e.preventDefault();
    };
    DateInput2.prototype.onElementClick = function(e) {
      this.mouseDownStarted = false;
      this.switchedPartOnPreviousKeyAction = false;
      var selection = this.selection;
      if (this.isInCaretMode()) {
        this.forceUpdate();
      }
      if (e.detail === 3) {
      } else {
        if (this.isActive && this.options.selectNearestSegmentOnFocus) {
          var selectionPresent = this.element.selectionStart !== this.element.selectionEnd;
          var placeholderToggled = isPresent(this.options.placeholder) && !this.dateObject.hasValue() && !this.focusedPriorToMouseDown;
          var selectFirstSegment = !selectionPresent && placeholderToggled;
          var index = selectFirstSegment ? 0 : this.caret()[0];
          this.selectNearestSegment(index);
        } else {
          this.setSelection(this.selectionByIndex(selection.start));
        }
      }
    };
    DateInput2.prototype.onElementInput = function(e) {
      this.triggerInput({
        event: e
      });
      var oldElementValue = this.elementValue;
      if (!this.element || !this.dateObject) {
        return;
      }
      var switchedPartOnPreviousKeyAction = this.switchedPartOnPreviousKeyAction;
      if (this.isPasteInProgress) {
        if (this.options.allowCaretMode) {
          this.resetSegmentValue = false;
        }
        this.updateOnPaste(e);
        this.isPasteInProgress = false;
        return;
      }
      var keyDownEvent = this.keyDownEvent || {};
      var isBackspaceKey = keyDownEvent.keyCode === KeyCode.BACKSPACE || keyDownEvent.key === Key.BACKSPACE;
      var isDeleteKey = keyDownEvent.keyCode === KeyCode.DELETE || keyDownEvent.key === Key.DELETE;
      var originalInteractionMode = this.interactionMode;
      if (this.options.allowCaretMode && originalInteractionMode !== DateInputInteractionMode.Caret && !isDeleteKey && !isBackspaceKey) {
        this.resetSegmentValue = true;
      }
      if (this.options.allowCaretMode) {
        this.interactionMode = DateInputInteractionMode.Caret;
      } else {
        this.interactionMode = DateInputInteractionMode.Selection;
      }
      var hasCaret = this.isInCaretMode();
      if (hasCaret && this.keyDownEvent.key === Key.SPACE) {
        this.restorePreviousInputEventState();
        return;
      }
      var oldExistingDateValue = this.dateObject && this.dateObject.getValue();
      var oldDateValue = this.dateObject ? this.dateObject.value : null;
      var _a2 = this.dateObject.getTextAndFormat(), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      var oldText = "";
      if (hasCaret) {
        if (isBackspaceKey || isDeleteKey) {
          oldText = this.previousElementValue;
        } else if (originalInteractionMode === DateInputInteractionMode.Caret) {
          oldText = this.previousElementValue;
        } else {
          oldText = currentText;
        }
      } else {
        oldText = currentText;
      }
      var newText = this.elementValue;
      var diff2 = approximateStringMatching({
        oldText,
        newText,
        formatPattern: this.currentFormat,
        selectionStart: this.selection.start,
        isInCaretMode: hasCaret,
        keyEvent: this.keyDownEvent
      });
      if (diff2 && diff2.length && diff2[0] && diff2[0][1] !== Constants.formatSeparator) {
        this.switchedPartOnPreviousKeyAction = false;
      }
      if (hasCaret && (!diff2 || diff2.length === 0)) {
        this.restorePreviousInputEventState();
        return;
      } else if (hasCaret && diff2.length === 1) {
        if (!diff2[0] || !diff2[0][0]) {
          this.restorePreviousInputEventState();
          return;
        } else if (hasCaret && diff2[0] && (diff2[0][0] === Constants.formatSeparator || diff2[0][1] === Constants.formatSeparator)) {
          this.restorePreviousInputEventState();
          return;
        }
      }
      var navigationOnly = diff2.length === 1 && diff2[0][1] === Constants.formatSeparator;
      var parsePartsResults = [];
      var switchPart = false;
      var error2 = null;
      if (!navigationOnly) {
        for (var i = 0; i < diff2.length; i++) {
          var parsePartResult = this.dateObject.parsePart({
            symbol: diff2[i][0],
            currentChar: diff2[i][1],
            resetSegmentValue: this.resetSegmentValue,
            cycleSegmentValue: !this.isInCaretMode(),
            rawTextValue: this.element.value,
            isDeleting: isBackspaceKey || isDeleteKey,
            originalFormat: this.currentFormat
          });
          parsePartsResults.push(parsePartResult);
          if (!parsePartResult.value) {
            error2 = {
              type: "parse"
            };
          }
          switchPart = parsePartResult.switchToNext;
        }
      }
      if (!this.options.autoSwitchParts) {
        switchPart = false;
      }
      this.resetSegmentValue = false;
      var hasFixedFormat = this.options.format === this.currentFormat || // all not fixed formats are 1 symbol, e.g. "d"
      isPresent(this.options.format) && this.options.format.length > 1;
      var lastParseResult = parsePartsResults[parsePartsResults.length - 1];
      var lastParseResultHasNoValue = lastParseResult && !isPresent(lastParseResult.value);
      var parsingFailedOnDelete = hasCaret && (isBackspaceKey || isDeleteKey) && lastParseResultHasNoValue;
      var resetPart = lastParseResult ? lastParseResult.resetPart : false;
      var newExistingDateValue = this.dateObject.getValue();
      var hasExistingDateValueChanged = !isEqual(oldExistingDateValue, newExistingDateValue);
      var newDateValue = this.dateObject.value;
      var symbolForSelection;
      var currentSelection = this.selection;
      if (hasCaret) {
        var diffChar = diff2 && diff2.length > 0 ? diff2[0][0] : null;
        var hasLeadingZero = this.dateObject.getLeadingZero()[diffChar];
        if (diff2.length && diff2[0][0] !== Constants.formatSeparator) {
          if (switchPart) {
            this.forceUpdateWithSelection();
            this.switchDateSegment(1);
          } else if (resetPart) {
            symbolForSelection = this.currentFormat[currentSelection.start];
            if (symbolForSelection) {
              this.forceUpdate();
              this.setSelection(this.selectionBySymbol(symbolForSelection));
            } else {
              this.restorePreviousInputEventState();
            }
          } else if (parsingFailedOnDelete) {
            this.forceUpdate();
            if (diff2.length && diff2[0][0] !== Constants.formatSeparator) {
              this.setSelection(this.selectionBySymbol(diff2[0][0]));
            }
          } else if (lastParseResultHasNoValue) {
            if (e.data === "0" && hasLeadingZero) {
            } else if (isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {
              this.restorePreviousInputEventState();
            } else if (!isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {
              this.forceUpdateWithSelection();
            } else if (isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {
              if (hasExistingDateValueChanged) {
                this.forceUpdateWithSelection();
              } else {
                this.restorePreviousInputEventState();
              }
            } else if (!isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {
              this.forceUpdateWithSelection();
            } else if (oldDateValue !== newDateValue) {
            } else {
              this.restorePreviousInputEventState();
            }
          } else if (!lastParseResultHasNoValue) {
            if (!hasFixedFormat) {
              this.forceUpdateWithSelection();
            }
          }
        } else {
          if (!this.options.autoSwitchParts && diff2[0][1] === Constants.formatSeparator) {
          } else {
            this.setSelection(this.selectionBySymbol(diff2[0][0]));
          }
        }
      } else if (!hasCaret) {
        this.forceUpdate();
        if (diff2.length && diff2[0][0] !== Constants.formatSeparator) {
          this.setSelection(this.selectionBySymbol(diff2[0][0]));
        }
        if (this.options.autoSwitchParts) {
          if (navigationOnly) {
            this.resetSegmentValue = true;
            if (!switchedPartOnPreviousKeyAction) {
              this.switchDateSegment(1);
            }
            this.switchedPartOnPreviousKeyAction = true;
          } else if (switchPart) {
            this.switchDateSegment(1);
            this.switchedPartOnPreviousKeyAction = true;
          }
        } else {
          if (lastParseResult && lastParseResult.switchToNext) {
            this.resetSegmentValue = true;
          } else if (navigationOnly) {
            this.resetSegmentValue = true;
            if (!switchedPartOnPreviousKeyAction) {
              this.switchDateSegment(1);
            }
            this.switchedPartOnPreviousKeyAction = true;
          }
        }
        if (isBackspaceKey && this.options.selectPreviousSegmentOnBackspace) {
          this.switchDateSegment(-1);
        }
      }
      this.tryTriggerValueChange({
        oldValue: oldExistingDateValue,
        event: e
      });
      this.triggerInputEnd({
        event: e,
        error: error2,
        oldElementValue,
        newElementValue: this.elementValue
      });
      if (hasCaret) {
        this.setTextAndFormat();
      }
    };
    DateInput2.prototype.onElementFocus = function(e) {
      if (this.triggerFocus({
        event: e
      })) {
        return;
      }
      this.isActive = true;
      this.interactionMode = DateInputInteractionMode.None;
      this.switchedPartOnPreviousKeyAction = false;
      this.refreshElementValue();
      if (!this.mouseDownStarted) {
        this.caret(0, this.elementValue.length);
      }
      this.mouseDownStarted = false;
      this.triggerFocusEnd({
        event: e
      });
    };
    DateInput2.prototype.onElementBlur = function(e) {
      this.resetSegmentValue = true;
      this.isActive = false;
      if (this.triggerBlur({
        event: e
      })) {
        return;
      }
      if (this.options.autoFill) {
        this.autoFill();
      }
      this.interactionMode = DateInputInteractionMode.None;
      this.switchedPartOnPreviousKeyAction = false;
      this.refreshElementValue();
      this.triggerBlurEnd({
        event: e
      });
    };
    DateInput2.prototype.onElementChange = function(e) {
      this.triggerChange({
        event: e
      });
    };
    DateInput2.prototype.onElementKeyDown = function(e) {
      if (this.triggerKeyDown({
        event: e
      })) {
        return;
      }
      var _a2 = this.selection, start = _a2.start, end = _a2.end;
      var event2 = e;
      this.keyDownEvent = e;
      this.previousElementValue = this.element.value;
      this.previousElementSelection = {
        start,
        end
      };
      if (this.keyEventMatchesAutoSwitchKeys(e)) {
        var isTabKey = e.keyCode === KeyCode.TAB;
        if (isTabKey) {
          var _b = this.selection, selectionStart = _b.start, selectionEnd = _b.end;
          if (e.shiftKey && isTabKey) {
            this.switchDateSegment(-1);
          } else {
            this.switchDateSegment(1);
          }
          if (selectionStart !== this.selection.start || selectionEnd !== this.selection.end) {
            e.preventDefault();
            return;
          }
        } else {
          e.preventDefault();
          this.switchDateSegment(1);
          return;
        }
      }
      var symbol = this.currentFormat[this.selection.start];
      var step = this.getStepFromSymbol(symbol);
      var shouldPreventDefault = false;
      var oldElementValue = this.elementValue;
      if (e.altKey || e.ctrlKey || e.metaKey || e.keyCode === KeyCode.TAB) {
        return;
      }
      switch (e.keyCode) {
        case KeyCode.ARROW_LEFT:
          this.switchDateSegment(-1);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_UP:
          this.modifyDateSegmentValue(step, symbol, event2);
          if (oldElementValue !== this.elementValue) {
            this.triggerInputEnd({
              event: e,
              error: null,
              newElementValue: this.elementValue,
              oldElementValue
            });
          }
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_RIGHT:
          this.switchDateSegment(1);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_DOWN:
          this.modifyDateSegmentValue(-step, symbol, event2);
          if (oldElementValue !== this.elementValue) {
            this.triggerInputEnd({
              event: e,
              error: null,
              newElementValue: this.elementValue,
              oldElementValue
            });
          }
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ENTER:
          break;
        case KeyCode.HOME:
          this.selectNearestSegment(0);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          this.resetSegmentValue = true;
          break;
        case KeyCode.END:
          this.selectNearestSegment(this.elementValue.length);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          this.resetSegmentValue = true;
          break;
        default:
          return;
      }
      if (shouldPreventDefault) {
        e.preventDefault();
      }
    };
    DateInput2.prototype.onElementPaste = function() {
      this.isPasteInProgress = true;
    };
    DateInput2.prototype.onElementMouseWheel = function(e) {
      var oldElementValue = this.elementValue;
      if (!this.options.enableMouseWheel || this.triggerMouseWheel({
        event: e
      })) {
        return;
      }
      if (!this.isActive) {
        return;
      }
      var event2 = e;
      if (event2.shiftKey) {
        this.switchDateSegment((event2.wheelDelta || -event2.detail) > 0 ? -1 : 1);
      } else {
        this.modifyDateSegmentValue((event2.wheelDelta || -event2.detail) > 0 ? 1 : -1);
      }
      event2.returnValue = false;
      if (event2.preventDefault) {
        event2.preventDefault();
      }
      if (oldElementValue !== this.elementValue) {
        this.triggerInputEnd({
          event: e,
          error: null,
          newElementValue: this.elementValue,
          oldElementValue
        });
      }
    };
    DateInput2.prototype.updateOnPaste = function(e) {
      var value2 = this.intl.parseDate(this.elementValue, this.inputFormat) || this.value;
      if (isPresent(value2) && this.dateObject.shouldNormalizeCentury()) {
        value2 = this.dateObject.normalizeCentury(value2);
      }
      var oldDateObjectValue = this.dateObject && this.dateObject.getValue();
      this.writeValue(value2);
      this.tryTriggerValueChange({
        oldValue: oldDateObjectValue,
        event: e
      });
    };
    Object.defineProperty(DateInput2.prototype, "elementValue", {
      get: function() {
        return (this.element || {}).value || "";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "inputFormat", {
      get: function() {
        if (!this.options.format) {
          return Constants.defaultDateFormat;
        }
        if (typeof this.options.format === "string") {
          return this.options.format;
        } else {
          return this.options.format.inputFormat;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "displayFormat", {
      get: function() {
        if (!this.options.format) {
          return Constants.defaultDateFormat;
        }
        if (typeof this.options.format === "string") {
          return this.options.format;
        } else {
          return this.options.format.displayFormat;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "selection", {
      get: function() {
        var returnValue = {
          start: 0,
          end: 0
        };
        if (this.element !== null && this.element.selectionStart !== void 0) {
          returnValue = {
            start: this.element.selectionStart,
            end: this.element.selectionEnd
          };
        }
        return returnValue;
      },
      enumerable: true,
      configurable: true
    });
    DateInput2.prototype.setSelection = function(selection) {
      if (this.element && document.activeElement === this.element) {
        this.element.setSelectionRange(selection.start, selection.end);
        if (selection.start !== selection.end) {
          this.interactionMode = DateInputInteractionMode.Selection;
        }
      }
    };
    DateInput2.prototype.selectionBySymbol = function(symbol) {
      var start = -1;
      var end = 0;
      for (var i = 0; i < this.currentFormat.length; i++) {
        if (this.currentFormat[i] === symbol) {
          end = i + 1;
          if (start === -1) {
            start = i;
          }
        }
      }
      if (start < 0) {
        start = 0;
      }
      if (!this.options.autoCorrectParts && this.currentFormat.length !== this.currentText.length) {
        if (this.currentFormat.length < this.currentText.length) {
          end += this.currentText.length - this.currentFormat.length;
        } else {
          end = Math.max(0, end - (this.currentFormat.length - this.currentText.length));
        }
      }
      return {
        start,
        end
      };
    };
    DateInput2.prototype.selectionByIndex = function(index) {
      var selection = {
        start: index,
        end: index
      };
      for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
        if (i < this.currentFormat.length && this.currentFormat[i] !== Constants.formatSeparator) {
          selection = this.selectionBySymbol(this.currentFormat[i]);
          break;
        }
        if (j >= 0 && this.currentFormat[j] !== Constants.formatSeparator) {
          selection = this.selectionBySymbol(this.currentFormat[j]);
          break;
        }
      }
      return selection;
    };
    DateInput2.prototype.switchDateSegment = function(offset2) {
      var selection = this.selection;
      if (this.isInCaretMode()) {
        var start = selection.start;
        var currentSymbol = this.currentFormat[start - 1];
        var symbol = "";
        var symbolCandidate = "";
        if (offset2 < 0) {
          for (var i = start + offset2; i >= 0; i--) {
            symbolCandidate = this.currentFormat[i];
            if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {
              start = i;
              symbol = symbolCandidate;
              break;
            }
          }
        } else {
          for (var i = start + offset2; i < this.currentFormat.length; i++) {
            symbolCandidate = this.currentFormat[i];
            if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {
              start = i;
              symbol = symbolCandidate;
              break;
            }
          }
        }
        if (symbol) {
          this.forceUpdate();
          this.setSelection(this.selectionBySymbol(symbol));
          this.interactionMode = DateInputInteractionMode.Selection;
          return;
        }
      }
      this.interactionMode = DateInputInteractionMode.None;
      var _a2 = this.selection, selectionStart = _a2.start, selectionEnd = _a2.end;
      if (selectionStart < selectionEnd && this.currentFormat[selectionStart] !== this.currentFormat[selectionEnd - 1]) {
        this.setSelection(this.selectionByIndex(offset2 > 0 ? selectionStart : selectionEnd - 1));
        this.resetSegmentValue = true;
        this.interactionMode = DateInputInteractionMode.None;
        return;
      }
      var previousFormatSymbol = this.currentFormat[selectionStart];
      var a = selectionStart + offset2;
      while (a > 0 && a < this.currentFormat.length) {
        if (this.currentFormat[a] !== previousFormatSymbol && this.currentFormat[a] !== Constants.formatSeparator) {
          break;
        }
        a += offset2;
      }
      if (this.currentFormat[a] === Constants.formatSeparator) {
        return;
      }
      var b = a;
      while (b >= 0 && b < this.currentFormat.length) {
        if (this.currentFormat[b] !== this.currentFormat[a]) {
          break;
        }
        b += offset2;
      }
      if (a > b && (b + 1 !== selectionStart || a + 1 !== selectionEnd)) {
        this.setSelection({
          start: b + 1,
          end: a + 1
        });
        this.resetSegmentValue = true;
      } else if (a < b && (a !== selectionStart || b !== selectionEnd)) {
        this.setSelection({
          start: a,
          end: b
        });
        this.resetSegmentValue = true;
      }
      this.interactionMode = DateInputInteractionMode.None;
    };
    DateInput2.prototype.modifyDateSegmentValue = function(offset2, symbol, event2) {
      if (symbol === void 0) {
        symbol = "";
      }
      if (event2 === void 0) {
        event2 = {};
      }
      if (!this.dateObject || this.options.readonly) {
        return;
      }
      var oldValue = this.value;
      var step = DEFAULT_SEGMENT_STEP;
      var caret = this.caret();
      symbol = symbol || this.currentFormat[caret[0]];
      if (symbol === "S" && (!this.options.steps.millisecond || this.options.steps.millisecond === DEFAULT_SEGMENT_STEP)) {
        var msDigits = millisecondDigitsInFormat(this.inputFormat);
        step = millisecondStepFor(msDigits);
      }
      this.dateObject.modifyPart(symbol, step * offset2);
      this.tryTriggerValueChange({
        oldValue,
        event: event2
      });
      this.forceUpdate();
      this.setSelection(this.selectionBySymbol(symbol));
    };
    DateInput2.prototype.tryTriggerValueChange = function(args) {
      if (args === void 0) {
        args = {
          oldValue: null,
          event: {}
        };
      }
      if (!isEqual(this.value, args.oldValue)) {
        return this.triggerValueChange(args);
      }
    };
    DateInput2.prototype.triggerValueChange = function(args) {
      if (args === void 0) {
        args = {
          oldValue: null,
          event: {}
        };
      }
      return this.trigger(VALUE_CHANGE, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerInput = function(args) {
      if (args === void 0) {
        args = {
          event: {}
        };
      }
      return this.trigger(INPUT, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerInputEnd = function(args) {
      if (args === void 0) {
        args = {
          event: {},
          error: null,
          oldElementValue: "",
          newElementValue: ""
        };
      }
      return this.trigger(INPUT_END, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerFocus = function(args) {
      if (args === void 0) {
        args = {
          event: {}
        };
      }
      return this.trigger(FOCUS, extend({}, args));
    };
    DateInput2.prototype.triggerFocusEnd = function(args) {
      if (args === void 0) {
        args = {
          event: {}
        };
      }
      return this.trigger(FOCUS_END, extend({}, args));
    };
    DateInput2.prototype.triggerBlur = function(args) {
      if (args === void 0) {
        args = {
          event: {}
        };
      }
      return this.trigger(BLUR, extend({}, args));
    };
    DateInput2.prototype.triggerBlurEnd = function(args) {
      if (args === void 0) {
        args = {
          event: {}
        };
      }
      return this.trigger(BLUR_END, extend({}, args));
    };
    DateInput2.prototype.triggerChange = function(args) {
      if (args === void 0) {
        args = {
          event: {}
        };
      }
      return this.trigger(CHANGE, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerKeyDown = function(args) {
      if (args === void 0) {
        args = {
          event: {}
        };
      }
      return this.trigger(KEY_DOWN, extend({}, args));
    };
    DateInput2.prototype.triggerMouseWheel = function(args) {
      if (args === void 0) {
        args = {
          event: {}
        };
      }
      return this.trigger(MOUSE_WHEEL, extend({}, args));
    };
    DateInput2.prototype.forceUpdate = function() {
      this.setTextAndFormat();
      this.refreshElementValue();
    };
    DateInput2.prototype.forceUpdateWithSelection = function() {
      var _a2 = this.selection, start = _a2.start, end = _a2.end;
      var elementValueLength = this.elementValue.length;
      this.forceUpdate();
      var selectionOffset = this.elementValue.length - elementValueLength;
      this.setSelection({
        start: start + selectionOffset,
        end: end + selectionOffset
      });
    };
    DateInput2.prototype.setTextAndFormat = function() {
      var _a2 = this.dateObject.getTextAndFormat(), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      this.currentText = currentText;
    };
    DateInput2.prototype.setElementValue = function(value2) {
      this.element.value = value2;
    };
    DateInput2.prototype.getStepFromSymbol = function(symbol) {
      switch (symbol) {
        case "S":
          return Number(this.options.steps.millisecond);
        case "s":
          return Number(this.options.steps.second);
        case "m":
          return Number(this.options.steps.minute);
        case "h":
        case "H":
          return Number(this.options.steps.hour);
        case "M":
          return Number(this.options.steps.month);
        case "d":
        case "E":
          return Number(this.options.steps.day);
        case "y":
          return Number(this.options.steps.year);
        default:
          return DEFAULT_SEGMENT_STEP;
      }
    };
    DateInput2.prototype.restorePreviousInputEventState = function() {
      this.restorePreviousElementValue();
      this.restorePreviousElementSelection();
    };
    DateInput2.prototype.restorePreviousElementValue = function() {
      this.setElementValue(this.previousElementValue || "");
    };
    DateInput2.prototype.restorePreviousElementSelection = function() {
      var _a2 = this.previousElementSelection, start = _a2.start, end = _a2.end;
      this.setSelection({
        start: start || 0,
        end: end || 0
      });
    };
    DateInput2.prototype.writeValue = function(value2) {
      this.verifyValue(value2);
      this.dateObject = this.getDateObject(value2);
      this.refreshElementValue();
    };
    DateInput2.prototype.verifyValue = function(value2) {
      if (value2 && !isValidDate(value2)) {
        throw new Error("The 'value' should be a valid JavaScript Date instance.");
      }
    };
    DateInput2.prototype.refreshElementValue = function() {
      var element = this.element;
      var format = this.isActive ? this.inputFormat : this.displayFormat;
      var _a2 = this.dateObject.getTextAndFormat(format), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      this.currentText = currentText;
      var hasPlaceholder = this.options.hasPlaceholder || isPresent(this.options.placeholder);
      var showPlaceholder = !this.isActive && hasPlaceholder && !this.dateObject.hasValue();
      if (hasPlaceholder && isPresent(this.options.placeholder)) {
        element.placeholder = this.options.placeholder;
      }
      var newElementValue = showPlaceholder ? "" : currentText;
      this.previousElementValue = this.elementValue;
      this.setElementValue(newElementValue);
    };
    DateInput2.prototype.caret = function(start, end) {
      if (end === void 0) {
        end = start;
      }
      var isPosition = start !== void 0;
      var returnValue = [start, start];
      var element = this.element;
      if (isPosition && (this.options.disabled || this.options.readonly)) {
        return void 0;
      }
      try {
        if (element.selectionStart !== void 0) {
          if (isPosition) {
            if (isDocumentAvailable2() && document.activeElement !== element) {
              element.focus();
            }
            element.setSelectionRange(start, end);
          }
          returnValue = [element.selectionStart, element.selectionEnd];
        }
      } catch (e) {
        returnValue = [];
      }
      return returnValue;
    };
    DateInput2.prototype.selectNearestSegment = function(index) {
      for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
        if (i < this.currentFormat.length && this.currentFormat[i] !== "_") {
          this.selectDateSegment(this.currentFormat[i]);
          return;
        }
        if (j >= 0 && this.currentFormat[j] !== "_") {
          this.selectDateSegment(this.currentFormat[j]);
          return;
        }
      }
    };
    DateInput2.prototype.selectDateSegment = function(symbol) {
      var begin = -1;
      var end = 0;
      for (var i = 0; i < this.currentFormat.length; i++) {
        if (this.currentFormat[i] === symbol) {
          end = i + 1;
          if (begin === -1) {
            begin = i;
          }
        }
      }
      if (begin < 0) {
        begin = 0;
      }
      this.caret(0, 0);
      this.caret(begin, end);
    };
    DateInput2.prototype.getDateObject = function(value2) {
      var leadingZero = (this.dateObject || {}).leadingZero;
      this.options.value = value2;
      var dateObject = this.createDateObject();
      dateObject.setLeadingZero(this.isActive ? leadingZero : null);
      return dateObject;
    };
    DateInput2.prototype.createDateObject = function() {
      var defaultOptions2 = this.getDateObjectOptions();
      var dateObject = new DateObject(extend({}, defaultOptions2));
      return dateObject;
    };
    DateInput2.prototype.getDateObjectOptions = function() {
      var newOptions = {
        intlService: this.options.intlService,
        formatPlaceholder: this.options.formatPlaceholder ? this.options.formatPlaceholder : "formatPattern",
        format: this.inputFormat,
        cycleTime: this.options.cycleTime,
        twoDigitYearMax: this.options.twoDigitYearMax,
        autoCorrectParts: this.options.autoCorrectParts,
        value: this.options.value,
        toggleDayPeriod: this.options.toggleDayPeriod
      };
      return newOptions;
    };
    DateInput2.prototype.keyEventMatchesAutoSwitchKeys = function(keyObject) {
      var autoSwitchKeys = (this.options.autoSwitchKeys || []).map(function(x) {
        return x.toString().toLowerCase().trim();
      });
      if (autoSwitchKeys.indexOf(keyObject.keyCode.toString()) >= 0 || autoSwitchKeys.indexOf(keyObject.keyCode) >= 0 || autoSwitchKeys.indexOf(keyObject.key.toLowerCase().trim()) >= 0) {
        return true;
      }
      return false;
    };
    DateInput2.prototype.autoFill = function() {
      var dateObject = this.dateObject, currentDate = /* @__PURE__ */ new Date(), day, month, year, hours, minutes, seconds;
      if (dateObject.date || dateObject.month || dateObject.year || dateObject.hours || dateObject.minutes || dateObject.seconds) {
        year = dateObject.year ? dateObject.value.getFullYear() : currentDate.getFullYear(), month = dateObject.month ? dateObject.value.getMonth() : currentDate.getMonth(), day = dateObject.date ? dateObject.value.getDate() : currentDate.getDate(), hours = dateObject.hours ? dateObject.value.getHours() : currentDate.getHours(), minutes = dateObject.minutes ? dateObject.value.getMinutes() : currentDate.getMinutes(), seconds = dateObject.seconds ? dateObject.value.getSeconds() : currentDate.getSeconds();
        dateObject.setValue(new Date(year, month, day, hours, minutes, seconds));
        this.refreshElementValue();
        this.triggerValueChange();
      }
    };
    return DateInput2;
  }(Observable2)
);

// node_modules/@progress/kendo-angular-dateinputs/fesm2022/progress-kendo-angular-dateinputs.mjs
var _c0 = ["kendoCalendarView", ""];
var _c1 = (a0, a1) => ({
  $implicit: a0,
  cellContext: a1
});
function ViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 3);
    ɵɵtext(1, " ");
    ɵɵelementEnd();
  }
}
function ViewComponent_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 4)(1, "th", 5);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-hidden", ctx_r0.ariaHidden);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r0.colSpan);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.getWeekNumber(ctx_r0.firstDate(row_r3)), " ");
  }
}
function ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template(rf, ctx) {
}
function ViewComponent_tr_3_ng_template_1_td_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 9);
    ɵɵlistener("click", function ViewComponent_tr_3_ng_template_1_td_0_Template_td_click_0_listener() {
      ɵɵrestoreView(_r2);
      const row_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleWeekNumberClick(row_r3));
    });
    ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template, 1, 1, "ng-template", 6)(2, ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.weekNumberTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.weekNumberTemplateRef)("ngTemplateOutlet", ctx_r0.weekNumberTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(4, _c1, ctx_r0.firstDate(row_r3), ctx_r0.getWeekNumberContext(row_r3)));
  }
}
function ViewComponent_tr_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ViewComponent_tr_3_ng_template_1_td_0_Template, 3, 7, "td", 8);
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    const emptyCell_r4 = ɵɵreference(1);
    ɵɵproperty("ngIf", ctx_r0.firstDate(row_r3))("ngIfElse", emptyCell_r4);
  }
}
function ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const cell_r5 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate(cell_r5.formattedValue);
  }
}
function ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template(rf, ctx) {
}
function ViewComponent_tr_3_ng_container_2_td_1_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const cell_r5 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c1, cell_r5.value, cell_r5));
  }
}
function ViewComponent_tr_3_ng_container_2_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 12)(1, "span", 13);
    ɵɵtemplate(2, ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template, 1, 1, "ng-template", 6)(3, ViewComponent_tr_3_ng_container_2_td_1_3_Template, 1, 5, null, 14);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const cell_r5 = ctx_r5.$implicit;
    const cellIndex_r7 = ctx_r5.index;
    const rowIndex_r8 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.getStyles(cell_r5))("title", cell_r5.title);
    ɵɵattribute("id", cell_r5.id)("data-cell-index", ctx_r0.tableCellIndex(rowIndex_r8, cellIndex_r7))("aria-selected", cell_r5.isSelected || cell_r5.isRangeStart || cell_r5.isRangeMid || cell_r5.isRangeEnd)("aria-disabled", cell_r5.isDisabled)("aria-label", ctx_r0.getMonthLabel(cell_r5.value));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.templateRef);
  }
}
function ViewComponent_tr_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ViewComponent_tr_3_ng_container_2_td_1_Template, 4, 9, "td", 11);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const cell_r5 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    const emptyCell_r4 = ɵɵreference(1);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.shouldRenderCellContent(cell_r5))("ngIfElse", emptyCell_r4);
  }
}
function ViewComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 4);
    ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_Template, 1, 2, "ng-template", 6)(2, ViewComponent_tr_3_ng_container_2_Template, 2, 2, "ng-container", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.weekNumber);
    ɵɵadvance();
    ɵɵproperty("kForOf", row_r3);
  }
}
var _c2 = (a0) => ({
  date: a0,
  className: "k-pointer-events-none"
});
var _c3 = (a0) => ({
  date: a0
});
function HorizontalViewListComponent_ng_template_0_caption_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "caption", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r3 = ɵɵnextContext().date;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getCaptionTitle(date_r3));
  }
}
function HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const name_r4 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵattribute("aria-label", ctx_r1.wideWeekNames[i_r5]);
    ɵɵadvance();
    ɵɵtextInterpolate(name_r4);
  }
}
function HorizontalViewListComponent_ng_template_0_thead_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead", 8)(1, "tr", 9);
    ɵɵtemplate(2, HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template, 2, 2, "th", 10);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.weekNames);
  }
}
function HorizontalViewListComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 3);
    ɵɵlistener("focus", function HorizontalViewListComponent_ng_template_0_Template_table_focus_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleClassicCalendarFocus());
    })("blur", function HorizontalViewListComponent_ng_template_0_Template_table_blur_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleClassicCalendarBlur($event));
    });
    ɵɵtemplate(1, HorizontalViewListComponent_ng_template_0_caption_1_Template, 2, 1, "caption", 4)(2, HorizontalViewListComponent_ng_template_0_thead_2_Template, 3, 1, "thead", 5);
    ɵɵelementStart(3, "tbody", 6);
    ɵɵlistener("cellClick", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellClick_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellClick.emit($event));
    })("weekNumberCellClick", function HorizontalViewListComponent_ng_template_0_Template_tbody_weekNumberCellClick_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.weekNumberCellClick.emit($event));
    })("cellEnter", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellEnter_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellEnter.emit($event));
    })("cellLeave", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellLeave_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellLeave.emit($event));
    })("focusedCellId", function HorizontalViewListComponent_ng_template_0_Template_tbody_focusedCellId_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focusedCellChange.emit($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const date_r3 = ctx.date;
    const class_r6 = ctx.className;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", class_r6);
    ɵɵattribute("role", ctx_r1.views >= 2 ? "none" : "grid")("aria-labelledby", ctx_r1.id)("aria-activedescendant", ctx_r1.getActiveDescendant)("tabindex", ctx_r1.getTabIndex);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showViewHeader);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isMonthView());
    ɵɵadvance();
    ɵɵproperty("allowReverse", ctx_r1.allowReverse)("showOtherMonthDays", ctx_r1.showOtherMonthDays)("activeView", ctx_r1.activeView)("isActive", ctx_r1.isActive)("min", ctx_r1.min)("max", ctx_r1.max)("cellUID", ctx_r1.cellUID)("focusedDate", ctx_r1.focusedDate)("selectedDates", ctx_r1.selectedDates)("selectionRange", ctx_r1.selectionRange)("activeRangeEnd", ctx_r1.activeRangeEnd)("weekNumber", ctx_r1.weekNumber)("templateRef", ctx_r1.cellTemplateRef)("weekNumberTemplateRef", ctx_r1.weekNumberTemplateRef)("viewDate", date_r3);
  }
}
function HorizontalViewListComponent_2_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c2, ctx_r1.nextAnimationDate));
  }
}
function HorizontalViewListComponent_3_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_3_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const date_r8 = ctx.$implicit;
    ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c3, date_r8));
  }
}
function HorizontalViewListComponent_4_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_4_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c2, ctx_r1.prevAnimationDate));
  }
}
var _c4 = (a0, a1, a2) => ({
  title: a0,
  activeView: a1,
  date: a2
});
var _c5 = (a0) => ({
  click: a0
});
var _c6 = (a0, a1, a2) => ({
  $implicit: a0,
  activeView: a1,
  date: a2
});
function HeaderComponent_0_ng_template_0_Template(rf, ctx) {
}
function HeaderComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HeaderComponent_0_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c4, ctx_r0.title, ctx_r0.activeViewValue, ctx_r0.currentDate));
  }
}
function HeaderComponent_ng_template_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function HeaderComponent_ng_template_1_ng_template_2_Template(rf, ctx) {
}
function HeaderComponent_ng_template_1_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵlistener("click", function HeaderComponent_ng_template_1_button_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.prevButtonClick.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("svgIcon", ctx_r0.chevronLeftIcon)("disabled", ctx_r0.isPrevDisabled)("title", ctx_r0.prevButtonTitle);
    ɵɵattribute("aria-disabled", ctx_r0.isPrevDisabled);
  }
}
function HeaderComponent_ng_template_1_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function HeaderComponent_ng_template_1_button_8_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.nextButtonClick.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("svgIcon", ctx_r0.chevronRightIcon)("disabled", ctx_r0.isNextDisabled)("title", ctx_r0.nextButtonTitle);
    ɵɵattribute("aria-disabled", ctx_r0.isNextDisabled);
  }
}
function HeaderComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 3);
    ɵɵtemplate(1, HeaderComponent_ng_template_1_ng_template_1_Template, 1, 1, "ng-template", 4)(2, HeaderComponent_ng_template_1_ng_template_2_Template, 0, 0, "ng-template", 5);
    ɵɵelementEnd();
    ɵɵelement(3, "span", 6);
    ɵɵelementStart(4, "span", 7);
    ɵɵtemplate(5, HeaderComponent_ng_template_1_button_5_Template, 1, 5, "button", 8);
    ɵɵelementStart(6, "button", 9);
    ɵɵtext(7);
    ɵɵelementEnd();
    ɵɵtemplate(8, HeaderComponent_ng_template_1_button_8_Template, 1, 5, "button", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.id)("size", ctx_r0.size)("disabled", !ctx_r0.navigate)("kendoEventsOutsideAngular", ɵɵpureFunction1(17, _c5, ctx_r0.handleNavigation))("title", ctx_r0.parentViewButtonTitle)("scope", ctx_r0);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.titleTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.titleTemplateRef)("ngTemplateOutlet", ctx_r0.titleTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction3(19, _c6, ctx_r0.title, ctx_r0.activeViewValue, ctx_r0.currentDate));
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.showNavigationButtons);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r0.size)("disabled", !ctx_r0.todayAvailable)("kendoEventsOutsideAngular", ɵɵpureFunction1(23, _c5, ctx_r0.handleTodayClick))("scope", ctx_r0);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.todayMessage, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showNavigationButtons);
  }
}
var _c7 = (a0, a1) => ({
  activeView: a0,
  date: a1
});
function FooterComponent_0_ng_template_0_Template(rf, ctx) {
}
function FooterComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FooterComponent_0_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.footerTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c7, ctx_r0.activeViewValue, ctx_r0.currentDate));
  }
}
function FooterComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.intl.formatDate(ctx_r0.getToday(), "D"), " ");
  }
}
function MultiViewCalendarComponent_kendo_calendar_header_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar-header", 4);
    ɵɵlistener("todayButtonClick", function MultiViewCalendarComponent_kendo_calendar_header_1_Template_kendo_calendar_header_todayButtonClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleTodayButtonClick({
        selectedDates: [$event],
        focusedDate: $event
      }));
    })("prevButtonClick", function MultiViewCalendarComponent_kendo_calendar_header_1_Template_kendo_calendar_header_prevButtonClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateView(ctx_r1.prevView));
    })("nextButtonClick", function MultiViewCalendarComponent_kendo_calendar_header_1_Template_kendo_calendar_header_nextButtonClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateView(ctx_r1.nextView));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("activeView", ctx_r1.activeViewEnum)("currentDate", ctx_r1.activeDate)("size", ctx_r1.size)("min", ctx_r1.min)("max", ctx_r1.max)("id", ctx_r1.headerId)("rangeLength", ctx_r1.views)("titleTemplateRef", ctx_r1.headerTitleTemplateRef == null ? null : ctx_r1.headerTitleTemplateRef.templateRef)("headerTemplateRef", ctx_r1.headerTemplateRef == null ? null : ctx_r1.headerTemplateRef.templateRef)("isPrevDisabled", ctx_r1.isPrevDisabled)("isNextDisabled", ctx_r1.isNextDisabled)("showNavigationButtons", true)("orientation", ctx_r1.orientation);
  }
}
function MultiViewCalendarComponent_kendo_calendar_footer_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-calendar-footer", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("footerTemplateRef", ctx_r1.footerTemplateRef == null ? null : ctx_r1.footerTemplateRef.templateRef)("activeViewValue", ctx_r1.activeView)("currentDate", ctx_r1.activeDate);
  }
}
var _c8 = ["*"];
var _c9 = ["list"];
function NavigationComponent_li_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const date_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r2.service.navigationTitle(date_r2));
  }
}
function NavigationComponent_li_4_ng_template_3_Template(rf, ctx) {
}
function NavigationComponent_li_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li")(1, "span");
    ɵɵtemplate(2, NavigationComponent_li_4_ng_template_2_Template, 1, 1, "ng-template", 5)(3, NavigationComponent_li_4_ng_template_3_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const date_r2 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵattribute("data-date-index", index_r4);
    ɵɵadvance();
    ɵɵclassProp("k-calendar-navigation-marker", ctx_r2.service.isRangeStart(date_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.templateRef)("ngTemplateOutlet", ctx_r2.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(7, _c6, ctx_r2.service.navigationTitle(date_r2), ctx_r2.activeViewValue, date_r2));
  }
}
function ViewListComponent_table_1_th_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const name_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵattribute("aria-label", ctx_r3.wideWeekNames[i_r3]);
    ɵɵadvance();
    ɵɵtextInterpolate(name_r2);
  }
}
function ViewListComponent_table_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "table", 8)(1, "thead", 9)(2, "tr", 10);
    ɵɵtemplate(3, ViewListComponent_table_1_th_3_Template, 2, 2, "th", 11);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵstyleProp("table-layout", "auto");
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r3.weekNames);
  }
}
function ViewListComponent_col_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
}
function ViewListComponent_tbody_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tbody", 13);
    ɵɵlistener("cellClick", function ViewListComponent_tbody_7_Template_tbody_cellClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.cellClick.emit($event));
    })("weekNumberCellClick", function ViewListComponent_tbody_7_Template_tbody_weekNumberCellClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.weekNumberCellClick.emit($event));
    })("focusedCellId", function ViewListComponent_tbody_7_Template_tbody_focusedCellId_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.focusedCellChange.emit($event));
    })("cellEnter", function ViewListComponent_tbody_7_Template_tbody_cellEnter_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.cellEnter.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r6 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("allowReverse", ctx_r3.allowReverse)("activeRangeEnd", ctx_r3.activeRangeEnd)("selectionRange", ctx_r3.selectionRange)("showOtherMonthDays", ctx_r3.showOtherMonthDays)("headerTitle", ctx_r3.headerTitle)("activeView", ctx_r3.activeView)("isActive", ctx_r3.isActive)("min", ctx_r3.min)("max", ctx_r3.max)("cellUID", ctx_r3.cellUID)("focusedDate", ctx_r3.focusedDate)("selectedDates", ctx_r3.selectedDates)("weekNumber", ctx_r3.weekNumber)("templateRef", ctx_r3.cellTemplateRef)("weekNumberTemplateRef", ctx_r3.weekNumberTemplateRef)("viewDate", date_r6);
  }
}
function ViewListComponent_kendo_calendar_footer_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-calendar-footer", 14);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("footerTemplateRef", ctx_r3.footerTemplateRef)("activeViewValue", ctx_r3.activeViewValue)("currentDate", ctx_r3.activeDate);
  }
}
function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar-navigation", 6);
    ɵɵlistener("valueChange", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_valueChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.handleNavigation($event));
    })("pageChange", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_pageChange_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onPageChange());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("activeView", ctx_r2.activeViewEnum)("focusedDate", ctx_r2.focusedDate)("min", ctx_r2.min)("max", ctx_r2.max)("templateRef", ctx_r2.navigationItemTemplateRef == null ? null : ctx_r2.navigationItemTemplateRef.templateRef);
  }
}
function CalendarComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template, 1, 5, "kendo-calendar-navigation", 3);
    ɵɵelementStart(2, "kendo-calendar-viewlist", 4);
    ɵɵlistener("todayButtonClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_todayButtonClick_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleDateChange({
        selectedDates: [$event],
        focusedDate: $event
      }));
    })("cellClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_cellClick_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleCellClick($event));
    })("weekNumberCellClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_weekNumberCellClick_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleWeekNumberClick($event));
    })("activeDateChange", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_activeDateChange_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleActiveDateChange($event));
    })("pageChange", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_pageChange_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onPageChange());
    })("focusCalendar", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_focusCalendar_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleFocus());
    })("blurCalendar", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_blurCalendar_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("cellEnter", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_cellEnter_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onCellEnter($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "kendo-resize-sensor", 5);
    ɵɵlistener("resize", function CalendarComponent_ng_container_1_Template_kendo_resize_sensor_resize_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onResize());
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    let tmp_11_0;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.navigation);
    ɵɵadvance();
    ɵɵproperty("activeView", ctx_r2.activeViewEnum)("allowReverse", ctx_r2.allowReverse)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("activeRangeEnd", ctx_r2.activeRangeEnd)("selectionRange", ctx_r2.selectionRange)("size", ctx_r2.size)("isActive", ctx_r2.isActive)("id", ctx_r2.headerId)("weekDaysFormat", ctx_r2.weekDaysFormat)("cellTemplateRef", (tmp_11_0 = ctx_r2.activeCellTemplate()) == null ? null : tmp_11_0.templateRef)("headerTitleTemplateRef", ctx_r2.headerTitleTemplateRef == null ? null : ctx_r2.headerTitleTemplateRef.templateRef)("headerTemplateRef", ctx_r2.headerTemplateRef == null ? null : ctx_r2.headerTemplateRef.templateRef)("showFooter", ctx_r2.footer)("footerTemplateRef", ctx_r2.footerTemplateRef == null ? null : ctx_r2.footerTemplateRef.templateRef)("weekNumberTemplateRef", ctx_r2.weekNumberTemplateRef == null ? null : ctx_r2.weekNumberTemplateRef.templateRef)("cellUID", ctx_r2.cellUID)("min", ctx_r2.min)("max", ctx_r2.max)("focusedDate", ctx_r2.focusedDate)("weekNumber", ctx_r2.weekNumber)("selectedDates", ctx_r2.selectedDates)("tabIndex", ctx_r2.tabIndex)("disabled", ctx_r2.disabled);
  }
}
function CalendarComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "kendo-multiviewcalendar", 7, 0);
    ɵɵlistener("activeViewChange", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_activeViewChange_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleActiveViewChange($event));
    })("navigate", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_navigate_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleNavigate($event));
    })("valueChange", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_valueChange_1_listener($event) {
      ɵɵrestoreView(_r4);
      const multiviewcalendar_r5 = ɵɵreference(2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleMultiViewCalendarValueChange($event, multiviewcalendar_r5.focusedDate));
    })("focusCalendar", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_focusCalendar_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleFocus());
    })("blur", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_blur_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("blurEvent", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_blurEvent_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("keydown", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_keydown_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleMultiViewCalendarKeydown($event));
    });
    ɵɵelement(3, "kendo-multiviewcalendar-messages", 8);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("views", 1)("min", ctx_r2.min)("max", ctx_r2.max)("size", ctx_r2.size)("id", ctx_r2.id)("activeRangeEnd", ctx_r2.activeRangeEnd)("selectionRange", ctx_r2.selectionRange)("allowReverse", ctx_r2.allowReverse)("disabled", ctx_r2.disabled)("isActive", ctx_r2.isActive)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("tabIndex", ctx_r2.tabIndex)("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("topView", ctx_r2.topView)("weekDaysFormat", ctx_r2.weekDaysFormat)("weekNumber", ctx_r2.weekNumber)("animateNavigation", ctx_r2.animateNavigation)("cellTemplate", ctx_r2.activeCellTemplate())("monthCellTemplate", ctx_r2.monthCellTemplateRef)("yearCellTemplate", ctx_r2.yearCellTemplateRef)("decadeCellTemplate", ctx_r2.decadeCellTemplateRef)("centuryCellTemplate", ctx_r2.centuryCellTemplateRef)("headerTitleTemplate", ctx_r2.headerTitleTemplateRef)("headerTemplate", ctx_r2.headerTemplateRef)("footerTemplate", ctx_r2.footerTemplateRef)("footer", ctx_r2.footer)("weekNumberTemplate", ctx_r2.weekNumberTemplateRef)("focusedDate", ctx_r2.focusedDate)("selection", ctx_r2.selection)("value", ctx_r2.value)("disabledDates", ctx_r2.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r2.localization.get("today"))("prevButtonTitle", ctx_r2.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r2.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r2.localization.get("parentViewButtonTitle"));
  }
}
var _c10 = ["dateInput"];
var _c11 = ["spinup"];
var _c12 = ["spindown"];
var _c13 = (a0, a1) => ({
  dragstart: a0,
  drop: a1
});
function DateInputComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 7);
    ɵɵlistener("click", function DateInputComponent_span_3_Template_span_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.resetInput());
    })("mousedown", function DateInputComponent_span_3_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r1);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(1, "kendo-icon-wrapper", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r1.localization.get("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function DateInputComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9);
    ɵɵlistener("mousedown", function DateInputComponent_span_4_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelementStart(1, "button", 10, 1);
    ɵɵlistener("mousedown", function DateInputComponent_span_4_Template_button_mousedown_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.Up);
    })("mouseleave", function DateInputComponent_span_4_Template_button_mouseleave_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.None);
    })("click", function DateInputComponent_span_4_Template_button_click_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleButtonClick(1));
    });
    ɵɵelement(3, "kendo-icon-wrapper", 11);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 12, 2);
    ɵɵlistener("click", function DateInputComponent_span_4_Template_button_click_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleButtonClick(-1));
    })("mousedown", function DateInputComponent_span_4_Template_button_mousedown_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.Down);
    })("mouseleave", function DateInputComponent_span_4_Template_button_mouseleave_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.None);
    });
    ɵɵelement(6, "kendo-icon-wrapper", 13);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.arrow.Up);
    ɵɵproperty("title", ctx_r1.localization.get("increment"));
    ɵɵattribute("aria-label", ctx_r1.localization.get("increment"));
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.caretAltUpIcon);
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.arrow.Down);
    ɵɵproperty("title", ctx_r1.localization.get("decrement"));
    ɵɵattribute("aria-label", ctx_r1.localization.get("decrement"));
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.caretAltDownIcon);
  }
}
var _c14 = ["container"];
var _c15 = ["popupTemplate"];
var _c16 = ["toggleButton"];
var _c17 = ["actionSheet"];
var _c18 = (a0, a1) => ({
  click: a0,
  mousedown: a1
});
var _c19 = (a0) => ({
  keydown: a0
});
function DatePickerComponent_ng_template_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DatePickerComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DatePickerComponent_ng_template_9_ng_container_0_Template, 1, 0, "ng-container", 15);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const calendarTemplate_r2 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", calendarTemplate_r2);
  }
}
function DatePickerComponent_kendo_resize_sensor_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 16);
    ɵɵlistener("resize", function DatePickerComponent_kendo_resize_sensor_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onResize());
    });
    ɵɵelementEnd();
  }
}
function DatePickerComponent_ng_template_14_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DatePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17)(1, "div", 18)(2, "div", 19)(3, "div", 20);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 21);
    ɵɵtext(6);
    ɵɵelementEnd()();
    ɵɵelementStart(7, "div", 22)(8, "button", 23);
    ɵɵlistener("click", function DatePickerComponent_ng_template_14_Template_button_click_8_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.show = false);
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(9, "div", 24);
    ɵɵtemplate(10, DatePickerComponent_ng_template_14_ng_container_10_Template, 1, 0, "ng-container", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const calendarTemplate_r2 = ɵɵreference(16);
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r3.title);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r3.xIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r3.localization.get("clearTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", calendarTemplate_r2);
  }
}
function DatePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar", 25, 6);
    ɵɵlistener("valueChange", function DatePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleChange(ctx_r3.mergeTime($event)));
    });
    ɵɵelement(2, "kendo-calendar-messages", 26);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("type", ctx_r3.calendarType)("size", ctx_r3.isAdaptive ? "large" : ctx_r3.size)("min", ctx_r3.min)("max", ctx_r3.max)("weekDaysFormat", ctx_r3.weekDaysFormat)("navigation", ctx_r3.navigation)("animateNavigation", ctx_r3.animateCalendarNavigation)("activeView", ctx_r3.activeView)("bottomView", ctx_r3.bottomView)("showOtherMonthDays", ctx_r3.showOtherMonthDays)("topView", ctx_r3.topView)("weekNumber", ctx_r3.weekNumber)("cellTemplate", ctx_r3.cellTemplate)("monthCellTemplate", ctx_r3.monthCellTemplate)("yearCellTemplate", ctx_r3.yearCellTemplate)("decadeCellTemplate", ctx_r3.decadeCellTemplate)("centuryCellTemplate", ctx_r3.centuryCellTemplate)("weekNumberTemplate", ctx_r3.weekNumberTemplate)("headerTitleTemplate", ctx_r3.headerTitleTemplate)("headerTemplate", ctx_r3.headerTemplate)("footerTemplate", ctx_r3.footerTemplate)("footer", ctx_r3.footer)("navigationItemTemplate", ctx_r3.navigationItemTemplate)("focusedDate", ctx_r3.focusedDate)("value", ctx_r3.value)("kendoEventsOutsideAngular", ɵɵpureFunction1(32, _c19, ctx_r3.handleKeydown))("scope", ctx_r3)("disabledDates", ctx_r3.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r3.localization.get("today"))("prevButtonTitle", ctx_r3.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r3.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r3.localization.get("parentViewButtonTitle"));
  }
}
function TimeListComponent_li_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const index_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵattribute("data-timelist-item-index", index_r2)("role", "option")("aria-selected", index_r2 === ctx_r2.currentSelectedIndex);
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r1.text);
  }
}
var _c20 = ["accept"];
var _c21 = ["cancel"];
var _c22 = ["now"];
var _c23 = ["listWrapper"];
var _c24 = (a0, a1, a2, a3) => ({
  click: a0,
  focus: a1,
  blur: a2,
  keydown: a3
});
var _c25 = (a0, a1) => ({
  focus: a0,
  blur: a1
});
function TimeSelectorComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 12, 0);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c24, ctx_r0.handleNow, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("nowLabel"))("aria-label", ctx_r0.localization.get("nowLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("now"));
  }
}
function TimeSelectorComponent_ng_template_7_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 15, 1)(2, "span", 6);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "kendo-timelist", 16);
    ɵɵtwoWayListener("valueChange", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_valueChange_4_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.current, $event) || (ctx_r0.current = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("tabOutLastPart", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_tabOutLastPart_4_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.tabOutLastPart.emit());
    })("tabOutFirstPart", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_tabOutFirstPart_4_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.tabOutFirstPart.emit());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const part_r4 = ctx_r2.$implicit;
    const idx_r5 = ctx_r2.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0.intl.dateFieldName(part_r4));
    ɵɵadvance();
    ɵɵproperty("isLast", idx_r5 === ctx_r0.dateFormatParts.length - 1)("isFirst", idx_r5 === 0)("min", ctx_r0.min)("max", ctx_r0.max)("part", part_r4)("step", ctx_r0.partStep(part_r4))("disabled", ctx_r0.disabled);
    ɵɵtwoWayProperty("value", ctx_r0.current);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(12, _c25, ctx_r0.handleListFocus, ctx_r0.handleBlur))("scope", ctx_r0);
    ɵɵattribute("data-timelist-index", idx_r5);
  }
}
function TimeSelectorComponent_ng_template_7_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const part_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", part_r4.pattern, " ");
  }
}
function TimeSelectorComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimeSelectorComponent_ng_template_7_div_0_Template, 5, 15, "div", 13)(1, TimeSelectorComponent_ng_template_7_div_1_Template, 2, 1, "div", 14);
  }
  if (rf & 2) {
    const part_r4 = ctx.$implicit;
    ɵɵproperty("ngIf", part_r4.type !== "literal");
    ɵɵadvance();
    ɵɵproperty("ngIf", part_r4.type === "literal");
  }
}
function TimeSelectorComponent_div_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 21, 2);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c24, ctx_r0.handleAccept, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("acceptLabel"))("aria-label", ctx_r0.localization.get("acceptLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("accept"));
  }
}
function TimeSelectorComponent_div_8_button_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 22, 3);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c24, ctx_r0.handleReject, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("cancelLabel"))("aria-label", ctx_r0.localization.get("cancelLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("cancel"));
  }
}
function TimeSelectorComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵtemplate(1, TimeSelectorComponent_div_8_button_1_Template, 3, 11, "button", 19)(2, TimeSelectorComponent_div_8_button_2_Template, 3, 11, "button", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.setButton);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.cancelButton);
  }
}
var _c26 = (a0, a1) => ({
  keydown: a0,
  mousedown: a1
});
function TimePickerComponent_ng_template_7_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TimePickerComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimePickerComponent_ng_template_7_ng_container_0_Template, 1, 0, "ng-container", 15);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const timeSelectorTemplate_r2 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", timeSelectorTemplate_r2);
  }
}
function TimePickerComponent_kendo_resize_sensor_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 16);
    ɵɵlistener("resize", function TimePickerComponent_kendo_resize_sensor_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onResize());
    });
    ɵɵelementEnd();
  }
}
function TimePickerComponent_ng_template_14_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TimePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17)(1, "div", 18)(2, "div", 19)(3, "div", 20);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 21);
    ɵɵtext(6);
    ɵɵelementEnd()();
    ɵɵelementStart(7, "div", 22)(8, "button", 23);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_8_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.show = false);
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(9, "div", 24);
    ɵɵtemplate(10, TimePickerComponent_ng_template_14_ng_container_10_Template, 1, 0, "ng-container", 15);
    ɵɵelementEnd();
    ɵɵelementStart(11, "div", 25)(12, "button", 26);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_12_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleReject());
    });
    ɵɵtext(13);
    ɵɵelementEnd();
    ɵɵelementStart(14, "button", 27);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_14_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleActionSheetAccept());
    });
    ɵɵtext(15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const timeSelectorTemplate_r2 = ɵɵreference(16);
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r3.title);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r3.xIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r3.localization.get("clearTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", timeSelectorTemplate_r2);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r3.localization.get("cancelLabel"))("aria-label", ctx_r3.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.localization.get("cancel"), " ");
    ɵɵadvance();
    ɵɵattribute("title", ctx_r3.localization.get("acceptLabel"))("aria-label", ctx_r3.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.localization.get("accept"), " ");
  }
}
function TimePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-timeselector", 28, 6);
    ɵɵlistener("valueChange", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_valueChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleChange($event));
    })("valueReject", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_valueReject_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleReject());
    })("tabOutLastPart", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutLastPart_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutLastPart());
    })("tabOutFirstPart", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutFirstPart_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutFirstPart());
    })("tabOutNow", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutNow_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutNow());
    });
    ɵɵelement(2, "kendo-timeselector-messages", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("k-timeselector-lg", ctx_r3.isAdaptive);
    ɵɵproperty("cancelButton", ctx_r3.cancelButton && !ctx_r3.isAdaptive)("setButton", !ctx_r3.isAdaptive)("nowButton", ctx_r3.nowButton)("format", ctx_r3.format)("min", ctx_r3.min)("max", ctx_r3.max)("steps", ctx_r3.steps)("value", ctx_r3.value)("isAdaptiveEnabled", ctx_r3.isAdaptiveModeEnabled)("kendoEventsOutsideAngular", ɵɵpureFunction2(24, _c26, ctx_r3.handleKeydown, ctx_r3.handleMousedown))("scope", ctx_r3);
    ɵɵadvance(2);
    ɵɵproperty("acceptLabel", ctx_r3.localization.get("acceptLabel"))("accept", ctx_r3.localization.get("accept"))("cancelLabel", ctx_r3.localization.get("cancelLabel"))("cancel", ctx_r3.localization.get("cancel"))("nowLabel", ctx_r3.localization.get("nowLabel"))("now", ctx_r3.localization.get("now"))("hour", ctx_r3.localization.get("hour"))("minute", ctx_r3.localization.get("minute"))("second", ctx_r3.localization.get("second"))("millisecond", ctx_r3.localization.get("millisecond"))("dayperiod", ctx_r3.localization.get("dayperiod"));
  }
}
var _c27 = (a0, a1) => ({
  mousedown: a0,
  click: a1
});
var _c28 = (a0, a1) => ({
  "k-datetime-wrap-md": a0,
  "k-datetime-wrap-lg": a1
});
var _c29 = (a0, a1) => ({
  mousedown: a0,
  keydown: a1
});
var _c30 = (a0, a1) => ({
  focusin: a0,
  focusout: a1
});
var _c31 = (a0, a1) => ({
  click: a0,
  "keydown.shift.tab": a1
});
var _c32 = (a0, a1) => ({
  click: a0,
  "keydown.tab": a1
});
var _c33 = (a0) => ({
  transitionend: a0
});
var _c34 = (a0) => ({
  "k-timeselector-lg": a0
});
var _c35 = (a0, a1, a2) => ({
  click: a0,
  "keydown.tab": a1,
  "keydown.shift.tab": a2
});
function DateTimePickerComponent_kendo_icon_wrapper_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 16);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.calendarIcon);
  }
}
function DateTimePickerComponent_kendo_icon_wrapper_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.clockIcon);
  }
}
function DateTimePickerComponent_ng_template_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DateTimePickerComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DateTimePickerComponent_ng_template_9_ng_container_0_Template, 1, 0, "ng-container", 18);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const dateTimeTemplate_r3 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", dateTimeTemplate_r3);
  }
}
function DateTimePickerComponent_kendo_resize_sensor_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 19);
    ɵɵlistener("resize", function DateTimePickerComponent_kendo_resize_sensor_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function DateTimePickerComponent_ng_template_14_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DateTimePickerComponent_ng_template_14_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 31);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_button_12_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleCancel());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("title", ctx_r1.localization.get("cancelLabel"))("aria-label", ctx_r1.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("cancel"), " ");
  }
}
function DateTimePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "div", 21)(2, "div", 22)(3, "div", 23);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 24);
    ɵɵtext(6);
    ɵɵelementEnd()();
    ɵɵelementStart(7, "div", 25)(8, "button", 26);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_Template_button_click_8_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleDateTime(false));
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(9, "div", 27);
    ɵɵtemplate(10, DateTimePickerComponent_ng_template_14_ng_container_10_Template, 1, 0, "ng-container", 18);
    ɵɵelementEnd();
    ɵɵelementStart(11, "div", 28);
    ɵɵtemplate(12, DateTimePickerComponent_ng_template_14_button_12_Template, 2, 3, "button", 29);
    ɵɵelementStart(13, "button", 30);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_Template_button_click_13_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleAccept());
    });
    ɵɵtext(14);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const dateTimeTemplate_r3 = ɵɵreference(16);
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r1.title);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.xIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r1.localization.get("clearTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", dateTimeTemplate_r3);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.cancelButton);
    ɵɵadvance();
    ɵɵproperty("disabled", !ctx_r1.calendarValue);
    ɵɵattribute("title", ctx_r1.localization.get("acceptLabel"))("aria-label", ctx_r1.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("accept"), " ");
  }
}
function DateTimePickerComponent_ng_template_15_div_16_button_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 48);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ctx_r1.popupButtonsClasses())("kendoEventsOutsideAngular", ɵɵpureFunction3(6, _c35, ctx_r1.handleCancel, ctx_r1.handleTab, ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("title", ctx_r1.localization.get("cancelLabel"))("aria-label", ctx_r1.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("cancel"), " ");
  }
}
function DateTimePickerComponent_ng_template_15_div_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 45)(1, "button", 46);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, DateTimePickerComponent_ng_template_15_div_16_button_3_Template, 2, 10, "button", 47);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(10, _c30, ctx_r1.handleFocus, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.popupButtonsClasses("primary"))("disabled", !ctx_r1.calendarValue)("kendoEventsOutsideAngular", ɵɵpureFunction3(13, _c35, ctx_r1.handleAccept, ctx_r1.handleTab, ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("title", ctx_r1.localization.get("acceptLabel"))("aria-label", ctx_r1.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("accept"), " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.cancelButton);
  }
}
function DateTimePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 32)(1, "div", 33)(2, "div", 34)(3, "button", 35);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "button", 36);
    ɵɵtext(6);
    ɵɵelementEnd()()();
    ɵɵelementStart(7, "div", 37, 5)(9, "div", 38)(10, "kendo-calendar", 39, 6);
    ɵɵtwoWayListener("valueChange", function DateTimePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_10_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.calendarValue, $event) || (ctx_r1.calendarValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("valueChange", function DateTimePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_10_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleCalendarValueChange());
    });
    ɵɵelement(12, "kendo-calendar-messages", 40);
    ɵɵelementEnd()();
    ɵɵelementStart(13, "div", 41)(14, "kendo-timeselector", 42);
    ɵɵlistener("tabOutLastPart", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutLastPart_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutLastPart());
    })("tabOutFirstPart", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutFirstPart_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutFirstPart());
    })("tabOutNow", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutNow_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutNow());
    });
    ɵɵelement(15, "kendo-timeselector-messages", 43);
    ɵɵelementEnd()()();
    ɵɵtemplate(16, DateTimePickerComponent_ng_template_15_div_16_Template, 4, 17, "div", 44);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dateTimeSelector_r8 = ɵɵreference(8);
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate1("k-datetime-wrap k-", ctx_r1.activeTab, "-tab");
    ɵɵproperty("ngClass", ɵɵpureFunction2(79, _c28, !ctx_r1.isAdaptive, ctx_r1.isAdaptive))("kendoEventsOutsideAngular", ɵɵpureFunction2(82, _c29, ctx_r1.preventMouseDown, ctx_r1.handleKeyDown))("scope", ctx_r1);
    ɵɵadvance();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(85, _c30, ctx_r1.handleFocus, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵadvance(2);
    ɵɵclassProp("k-selected", ctx_r1.activeTab === "date");
    ɵɵproperty("ngClass", ctx_r1.popupButtonsClasses())("kendoEventsOutsideAngular", ɵɵpureFunction2(88, _c31, ctx_r1.changeActiveTab.bind(ctx_r1, "date"), ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("aria-pressed", ctx_r1.activeTab === "date" ? "true" : "false")("title", ctx_r1.localization.get("dateTabLabel"))("aria-label", ctx_r1.localization.get("dateTabLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("dateTab"), " ");
    ɵɵadvance();
    ɵɵclassProp("k-selected", ctx_r1.activeTab === "time");
    ɵɵproperty("ngClass", ctx_r1.popupButtonsClasses())("kendoEventsOutsideAngular", ɵɵpureFunction2(91, _c32, ctx_r1.changeActiveTab.bind(ctx_r1, "time"), ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("aria-pressed", ctx_r1.activeTab === "time" ? "true" : "false")("title", ctx_r1.localization.get("timeTabLabel"))("aria-label", ctx_r1.localization.get("timeTabLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("timeTab"), " ");
    ɵɵadvance();
    ɵɵstyleProp("transition", ctx_r1.tabSwitchTransition);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(94, _c33, ctx_r1.handleTabChangeTransitionEnd.bind(ctx_r1, dateTimeSelector_r8)));
    ɵɵadvance(3);
    ɵɵproperty("focusedDate", ctx_r1.focusedDate)("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size);
    ɵɵtwoWayProperty("value", ctx_r1.calendarValue);
    ɵɵproperty("type", ctx_r1.calendarType)("min", ctx_r1.calendarMin)("max", ctx_r1.calendarMax)("weekDaysFormat", ctx_r1.weekDaysFormat)("weekNumber", ctx_r1.weekNumber)("navigation", false)("animateNavigation", ctx_r1.animateCalendarNavigation)("showOtherMonthDays", ctx_r1.showOtherMonthDays)("cellTemplate", ctx_r1.cellTemplate)("monthCellTemplate", ctx_r1.monthCellTemplate)("yearCellTemplate", ctx_r1.yearCellTemplate)("decadeCellTemplate", ctx_r1.decadeCellTemplate)("centuryCellTemplate", ctx_r1.centuryCellTemplate)("weekNumberTemplate", ctx_r1.weekNumberTemplate)("headerTitleTemplate", ctx_r1.headerTitleTemplate)("headerTemplate", ctx_r1.headerTemplate)("footerTemplate", ctx_r1.footerTemplate)("footer", ctx_r1.footer)("disabled", ctx_r1.disableCalendar)("disabledDates", ctx_r1.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r1.localization.get("today"))("prevButtonTitle", ctx_r1.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r1.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r1.localization.get("parentViewButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(96, _c34, ctx_r1.isAdaptive))("value", ctx_r1.value)("format", ctx_r1.timeSelectorFormat)("min", ctx_r1.timeSelectorMin)("max", ctx_r1.timeSelectorMax)("setButton", false)("cancelButton", false)("steps", ctx_r1.steps)("disabled", ctx_r1.disableTimeSelector)("isAdaptiveEnabled", ctx_r1.isAdaptiveModeEnabled)("isDateTimePicker", true);
    ɵɵadvance();
    ɵɵproperty("acceptLabel", ctx_r1.localization.get("acceptLabel"))("accept", ctx_r1.localization.get("accept"))("cancelLabel", ctx_r1.localization.get("cancelLabel"))("cancel", ctx_r1.localization.get("cancel"))("nowLabel", ctx_r1.localization.get("nowLabel"))("now", ctx_r1.localization.get("now"))("hour", ctx_r1.localization.get("hour"))("minute", ctx_r1.localization.get("minute"))("second", ctx_r1.localization.get("second"))("millisecond", ctx_r1.localization.get("millisecond"))("dayperiod", ctx_r1.localization.get("dayperiod"));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isAdaptive);
  }
}
var _c36 = ["defaultTemplate"];
function DateRangePopupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-multiviewcalendar", 6);
    ɵɵlistener("onClosePopup", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onClosePopup_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.closePopup($event));
    })("onTabPress", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onTabPress_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleTab($event));
    })("onShiftTabPress", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onShiftTabPress_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleShiftTab($event));
    })("rangeSelectionChange", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_rangeSelectionChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onRangeSelectionChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("animateNavigation", ctx_r2.animateNavigation)("disabled", ctx_r2.disabled)("views", ctx_r2.views)("weekNumber", ctx_r2.weekNumber)("topView", ctx_r2.topView)("disabledDates", ctx_r2.disabledDates)("min", ctx_r2.min)("max", ctx_r2.max)("showCalendarHeader", ctx_r2.showCalendarHeader)("focusedDate", ctx_r2.focusedDate)("allowReverse", ctx_r2.allowReverse)("showViewHeader", ctx_r2.showViewHeader)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("size", ctx_r2.size)("value", ctx_r2.dateRangeService.selectionRange);
  }
}
function DateRangePopupComponent_ng_template_7_kendo_resize_sensor_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 21);
    ɵɵlistener("resize", function DateRangePopupComponent_ng_template_7_kendo_resize_sensor_0_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onResize());
    });
    ɵɵelementEnd();
  }
}
function DateRangePopupComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵtemplate(0, DateRangePopupComponent_ng_template_7_kendo_resize_sensor_0_Template, 1, 0, "kendo-resize-sensor", 7);
    ɵɵelementStart(1, "div", 8)(2, "div", 9)(3, "div", 10)(4, "div", 11);
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "div", 12);
    ɵɵtext(7);
    ɵɵelementEnd()();
    ɵɵelementStart(8, "div", 13)(9, "button", 14);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_9_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.show = false);
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(10, "div", 15)(11, "div", 16)(12, "kendo-multiviewcalendar", 17);
    ɵɵlistener("rangeSelectionChange", function DateRangePopupComponent_ng_template_7_Template_kendo_multiviewcalendar_rangeSelectionChange_12_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onRangeSelectionChange($event));
    });
    ɵɵelementEnd()()();
    ɵɵelementStart(13, "div", 18)(14, "button", 19);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_14_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.show = false);
    });
    ɵɵtext(15);
    ɵɵelementEnd();
    ɵɵelementStart(16, "button", 20);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_16_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleAccept());
    });
    ɵɵtext(17);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r2.isAdaptiveModeEnabled);
    ɵɵadvance(5);
    ɵɵtextInterpolate(ctx_r2.title);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r2.xIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r2.localization.get("clearTitle"));
    ɵɵadvance(3);
    ɵɵproperty("animateNavigation", ctx_r2.animateNavigation)("disabled", ctx_r2.disabled)("views", ctx_r2.views)("weekNumber", ctx_r2.weekNumber)("disabledDates", ctx_r2.disabledDates)("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("topView", ctx_r2.topView)("min", ctx_r2.min)("max", ctx_r2.max)("showCalendarHeader", ctx_r2.showCalendarHeader)("focusedDate", ctx_r2.focusedDate)("allowReverse", ctx_r2.allowReverse)("showViewHeader", ctx_r2.showViewHeader)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("focusedDate", ctx_r2.dateRangeService.focusedDate)("value", ctx_r2.dateRangeService.selectionRange);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r2.localization.get("cancelLabel"))("aria-label", ctx_r2.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.localization.get("cancel"), " ");
    ɵɵadvance();
    ɵɵattribute("title", ctx_r2.localization.get("acceptLabel"))("aria-label", ctx_r2.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.localization.get("accept"), " ");
  }
}
function DateRangeComponent_kendo_daterange_popup_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-daterange-popup", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r0.size);
  }
}
var packageMetadata = {
  name: "@progress/kendo-angular-dateinputs",
  productName: "Kendo UI for Angular",
  productCodes: ["KENDOUIANGULAR", "KENDOUICOMPLETE"],
  publishDate: 1733732436,
  version: "17.1.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var Action;
(function(Action2) {
  Action2[Action2["Left"] = 0] = "Left";
  Action2[Action2["Right"] = 1] = "Right";
  Action2[Action2["Up"] = 2] = "Up";
  Action2[Action2["Down"] = 3] = "Down";
  Action2[Action2["PrevView"] = 4] = "PrevView";
  Action2[Action2["NextView"] = 5] = "NextView";
  Action2[Action2["FirstInView"] = 6] = "FirstInView";
  Action2[Action2["LastInView"] = 7] = "LastInView";
  Action2[Action2["LowerView"] = 8] = "LowerView";
  Action2[Action2["UpperView"] = 9] = "UpperView";
})(Action || (Action = {}));
var EMPTY_SELECTIONRANGE = {
  start: null,
  end: null
};
var MIDNIGHT_DATE = new Date(1980, 0, 1);
var MIN_DATE = new Date(1900, 0, 1);
var MAX_DATE = new Date(2099, 11, 31);
var MIN_TIME = new Date(1980, 0, 1);
var MAX_TIME = new Date(1980, 0, 1, 23, 59, 59);
var requiresZoneOnBlur = (ngControl) => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === "blur");
var preventDefault = (args) => args.preventDefault();
var currentFocusTarget = (blurArgs) => blurArgs.relatedTarget || document.activeElement;
var isPresent2 = (value2) => value2 !== void 0 && value2 !== null;
var isNullOrDate = (value2) => value2 === null || value2 instanceof Date;
var isTruthy = (value2) => !!value2;
var isNumberArray = (value2) => Array.isArray(value2) && value2.length > 0 && value2.every((item) => typeof item === "number");
var isDateArray = (value2) => Array.isArray(value2) && value2.length > 0 && value2.every((item) => item instanceof Date);
var isArrowWithShiftPressed = (args) => args.shiftKey && (args.keyCode === Keys2.ArrowRight || args.keyCode === Keys2.ArrowLeft || args.keyCode === Keys2.ArrowDown || args.keyCode === Keys2.ArrowUp);
var Keys2;
(function(Keys3) {
  Keys3[Keys3["ArrowDown"] = 40] = "ArrowDown";
  Keys3[Keys3["ArrowLeft"] = 37] = "ArrowLeft";
  Keys3[Keys3["ArrowRight"] = 39] = "ArrowRight";
  Keys3[Keys3["ArrowUp"] = 38] = "ArrowUp";
})(Keys2 || (Keys2 = {}));
var selectors = {
  infiniteCalendarTable: ".k-content .k-calendar-table",
  multiViewCalendarTable: ".k-calendar-table"
};
var attributeNames = {
  ariaActiveDescendant: "aria-activedescendant",
  ariaControls: "aria-controls",
  ariaExpanded: "aria-expanded",
  ariaHasPopup: "aria-haspopup",
  valueNow: "aria-valuenow",
  valuetext: "aria-valuetext",
  ariaInvalid: "aria-invalid"
};
var isSet = (value2) => value2 !== null && value2 !== void 0;
var setter = (method) => (date, value2) => {
  const clone2 = cloneDate(date);
  clone2[method](value2);
  return clone2;
};
var setTime = (origin, candidate) => {
  const date = cloneDate(origin);
  date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
  return date;
};
var getTimeInMilliseconds = (candidate) => {
  const hoursInMilliseconds = candidate.getHours() * MS_PER_HOUR;
  const minutesInMilliseconds = candidate.getMinutes() * MS_PER_MINUTE;
  const secondsInMilliseconds = candidate.getSeconds() * 1e3;
  return hoursInMilliseconds + minutesInMilliseconds + secondsInMilliseconds + candidate.getMilliseconds();
};
var normalizeTimes = (candidate, min, max) => {
  return {
    candidateValue: setTime(MIDNIGHT_DATE, candidate),
    maxValue: addDays(setTime(MIDNIGHT_DATE, max), getTimeInMilliseconds(min) < getTimeInMilliseconds(max) ? 0 : 1),
    minValue: setTime(MIDNIGHT_DATE, min)
  };
};
var setYears2 = setter("setFullYear");
var setHours$1 = setter("setHours");
var setMinutes = setter("setMinutes");
var setSeconds = setter("setSeconds");
var setMilliseconds = setter("setMilliseconds");
var range = (start, end, step = 1) => {
  const result = [];
  for (let i = start; i < end; i = i + step) {
    result.push(i);
  }
  return result;
};
var isInRange = (candidate, min, max) => !candidate || !(min && min > candidate || max && max < candidate);
var isInTimeRange = (candidate, min, max) => {
  if (!candidate || !min || !max) {
    return true;
  }
  const {
    candidateValue,
    minValue,
    maxValue
  } = normalizeTimes(candidate, min, max);
  return minValue <= candidateValue && candidateValue <= maxValue;
};
var isValidRange = (min, max) => !isSet(min) || !isSet(max) || min <= max;
var dateInRange = (candidate, min, max) => {
  if (!candidate) {
    return candidate;
  }
  if (min && candidate < min) {
    return cloneDate(min);
  }
  if (max && candidate > max) {
    return cloneDate(max);
  }
  return candidate;
};
var timeInRange = (candidate, min, max) => {
  if (!candidate || !min || !max) {
    return candidate;
  }
  const {
    candidateValue,
    minValue,
    maxValue
  } = normalizeTimes(candidate, min, max);
  if (candidateValue < minValue) {
    return setTime(candidate, min);
  }
  if (candidateValue > maxValue) {
    return setTime(candidate, max);
  }
  return candidate;
};
var getNow = () => /* @__PURE__ */ new Date();
var getToday = () => getDate(/* @__PURE__ */ new Date());
var noop$2 = (_) => {
};
var isWindowAvailable = () => {
  return typeof window !== "undefined";
};
var stringifyClassObject = (classes) => {
  const pushToAcc = (acc, cls) => classes[cls] ? acc.concat(cls) : acc;
  return Object.keys(classes).reduce(pushToAcc, []).join(" ");
};
var shiftWeekNames = (names, offset2) => names.slice(offset2).concat(names.slice(0, offset2));
var domContainerFactory = (type) => (children, classes = "", styles = {}) => {
  const container = document.createElement(type);
  container.className = classes;
  Object.keys(styles).map((key) => container.style[key] = styles[key]);
  if (typeof children === "string") {
    container.innerHTML = children || "";
  } else {
    (children || []).forEach((child) => child && container.appendChild(child));
  }
  return container;
};
var hasChange = (changes, field) => changes[field] !== void 0;
var hasExistingValue = (changes, field) => changes[field] && changes[field].currentValue !== void 0 && changes[field].currentValue !== null;
var last = (list2 = []) => list2 && list2[list2.length - 1];
var isInSelectionRange = (value2, selectionRange) => {
  const {
    start,
    end
  } = selectionRange || EMPTY_SELECTIONRANGE;
  if (!start || !end) {
    return false;
  }
  return start < value2 && value2 < end;
};
var either = (value1, value2) => value1 || value2;
var clampRange = (value2) => ({
  start: value2,
  end: value2
});
var isEqualRange = (initial2, updated) => {
  const {
    start: initialStart,
    end: initialEnd
  } = initial2 || EMPTY_SELECTIONRANGE;
  const {
    start: updatedStart,
    end: updatedEnd
  } = updated || EMPTY_SELECTIONRANGE;
  return isEqual(initialStart, updatedStart) && isEqual(initialEnd, updatedEnd);
};
var areDatesEqual = (first, second) => {
  first = first || [];
  second = second || [];
  return first.length === second.length && first.every((date, index) => isEqual(date, second[index]));
};
var sortDates = (dates) => {
  return dates.filter((date) => isPresent2(date)).sort((a, b) => a.getTime() - b.getTime());
};
var mergeDateAndTime = (date, time) => {
  if (!(date && time)) {
    return null;
  }
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
};
var lastMillisecondOfDate = (date) => {
  if (!date) {
    return null;
  }
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
};
var disabledDatesInRange = (start, end, isDateDisabled) => {
  if (!(start && end && isDateDisabled) || start > end) {
    return [];
  }
  const dates = [];
  let current = start;
  while (current <= end) {
    if (isDateDisabled(current)) {
      dates.push(current);
    }
    current = addDays(current, 1);
  }
  return dates;
};
var isTabExitingCalendar = (calendarType, focusedElement, shiftKey) => {
  if (!isPresent2(focusedElement)) {
    return false;
  }
  return calendarType === "infinite" || // infinte calendar is always exited on first tab keydown
  calendarType === "classic" && shiftKey && focusedElement.classList.contains("k-calendar-table") || // exited on main calendar element focused and back-tab
  !shiftKey && focusedElement.classList.contains("k-calendar-table");
};
var getSizeClass = (component, size) => {
  const SIZE_CLASSES = {
    "small": `k-${component}-sm`,
    "medium": `k-${component}-md`,
    "large": `k-${component}-lg`
  };
  return SIZE_CLASSES[size];
};
var getRoundedClass = (rounded) => {
  const ROUNDED_CLASSES = {
    "small": "k-rounded-sm",
    "medium": "k-rounded-md",
    "large": "k-rounded-lg",
    "full": "k-rounded-full"
  };
  return ROUNDED_CLASSES[rounded];
};
var getFillModeClass = (component, fillMode) => {
  const FILLMODE_CLASSES = {
    "solid": `k-${component}-solid`,
    "flat": `k-${component}-flat`,
    "outline": `k-${component}-outline`
  };
  return FILLMODE_CLASSES[fillMode];
};
var DEFAULT_ROUNDED = "medium";
var DEFAULT_SIZE = "medium";
var DEFAULT_FILL_MODE = "solid";
var windowSize = () => {
  if (!isDocumentAvailable()) {
    return;
  }
  if (window.innerWidth > 768) {
    return "large";
  } else if (window.innerWidth > 500) {
    return "medium";
  } else {
    return "small";
  }
};
var EMPTY_DATA$3 = [[]];
var CELLS_LENGTH$3 = 4;
var ROWS_LENGTH$3 = 3;
var upStep$1 = (year) => {
  const decadeOfCentury = Number(year.toString().slice(-2, -1));
  if (decadeOfCentury < 2) {
    return -2;
  }
  if (decadeOfCentury < 4) {
    return -6;
  }
  return -4;
};
var downStep$1 = (year) => {
  const decadeOfCentury = Number(year.toString().slice(-2, -1));
  if (decadeOfCentury > 7) {
    return 2;
  }
  if (decadeOfCentury > 5) {
    return 6;
  }
  return 4;
};
var ACTIONS$3 = {
  [Action.Left]: (date) => addDecades(date, -1),
  [Action.Up]: (date) => addDecades(date, upStep$1(date.getFullYear())),
  [Action.Right]: (date) => addDecades(date, 1),
  [Action.Down]: (date) => addDecades(date, downStep$1(date.getFullYear())),
  [Action.PrevView]: (date) => addCenturies(date, -1),
  [Action.NextView]: (date) => addCenturies(date, 1),
  [Action.FirstInView]: (date) => firstDecadeOfCentury(date),
  [Action.LastInView]: (date) => lastDecadeOfCentury(date)
};
var CenturyViewService = class _CenturyViewService {
  addToDate(min, skip3) {
    return addCenturies(min, skip3);
  }
  datesList(start, count) {
    return range(0, count).map((i) => addCenturies(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$3;
    }
    const cells = range(0, CELLS_LENGTH$3);
    const firstDate = firstDecadeOfCentury(viewDate);
    const lastDate = lastDecadeOfCentury(viewDate);
    const today2 = getToday();
    return range(0, ROWS_LENGTH$3).map((rowOffset) => {
      const baseDate = addDecades(firstDate, rowOffset * CELLS_LENGTH$3);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addDecades(baseDate, cellOffset), min, max);
        const nextCentury = cellDate.getFullYear() > lastDate.getFullYear();
        if (!this.isInRange(cellDate, min, max) || nextCentury) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date) => this.isEqual(cellDate, date)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today2),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return firstYearOfDecade(candidate).getFullYear() === firstYearOfDecade(expected).getFullYear();
  }
  isInArray(date, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 99;
  }
  isInRange(candidate, min, max) {
    const year = firstYearOfDecade(candidate).getFullYear();
    const aboveMin = !min || firstYearOfDecade(min).getFullYear() <= year;
    const belowMax = !max || year <= firstYearOfDecade(max).getFullYear();
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date) {
    if (!date) {
      return date;
    }
    const firstYear = firstYearOfDecade(firstDecadeOfCentury(date));
    return createDate(firstYear.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date) {
    const decade = lastDecadeOfCentury(date);
    const year = lastYearOfDecade(decade);
    const month = lastMonthOfYear(year);
    return lastDayOfMonth(month);
  }
  isRangeStart(value2) {
    return value2.getFullYear() % 1e3 === 0;
  }
  move(value2, action) {
    const modifier = ACTIONS$3[action];
    if (!modifier) {
      return value2;
    }
    return modifier(value2);
  }
  cellTitle(value2) {
    return firstYearOfDecade(value2).getFullYear().toString();
  }
  navigationTitle(value2) {
    return value2 ? firstDecadeOfCentury(value2).getFullYear().toString() : "";
  }
  title(value2) {
    if (!value2) {
      return "";
    }
    return `${firstDecadeOfCentury(value2).getFullYear()} - ${lastDecadeOfCentury(value2).getFullYear()}`;
  }
  rowLength() {
    return CELLS_LENGTH$3;
  }
  skip(value2, min) {
    return durationInCenturies(min, value2);
  }
  total(min, max) {
    return durationInCenturies(min, max) + 1;
  }
  value(current) {
    return current ? firstYearOfDecade(current).getFullYear().toString() : "";
  }
  viewDate(date, max, viewsCount = 1) {
    const viewsInRange = this.total(date, max);
    if (viewsInRange < viewsCount) {
      const centuriesToSubtract = viewsCount - viewsInRange;
      return addCenturies(date, -1 * centuriesToSubtract);
    }
    return date;
  }
  dateRange = (start, end) => {
    if (!isPresent2(start) || !isPresent2(end)) {
      return [];
    }
    const result = [];
    let current = start;
    while (current <= end) {
      result.push(current);
      current = addDecades(current, 1);
    }
    return result;
  };
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function CenturyViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CenturyViewService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CenturyViewService,
    factory: _CenturyViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CenturyViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var EMPTY_DATA$2 = [[]];
var CELLS_LENGTH$2 = 4;
var ROWS_LENGTH$2 = 3;
var upStep = (year) => {
  const yearOfDecade = Number(year.toString().slice(-1));
  if (yearOfDecade < 2) {
    return -2;
  }
  if (yearOfDecade < 4) {
    return -6;
  }
  return -4;
};
var downStep = (year) => {
  const yearOfDecade = Number(year.toString().slice(-1));
  if (yearOfDecade > 7) {
    return 2;
  }
  if (yearOfDecade > 5) {
    return 6;
  }
  return 4;
};
var ACTIONS$2 = {
  [Action.Left]: (date) => addYears(date, -1),
  [Action.Up]: (date) => addYears(date, upStep(date.getFullYear())),
  [Action.Right]: (date) => addYears(date, 1),
  [Action.Down]: (date) => addYears(date, downStep(date.getFullYear())),
  [Action.PrevView]: (date) => addDecades(date, -1),
  [Action.NextView]: (date) => addDecades(date, 1),
  [Action.FirstInView]: (date) => firstYearOfDecade(date),
  [Action.LastInView]: (date) => lastYearOfDecade(date)
};
var DecadeViewService = class _DecadeViewService {
  addToDate(min, skip3) {
    return addDecades(min, skip3);
  }
  datesList(start, count) {
    return range(0, count).map((i) => addDecades(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$2;
    }
    const cells = range(0, CELLS_LENGTH$2);
    const firstDate = firstYearOfDecade(viewDate);
    const lastDate = lastYearOfDecade(viewDate);
    const today2 = getToday();
    return range(0, ROWS_LENGTH$2).map((rowOffset) => {
      const baseDate = addYears(firstDate, rowOffset * CELLS_LENGTH$2);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addYears(baseDate, cellOffset), min, max);
        const nextDecade = cellDate.getFullYear() > lastDate.getFullYear();
        if (!this.isInRange(cellDate, min, max) || nextDecade) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date) => this.isEqual(cellDate, date)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today2),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return candidate.getFullYear() === expected.getFullYear();
  }
  isInArray(date, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 9;
  }
  isInRange(candidate, min, max) {
    const year = candidate.getFullYear();
    const aboveMin = !min || min.getFullYear() <= year;
    const belowMax = !max || year <= max.getFullYear();
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date) {
    if (!date) {
      return date;
    }
    const firstYear = firstYearOfDecade(date);
    return createDate(firstYear.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date) {
    const year = lastYearOfDecade(date);
    const month = lastMonthOfYear(year);
    return lastDayOfMonth(month);
  }
  isRangeStart(value2) {
    return value2.getFullYear() % 100 === 0;
  }
  move(value2, action) {
    const modifier = ACTIONS$2[action];
    if (!modifier) {
      return value2;
    }
    return modifier(value2);
  }
  cellTitle(value2) {
    return value2.getFullYear().toString();
  }
  navigationTitle(value2) {
    return value2 ? firstYearOfDecade(value2).getFullYear().toString() : "";
  }
  title(value2) {
    if (!value2) {
      return "";
    }
    return `${firstYearOfDecade(value2).getFullYear()} - ${lastYearOfDecade(value2).getFullYear()}`;
  }
  rowLength() {
    return CELLS_LENGTH$2;
  }
  skip(value2, min) {
    return durationInDecades(min, value2);
  }
  total(min, max) {
    return durationInDecades(min, max) + 1;
  }
  value(current) {
    return current ? current.getFullYear().toString() : "";
  }
  viewDate(date, max, viewsCount = 1) {
    const viewsInRange = this.total(date, max);
    if (viewsInRange < viewsCount) {
      const decadesToSubtract = viewsCount - viewsInRange;
      return addDecades(date, -1 * decadesToSubtract);
    }
    return date;
  }
  dateRange = (start, end) => {
    if (!isPresent2(start) || !isPresent2(end)) {
      return [];
    }
    const result = [];
    let current = start;
    while (current <= end) {
      result.push(current);
      current = addYears(current, 1);
    }
    return result;
  };
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function DecadeViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DecadeViewService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DecadeViewService,
    factory: _DecadeViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var EMPTY_DATA$1 = [[]];
var CELLS_LENGTH$1 = 7;
var ROWS_LENGTH$1 = 6;
var ACTIONS$1 = {
  [Action.Left]: (date) => addDays(date, -1),
  [Action.Up]: (date) => addWeeks(date, -1),
  [Action.Right]: (date) => addDays(date, 1),
  [Action.Down]: (date) => addWeeks(date, 1),
  [Action.PrevView]: (date) => addMonths(date, -1),
  [Action.NextView]: (date) => addMonths(date, 1),
  [Action.FirstInView]: (date) => firstDayOfMonth(date),
  [Action.LastInView]: (date) => lastDayOfMonth(date)
};
var MonthViewService = class _MonthViewService {
  _intlService;
  constructor(_intlService) {
    this._intlService = _intlService;
  }
  addToDate(min, skip3) {
    return addMonths(min, skip3);
  }
  datesList(start, count) {
    return range(0, count).map((i) => addMonths(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      isDateDisabled = () => false,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$1;
    }
    const firstMonthDate = firstDayOfMonth(viewDate);
    const firstMonthDay = getDate(firstMonthDate);
    const lastMonthDate = lastDayOfMonth(viewDate);
    const lastMonthDay = getDate(lastMonthDate);
    const backward = -1;
    const date = dayOfWeek(firstMonthDate, this._intlService.firstDay(), backward);
    const cells = range(0, CELLS_LENGTH$1);
    const today2 = getToday();
    return range(0, ROWS_LENGTH$1).map((rowOffset) => {
      const baseDate = addDays(date, rowOffset * CELLS_LENGTH$1);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addDays(baseDate, cellOffset), min, max);
        const cellDay = getDate(cellDate);
        const otherMonth = cellDay < firstMonthDay || cellDay > lastMonthDay;
        const outOfRange2 = cellDate < min || cellDate > max;
        if (outOfRange2) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${otherMonth ? cellDate.getTime() + "1" : cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date2) => this.isEqual(cellDate, date2)),
          isWeekend: this.isWeekend(cellDate),
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstMonthDate),
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastMonthDate),
          isToday: this.isEqual(cellDate, today2),
          title: this.cellTitle(cellDate),
          value: cellDate,
          isDisabled: isDateDisabled(cellDate),
          isOtherMonth: otherMonth,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return getDate(candidate).getTime() === getDate(expected).getTime();
  }
  isInArray(date, dates) {
    if (dates.length === 0) {
      return false;
    }
    const lowerBound = this.beginningOfPeriod(dates[0]);
    const upperBound = this.beginningOfPeriod(addMonths(dates[dates.length - 1], 1));
    return lowerBound <= date && date < upperBound;
  }
  isInRange(candidate, min, max) {
    const value2 = getDate(candidate);
    const aboveMin = !min || getDate(min) <= value2;
    const belowMax = !max || value2 <= getDate(max);
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date) {
    if (!date) {
      return date;
    }
    return createDate(date.getFullYear(), date.getMonth(), 1);
  }
  lastDayOfPeriod(date) {
    return lastDayOfMonth(date);
  }
  isRangeStart(value2) {
    return !value2.getMonth();
  }
  move(value2, action) {
    const modifier = ACTIONS$1[action];
    if (!modifier) {
      return value2;
    }
    return modifier(value2);
  }
  cellTitle(value2) {
    return this._intlService.formatDate(value2, "D");
  }
  navigationTitle(value2) {
    if (!value2) {
      return "";
    }
    return this.isRangeStart(value2) ? value2.getFullYear().toString() : this.abbrMonthNames()[value2.getMonth()];
  }
  title(current) {
    return `${this.wideMonthNames()[current.getMonth()]} ${current.getFullYear()}`;
  }
  rowLength(options = {}) {
    return CELLS_LENGTH$1 + (options.prependCell ? 1 : 0);
  }
  skip(value2, min) {
    return durationInMonths(min, value2);
  }
  total(min, max) {
    return durationInMonths(min, max) + 1;
  }
  value(current) {
    return current ? current.getDate().toString() : "";
  }
  viewDate(date, max, viewsCount = 1) {
    const viewsInRange = this.total(date, max);
    if (viewsInRange < viewsCount) {
      const monthsToSubtract = viewsCount - viewsInRange;
      return addMonths(date, -1 * monthsToSubtract);
    }
    return date;
  }
  isWeekend(date) {
    const {
      start,
      end
    } = this._intlService.weekendRange();
    const day = date.getDay();
    if (end < start) {
      return day <= end || start <= day;
    }
    return start <= day && day <= end;
  }
  dateRange = (start, end) => {
    if (!isPresent2(start) || !isPresent2(end)) {
      return [];
    }
    const result = [];
    let current = start;
    while (current <= end) {
      result.push(current);
      current = addDays(current, 1);
    }
    return result;
  };
  abbrMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "abbreviated",
      type: "months"
    });
  }
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  wideMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "wide",
      type: "months"
    });
  }
  static ɵfac = function MonthViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthViewService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MonthViewService,
    factory: _MonthViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var EMPTY_DATA = [[]];
var CELLS_LENGTH = 4;
var ROWS_LENGTH = 3;
var ACTIONS = {
  [Action.Left]: (date) => addMonths(date, -1),
  [Action.Up]: (date) => addMonths(date, -4),
  [Action.Right]: (date) => addMonths(date, 1),
  [Action.Down]: (date) => addMonths(date, 4),
  [Action.PrevView]: (date) => addYears(date, -1),
  [Action.NextView]: (date) => addYears(date, 1),
  [Action.FirstInView]: (date) => firstMonthOfYear(date),
  [Action.LastInView]: (date) => lastMonthOfYear(date)
};
var YearViewService = class _YearViewService {
  _intlService;
  constructor(_intlService) {
    this._intlService = _intlService;
  }
  addToDate(min, skip3) {
    return addYears(min, skip3);
  }
  datesList(start, count) {
    return range(0, count).map((i) => addYears(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA;
    }
    const months = this.abbrMonthNames();
    const firstDate = firstMonthOfYear(viewDate);
    const lastDate = lastMonthOfYear(viewDate);
    const currentYear = firstDate.getFullYear();
    const cells = range(0, CELLS_LENGTH);
    const today2 = getToday();
    return range(0, ROWS_LENGTH).map((rowOffset) => {
      const baseDate = addMonths(firstDate, rowOffset * CELLS_LENGTH);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addMonths(baseDate, cellOffset), min, max);
        const changedYear = currentYear < cellDate.getFullYear();
        if (!this.isInRange(cellDate, min, max) || changedYear) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: months[cellDate.getMonth()],
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date) => this.isEqual(cellDate, date)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today2),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return candidate.getFullYear() === expected.getFullYear() && candidate.getMonth() === expected.getMonth();
  }
  isInArray(date, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear();
  }
  isInRange(candidate, min, max) {
    const candidateValue = createDate(candidate.getFullYear(), candidate.getMonth(), 1);
    const aboveMin = !min || createDate(min.getFullYear(), min.getMonth(), 1) <= candidateValue;
    const belowMax = !max || candidateValue <= createDate(max.getFullYear(), max.getMonth(), 1);
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date) {
    if (!date) {
      return date;
    }
    return createDate(date.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date) {
    const month = lastMonthOfYear(date);
    return lastDayOfMonth(month);
  }
  isRangeStart(value2) {
    return value2.getFullYear() % 10 === 0;
  }
  move(value2, action) {
    const modifier = ACTIONS[action];
    if (!modifier) {
      return value2;
    }
    return modifier(value2);
  }
  cellTitle(value2) {
    return `${value2.getFullYear()} ${this.value(value2)}`;
  }
  navigationTitle(value2) {
    return this.title(value2);
  }
  title(current) {
    return current ? current.getFullYear().toString() : "";
  }
  rowLength() {
    return CELLS_LENGTH;
  }
  skip(value2, min) {
    return durationInYears(min, value2);
  }
  total(min, max) {
    return durationInYears(min, max) + 1;
  }
  value(current) {
    return current ? this.abbrMonthNames()[current.getMonth()] : "";
  }
  viewDate(date, max, viewsCount = 1) {
    const viewsInRange = this.total(date, max);
    if (viewsInRange < viewsCount) {
      const yearsToSubtract = viewsCount - viewsInRange;
      return addYears(date, -1 * yearsToSubtract);
    }
    return date;
  }
  dateRange = (start, end) => {
    if (!isPresent2(start) || !isPresent2(end)) {
      return [];
    }
    const result = [];
    let current = start;
    while (current <= end) {
      result.push(current);
      current = addMonths(current, 1);
    }
    return result;
  };
  abbrMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "abbreviated",
      type: "months"
    });
  }
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function YearViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _YearViewService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _YearViewService,
    factory: _YearViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var CalendarViewEnum;
(function(CalendarViewEnum2) {
  CalendarViewEnum2[CalendarViewEnum2["month"] = 0] = "month";
  CalendarViewEnum2[CalendarViewEnum2["year"] = 1] = "year";
  CalendarViewEnum2[CalendarViewEnum2["decade"] = 2] = "decade";
  CalendarViewEnum2[CalendarViewEnum2["century"] = 3] = "century";
})(CalendarViewEnum || (CalendarViewEnum = {}));
var services$1 = {
  [CalendarViewEnum.month]: MonthViewService,
  [CalendarViewEnum.year]: YearViewService,
  [CalendarViewEnum.decade]: DecadeViewService,
  [CalendarViewEnum.century]: CenturyViewService
};
var viewOffset = (view2, offset2) => {
  const candidate = CalendarViewEnum[CalendarViewEnum[view2 + offset2]];
  return candidate !== void 0 ? candidate : view2;
};
var nextCalendarId = 0;
var BusViewService = class _BusViewService {
  injector;
  viewChanged = new EventEmitter();
  bottom = CalendarViewEnum.month;
  top = CalendarViewEnum.century;
  calendarId;
  constructor(injector) {
    this.injector = injector;
    this.calendarId = nextCalendarId++;
  }
  configure(bottom, top) {
    this.bottom = bottom;
    this.top = top;
  }
  service(view2) {
    const serviceType = services$1[view2];
    return serviceType ? this.injector.get(serviceType) : null;
  }
  moveDown(view2) {
    this.move(view2, -1);
  }
  moveUp(view2) {
    this.move(view2, 1);
  }
  moveToBottom(activeView) {
    if (activeView === this.bottom) {
      return;
    }
    this.viewChanged.emit({
      view: this.bottom
    });
  }
  canMoveDown(view2) {
    return this.bottom < view2;
  }
  canMoveUp(view2) {
    return view2 < this.top;
  }
  clamp(view2) {
    if (view2 < this.bottom) {
      return this.bottom;
    }
    if (view2 > this.top) {
      return this.top;
    }
    return view2;
  }
  move(view2, offset2) {
    const candidate = this.clamp(viewOffset(view2, offset2));
    if (candidate === view2) {
      return;
    }
    this.viewChanged.emit({
      view: candidate
    });
  }
  static ɵfac = function BusViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BusViewService)(ɵɵinject(Injector));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BusViewService,
    factory: _BusViewService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BusViewService, [{
    type: Injectable
  }], function() {
    return [{
      type: Injector
    }];
  }, null);
})();
var KForOfContext = class {
  $implicit;
  kForOf;
  index;
  count;
  constructor($implicit, kForOf, index, count) {
    this.$implicit = $implicit;
    this.kForOf = kForOf;
    this.index = index;
    this.count = count;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
};
var KForOf = class _KForOf {
  _viewContainer;
  _template;
  _differs;
  kForOf;
  kForTrackBy;
  _differ = null;
  constructor(_viewContainer, _template, _differs) {
    this._viewContainer = _viewContainer;
    this._template = _template;
    this._differs = _differs;
  }
  set kForTemplate(value2) {
    if (value2) {
      this._template = value2;
    }
  }
  ngOnChanges(changes) {
    if ("kForOf" in changes) {
      const value2 = changes["kForOf"].currentValue;
      if (this._differ || !value2) {
        return;
      }
      try {
        this._differ = this._differs.find(value2).create(this.kForTrackBy);
      } catch (e) {
        throw new Error(`Cannot find a differ supporting object '${value2}' of type '${getTypeNameForDebugging(value2)}'.`);
      }
    }
  }
  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this.kForOf);
      if (changes) {
        this._applyChanges(changes);
      }
    }
  }
  _applyChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    const viewContainerLength = this._viewContainer.length;
    const dataLength = this.kForOf.length;
    const tuples = {};
    changes.forEachOperation((record, _, currentIndex) => {
      if (currentIndex !== null) {
        tuples[currentIndex] = record.item;
      }
    });
    for (let i = viewContainerLength; i < dataLength; i++) {
      this._viewContainer.createEmbeddedView(this._template, new KForOfContext(null, this.kForOf, -1, -1), i);
    }
    for (let i = this._viewContainer.length; i > dataLength; i--) {
      this._viewContainer.remove(i - 1);
    }
    for (let i = 0; i < this._viewContainer.length; i++) {
      const view2 = this._viewContainer.get(i);
      view2.context.index = i;
      view2.context.count = length;
      view2.context.$implicit = tuples[i] || null;
    }
  }
  static ɵfac = function KForOf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KForOf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _KForOf,
    selectors: [["", "kFor", "", "kForOf", ""]],
    inputs: {
      kForOf: "kForOf",
      kForTrackBy: "kForTrackBy",
      kForTemplate: "kForTemplate"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KForOf, [{
    type: Directive,
    args: [{
      selector: "[kFor][kForOf]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: TemplateRef
    }, {
      type: IterableDiffers
    }];
  }, {
    kForOf: [{
      type: Input
    }],
    kForTrackBy: [{
      type: Input
    }],
    kForTemplate: [{
      type: Input
    }]
  });
})();
function getTypeNameForDebugging(type) {
  return type.name || typeof type;
}
var noop$1 = () => false;
var DISABLED_DATES_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/disabled-dates/";
var DisabledDatesService = class _DisabledDatesService {
  /**
   * Emits every time the `isDateDisabled` method changes.
   */
  changes = new Subject();
  /**
   * Based on the user-defined `disabledDates` input evaluates if the date is disabled.
   * If not set, returns `false`.
   */
  isDateDisabled = noop$1;
  /**
   * Configures the `isDateDisabled` function.
   *
   * * If a function is provided, uses it as-is and passes each date to it for evaluation.
   * The time part is set to `midnight`.
   * * If a `Date[]` is provided, creates a function that checks the targeted date against
   * the listed dates and, if the targeted date is listed, marks it as disabled.
   * * If a `Day[]` is provided, creates a function that evaluates the provided days of the
   * week as disabled.
   */
  initialize(disabledDates) {
    if (typeof disabledDates === "function") {
      this.isDateDisabled = (date) => disabledDates(getDate(date));
    } else if (isNumberArray(disabledDates)) {
      const disabledWeekDays = new Set(disabledDates);
      this.isDateDisabled = (date) => disabledWeekDays.has(date.getDay());
    } else if (isDateArray(disabledDates)) {
      const normalizedDisabledDates = new Set(disabledDates.map((date) => getDate(date).getTime()));
      this.isDateDisabled = (date) => normalizedDisabledDates.has(getDate(date).getTime());
    } else {
      this.isDateDisabled = noop$1;
      this.notifyInvalidInput(disabledDates);
    }
    this.notifyServiceChange();
  }
  notifyInvalidInput(disabledDates) {
    if (isPresent2(disabledDates) && isDevMode()) {
      throw new Error(`The 'disabledDates' value should be a function, a Day array or a Date array. Check ${DISABLED_DATES_DOC_LINK} for more information.`);
    }
  }
  notifyServiceChange() {
    this.changes.next();
  }
  static ɵfac = function DisabledDatesService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DisabledDatesService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DisabledDatesService,
    factory: _DisabledDatesService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisabledDatesService, [{
    type: Injectable
  }], null, null);
})();
var closestInScope = (node, predicate, scope) => {
  while (node && node !== scope && !predicate(node)) {
    node = node.parentNode;
  }
  if (node !== scope) {
    return node;
  }
};
var closest2 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var ViewComponent = class _ViewComponent {
  bus;
  intl;
  cdr;
  element;
  zone;
  renderer;
  disabledDatesService;
  allowReverse;
  showOtherMonthDays;
  direction = "vertical";
  isActive = true;
  activeView;
  cellUID;
  focusedDate;
  viewDate;
  activeRangeEnd;
  selectionRange;
  min;
  max;
  selectedDates = [];
  get weekNumber() {
    return this.showWeekNumbers && this.activeView === CalendarViewEnum.month;
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  viewIndex;
  templateRef;
  weekNumberTemplateRef;
  headerTitle;
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  cellEnter = new EventEmitter();
  cellLeave = new EventEmitter();
  focusedCellId = new EventEmitter();
  get ariaHidden() {
    return this.headerTitle === this.title ? null : true;
  }
  colSpan = 0;
  data;
  service;
  title;
  subscriptions = new Subscription();
  showWeekNumbers;
  domEvents = [];
  currentCellIndex;
  constructor(bus, intl, cdr, element, zone, renderer, disabledDatesService) {
    this.bus = bus;
    this.intl = intl;
    this.cdr = cdr;
    this.element = element;
    this.zone = zone;
    this.renderer = renderer;
    this.disabledDatesService = disabledDatesService;
    this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.disabledDatesChange.bind(this)));
  }
  ngOnInit() {
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.colSpan = this.service.rowLength({
      prependCell: this.weekNumber
    });
    this.title = this.service.title(this.viewDate);
    this.updateData();
    if (changes.activeView) {
      this.currentCellIndex = null;
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.domEvents.forEach((unsubscribeCallback) => unsubscribeCallback());
  }
  isHorizontal() {
    return this.direction === "horizontal";
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  shouldRenderCellContent(cellCtx) {
    return isPresent2(cellCtx) && (!cellCtx.isOtherMonth || cellCtx.isOtherMonth && this.showOtherMonthDays);
  }
  firstDate(rowCtx) {
    const ctx = this.firstWeekDateContext(rowCtx);
    return ctx ? ctx.value : null;
  }
  getWeekNumber(date) {
    if (!this.weekNumber) {
      return null;
    }
    return weekInYear(date, this.intl.firstDay());
  }
  getWeekNumberContext(rowCtx) {
    const ctx = this.firstWeekDateContext(rowCtx);
    if (!this.weekNumber || !ctx) {
      return null;
    }
    const weekNumber = weekInYear(ctx.value, this.intl.firstDay()).toString();
    return {
      formattedValue: weekNumber,
      id: null,
      isFocused: false,
      isSelected: false,
      isWeekend: false,
      title: weekNumber,
      value: cloneDate(ctx.value)
    };
  }
  getStyles(context) {
    if (!context.isOtherMonth && this.isActive && context.isFocused) {
      this.focusedCellId.emit(context.id);
    }
    const {
      isRangeEnd,
      isRangeStart
    } = context;
    const isEndActive = this.activeRangeEnd === "end" && isRangeEnd;
    const isStartActive = this.activeRangeEnd === "start" && isRangeStart;
    return stringifyClassObject({
      "k-range-end": !context.isOtherMonth && isRangeEnd,
      "k-range-mid": !context.isOtherMonth && context.isRangeMid,
      "k-range-split-end": !context.isOtherMonth && context.isRangeSplitEnd,
      "k-range-split-start": !context.isOtherMonth && context.isRangeSplitStart,
      "k-range-start": !context.isOtherMonth && isRangeStart,
      "k-active": isStartActive || isEndActive,
      "k-focus": !context.isOtherMonth && this.isActive && context.isFocused,
      "k-selected": !context.isOtherMonth && (context.isSelected || isRangeStart || isRangeEnd),
      "k-today": !context.isOtherMonth && context.isToday,
      "k-weekend": context.isWeekend,
      "k-disabled": context.isDisabled,
      "k-other-month": context.isOtherMonth
    });
  }
  tableCellIndex(rowIndex, cellIndex) {
    return `${rowIndex}:${cellIndex}`;
  }
  handleWeekNumberClick(week) {
    const availableDates = week.filter((day) => day).map((item) => item.value).filter((date) => !this.disabledDatesService.isDateDisabled(date));
    this.weekNumberCellClick.emit(availableDates);
  }
  getMonthLabel(date) {
    return this.activeView === 1 ? this.intl.formatDate(date, "MMMM") : null;
  }
  firstWeekDateContext(rowCtx) {
    if (!this.weekNumber) {
      return null;
    }
    let idx2 = 0;
    let ctx = this.shouldRenderCellContent(rowCtx[idx2]) ? rowCtx[idx2] : null;
    while (!ctx && idx2 < rowCtx.length) {
      const cellCtx = rowCtx[++idx2];
      ctx = this.shouldRenderCellContent(cellCtx) ? cellCtx : null;
    }
    return ctx;
  }
  updateData() {
    const time = last(this.selectedDates) || getToday();
    const viewDate = setTime(this.viewDate, time);
    this.data = this.service.data({
      cellUID: this.cellUID,
      focusedDate: this.focusedDate,
      isActiveView: !this.bus.canMoveDown(this.activeView),
      max: this.max,
      min: this.min,
      selectedDates: this.selectedDates,
      selectionRange: this.selectionRange,
      viewDate,
      isDateDisabled: this.disabledDatesService.isDateDisabled,
      direction: this.direction,
      allowReverse: this.allowReverse
    });
  }
  intlChange() {
    this.updateData();
    this.cdr.markForCheck();
  }
  disabledDatesChange() {
    this.updateData();
    this.cdr.markForCheck();
  }
  bindEvents() {
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "mouseover", this.cellMouseoverHandler.bind(this)), this.renderer.listen(element, "mouseleave", this.mouseLeaveHandler.bind(this)), this.renderer.listen(element, "click", this.clickHandler.bind(this)));
  }
  clickHandler(args) {
    const cell = this.closestCell(args);
    if (!cell) {
      return;
    }
    const index = cell.getAttribute("data-cell-index");
    const cellContext = this.cellByIndex(index);
    if (!cellContext.isDisabled) {
      const {
        ctrlKey,
        metaKey,
        shiftKey
      } = args;
      this.cellClick.emit({
        date: cellContext.value,
        modifiers: {
          ctrlKey,
          metaKey,
          shiftKey
        }
      });
    }
  }
  mouseLeaveHandler() {
    if (this.currentCellIndex) {
      this.emitCellLeave();
    }
  }
  cellMouseoverHandler(args) {
    const cell = this.closestCell(args);
    if (cell) {
      const index = cell.getAttribute("data-cell-index");
      if (this.currentCellIndex && this.currentCellIndex !== index) {
        this.emitCellLeave();
      }
      const value2 = this.cellByIndex(index).value;
      this.cellEnter.emit(value2);
      this.currentCellIndex = index;
    } else if (this.currentCellIndex) {
      this.emitCellLeave();
    }
  }
  closestCell(eventArgs) {
    return closestInScope(eventArgs.target, (node) => node.hasAttribute("data-cell-index"), this.element.nativeElement);
  }
  emitCellLeave() {
    const item = this.cellByIndex(this.currentCellIndex);
    if (item) {
      this.cellLeave.emit(item.value);
    }
    this.currentCellIndex = null;
  }
  cellByIndex(index) {
    const [rowIndex, cellIndex] = index.split(":");
    return this.data[rowIndex][cellIndex];
  }
  static ɵfac = function ViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DisabledDatesService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ViewComponent,
    selectors: [["", "kendoCalendarView", ""]],
    inputs: {
      allowReverse: "allowReverse",
      showOtherMonthDays: "showOtherMonthDays",
      direction: "direction",
      isActive: "isActive",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      viewDate: "viewDate",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      min: "min",
      max: "max",
      selectedDates: "selectedDates",
      weekNumber: "weekNumber",
      viewIndex: "viewIndex",
      templateRef: "templateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      headerTitle: "headerTitle"
    },
    outputs: {
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      focusedCellId: "focusedCellId"
    },
    features: [ɵɵNgOnChangesFeature],
    attrs: _c0,
    decls: 4,
    vars: 2,
    consts: [["emptyCell", ""], ["class", "k-calendar-tr", "role", "row", 4, "ngIf"], ["class", "k-calendar-tr", "role", "row", 4, "kFor", "kForOf"], ["role", "gridcell", 1, "k-empty", "k-calendar-td"], ["role", "row", 1, "k-calendar-tr"], ["scope", "col", 1, "k-calendar-caption", 3, "colSpan"], [3, "ngIf"], [4, "kFor", "kForOf"], ["class", "k-alt k-calendar-td", "role", "gridcell", 3, "click", 4, "ngIf", "ngIfElse"], ["role", "gridcell", 1, "k-alt", "k-calendar-td", 3, "click"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "k-calendar-td", "role", "gridcell", 3, "ngClass", "title", 4, "ngIf", "ngIfElse"], ["role", "gridcell", 1, "k-calendar-td", 3, "ngClass", "title"], [1, "k-link"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function ViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ViewComponent_ng_template_0_Template, 2, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, ViewComponent_tr_2_Template, 3, 3, "tr", 1)(3, ViewComponent_tr_3_Template, 3, 2, "tr", 2);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.isHorizontal());
        ɵɵadvance();
        ɵɵproperty("kForOf", ctx.data);
      }
    },
    dependencies: [NgIf, KForOf, NgTemplateOutlet, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line
      selector: "[kendoCalendarView]",
      template: `
    <ng-template #emptyCell><td class="k-empty k-calendar-td" role="gridcell">&nbsp;</td></ng-template>
    <tr *ngIf="!isHorizontal()" class="k-calendar-tr" role="row" [attr.aria-hidden]="ariaHidden"><th class="k-calendar-caption" scope="col" [colSpan]="colSpan">{{title}}</th></tr>
    <tr *kFor="let row of data; let rowIndex = index" class="k-calendar-tr" role="row">
        <ng-template [ngIf]="weekNumber">
            <td
                class="k-alt k-calendar-td"
                role="gridcell"
                *ngIf="firstDate(row); else emptyCell"
                (click)="handleWeekNumberClick(row)"
            >
                <ng-template [ngIf]="!weekNumberTemplateRef">
                    {{getWeekNumber(firstDate(row))}}
                </ng-template>
                <ng-template
                    [ngIf]="weekNumberTemplateRef"
                    [ngTemplateOutlet]="weekNumberTemplateRef"
                    [ngTemplateOutletContext]="{
                        $implicit: firstDate(row),
                        cellContext: getWeekNumberContext(row)
                    }"
                ></ng-template>
            </td>
        </ng-template>
        <ng-container *kFor="let cell of row; let cellIndex = index">
            <td class="k-calendar-td"
                *ngIf="shouldRenderCellContent(cell); else emptyCell"
                role="gridcell"
                [attr.id]="cell.id"
                [attr.data-cell-index]="tableCellIndex(rowIndex, cellIndex)"
                [attr.aria-selected]="cell.isSelected || cell.isRangeStart || cell.isRangeMid || cell.isRangeEnd"
                [attr.aria-disabled]="cell.isDisabled"
                [attr.aria-label]="getMonthLabel(cell.value)"
                [ngClass]="getStyles(cell)"
                [title]="cell.title"
            >
                <span class="k-link">
                    <ng-template [ngIf]="!templateRef">{{cell.formattedValue}}</ng-template>
                    <ng-template
                        *ngIf="templateRef"
                        [ngTemplateOutlet]="templateRef"
                        [ngTemplateOutletContext]="{ $implicit: cell.value, cellContext: cell }"
                    ></ng-template>
                </span>
            </td>
        </ng-container>
    </tr>
  `,
      standalone: true,
      imports: [NgIf, KForOf, NgTemplateOutlet, NgClass]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: DisabledDatesService
    }];
  }, {
    allowReverse: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    direction: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    viewDate: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    viewIndex: [{
      type: Input
    }],
    templateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    headerTitle: [{
      type: Input
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    focusedCellId: [{
      type: Output
    }]
  });
})();
var DEFAULT_VIEWS_LENGTH = 2;
var HorizontalViewListComponent = class _HorizontalViewListComponent {
  bus;
  intl;
  cdr;
  element;
  renderer;
  handleMultiViewCalendarFocus() {
    this.focusCalendar.emit();
  }
  handleMultiViewCalendarBlur(event2) {
    this.blurCalendar.emit(event2);
  }
  /**
   * Needed for the MultiViewCalendar used in the Scheduler Year view
   */
  showOtherMonthDays = true;
  cellTemplateRef;
  weekNumberTemplateRef;
  allowReverse;
  activeRangeEnd;
  activeView = CalendarViewEnum.month;
  cellUID;
  focusedDate;
  isActive = true;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  selectionRange;
  selectedDates = [];
  views = DEFAULT_VIEWS_LENGTH;
  showViewHeader = false;
  animateNavigation = false;
  orientation = "horizontal";
  activeDescendant;
  tabIndex = 0;
  disabled = false;
  id;
  weekDaysFormat = "short";
  get weekNumber() {
    return this.showWeekNumbers && this.isMonthView();
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  cellEnter = new EventEmitter();
  cellLeave = new EventEmitter();
  activeDateChange = new EventEmitter();
  focusCalendar = new EventEmitter();
  blurCalendar = new EventEmitter();
  focusedCellChange = new EventEmitter();
  getComponentClass = true;
  get horizontalHostClass() {
    return this.orientation === "horizontal";
  }
  get verticalHostClass() {
    return this.orientation === "vertical";
  }
  get getComponentMonthClass() {
    return this.activeView === CalendarViewEnum.month;
  }
  get getComponentYearClass() {
    return this.activeView === CalendarViewEnum.year;
  }
  get getComponentDecadeClass() {
    return this.activeView === CalendarViewEnum.decade;
  }
  get getComponentCenturyClass() {
    return this.activeView === CalendarViewEnum.century;
  }
  get role() {
    return this.views >= 2 ? "grid" : null;
  }
  get tabindex() {
    return this.views >= 2 ? "0" : null;
  }
  get getActiveDescendant() {
    return this.views === 1 ? this.activeDescendant : null;
  }
  get getTabIndex() {
    return this.disabled || this.views >= 2 ? null : this.tabIndex;
  }
  service;
  weekNames = [];
  wideWeekNames = [];
  activeDate;
  dates = [];
  skip;
  total;
  nextAnimationDate;
  prevAnimationDate;
  showWeekNumbers;
  intlSubscription;
  animation;
  constructor(bus, intl, cdr, element, renderer) {
    this.bus = bus;
    this.intl = intl;
    this.cdr = cdr;
    this.element = element;
    this.renderer = renderer;
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.initService();
    if (this.weekNames.length === 0 || changes.weekNumber) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
      this.wideWeekNames = this.getWeekNames("wide");
    }
    if (changes.weekDaysFormat && this.weekNames.length !== 0 && !changes.weekNumber) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
    }
    if (!this.service) {
      return;
    }
    this.views = this.views || DEFAULT_VIEWS_LENGTH;
    const focusedDate = this.focusedDate;
    const viewDate = this.clampDate(this.service.viewDate(focusedDate, this.max, this.views));
    this.skip = this.service.skip(viewDate, this.min);
    this.total = this.service.total(this.min, this.max);
    const activeViewChanged = hasChange(changes, "activeView");
    const viewsHasChanged = this.views > 0 && hasChange(changes, "views");
    if (activeViewChanged || !this.isInDates(focusedDate) || viewsHasChanged || !this.activeDate) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
      this.activeDate = cloneDate(this.dates[0]);
      this.activeDateChange.emit(this.activeDate);
    }
    this.setAriaActivedescendant();
    if (this.views >= 2) {
      this.renderer.setAttribute(this.element.nativeElement, "tabindex", this.tabIndex.toString());
    }
  }
  ngOnDestroy() {
    this.intlSubscription.unsubscribe();
  }
  initService() {
    this.service = this.bus.service(this.activeView);
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  getCaptionTitle(date) {
    return this.service.title(date);
  }
  handleClassicCalendarFocus() {
    this.focusCalendar.emit();
  }
  handleClassicCalendarBlur(event2) {
    this.blurCalendar.emit(event2);
  }
  animateView(action) {
    const container = this.element.nativeElement;
    const table2 = container.querySelector("table");
    const initialContainerWidth = parseFloat(getComputedStyle(container).width);
    const tableWidth = parseFloat(getComputedStyle(table2).width);
    this.renderer.setStyle(container, "width", `${initialContainerWidth}px`);
    this.renderer.setStyle(container, "overflow", "visible");
    if (action === Action.NextView) {
      this.nextAnimationDate = cloneDate(this.dates[0]);
    } else {
      this.prevAnimationDate = cloneDate(this.dates[this.dates.length - 1]);
    }
    this.cdr.detectChanges();
    container.querySelectorAll("table").forEach((table3) => {
      this.renderer.setStyle(table3, "width", `${tableWidth}px`);
    });
    const tabRect = table2.getBoundingClientRect();
    const containerGap = parseFloat(getComputedStyle(container).columnGap);
    const start = action === Action.NextView ? "translateX(0)" : `translateX(-${tabRect.width + containerGap}px)`;
    const end = action === Action.NextView ? `translateX(-${tabRect.width + containerGap}px)` : "translateX(0)";
    if (!this.animation) {
      this.animation = container.animate([{
        transform: start
      }, {
        transform: end
      }], {
        duration: 500,
        easing: "ease-out"
      });
      this.animation.oncancel = this.animation.onfinish = () => {
        this.renderer.removeStyle(container, "width");
        this.renderer.removeStyle(container, "overflow");
        container.querySelectorAll("table").forEach((table3) => {
          this.renderer.removeStyle(table3, "width");
        });
        this.animation = null;
        this.nextAnimationDate = null;
        this.prevAnimationDate = null;
        this.cdr.detectChanges();
      };
    } else {
      this.animation.cancel();
    }
  }
  navigate(action) {
    if (this.animateNavigation && isDocumentAvailable() && isPresent2(this.element.nativeElement.animate)) {
      this.animateView(action);
    }
    const candidate = this.move(action);
    const list2 = this.service.datesList(candidate, this.getTake(this.skip));
    if (this.isListInRange(list2)) {
      this.dates = list2;
    }
    this.activeDate = cloneDate(this.dates[0]);
    this.focusedDate = cloneDate(candidate);
    this.cdr.markForCheck();
    this.activeDateChange.emit(this.activeDate);
    return cloneDate(candidate);
  }
  canNavigate(action) {
    if (!this.service) {
      return false;
    }
    return this.isListInRange(this.service.datesList(this.move(action), this.getTake(this.skip)));
  }
  getWeekNames(type) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType: type,
      type: "days"
    }), this.intl.firstDay());
    return this.weekNumber ? [""].concat(weekNames) : weekNames;
  }
  intlChange() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    this.cdr.markForCheck();
  }
  clampDate(value2) {
    return dateInRange(value2, this.min, this.max);
  }
  move(action) {
    return this.service.move(this.dates[0] || this.focusedDate, action);
  }
  isListInRange(list2) {
    const lowerBound = this.service.beginningOfPeriod(this.min);
    const upperBound = this.service.beginningOfPeriod(this.service.addToDate(this.max, 1));
    return lowerBound <= list2[0] && list2[list2.length - 1] < upperBound;
  }
  isInDates(value2) {
    return this.service.isInArray(value2, this.dates);
  }
  getTake(skip3) {
    return Math.min(this.total - skip3, this.views);
  }
  setAriaActivedescendant() {
    if (this.views >= 2) {
      this.renderer.setAttribute(this.element.nativeElement, attributeNames.ariaActiveDescendant, this.activeDescendant);
    }
  }
  static ɵfac = function HorizontalViewListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HorizontalViewListComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HorizontalViewListComponent,
    selectors: [["kendo-calendar-horizontal"]],
    hostVars: 20,
    hostBindings: function HorizontalViewListComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function HorizontalViewListComponent_focus_HostBindingHandler() {
          return ctx.handleMultiViewCalendarFocus();
        })("blur", function HorizontalViewListComponent_blur_HostBindingHandler($event) {
          return ctx.handleMultiViewCalendarBlur($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex);
        ɵɵclassProp("k-calendar-view", ctx.getComponentClass)("k-align-items-start", ctx.getComponentClass)("k-justify-content-center", ctx.getComponentClass)("k-hstack", ctx.horizontalHostClass)("k-vstack", ctx.verticalHostClass)("k-calendar-monthview", ctx.getComponentMonthClass)("k-calendar-yearview", ctx.getComponentYearClass)("k-calendar-decadeview", ctx.getComponentDecadeClass)("k-calendar-centuryview", ctx.getComponentCenturyClass);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      cellTemplateRef: "cellTemplateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      allowReverse: "allowReverse",
      activeRangeEnd: "activeRangeEnd",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      isActive: "isActive",
      min: "min",
      max: "max",
      selectionRange: "selectionRange",
      selectedDates: "selectedDates",
      views: "views",
      showViewHeader: "showViewHeader",
      animateNavigation: "animateNavigation",
      orientation: "orientation",
      activeDescendant: "activeDescendant",
      tabIndex: "tabIndex",
      disabled: "disabled",
      id: "id",
      weekDaysFormat: "weekDaysFormat",
      weekNumber: "weekNumber"
    },
    outputs: {
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      activeDateChange: "activeDateChange",
      focusCalendar: "focusCalendar",
      blurCalendar: "blurCalendar",
      focusedCellChange: "focusedCellChange"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 3,
    consts: [["tableTemplate", ""], [4, "ngIf"], [4, "kFor", "kForOf"], [1, "k-calendar-table", 3, "focus", "blur", "ngClass"], ["class", "k-calendar-caption", 4, "ngIf"], ["class", "k-calendar-thead", "role", "rowgroup", 4, "ngIf"], ["kendoCalendarView", "", "role", "rowgroup", "direction", "horizontal", 1, "k-calendar-tbody", 3, "cellClick", "weekNumberCellClick", "cellEnter", "cellLeave", "focusedCellId", "allowReverse", "showOtherMonthDays", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "selectionRange", "activeRangeEnd", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate"], [1, "k-calendar-caption"], ["role", "rowgroup", 1, "k-calendar-thead"], ["role", "row", 1, "k-calendar-tr"], ["class", "k-calendar-th", "scope", "col", "role", "columnheader", 4, "ngFor", "ngForOf"], ["scope", "col", "role", "columnheader", 1, "k-calendar-th"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function HorizontalViewListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, HorizontalViewListComponent_ng_template_0_Template, 4, 22, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, HorizontalViewListComponent_2_Template, 1, 4, null, 1)(3, HorizontalViewListComponent_3_Template, 1, 4, null, 2)(4, HorizontalViewListComponent_4_Template, 1, 4, null, 1);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.nextAnimationDate);
        ɵɵadvance();
        ɵɵproperty("kForOf", ctx.dates);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prevAnimationDate);
      }
    },
    dependencies: [NgClass, NgIf, NgForOf, ViewComponent, NgTemplateOutlet, KForOf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HorizontalViewListComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-horizontal",
      template: `
        <ng-template #tableTemplate let-date="date" let-class="className">
            <table
                [attr.role]="views >= 2 ? 'none' : 'grid'"
                class="k-calendar-table"
                [ngClass]="class"
                [attr.aria-labelledby]="id"
                [attr.aria-activedescendant]="getActiveDescendant"
                [attr.tabindex]="getTabIndex"
                (focus)="handleClassicCalendarFocus()"
                (blur)="handleClassicCalendarBlur($event)"
            >
                <caption *ngIf="showViewHeader" class="k-calendar-caption">{{ getCaptionTitle(date) }}</caption>
                <thead *ngIf="isMonthView()" class="k-calendar-thead" role="rowgroup">
                    <tr class="k-calendar-tr" role="row">
                        <th *ngFor="let name of weekNames; let i = index;"
                        class="k-calendar-th"
                        scope="col"
                        [attr.aria-label]="wideWeekNames[i]"
                        role="columnheader"
                        >{{name}}</th>
                    </tr>
                </thead>
                <tbody
                    class="k-calendar-tbody"
                    kendoCalendarView
                    [allowReverse]="allowReverse"
                    [showOtherMonthDays]="showOtherMonthDays"
                    role="rowgroup"
                    direction="horizontal"
                    [activeView]="activeView"
                    [isActive]="isActive"
                    [min]="min"
                    [max]="max"
                    [cellUID]="cellUID"
                    [focusedDate]="focusedDate"
                    [selectedDates]="selectedDates"
                    [selectionRange]="selectionRange"
                    [activeRangeEnd]="activeRangeEnd"
                    [weekNumber]="weekNumber"
                    [templateRef]="cellTemplateRef"
                    [weekNumberTemplateRef]="weekNumberTemplateRef"
                    [viewDate]="date"
                    (cellClick)="cellClick.emit($event)"
                    (weekNumberCellClick)="weekNumberCellClick.emit($event)"
                    (cellEnter)="cellEnter.emit($event)"
                    (cellLeave)="cellLeave.emit($event)"
                    (focusedCellId)="focusedCellChange.emit($event)"
                >
                </tbody>
            </table>
        </ng-template>

        <!-- When Next is clicked a placeholder table is rendered before the Main Table -->
        <ng-template
            *ngIf="nextAnimationDate"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: nextAnimationDate,
                className: 'k-pointer-events-none'
            }"
        >
        </ng-template>

        <ng-template
            *kFor="let date of dates"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: date
            }"
        >
        </ng-template>

        <!-- When Prev is clicked a placeholder table is rendered after the Main Table -->
        <ng-template
            *ngIf="prevAnimationDate"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: prevAnimationDate,
                className: 'k-pointer-events-none'
            }"
        >
        </ng-template>
    `,
      standalone: true,
      imports: [NgClass, NgIf, NgForOf, ViewComponent, NgTemplateOutlet, KForOf]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    handleMultiViewCalendarFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    handleMultiViewCalendarBlur: [{
      type: HostListener,
      args: ["blur", ["$event"]]
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    cellTemplateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    activeDescendant: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    activeDateChange: [{
      type: Output
    }],
    focusCalendar: [{
      type: Output
    }],
    blurCalendar: [{
      type: Output
    }],
    focusedCellChange: [{
      type: Output
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-view"]
    }, {
      type: HostBinding,
      args: ["class.k-align-items-start"]
    }, {
      type: HostBinding,
      args: ["class.k-justify-content-center"]
    }],
    horizontalHostClass: [{
      type: HostBinding,
      args: ["class.k-hstack"]
    }],
    verticalHostClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }],
    getComponentMonthClass: [{
      type: HostBinding,
      args: ["class.k-calendar-monthview"]
    }],
    getComponentYearClass: [{
      type: HostBinding,
      args: ["class.k-calendar-yearview"]
    }],
    getComponentDecadeClass: [{
      type: HostBinding,
      args: ["class.k-calendar-decadeview"]
    }],
    getComponentCenturyClass: [{
      type: HostBinding,
      args: ["class.k-calendar-centuryview"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }]
  });
})();
var HeaderComponent = class _HeaderComponent {
  bus;
  cdr;
  localization;
  intl;
  disabledDatesService;
  /**
   * @hidden
   */
  chevronRightIcon = chevronRightIcon;
  /**
   * @hidden
   */
  chevronLeftIcon = chevronLeftIcon;
  navigate = true;
  todayAvailable = true;
  activeViewValue;
  todayMessage;
  title;
  prevButtonTitle;
  nextButtonTitle;
  parentViewButtonTitle;
  activeView;
  currentDate;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  rangeLength = 1;
  titleTemplateRef;
  headerTemplateRef;
  isPrevDisabled = true;
  isNextDisabled = true;
  showNavigationButtons = false;
  orientation = "horizontal";
  id;
  size;
  todayButtonClick = new EventEmitter();
  prevButtonClick = new EventEmitter();
  nextButtonClick = new EventEmitter();
  getComponentClass = true;
  get verticalHostClass() {
    return this.orientation === "vertical";
  }
  subscriptions = new Subscription();
  constructor(bus, cdr, localization, intl, disabledDatesService) {
    this.bus = bus;
    this.cdr = cdr;
    this.localization = localization;
    this.intl = intl;
    this.disabledDatesService = disabledDatesService;
  }
  ngOnInit() {
    this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.subscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));
    this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.setTodayAvailability.bind(this)));
  }
  ngOnChanges(_) {
    const service = this.bus.service(this.activeView);
    if (!service) {
      return;
    }
    this.activeViewValue = CalendarViewEnum[this.activeView];
    this.todayMessage = this.localization.get("today");
    this.parentViewButtonTitle = this.localization.get("parentViewButtonTitle");
    this.setTodayAvailability();
    this.navigate = this.bus.canMoveUp(this.activeView);
    this.title = this.getTitle();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  handleTodayClick() {
    if (!this.todayAvailable) {
      return;
    }
    this.bus.moveToBottom(this.activeView);
    this.todayButtonClick.emit(dateInRange(getToday(), this.min, this.max));
  }
  handleNavigation() {
    if (!this.navigate) {
      return;
    }
    this.bus.moveUp(this.activeView);
  }
  isDisabled() {
    return this.navigate ? null : "";
  }
  intlChange() {
    if (this.currentDate && this.bus.service(this.activeView)) {
      this.title = this.getTitle();
      this.cdr.markForCheck();
    }
  }
  l10nChange() {
    this.prevButtonTitle = this.localization.get("prevButtonTitle");
    this.nextButtonTitle = this.localization.get("nextButtonTitle");
    this.parentViewButtonTitle = this.localization.get("parentViewButtonTitle");
    this.todayMessage = this.localization.get("today");
    this.cdr.markForCheck();
  }
  getTitle() {
    if (!this.currentDate) {
      return "";
    }
    const service = this.bus.service(this.activeView);
    const take4 = this.rangeLength - 1;
    const title = service.title(this.currentDate);
    const nextDate = service.addToDate(this.currentDate, take4);
    if (take4 < 1 || !service.isInRange(nextDate, this.min, this.max)) {
      return title;
    }
    return `${title} - ${service.title(nextDate)}`;
  }
  setTodayAvailability() {
    const today2 = getToday();
    const isTodayInRange = isInRange(today2, getDate(this.min), getDate(this.max));
    const isDisabled = this.disabledDatesService.isDateDisabled(today2);
    this.todayAvailable = isTodayInRange && !isDisabled;
    this.cdr.markForCheck();
  }
  static ɵfac = function HeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(DisabledDatesService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HeaderComponent,
    selectors: [["kendo-calendar-header"]],
    hostVars: 4,
    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-header", ctx.getComponentClass)("k-vstack", ctx.verticalHostClass);
      }
    },
    inputs: {
      activeView: "activeView",
      currentDate: "currentDate",
      min: "min",
      max: "max",
      rangeLength: "rangeLength",
      titleTemplateRef: "titleTemplateRef",
      headerTemplateRef: "headerTemplateRef",
      isPrevDisabled: "isPrevDisabled",
      isNextDisabled: "isNextDisabled",
      showNavigationButtons: "showNavigationButtons",
      orientation: "orientation",
      id: "id",
      size: "size"
    },
    outputs: {
      todayButtonClick: "todayButtonClick",
      prevButtonClick: "prevButtonClick",
      nextButtonClick: "nextButtonClick"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 2,
    consts: [["defaultRendering", ""], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", "role", "button", "type", "button", "fillMode", "flat", "themeColor", "primary", "tabindex", "-1", 1, "k-calendar-title", 3, "id", "size", "disabled", "kendoEventsOutsideAngular", "title", "scope"], [3, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-spacer"], [1, "k-calendar-nav"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-left", "tabindex", "-1", "type", "button", "class", "k-calendar-nav-prev", 3, "size", "svgIcon", "disabled", "title", "click", 4, "ngIf"], ["kendoButton", "", "fillMode", "flat", "role", "link", "type", "button", 1, "k-calendar-nav-today", 3, "size", "disabled", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-right", "class", "k-calendar-nav-next", "tabindex", "-1", "type", "button", 3, "size", "svgIcon", "disabled", "title", "click", 4, "ngIf"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-left", "tabindex", "-1", "type", "button", 1, "k-calendar-nav-prev", 3, "click", "size", "svgIcon", "disabled", "title"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-right", "tabindex", "-1", "type", "button", 1, "k-calendar-nav-next", 3, "click", "size", "svgIcon", "disabled", "title"]],
    template: function HeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, HeaderComponent_0_Template, 1, 6, null, 1)(1, HeaderComponent_ng_template_1_Template, 9, 25, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const defaultRendering_r4 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.headerTemplateRef)("ngIfElse", defaultRendering_r4);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, ButtonComponent, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderComponent, [{
    type: Component,
    args: [{
      selector: "kendo-calendar-header",
      template: `
    <ng-template *ngIf="headerTemplateRef; else defaultRendering" 
                [ngTemplateOutlet]="headerTemplateRef"
                [ngTemplateOutletContext]="{ title: title, activeView: activeViewValue, date: currentDate }">
    </ng-template>
    <ng-template #defaultRendering>
        <button 
            kendoButton
            class="k-calendar-title"
            role="button"
            [id]="id"
            type="button"
            fillMode="flat"
            [size]="size"
            themeColor="primary"
            tabindex="-1"
            [disabled]="!navigate"
            [kendoEventsOutsideAngular]="{
                click: handleNavigation
            }"
            [title]="parentViewButtonTitle"
            [scope]="this">
            <ng-template [ngIf]="!titleTemplateRef">{{title}}</ng-template>
            <ng-template
                [ngIf]="titleTemplateRef"
                [ngTemplateOutlet]="titleTemplateRef"
                [ngTemplateOutletContext]="{ $implicit: title, activeView: activeViewValue, date: currentDate }"
            ></ng-template>
        </button>
        <span class="k-spacer"></span>
        <span class="k-calendar-nav">
            <button
                *ngIf="showNavigationButtons"
                kendoButton
                fillMode="flat"
                [size]="size"
                [svgIcon]="chevronLeftIcon"
                icon="chevron-left"
                tabindex="-1"
                type="button"
                class="k-calendar-nav-prev"
                [attr.aria-disabled]="isPrevDisabled"
                [disabled]="isPrevDisabled"
                [title]="prevButtonTitle"
                (click)="prevButtonClick.emit()"
            >
            </button>
            <button
                kendoButton
                class="k-calendar-nav-today"
                fillMode="flat"
                role="link"
                [size]="size"
                [disabled]="!todayAvailable"
                [kendoEventsOutsideAngular]="{
                    click: handleTodayClick
                }"
                [scope]="this"
                type="button"
            >
                {{ todayMessage }}
            </button>
            <button
                *ngIf="showNavigationButtons"
                kendoButton
                fillMode="flat"
                [size]="size"
                [svgIcon]="chevronRightIcon"
                icon="chevron-right"
                class="k-calendar-nav-next"
                tabindex="-1"
                type="button"
                [attr.aria-disabled]="isNextDisabled"
                [disabled]="isNextDisabled"
                [title]="nextButtonTitle"
                (click)="nextButtonClick.emit()"
            >
            </button>
        </span>
    </ng-template>
`,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, ButtonComponent, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: IntlService
    }, {
      type: DisabledDatesService
    }];
  }, {
    activeView: [{
      type: Input
    }],
    currentDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeLength: [{
      type: Input
    }],
    titleTemplateRef: [{
      type: Input
    }],
    headerTemplateRef: [{
      type: Input
    }],
    isPrevDisabled: [{
      type: Input
    }],
    isNextDisabled: [{
      type: Input
    }],
    showNavigationButtons: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    todayButtonClick: [{
      type: Output
    }],
    prevButtonClick: [{
      type: Output
    }],
    nextButtonClick: [{
      type: Output
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-header"]
    }],
    verticalHostClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }]
  });
})();
var SelectionService = class _SelectionService {
  bus;
  constructor(bus) {
    this.bus = bus;
  }
  lastClicked;
  performSelection(args) {
    let {
      date,
      modifiers,
      selectionMode,
      activeViewEnum,
      rangePivot
    } = args;
    let selectedDates = args.selectedDates.slice();
    if (selectionMode === "multiple") {
      if (modifiers.ctrlKey || modifiers.metaKey) {
        if (this.isDateSelected(selectedDates, date)) {
          selectedDates = selectedDates.filter((item) => !isEqual(item, date));
        } else {
          selectedDates.push(date);
        }
        rangePivot = date;
      } else if (modifiers.shiftKey) {
        const [start, end] = sortDates([rangePivot || date, date]);
        selectedDates = this.bus.service(activeViewEnum).dateRange(start, end);
        rangePivot = date > selectedDates[0] ? selectedDates[0] : last(selectedDates);
        if (modifiers.anyArrow) {
          const [start2, end2] = sortDates([this.lastClicked || date, date]);
          selectedDates = this.bus.service(0).dateRange(start2, end2);
        }
      } else {
        selectedDates = [date];
        rangePivot = date;
      }
    } else {
      selectedDates = [date];
      rangePivot = date;
    }
    return {
      selectedDates,
      rangePivot
    };
  }
  isDateSelected(selectedDates, date) {
    return selectedDates.some((item) => isEqual(item, date));
  }
  static ɵfac = function SelectionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionService)(ɵɵinject(BusViewService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService, [{
    type: Injectable
  }], function() {
    return [{
      type: BusViewService
    }];
  }, null);
})();
var CellTemplateDirective = class _CellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CellTemplateDirective,
    selectors: [["", "kendoCalendarCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var MonthCellTemplateDirective = class _MonthCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MonthCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MonthCellTemplateDirective,
    selectors: [["", "kendoCalendarMonthCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarMonthCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var YearCellTemplateDirective = class _YearCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function YearCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _YearCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _YearCellTemplateDirective,
    selectors: [["", "kendoCalendarYearCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarYearCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var DecadeCellTemplateDirective = class _DecadeCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DecadeCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DecadeCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DecadeCellTemplateDirective,
    selectors: [["", "kendoCalendarDecadeCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarDecadeCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var CenturyCellTemplateDirective = class _CenturyCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CenturyCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CenturyCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CenturyCellTemplateDirective,
    selectors: [["", "kendoCalendarCenturyCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CenturyCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarCenturyCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var WeekNumberCellTemplateDirective = class _WeekNumberCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function WeekNumberCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WeekNumberCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _WeekNumberCellTemplateDirective,
    selectors: [["", "kendoCalendarWeekNumberCellTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WeekNumberCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarWeekNumberCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var HeaderTitleTemplateDirective = class _HeaderTitleTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTitleTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderTitleTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTitleTemplateDirective,
    selectors: [["", "kendoCalendarHeaderTitleTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTitleTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarHeaderTitleTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
function handleRangeSelection(date, selectionRange, activeRangeEnd, allowReverse = false) {
  if (activeRangeEnd === "start" && selectionRange.start?.getTime() === date?.getTime() && (allowReverse && !selectionRange.end || !allowReverse) || activeRangeEnd === "end" && selectionRange.end?.getTime() === date?.getTime()) {
    return {
      activeRangeEnd,
      selectionRange
    };
  }
  if (allowReverse) {
    if (activeRangeEnd === "start" && selectionRange.start?.getTime() !== date?.getTime()) {
      selectionRange.start = date;
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "end" && selectionRange.end?.getTime() !== date?.getTime()) {
      selectionRange.end = date;
      activeRangeEnd = "start";
    }
  }
  if (!allowReverse) {
    if (activeRangeEnd === "start" && date > selectionRange.end || activeRangeEnd === "end" && date < selectionRange.start) {
      selectionRange = {
        start: date,
        end: null
      };
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "start" && date <= selectionRange.end) {
      selectionRange.start = date;
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "end" && date >= selectionRange.start && date.getTime() !== selectionRange.end?.getTime()) {
      selectionRange.end = date;
      activeRangeEnd = "start";
    }
  }
  return {
    activeRangeEnd,
    selectionRange
  };
}
var minValidator = (minValue) => {
  return (control) => {
    const err = {
      minError: {
        minValue,
        value: control.value
      }
    };
    if (!minValue || !control.value) {
      return null;
    }
    return control.value < minValue ? err : null;
  };
};
var maxValidator = (maxValue) => {
  return (control) => {
    const err = {
      maxError: {
        maxValue,
        value: control.value
      }
    };
    if (!maxValue || !control.value) {
      return null;
    }
    return control.value > maxValue ? err : null;
  };
};
var noop = () => null;
var disabledDatesRangeValidator = (isDateDisabled) => {
  if (!isPresent2(isDateDisabled)) {
    return noop;
  }
  return (selectedRange) => {
    const isRangeComplete = isPresent2(selectedRange) && isPresent2(selectedRange.start) && isPresent2(selectedRange.end);
    if (!isRangeComplete || selectedRange.start > selectedRange.end) {
      return null;
    }
    const disabledDates = disabledDatesInRange(selectedRange.start, selectedRange.end, isDateDisabled);
    const error2 = {
      disabledDatesInRange: disabledDates
    };
    return disabledDates.length ? error2 : null;
  };
};
var KEY_TO_ACTION = {
  "33": Action.PrevView,
  "34": Action.NextView,
  "35": Action.LastInView,
  "36": Action.FirstInView,
  "37": Action.Left,
  "38": Action.Up,
  "39": Action.Right,
  "40": Action.Down,
  "meta+38": Action.UpperView,
  "meta+40": Action.LowerView
};
var NavigationService = class _NavigationService {
  bus;
  constructor(bus) {
    this.bus = bus;
  }
  action(event2) {
    const action = `${event2.ctrlKey || event2.metaKey ? "meta+" : ""}${event2.keyCode}`;
    return KEY_TO_ACTION[action];
  }
  move(value2, action, activeView) {
    const service = this.bus.service(activeView);
    if (!service) {
      return value2;
    }
    if (action === Action.UpperView && this.bus.canMoveUp(activeView)) {
      this.bus.moveUp(activeView);
      return value2;
    }
    if (action === Action.LowerView && this.bus.canMoveDown(activeView)) {
      this.bus.moveDown(activeView);
      return value2;
    }
    return service.move(value2, action);
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(BusViewService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: BusViewService
    }];
  }, null);
})();
var HeaderTemplateDirective = class _HeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTemplateDirective,
    selectors: [["", "kendoCalendarHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FooterTemplateDirective = class _FooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FooterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterTemplateDirective,
    selectors: [["", "kendoCalendarFooterTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FooterComponent = class _FooterComponent {
  intl;
  showFooter = true;
  footerTemplateRef;
  activeViewValue;
  currentDate;
  getToday = getToday;
  constructor(intl) {
    this.intl = intl;
  }
  static ɵfac = function FooterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterComponent)(ɵɵdirectiveInject(IntlService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FooterComponent,
    selectors: [["kendo-calendar-footer"]],
    hostVars: 2,
    hostBindings: function FooterComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-footer", ctx.showFooter);
      }
    },
    inputs: {
      footerTemplateRef: "footerTemplateRef",
      activeViewValue: "activeViewValue",
      currentDate: "currentDate"
    },
    decls: 3,
    vars: 2,
    consts: [["defaultRendering", ""], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", "fillMode", "flat", "themeColor", "primary", "type", "button", "tabindex", "-1", 1, "k-calendar-nav-today"]],
    template: function FooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, FooterComponent_0_Template, 1, 5, null, 1)(1, FooterComponent_ng_template_1_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const defaultRendering_r2 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.footerTemplateRef)("ngIfElse", defaultRendering_r2);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-calendar-footer",
      template: `
    <ng-template *ngIf="footerTemplateRef; else defaultRendering"
        [ngTemplateOutlet]="footerTemplateRef"
        [ngTemplateOutletContext]="{ activeView: activeViewValue, date: currentDate }">
    </ng-template>
    <ng-template #defaultRendering>
        <button kendoButton
            fillMode="flat"
            themeColor="primary"
            class="k-calendar-nav-today"
            type="button"
            tabindex="-1">
                {{intl.formatDate(getToday(), 'D')}}
        </button>
    </ng-template>
  `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, ButtonComponent]
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, {
    showFooter: [{
      type: HostBinding,
      args: ["class.k-calendar-footer"]
    }],
    footerTemplateRef: [{
      type: Input
    }],
    activeViewValue: [{
      type: Input
    }],
    currentDate: [{
      type: Input
    }]
  });
})();
var Messages = class _Messages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the MultiViewCalendar.
   */
  today;
  /**
   * The title of the **Prev** button in the header of the MultiViewCalendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the MultiViewCalendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the MultiViewCalendar.
   */
  parentViewButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendo-multiview-calendar-messages-base"]],
    inputs: {
      today: "today",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-multiview-calendar-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }]
  });
})();
var MultiViewCalendarLocalizedMessagesDirective = class _MultiViewCalendarLocalizedMessagesDirective extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function MultiViewCalendarLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiViewCalendarLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiViewCalendarLocalizedMessagesDirective,
    selectors: [["", "kendoMultiViewCalendarLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _MultiViewCalendarLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => MultiViewCalendarLocalizedMessagesDirective)
      }],
      selector: "[kendoMultiViewCalendarLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var BOTTOM_VIEW_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview";
var TOP_VIEW_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview";
var MIN_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min";
var MAX_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max";
var VALUE_DOC_LINK$5 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json";
var RANGE_CALENDAR_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MultiViewCalendarComponent)
};
var RANGE_CALENDAR_RANGE_VALIDATORS = {
  multi: true,
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MultiViewCalendarComponent)
};
var MultiViewCalendarComponent = class _MultiViewCalendarComponent {
  bus;
  element;
  navigator;
  renderer;
  cdr;
  zone;
  disabledDatesService;
  selectionService;
  /**
   * Displays the days that fall out of the current month ([see example]({% slug viewoptions_multiviewcalendar %}#toc-displaying-other-month-days)).
   * @default true
   */
  showOtherMonthDays = true;
  /**
   * @hidden
   *
   * Determines whether to display the calendar header.
   */
  showCalendarHeader = true;
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE;
    this.renderer.removeClass(this.element.nativeElement, getSizeClass("calendar", this.size));
    if (newSize !== "none") {
      this.renderer.addClass(this.element.nativeElement, getSizeClass("calendar", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  _size = DEFAULT_SIZE;
  /**
   * @hidden
   */
  id;
  /**
   * Sets or gets the `focusedDate` property of the Calendar and
   * defines the focused date of the component
   * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
   *
   * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.
   */
  set focusedDate(focusedDate) {
    this._focusedDate = focusedDate || getToday();
  }
  get focusedDate() {
    return this._focusedDate;
  }
  /**
   * Toggles the visibility of the footer.
   * @default false
   */
  footer = false;
  /**
   * @hidden
   */
  get headerId() {
    return this.id + "header-";
  }
  /**
   * @hidden
   */
  get multiViewCalendarHeaderIdLabel() {
    return this.views >= 2 ? this.id + "header-" : null;
  }
  /**
  * @hidden
  */
  get calendarHeaderIdLabel() {
    return this.views === 1 ? this.id + "header-" : null;
  }
  /**
   * Sets or gets the `min` property of the Calendar and
   * defines the minimum allowed date value.
   * By default, the `min` value is `1900-1-1`.
   */
  set min(min) {
    this._min = min || new Date(MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Sets or gets the `max` property of the Calendar and
   * defines the maximum allowed date value.
   * By default, the `max` value is `2099-12-31`.
   */
  set max(max) {
    this._max = max || new Date(MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form.
   */
  rangeValidation = false;
  /**
   * Determines whether the built-in validator for disabled
   * date ranges is enforced when validating a form
   * ([see example](slug:disabled_dates_multiviewcalendar)).
   */
  disabledDatesRangeValidation = false;
  /**
   * Sets the Calendar selection mode
   * ([see example]({% slug selection_multiviewcalendar %})).
   *
   * The available values are:
   * * `single` (default)
   * * `multiple`
   * * `range`
   */
  set selection(_selection) {
    this.selectionSetter = true;
    this._selection = _selection;
  }
  get selection() {
    return this._selection;
  }
  _selection = "single";
  /**
   * Allows reverse selection when using `range` selection.
   * If `allowReverse` is set to `true`, the component skips the validation of whether the start date is after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Sets or gets the `value` property of the Calendar and defines the selected value of the component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)
      instance when in `single` selection mode, an array of valid JavaScript Date instances when in `multiple` selection mode, or
      an object of type `SelectionRange` when in `range` selection mode.
   */
  set value(candidate) {
    this.valueSetter = true;
    this._value = candidate;
  }
  get value() {
    return this._value;
  }
  /**
   * Sets or gets the `disabled` property of the Calendar and
   * determines whether the component is active
   * ([see example]({% slug disabled_multiviewcalendar %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_multiviewcalendar#toc-managing-the-multiviewcalendar-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets or gets the `tabindex` property of the Calendar. Based on the
   * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,
   * it determines whether the component is focusable.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * @hidden
   */
  isActive = false;
  /**
   * Sets the dates of the MultiViewCalendar that will be disabled
   * ([see example]({% slug disabled_dates_multiviewcalendar %})).
   */
  set disabledDates(value2) {
    this.disabledDatesService.initialize(value2);
  }
  /**
   * Defines the active view that the Calendar initially renders
   * ([see example]({% slug viewoptions_multiviewcalendar %})).
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost view, to which the user can navigate
   * ([see example](slug:viewdepth_multiviewcalendar)).
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost view, to which the user can navigate.
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Determines whether to display a header for every view (for example the month name).
   */
  showViewHeader = false;
  /**
   * Determines whether to enable animation when navigating to previous/next view.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateNavigation = false;
  /**
   * Determines whether to display a week number column in the `month` view
   * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).
   */
  weekNumber = false;
  /**
   * Specify, which end of the defined selection range should be marked as active.
   *
   * > Value will be ignored if the selection range is undefined.
   * > If range selection is used then the default value is 'start'.
   */
  set activeRangeEnd(_activeRangeEnd) {
    this._activeRangeEnd = _activeRangeEnd;
  }
  get activeRangeEnd() {
    return this.selection === "range" && !this._activeRangeEnd ? "start" : this._activeRangeEnd;
  }
  /**
   * Sets or gets the `selectionRange` property of the Calendar and
   * defines the selection range of the component
   * ([see example](slug:selection_multiviewcalendar#toc-range-selection)).
   * > We recommend using the `value` property as it now supports `range` selection.
   */
  set selectionRange(range3) {
    this._selectionRange = range3;
    if (this.disabledDatesRangeValidation) {
      this.onValidatorChange();
    }
  }
  get selectionRange() {
    return this._selectionRange;
  }
  /**
   * Sets or gets the `views` property of the Calendar and
   * defines the number of rendered months.
   */
  views = 2;
  /**
   * Specifies the orientation of the MultiViewCalendar.
   *
   * The available values are:
   * * `horizontal` (default)
   * * `vertical`
   */
  orientation = "horizontal";
  /**
   * Fires when the active view is changed
   * ([see example](slug:events_multiviewcalendar)).
   */
  activeViewChange = new EventEmitter();
  /**
   * Fires when navigating in the currently active view
   * ([see example](slug:events_multiviewcalendar)).
   */
  navigate = new EventEmitter();
  /**
   * Fires when a view cell is entered
   * ([see example](slug:events_multiviewcalendar)).
   */
  cellEnter = new EventEmitter();
  /**
   * Fires when a view cell is leaved
   * ([see example](slug:events_multiviewcalendar)).
   */
  cellLeave = new EventEmitter();
  /**
   * Fires when the value is changed
   * ([see example](slug:events_multiviewcalendar)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   * Fires when the range selection changes.
   */
  rangeSelectionChange = new EventEmitter();
  /**
   * Fires each time the MultiViewCalendar gets blurred
   * ([see example](slug:events_multiviewcalendar)).
   */
  blurEvent = new EventEmitter();
  /**
   * Fires each time the MultiViewCalendar gets focused
   * ([see example](slug:events_multiviewcalendar)).
   */
  focusEvent = new EventEmitter();
  /**
   * @hidden
   */
  focusCalendar = new EventEmitter();
  /**
   * @hidden
   */
  onClosePopup = new EventEmitter();
  /**
   * @hidden
   */
  onTabPress = new EventEmitter();
  /**
   * @hidden
   */
  onShiftTabPress = new EventEmitter();
  /**
   * @hidden
   *
   * Queries the template for a cell template declaration.
   * Ignored if a `[cellTemplate]` value is explicitly provided.
   */
  cellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set cellTemplateRef(template) {
    this._cellTemplateRef = template;
  }
  get cellTemplateRef() {
    return this._cellTemplateRef || this.cellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a month cell template declaration.
   * Ignored if a `[monthCellTemplate]` value is explicitly provided.
   */
  monthCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each month cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set monthCellTemplateRef(template) {
    this._monthCellTemplateRef = template;
  }
  get monthCellTemplateRef() {
    return this._monthCellTemplateRef || this.monthCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a year cell template declaration.
   * Ignored if a `[yearCellTemplate]` value is explicitly provided.
   */
  yearCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each year cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set yearCellTemplateRef(template) {
    this._yearCellTemplateRef = template;
  }
  get yearCellTemplateRef() {
    return this._yearCellTemplateRef || this.yearCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a decade cell template declaration.
   * Ignored if a `[decadeCellTemplate]` value is explicitly provided.
   */
  decadeCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each decade cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set decadeCellTemplateRef(template) {
    this._decadeCellTemplateRef = template;
  }
  get decadeCellTemplateRef() {
    return this._decadeCellTemplateRef || this.decadeCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a century cell template declaration.
   * Ignored if a `[centuryCellTemplate]` value is explicitly provided.
   */
  centuryCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each century cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set centuryCellTemplateRef(template) {
    this._centuryCellTemplateRef = template;
  }
  get centuryCellTemplateRef() {
    return this._centuryCellTemplateRef || this.centuryCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a week number cell template declaration.
   * Ignored if a `[weekNumberTemplate]` value is explicitly provided.
   */
  weekNumberTemplate;
  /**
   * @hidden
   *
   * Defines the template for the week cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set weekNumberTemplateRef(template) {
    this._weekNumberTemplateRef = template;
  }
  get weekNumberTemplateRef() {
    return this._weekNumberTemplateRef || this.weekNumberTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a header title template declaration.
   * Ignored if a `[headerTitleTemplate]` value is explicitly provided.
   */
  headerTitleTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   */
  headerTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   */
  footerTemplate;
  /**
   * @hidden
   *
   * Defines the template for the Calendar footer.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set footerTemplateRef(template) {
    this._footerTemplateRef = template;
  }
  get footerTemplateRef() {
    return this._footerTemplateRef || this.footerTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the header title.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set headerTitleTemplateRef(template) {
    this._headerTitleTemplateRef = template;
  }
  get headerTitleTemplateRef() {
    return this._headerTitleTemplateRef || this.headerTitleTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the Calendar header.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set headerTemplateRef(template) {
    this._headerTemplateRef = template;
  }
  get headerTemplateRef() {
    return this._headerTemplateRef || this.headerTemplate;
  }
  headerElement;
  viewList;
  cellUID = guid();
  isHovered = false;
  activeDate;
  isPrevDisabled = true;
  isNextDisabled = true;
  prevView = Action.PrevView;
  nextView = Action.NextView;
  selectedDates = [];
  rangePivot;
  shouldHoverWhenNoStart = false;
  canHover = false;
  changes = {};
  valueSetter = false;
  selectionSetter = false;
  _min = new Date(MIN_DATE);
  _max = new Date(MAX_DATE);
  _focusedDate = getToday();
  _value;
  _selectionRange = {
    start: null,
    end: null
  };
  _activeRangeEnd;
  resolvedPromise = Promise.resolve();
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesRangeValidateFn = noop$2;
  subscriptions = new Subscription();
  _cellTemplateRef;
  _monthCellTemplateRef;
  _yearCellTemplateRef;
  _decadeCellTemplateRef;
  _centuryCellTemplateRef;
  _weekNumberTemplateRef;
  _headerTitleTemplateRef;
  _headerTemplateRef;
  _footerTemplateRef;
  get activeViewEnum() {
    const activeView = CalendarViewEnum[this.activeView];
    return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;
  }
  get bottomViewEnum() {
    return CalendarViewEnum[this.bottomView];
  }
  get topViewEnum() {
    return CalendarViewEnum[this.topView];
  }
  get widgetId() {
    return this.views >= 2 ? this.id : null;
  }
  get ariaDisabled() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  get ariaActivedescendant() {
    return this.cellUID + this.focusedDate.getTime();
  }
  /**
   * @hidden
   */
  handleFocusout(event2) {
    const relatedTarget = event2.relatedTarget;
    if (!this.element.nativeElement.contains(relatedTarget)) {
      const isClassicCalendar = this.views === 1;
      isClassicCalendar ? this.blurEvent.emit(event2) : this.blurEvent.emit();
      this.onControlTouched();
    }
    this.isActive = false;
    this.isHovered = false;
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.isActive = true;
    const isClassicCalendar = this.views === 1;
    isClassicCalendar ? this.focusCalendar.emit() : this.focusEvent.emit();
    this.focusEvent.emit();
  }
  /**
   * @hidden
   */
  handleMouseEnter() {
    this.isHovered = true;
  }
  /**
   * @hidden
   */
  handleMouseLeave() {
    this.isHovered = false;
    this.setRangeSelectionToValue();
  }
  /**
   * @hidden
   */
  handleMousedown(event2) {
    event2.preventDefault();
  }
  /**
   * @hidden
   */
  handleClick() {
    if (this.isActive) {
      return;
    }
    this.focus();
  }
  /**
   * @hidden
   */
  keydown(event2) {
    const arrowUpOrDownKeyPressed = [Keys.ArrowUp, Keys.ArrowDown].indexOf(event2.keyCode) !== -1;
    const ctrlKey = event2.ctrlKey || event2.metaKey;
    const onArrowRightAndControl = event2.keyCode === Keys.ArrowRight && ctrlKey;
    const onArrowLeftAndControl = event2.keyCode === Keys.ArrowLeft && ctrlKey;
    const onTKeyPress = event2.keyCode === Keys.KeyT;
    const onEnterKeyPress = event2.keyCode === Keys.Enter;
    const onArrowUpPress = event2.keyCode === Keys.ArrowUp;
    const altKey = event2.altKey;
    const escKey = event2.keyCode === Keys.Escape;
    const tabKeyPress = event2.keyCode === Keys.Tab;
    const shiftKeyPress = event2.shiftKey;
    if (onArrowRightAndControl) {
      event2.preventDefault();
      this.navigateView(this.nextView);
      return;
    } else if (onArrowLeftAndControl) {
      event2.preventDefault();
      this.navigateView(this.prevView);
      return;
    } else if (ctrlKey && arrowUpOrDownKeyPressed) {
      event2.preventDefault();
    } else if (onTKeyPress) {
      this.focusedDate = getToday();
      this.bus.moveToBottom(this.activeViewEnum);
      return;
    } else if (onEnterKeyPress) {
      if (this.selection !== "range") {
        this.selectionService.lastClicked = this.focusedDate;
        this.performSelection(this.focusedDate, event2);
      } else {
        this.performRangeSelection(this.focusedDate);
      }
    }
    if (this.views >= 2) {
      if (escKey || altKey && onArrowUpPress) {
        this.onClosePopup.emit(event2);
      } else if (tabKeyPress && shiftKeyPress) {
        this.onShiftTabPress.emit(event2);
      } else if (tabKeyPress && !shiftKeyPress) {
        this.onTabPress.emit(event2);
      }
    }
    const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(event2), this.activeViewEnum), this.min, this.max);
    if (isEqual(this.focusedDate, candidate)) {
      return;
    }
    this.focusedDate = candidate;
    event2.preventDefault();
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);
    if (!isSameView) {
      this.emitNavigate(this.focusedDate);
    }
    if (isArrowWithShiftPressed(event2) && this.selection !== "range") {
      event2["anyArrow"] = true;
      this.performSelection(this.focusedDate, event2);
    }
  }
  constructor(bus, element, navigator2, renderer, cdr, zone, disabledDatesService, selectionService) {
    this.bus = bus;
    this.element = element;
    this.navigator = navigator2;
    this.renderer = renderer;
    this.cdr = cdr;
    this.zone = zone;
    this.disabledDatesService = disabledDatesService;
    this.selectionService = selectionService;
    this.id = `kendo-multiviewcalendarid-${this.bus.calendarId}-`;
  }
  ngOnInit() {
    this.setClasses(this.element.nativeElement);
    this.subscriptions.add(this.bus.viewChanged.subscribe(({
      view: view2
    }) => {
      this.activeView = CalendarViewEnum[view2];
      this.activeViewChange.emit(this.activeView);
      this.cdr.detectChanges();
      this.updateButtonState();
    }));
  }
  ngOnChanges(changes) {
    this.changes = changes;
    this.verifyChanges();
    this.bus.configure(this.bottomViewEnum, this.topViewEnum);
  }
  ngDoCheck() {
    if (this.valueSetter || this.selectionSetter) {
      if (this.selection === "range" && (this.value?.start || this.value?.end) && this.focusedDate.getTime() !== this.value.start?.getTime() && this.focusedDate.getTime() !== this.value.end?.getTime()) {
        this.focusedDate = this.value.start || this.value.end || getToday();
      }
      this.setValue(this.value);
      this.valueSetter = false;
      this.selectionSetter = false;
    }
    if (hasExistingValue(this.changes, "focusedDate")) {
      const focusedDate = this.changes.focusedDate.currentValue;
      this.focusedDate = dateInRange(focusedDate, this.min, this.max);
    }
    if (this.changes.min || this.changes.max || this.changes.rangeValidation || this.changes.disabledDates || this.changes.disabledDatesRangeValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesRangeValidateFn = this.disabledDatesRangeValidation ? disabledDatesRangeValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.onValidatorChange();
    }
    if (this.changes.min || this.changes.max || this.changes.focusedDate || this.changes.activeView) {
      this.updateButtonState();
    }
    this.changes = {};
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  ngAfterViewInit() {
    this.updateButtonState();
  }
  /**
   * Focuses the host element of the Calendar.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="multiviewcalendar.focus()">Focus calendar</button>
   *  <kendo-multiviewcalendar #multiviewcalendar></kendo-multiviewcalendar>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.querySelector(".k-calendar-view").focus({
      preventScroll: true
    });
  }
  /**
   * Blurs the Calendar component.
   */
  blur() {
    if (!this.element) {
      return;
    }
    const activeElement = this.views >= 2 ? this.element.nativeElement.querySelector(".k-calendar-view") : this.element.nativeElement.querySelector(".k-calendar-table");
    activeElement.blur();
  }
  /**
   * @hidden
   */
  handleDateChange(args) {
    const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);
    const availableDates = args.selectedDates.filter((date) => !this.disabledDatesService.isDateDisabled(date));
    this.focusedDate = args.focusedDate || this.focusedDate;
    const sameDates = !canNavigateDown && areDatesEqual(availableDates, this.selectedDates);
    if (this.disabled || sameDates) {
      return;
    }
    if (canNavigateDown) {
      this.bus.moveDown(this.activeViewEnum);
      return;
    }
    if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {
      return;
    }
    if (this.selection === "range") {
      return;
    }
    this.selectedDates = availableDates.map((date) => cloneDate(date));
    this.value = this.parseSelectionToValue(availableDates);
    this.onControlChange(this.parseSelectionToValue(availableDates));
    this.valueChange.emit(this.parseSelectionToValue(availableDates));
  }
  /**
   * @hidden
   */
  onCellEnter(cellEnter, date) {
    this.emitCellEvent(cellEnter, date);
    if (this.selection === "range" && (this.canHover || this.shouldHoverWhenNoStart)) {
      this.zone.run(() => {
        if (this.canHover && !this.shouldHoverWhenNoStart) {
          if (this.allowReverse) {
            if (this.activeRangeEnd === "end" && this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: date
              };
            }
            if (this.activeRangeEnd === "start" && this.selectionRange.end) {
              this.selectionRange = {
                start: date,
                end: this.selectionRange.end
              };
            }
          } else {
            if (this.activeRangeEnd === "end" && this.selectionRange.start && date >= this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: date
              };
            }
            if (this.selectionRange.start && date < this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: null
              };
            }
          }
        } else if (this.shouldHoverWhenNoStart && date <= this.selectionRange.end) {
          this.selectionRange = {
            start: date,
            end: this.selectionRange.end
          };
        } else {
          this.selectionRange = {
            start: null,
            end: this.selectionRange.end
          };
        }
      });
    }
  }
  /**
   * @hidden
   */
  handleTodayButtonClick(args) {
    const todayDate2 = args.focusedDate;
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(todayDate2, this.viewList.dates);
    const isBottomView = !this.bus.canMoveDown(this.activeViewEnum);
    if (!isSameView && isBottomView) {
      this.emitNavigate(todayDate2);
    }
    this.handleDateChange(args);
  }
  /**
   * @hidden
   */
  setActiveDate(date) {
    this.activeDate = cloneDate(date);
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  writeValue(candidate) {
    this.verifyValue(candidate);
    this.value = candidate;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesRangeValidateFn(this.selectionRange);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  activeCellTemplate() {
    switch (this.activeViewEnum) {
      case CalendarViewEnum.month:
        return this.monthCellTemplateRef || this.cellTemplateRef;
      case CalendarViewEnum.year:
        return this.yearCellTemplateRef;
      case CalendarViewEnum.decade:
        return this.decadeCellTemplateRef;
      case CalendarViewEnum.century:
        return this.centuryCellTemplateRef;
      default:
        return null;
    }
  }
  /**
   * @hidden
   */
  navigateView(action) {
    this.focusedDate = this.viewList.navigate(action);
    this.updateButtonState();
    this.emitNavigate(this.focusedDate);
  }
  /**
   * @hidden
   */
  emitNavigate(focusedDate) {
    const activeView = CalendarViewEnum[this.activeViewEnum];
    this.navigate.emit({
      activeView,
      focusedDate
    });
  }
  /**
   * @hidden
   */
  emitCellEvent(emitter, args) {
    if (hasObservers(emitter)) {
      this.zone.run(() => {
        emitter.emit(args);
      });
    }
  }
  /**
   * @hidden
   */
  handleCellClick({
    date,
    modifiers
  }) {
    if (this.selection === "range" && this.activeViewEnum === CalendarViewEnum[this.bottomView]) {
      this.performRangeSelection(date);
    } else {
      this.selectionService.lastClicked = date;
      this.performSelection(date, modifiers);
    }
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);
    if (!isSameView) {
      this.emitNavigate(this.focusedDate);
    }
  }
  /**
   * @hidden
   */
  handleWeekNumberClick(dates) {
    if (this.selection === "single") {
      return;
    }
    this.zone.run(() => {
      if (this.selection === "multiple") {
        this.handleDateChange({
          selectedDates: dates,
          focusedDate: last(dates)
        });
      }
      if (this.selection === "range") {
        this.activeRangeEnd = "start";
        const shouldEmitValueChange = this.selectionRange.start?.getTime() !== dates[0].getTime() || this.selectionRange.end?.getTime() !== last(dates).getTime();
        this.selectionRange.start = dates[0];
        this.selectionRange.end = last(dates);
        this.value = this.selectionRange;
        if (shouldEmitValueChange) {
          this.valueChange.emit(this.value);
        }
      }
    });
  }
  setClasses(element) {
    this.renderer.addClass(element, "k-calendar");
    this.renderer.addClass(element, getSizeClass("calendar", this.size));
    if (this.views >= 2) {
      this.renderer.addClass(element, "k-calendar-range");
    }
  }
  verifyChanges() {
    if (!isDevMode()) {
      return;
    }
    if (this.min > this.max) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$3} and ${MAX_DOC_LINK$3}.`);
    }
    if (this.bottomViewEnum > this.topViewEnum) {
      throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK$1} and ${TOP_VIEW_DOC_LINK$1}.`);
    }
  }
  verifyValue(candidate) {
    if (!isDevMode()) {
      return;
    }
    if (this.selection === "single" && candidate && !isNullOrDate(candidate)) {
      throw new Error(`When using 'single' selection the 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
    } else if (this.selection === "multiple" && candidate) {
      if (Array.isArray(candidate)) {
        const onlyDates = candidate.every((value2) => value2 instanceof Date);
        if (!onlyDates) {
          throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
        }
      }
      if (Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
        throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
      }
    } else if (this.selection === "range" && candidate && !(isNullOrDate(candidate["start"]) && isNullOrDate(candidate["end"]))) {
      throw new Error(`The 'value' should be an object with start and end dates. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
    }
  }
  updateButtonState() {
    this.resolvedPromise.then(() => {
      this.isPrevDisabled = !this.viewList.canNavigate(this.prevView);
      this.isNextDisabled = !this.viewList.canNavigate(this.nextView);
      this.cdr.markForCheck();
    });
  }
  parseSelectionToValue(selection) {
    selection = selection || [];
    return this.selection === "single" ? cloneDate(last(selection)) : selection.map((date) => cloneDate(date));
  }
  setValue(candidate) {
    this.verifyValue(candidate);
    if (candidate === null) {
      this._value = null;
      this.selectedDates = [];
    } else if (Array.isArray(candidate)) {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = candidate.filter((date) => isPresent2(date)).map((element) => cloneDate(element));
    } else if (isObject(candidate) && Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = {
        start: null,
        end: null
      };
      this._value.start = candidate.start instanceof Date ? cloneDate(candidate.start) : null;
      this._value.end = candidate.end instanceof Date ? cloneDate(candidate.end) : null;
      this.selectionRange = Object.assign({}, this._value);
      if (this._value?.start && !this._value?.end) {
        this.activeRangeEnd = "end";
        this.canHover = true;
      }
      if (this._value?.end && !this._value?.start) {
        this.activeRangeEnd = "start";
        this.canHover = true;
      }
      if (this._value?.end && this._value?.start) {
        this.canHover = false;
      }
    } else {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = cloneDate(candidate);
    }
    if (this.selection !== "range") {
      const selection = [].concat(candidate).filter((date) => isPresent2(date)).map((date) => cloneDate(date));
      if (!areDatesEqual(selection, this.selectedDates)) {
        const lastSelected = last(selection);
        this.rangePivot = cloneDate(lastSelected);
        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;
        this.selectedDates = selection;
      }
    }
  }
  setRangeSelectionToValue() {
    if (this.selection === "range" && this.value) {
      this.selectionRange = this.value;
      this.cdr.markForCheck();
    }
  }
  performRangeSelection(date) {
    this.focusedDate = date;
    const clonedRangeSelection = Object.assign({}, this.selectionRange);
    const emitValueChange = this.activeRangeEnd === "start" && this.value?.start?.getTime() !== date?.getTime() || this.activeRangeEnd === "end" && this.value?.end?.getTime() !== date?.getTime();
    this.zone.run(() => {
      const rangeSelection = handleRangeSelection(date, clonedRangeSelection, this.activeRangeEnd, this.allowReverse);
      this.activeRangeEnd = rangeSelection.activeRangeEnd;
      if (this.canHover && rangeSelection.activeRangeEnd === "end" && rangeSelection.selectionRange.end?.getTime() === date.getTime()) {
        this.activeRangeEnd = "start";
        rangeSelection.activeRangeEnd = "start";
      }
      this.canHover = this.activeRangeEnd === "end" && rangeSelection.selectionRange.start && !rangeSelection.selectionRange.end;
      if (emitValueChange && (this.value?.start?.getTime() !== rangeSelection.selectionRange?.start?.getTime() || this.value?.end?.getTime() !== rangeSelection.selectionRange?.end?.getTime())) {
        this.value = rangeSelection.selectionRange;
        this.valueChange.emit(this.value);
        this.rangeSelectionChange.emit(rangeSelection);
      }
      this.cdr.markForCheck();
    });
  }
  performSelection(date, selectionModifiers) {
    const selection = this.selectionService.performSelection({
      date,
      modifiers: selectionModifiers,
      selectionMode: this.selection,
      activeViewEnum: this.activeViewEnum,
      rangePivot: this.rangePivot,
      selectedDates: this.selectedDates
    });
    this.rangePivot = selection.rangePivot;
    this.handleDateChange({
      selectedDates: selection.selectedDates,
      focusedDate: date
    });
  }
  static ɵfac = function MultiViewCalendarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiViewCalendarComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(SelectionService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiViewCalendarComponent,
    selectors: [["kendo-multiviewcalendar"]],
    contentQueries: function MultiViewCalendarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      }
    },
    viewQuery: function MultiViewCalendarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(HeaderComponent, 5, ElementRef);
        ɵɵviewQuery(HorizontalViewListComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewList = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function MultiViewCalendarComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("mouseenter", function MultiViewCalendarComponent_mouseenter_HostBindingHandler() {
          return ctx.handleMouseEnter();
        })("mouseleave", function MultiViewCalendarComponent_mouseleave_HostBindingHandler() {
          return ctx.handleMouseLeave();
        })("mousedown", function MultiViewCalendarComponent_mousedown_HostBindingHandler($event) {
          return ctx.handleMousedown($event);
        })("click", function MultiViewCalendarComponent_click_HostBindingHandler() {
          return ctx.handleClick();
        })("keydown", function MultiViewCalendarComponent_keydown_HostBindingHandler($event) {
          return ctx.keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("id", ctx.widgetId)("aria-disabled", ctx.ariaDisabled);
        ɵɵclassProp("k-disabled", ctx.ariaDisabled);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      showCalendarHeader: "showCalendarHeader",
      size: "size",
      id: "id",
      focusedDate: "focusedDate",
      footer: "footer",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      disabledDatesRangeValidation: "disabledDatesRangeValidation",
      selection: "selection",
      allowReverse: "allowReverse",
      value: "value",
      disabled: "disabled",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      weekDaysFormat: "weekDaysFormat",
      isActive: "isActive",
      disabledDates: "disabledDates",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      showViewHeader: "showViewHeader",
      animateNavigation: "animateNavigation",
      weekNumber: "weekNumber",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      views: "views",
      orientation: "orientation",
      cellTemplateRef: [0, "cellTemplate", "cellTemplateRef"],
      monthCellTemplateRef: [0, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [0, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [0, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [0, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [0, "weekNumberTemplate", "weekNumberTemplateRef"],
      footerTemplateRef: [0, "footerTemplate", "footerTemplateRef"],
      headerTitleTemplateRef: [0, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [0, "headerTemplate", "headerTemplateRef"]
    },
    outputs: {
      activeViewChange: "activeViewChange",
      navigate: "navigate",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      valueChange: "valueChange",
      rangeSelectionChange: "rangeSelectionChange",
      blurEvent: "blur",
      focusEvent: "focus",
      focusCalendar: "focusCalendar",
      onClosePopup: "onClosePopup",
      onTabPress: "onTabPress",
      onShiftTabPress: "onShiftTabPress"
    },
    exportAs: ["kendo-multiviewcalendar"],
    features: [ɵɵProvidersFeature([BusViewService, RANGE_CALENDAR_VALUE_ACCESSOR, RANGE_CALENDAR_RANGE_VALIDATORS, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multiviewcalendar"
    }, NavigationService, SelectionService]), ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 26,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_0 = goog.getMsg("Today");
        i18n_0 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.multiviewcalendar.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_1 = goog.getMsg("Navigate to previous view");
        i18n_1 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar:Navigate to previous view`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_2 = goog.getMsg("Navigate to next view");
        i18n_2 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar:Navigate to next view`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_3 = goog.getMsg("Navigate to parent view");
        i18n_3 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.multiviewcalendar.parentViewButtonTitle|The title of the parent view button in the Multiview calendar header:Navigate to parent view`;
      }
      return [["kendoMultiViewCalendarLocalizedMessages", "", "today", i18n_0, "prevButtonTitle", i18n_1, "nextButtonTitle", i18n_2, "parentViewButtonTitle", i18n_3], [3, "activeView", "currentDate", "size", "min", "max", "id", "rangeLength", "titleTemplateRef", "headerTemplateRef", "isPrevDisabled", "isNextDisabled", "showNavigationButtons", "orientation", "todayButtonClick", "prevButtonClick", "nextButtonClick", 4, "ngIf"], [3, "cellClick", "weekNumberCellClick", "cellEnter", "cellLeave", "activeDateChange", "focusCalendar", "blurCalendar", "showOtherMonthDays", "allowReverse", "id", "activeView", "activeDescendant", "isActive", "cellTemplateRef", "weekNumberTemplateRef", "cellUID", "weekDaysFormat", "views", "min", "max", "focusedDate", "animateNavigation", "showViewHeader", "weekNumber", "activeRangeEnd", "selectionRange", "selectedDates", "orientation", "tabIndex", "disabled"], [3, "footerTemplateRef", "activeViewValue", "currentDate", 4, "ngIf"], [3, "todayButtonClick", "prevButtonClick", "nextButtonClick", "activeView", "currentDate", "size", "min", "max", "id", "rangeLength", "titleTemplateRef", "headerTemplateRef", "isPrevDisabled", "isNextDisabled", "showNavigationButtons", "orientation"], [3, "footerTemplateRef", "activeViewValue", "currentDate"]];
    },
    template: function MultiViewCalendarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵtemplate(1, MultiViewCalendarComponent_kendo_calendar_header_1_Template, 1, 13, "kendo-calendar-header", 1);
        ɵɵelementStart(2, "kendo-calendar-horizontal", 2);
        ɵɵlistener("cellClick", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellClick_2_listener($event) {
          return ctx.handleCellClick($event);
        })("weekNumberCellClick", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_weekNumberCellClick_2_listener($event) {
          return ctx.handleWeekNumberClick($event);
        })("cellEnter", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellEnter_2_listener($event) {
          return ctx.onCellEnter(ctx.cellEnter, $event);
        })("cellLeave", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellLeave_2_listener($event) {
          return ctx.emitCellEvent(ctx.cellLeave, $event);
        })("activeDateChange", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_activeDateChange_2_listener($event) {
          return ctx.setActiveDate($event);
        })("focusCalendar", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_focusCalendar_2_listener() {
          return ctx.handleFocus();
        })("blurCalendar", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_blurCalendar_2_listener($event) {
          return ctx.handleFocusout($event);
        });
        ɵɵelementEnd();
        ɵɵtemplate(3, MultiViewCalendarComponent_kendo_calendar_footer_3_Template, 1, 3, "kendo-calendar-footer", 3);
      }
      if (rf & 2) {
        let tmp_7_0;
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showCalendarHeader);
        ɵɵadvance();
        ɵɵproperty("showOtherMonthDays", ctx.showOtherMonthDays)("allowReverse", ctx.allowReverse)("id", ctx.calendarHeaderIdLabel)("activeView", ctx.activeViewEnum)("activeDescendant", ctx.ariaActivedescendant)("isActive", ctx.isActive || ctx.isHovered)("cellTemplateRef", (tmp_7_0 = ctx.activeCellTemplate()) == null ? null : tmp_7_0.templateRef)("weekNumberTemplateRef", ctx.weekNumberTemplateRef == null ? null : ctx.weekNumberTemplateRef.templateRef)("cellUID", ctx.cellUID)("weekDaysFormat", ctx.weekDaysFormat)("views", ctx.views)("min", ctx.min)("max", ctx.max)("focusedDate", ctx.focusedDate)("animateNavigation", ctx.animateNavigation)("showViewHeader", ctx.showViewHeader)("weekNumber", ctx.weekNumber)("activeRangeEnd", ctx.activeRangeEnd)("selectionRange", ctx.selectionRange)("selectedDates", ctx.selectedDates)("orientation", ctx.orientation)("tabIndex", ctx.tabIndex)("disabled", ctx.disabled);
        ɵɵattribute("aria-labelledby", ctx.multiViewCalendarHeaderIdLabel);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.footer);
      }
    },
    dependencies: [MultiViewCalendarLocalizedMessagesDirective, NgIf, HeaderComponent, HorizontalViewListComponent, FooterComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-multiviewcalendar",
      providers: [BusViewService, RANGE_CALENDAR_VALUE_ACCESSOR, RANGE_CALENDAR_RANGE_VALIDATORS, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multiviewcalendar"
      }, NavigationService, SelectionService],
      selector: "kendo-multiviewcalendar",
      template: `
    <ng-container kendoMultiViewCalendarLocalizedMessages
        i18n-today="kendo.multiviewcalendar.today|The label for the today button in the calendar header"
        today="Today"

        i18n-prevButtonTitle="kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar"
        prevButtonTitle="Navigate to previous view"

        i18n-nextButtonTitle="kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar"
        nextButtonTitle="Navigate to next view"

        i18n-parentViewButtonTitle="kendo.multiviewcalendar.parentViewButtonTitle|The title of the parent view button in the Multiview calendar header"
        parentViewButtonTitle="Navigate to parent view"
    >
    </ng-container>
    <kendo-calendar-header
        *ngIf="showCalendarHeader"
        [activeView]="activeViewEnum"
        [currentDate]="activeDate"
        [size]="size"
        [min]="min"
        [max]="max"
        [id]="headerId"
        [rangeLength]="views"
        [titleTemplateRef]="headerTitleTemplateRef?.templateRef"
        [headerTemplateRef]="headerTemplateRef?.templateRef"
        [isPrevDisabled]="isPrevDisabled"
        [isNextDisabled]="isNextDisabled"
        [showNavigationButtons]="true"
        [orientation]="orientation"
        (todayButtonClick)="handleTodayButtonClick({ selectedDates: [$event], focusedDate: $event })"
        (prevButtonClick)="navigateView(prevView)"
        (nextButtonClick)="navigateView(nextView)"
    >
    </kendo-calendar-header>
    <kendo-calendar-horizontal
        [showOtherMonthDays]="showOtherMonthDays"
        [allowReverse]="allowReverse"
        [id]="calendarHeaderIdLabel"
        [attr.aria-labelledby]="multiViewCalendarHeaderIdLabel"
        [activeView]="activeViewEnum"
        [activeDescendant]="ariaActivedescendant"
        [isActive]="isActive || isHovered"
        [cellTemplateRef]="activeCellTemplate()?.templateRef"
        [weekNumberTemplateRef]="weekNumberTemplateRef?.templateRef"
        [cellUID]="cellUID"
        [weekDaysFormat]="weekDaysFormat"
        [views]="views"
        [min]="min"
        [max]="max"
        [focusedDate]="focusedDate"
        [animateNavigation]="animateNavigation"
        [showViewHeader]="showViewHeader"
        [weekNumber]="weekNumber"
        [activeRangeEnd]="activeRangeEnd"
        [selectionRange]="selectionRange"
        [selectedDates]="selectedDates"
        [orientation]="orientation"
        [tabIndex]="tabIndex"
        [disabled]="disabled"
        (cellClick)="handleCellClick($event)"
        (weekNumberCellClick)="handleWeekNumberClick($event)"
        (cellEnter)="onCellEnter(cellEnter, $event)"
        (cellLeave)="emitCellEvent(cellLeave, $event)"
        (activeDateChange)="setActiveDate($event)"
        (focusCalendar)="handleFocus()"
        (blurCalendar)="handleFocusout($event)"
    >
    </kendo-calendar-horizontal>
    <kendo-calendar-footer
        *ngIf="footer"
        [footerTemplateRef]="footerTemplateRef?.templateRef"
        [activeViewValue]="activeView"
        [currentDate]="activeDate">
    </kendo-calendar-footer>
  `,
      standalone: true,
      imports: [MultiViewCalendarLocalizedMessagesDirective, NgIf, HeaderComponent, HorizontalViewListComponent, FooterComponent]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: ElementRef
    }, {
      type: NavigationService
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: DisabledDatesService
    }, {
      type: SelectionService
    }];
  }, {
    showOtherMonthDays: [{
      type: Input
    }],
    showCalendarHeader: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesRangeValidation: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    activeViewChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    rangeSelectionChange: [{
      type: Output
    }],
    blurEvent: [{
      type: Output,
      args: ["blur"]
    }],
    focusEvent: [{
      type: Output,
      args: ["focus"]
    }],
    focusCalendar: [{
      type: Output
    }],
    onClosePopup: [{
      type: Output
    }],
    onTabPress: [{
      type: Output
    }],
    onShiftTabPress: [{
      type: Output
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    headerElement: [{
      type: ViewChild,
      args: [HeaderComponent, {
        static: false,
        read: ElementRef
      }]
    }],
    viewList: [{
      type: ViewChild,
      args: [HorizontalViewListComponent, {
        static: false
      }]
    }],
    widgetId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    handleMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    handleMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }],
    handleMousedown: [{
      type: HostListener,
      args: ["mousedown", ["$event"]]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click"]
    }],
    keydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var div$1 = domContainerFactory("div");
var ul$1 = domContainerFactory("ul");
var li$1 = domContainerFactory("li");
var td = domContainerFactory("td");
var th = domContainerFactory("th");
var tr = domContainerFactory("tr");
var tbody = domContainerFactory("tbody");
var thead = domContainerFactory("thead");
var table = domContainerFactory("table");
var monthHeader = () => div$1(`
            <span class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-calendar-title">March 2017</span>
            <span class="k-spacer"></span>
            <span class="k-calendar-nav">
                <button class="k-calendar-nav-today k-button k-button-md k-button-flat k-button-flat-base k-rounded-md">TODAY</button>
            </span>
        `, "k-calendar-header");
var monthWeekHeader = () => table([thead([tr([th("MO", "k-calendar-th")], "k-calendar-tr")], "k-calendar-thead")], "k-calendar-weekdays k-calendar-table");
var repeat = (count, mapper) => new Array(count).fill("1").map(mapper);
var content = (rows, cells = 1) => table([tbody([tr([th("1", "k-calendar-th")], "k-calendar-tr")].concat(repeat(rows, () => tr(repeat(cells, (c) => td(`<span class="k-link">${c}</span>`, "k-calendar-td")), "k-calendar-tr"))), "k-calendar-tbody")], "k-calendar-table");
var scrollable$1 = (children) => div$1(children, "k-flex k-content k-scrollable");
var view = (contentElement, className, renderWeekHeader) => div$1([monthHeader(), renderWeekHeader ? monthWeekHeader() : null, scrollable$1([contentElement, contentElement])], className, {
  left: "-10000px",
  position: "absolute"
});
var navigationList = /* @__PURE__ */ (() => {
  let navElement;
  return () => {
    if (!isDocumentAvailable) {
      return null;
    }
    if (!navElement) {
      navElement = div$1([scrollable$1([ul$1([li$1("<span>FEB</span>")])])], "k-calendar-navigation", {
        left: "0px",
        position: "absolute"
      });
    }
    return navElement;
  };
})();
var viewFactory = ({
  cells,
  rows
}, className, renderWeekHeader) => {
  let viewElement;
  return () => {
    if (!isDocumentAvailable) {
      return null;
    }
    if (!viewElement) {
      viewElement = view(content(rows, cells), className, renderWeekHeader);
    }
    return viewElement;
  };
};
var getScrollable = (element) => element.querySelector(".k-scrollable");
var horizontal = (element) => {
  const scrollableElement = getScrollable(element);
  scrollableElement.classList.add("k-scrollable-horizontal");
  return element;
};
var monthView = viewFactory({
  cells: 7,
  rows: 6
}, "k-vstack k-calendar-view k-calendar-monthview", true);
var yearView = viewFactory({
  cells: 4,
  rows: 3
}, "k-vstack k-calendar-view k-calendar-yearview", false);
var decadeView = viewFactory({
  cells: 4,
  rows: 3
}, "k-vstack k-calendar-view k-calendar-decadeview", false);
var horzMonthView = () => horizontal(monthView());
var horzYearView = () => horizontal(yearView());
var horzDecadeView = () => horizontal(decadeView());
var height = (element) => parseFloat(window.getComputedStyle(element).height) || element.offsetHeight;
var width = (element) => {
  const styles = window.getComputedStyle(element);
  const computed = parseFloat(styles.width) + parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
  return computed || element.offsetWidth;
};
var getBody = (element) => element.querySelector("tbody");
var CalendarDOMService = class _CalendarDOMService {
  //heights
  calendarHeight;
  headerHeight;
  monthViewHeight;
  yearViewHeight;
  decadeViewHeight;
  centuryViewHeight;
  navigationItemHeight;
  scrollableContentHeight;
  scrollableYearContentHeight;
  //widths
  calendarWidth;
  monthViewWidth;
  yearViewWidth;
  decadeViewWidth;
  centuryViewWidth;
  scrollableContentWidth;
  hostContainer;
  ensureHeights() {
    if (this.calendarHeight !== void 0) {
      return;
    }
    this.calculateHeights();
  }
  calculateHeights(container) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.hostContainer = container;
    this.batch(monthView(), (contentElement) => {
      const viewElement = getBody(contentElement);
      this.calendarHeight = height(contentElement);
      this.monthViewHeight = height(viewElement);
      this.headerHeight = height(viewElement.children[0]);
      this.scrollableContentHeight = height(getScrollable(contentElement));
    });
    this.batch(horzMonthView(), (contentElement) => {
      const viewElement = getBody(contentElement);
      this.calendarWidth = width(contentElement);
      this.monthViewWidth = width(viewElement);
      this.scrollableContentWidth = width(getScrollable(contentElement));
    });
    this.batch(yearView(), (contentElement) => {
      this.yearViewHeight = height(getBody(contentElement));
      this.scrollableYearContentHeight = height(getScrollable(contentElement));
    });
    this.batch(horzYearView(), (contentElement) => {
      this.yearViewWidth = width(getBody(contentElement));
    });
    this.batch(decadeView(), (contentElement) => {
      this.decadeViewHeight = height(getBody(contentElement));
      this.centuryViewHeight = this.decadeViewHeight;
    });
    this.batch(horzDecadeView(), (contentElement) => {
      this.decadeViewWidth = width(getBody(contentElement));
      this.centuryViewWidth = this.decadeViewWidth;
    });
    this.batch(navigationList(), (contentElement) => {
      this.navigationItemHeight = height(contentElement.querySelector("li"));
    });
  }
  viewHeight(viewType) {
    return this.viewDimension(viewType, "height");
  }
  viewWidth(viewType) {
    return this.viewDimension(viewType, "width");
  }
  viewDimension(viewType, dimension) {
    const viewProp = dimension === "height" ? "ViewHeight" : "ViewWidth";
    switch (viewType) {
      case CalendarViewEnum.month:
        return this[`month${viewProp}`];
      case CalendarViewEnum.year:
        return this[`year${viewProp}`];
      case CalendarViewEnum.decade:
        return this[`decade${viewProp}`];
      case CalendarViewEnum.century:
        return this[`century${viewProp}`];
      default:
        return 1;
    }
  }
  batch(contentElement, action) {
    if (!isPresent2(this.hostContainer)) {
      return;
    }
    const hostClone = this.hostContainer.cloneNode();
    document.body.appendChild(hostClone);
    try {
      const appendedContent = hostClone.appendChild(contentElement);
      action(appendedContent);
    } finally {
      document.body.removeChild(hostClone);
    }
  }
  static ɵfac = function CalendarDOMService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarDOMService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CalendarDOMService,
    factory: _CalendarDOMService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarDOMService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var update = (arr, idx2, value2) => [...arr.slice(0, idx2 + 1), ...arr.slice(idx2 + 1).map((x) => x + value2)];
var RowHeightService = class {
  total;
  rowHeight;
  detailRowHeight;
  offsets = [];
  heights = [];
  constructor(total = 0, rowHeight, detailRowHeight) {
    this.total = total;
    this.rowHeight = rowHeight;
    this.detailRowHeight = detailRowHeight;
    let agg = 0;
    for (let idx2 = 0; idx2 < total; idx2++) {
      this.offsets.push(agg);
      agg += rowHeight;
      this.heights.push(rowHeight);
    }
  }
  height(rowIndex) {
    return this.heights[rowIndex];
  }
  expandDetail(rowIndex) {
    if (this.height(rowIndex) === this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight);
    }
  }
  collapseDetail(rowIndex) {
    if (this.height(rowIndex) > this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);
    }
  }
  index(position) {
    if (position < 0) {
      return void 0;
    }
    const result = this.offsets.reduce((prev, current, idx2) => {
      if (prev !== void 0) {
        return prev;
      } else if (current === position) {
        return idx2;
      } else if (current > position) {
        return idx2 - 1;
      }
      return void 0;
    }, void 0);
    return result === void 0 ? this.total - 1 : result;
  }
  offset(rowIndex) {
    return this.offsets[rowIndex];
  }
  totalHeight() {
    return this.heights.reduce((prev, curr) => prev + curr, 0);
  }
  updateRowHeight(rowIndex, value2) {
    this.heights[rowIndex] += value2;
    this.offsets = update(this.offsets, rowIndex, value2);
  }
};
var normalize2 = (x) => Math.max(x, 0);
var ScrollAction = class {
  offset;
  constructor(offset2) {
    this.offset = offset2;
  }
};
var PageAction = class {
  skip;
  constructor(skip3) {
    this.skip = skip3;
  }
};
var ScrollerService = class {
  scrollObservable;
  direction;
  firstLoaded = 0;
  lastLoaded;
  lastScroll;
  take;
  total;
  rowHeightService;
  scrollSubscription;
  subscription;
  bottomOffset = 0;
  topOffset = 0;
  constructor(scrollObservable) {
    this.scrollObservable = scrollObservable;
  }
  create(rowHeightService, skip3, take4, total, topOffset = 0, bottomOffset = 0, direction = "vertical") {
    this.rowHeightService = rowHeightService;
    this.firstLoaded = skip3;
    this.lastLoaded = skip3 + take4;
    this.take = take4;
    this.total = total;
    this.lastScroll = 0;
    this.topOffset = topOffset;
    this.bottomOffset = bottomOffset;
    this.direction = direction;
    const subject = new ReplaySubject(2);
    const offsetBufferRows = this.rowsForHeight(topOffset);
    const skipWithOffset = normalize2(skip3 - offsetBufferRows);
    subject.next(new ScrollAction(this.rowOffset(skipWithOffset)));
    if (offsetBufferRows) {
      subject.next(new PageAction(skipWithOffset));
    }
    this.subscription = new Observable((observer) => {
      this.unsubscribe();
      this.scrollSubscription = this.scrollObservable.subscribe((x) => this.onScroll(x, observer));
    }).subscribe((x) => subject.next(x));
    return subject;
  }
  destroy() {
    this.unsubscribe();
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  onScroll({
    scrollLeft,
    scrollTop,
    offsetHeight,
    offsetWidth
  }, observer) {
    const scrollPosition = this.direction === "vertical" ? scrollTop : scrollLeft;
    const offsetSize = this.direction === "vertical" ? offsetHeight : offsetWidth;
    if (this.lastScroll === scrollPosition) {
      return;
    }
    const up = this.lastScroll >= scrollPosition;
    this.lastScroll = scrollPosition;
    const firstItemIndex = this.rowHeightService.index(normalize2(scrollPosition - this.topOffset));
    const lastItemIndex = this.rowHeightService.index(normalize2(scrollPosition + offsetSize - this.bottomOffset));
    if (!up && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
      this.firstLoaded = firstItemIndex;
      observer.next(new ScrollAction(this.rowOffset(firstItemIndex)));
      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
      observer.next(new PageAction(this.firstLoaded));
    }
    if (up && firstItemIndex <= this.firstLoaded) {
      const nonVisibleBuffer = Math.floor(this.take * 0.3);
      this.firstLoaded = normalize2(firstItemIndex - nonVisibleBuffer);
      observer.next(new ScrollAction(this.rowOffset(this.firstLoaded)));
      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
      observer.next(new PageAction(this.firstLoaded));
    }
  }
  rowOffset(index) {
    return this.rowHeightService.offset(index) + this.topOffset;
  }
  rowsForHeight(height2) {
    return Math.ceil(height2 / this.rowHeightService.height(0));
  }
  unsubscribe() {
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
      this.scrollSubscription = null;
    }
  }
};
var SCROLLER_FACTORY_TOKEN = new InjectionToken("dateinputs-scroll-service-factory");
function DEFAULT_SCROLLER_FACTORY(observable) {
  return new ScrollerService(observable);
}
var ScrollDirection;
(function(ScrollDirection2) {
  ScrollDirection2[ScrollDirection2["Backward"] = 0] = "Backward";
  ScrollDirection2[ScrollDirection2["Forward"] = 1] = "Forward";
})(ScrollDirection || (ScrollDirection = {}));
var FRAME_DURATION = 17;
var scrollModifiers = {
  [ScrollDirection.Forward]: (step) => (value2) => value2 + step,
  [ScrollDirection.Backward]: (step) => (value2) => value2 - step
};
var scrollNormalizers = {
  [ScrollDirection.Forward]: (end) => (value2) => Math.min(value2, end),
  [ScrollDirection.Backward]: (end) => (value2) => Math.max(value2, end)
};
var scrollValidators = {
  [ScrollDirection.Forward]: (end) => (start) => start < end,
  [ScrollDirection.Backward]: (end) => (start) => start > end
};
var differenceToScroll = (scrollTop, staticOffset, maxScrollDifference) => {
  return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);
};
var VirtualizationComponent = class _VirtualizationComponent {
  container;
  renderer;
  zone;
  scrollBarWidthService;
  direction = "vertical";
  itemHeight = 1;
  itemWidth = 1;
  topOffset = 0;
  bottomOffset = 0;
  maxScrollDifference = 100;
  scrollOffsetSize = 0;
  scrollDuration = 150;
  skip;
  take;
  total;
  activeIndexChange = new EventEmitter();
  pageChange = new EventEmitter();
  scrollChange = new EventEmitter();
  wrapperClasses = true;
  get horizontalClass() {
    return this.direction === "horizontal";
  }
  totalSize;
  get totalVertexLength() {
    const value2 = `${this.totalSize}px`;
    return this.direction === "vertical" ? {
      height: value2
    } : {
      width: value2
    };
  }
  get containerOffsetSize() {
    return this.getContainerProperty(this.direction === "vertical" ? "offsetHeight" : "offsetWidth");
  }
  get containerScrollSize() {
    return this.getContainerProperty(this.direction === "vertical" ? "scrollHeight" : "scrollWidth");
  }
  get containerScrollPosition() {
    return this.getContainerProperty(this.direction === "vertical" ? "scrollTop" : "scrollLeft");
  }
  lastActiveIndex;
  resolvedPromise = Promise.resolve(null);
  scroller;
  rowHeightService;
  dispatcher = new Subject();
  scrollSubscription;
  containerScrollSubscription;
  animationSubscription;
  constructor(scrollerFactory, container, renderer, zone, scrollBarWidthService) {
    this.container = container;
    this.renderer = renderer;
    this.zone = zone;
    this.scrollBarWidthService = scrollBarWidthService;
    this.scroller = scrollerFactory(this.dispatcher);
  }
  ngOnChanges(changes) {
    if (changes.direction || changes.take || changes.total) {
      this.initServices();
      this.totalSize = this.rowHeightService.totalHeight() + this.bottomOffset;
    }
  }
  ngOnInit() {
    if (!this.rowHeightService) {
      this.rowHeightService = this.createRowHeightService();
    }
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => {
      this.containerScrollSubscription = this.scroll$().pipe(map((event2) => event2.target)).subscribe((t) => {
        this.dispatcher.next(t);
        this.emitActiveIndex();
      });
    });
  }
  ngOnDestroy() {
    if (this.containerScrollSubscription) {
      this.containerScrollSubscription.unsubscribe();
    }
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
    if (this.animationSubscription) {
      this.animationSubscription.unsubscribe();
    }
  }
  getContainerProperty(propertyName) {
    return this.container.nativeElement[propertyName];
  }
  activeIndex() {
    return this.itemIndex(Math.ceil(this.containerScrollPosition));
  }
  itemIndex(offset2) {
    return this.rowHeightService.index(offset2);
  }
  itemOffset(index) {
    return this.rowHeightService.offset(index);
  }
  isIndexVisible(index) {
    if (!this.rowHeightService) {
      return false;
    }
    const containerTop = this.containerScrollPosition;
    const containerBottom = containerTop + this.containerOffsetSize;
    const top = this.rowHeightService.offset(index);
    const bottom = top + this.rowHeightService.height(index);
    return top >= containerTop && bottom <= containerBottom;
  }
  isListScrolled(index) {
    return this.containerScrollPosition !== this.rowHeightService.offset(index);
  }
  scrollTo(value2) {
    const scrollProperty = this.direction === "vertical" ? "scrollTop" : "scrollLeft";
    this.renderer.setProperty(this.container.nativeElement, scrollProperty, value2);
  }
  scrollToIndex(index) {
    this.zone.runOutsideAngular(() => {
      this.resolvedPromise.then(() => {
        this.scrollTo(this.rowHeightService.offset(index));
      });
    });
  }
  scrollToBottom() {
    this.scrollTo(this.totalSize);
  }
  animateToIndex(index) {
    if (this.animationSubscription) {
      this.animationSubscription.unsubscribe();
    }
    const indexOffset = this.rowHeightService.offset(index);
    const direction = this.getContainerScrollDirection(indexOffset);
    const {
      start,
      end
    } = this.scrollRange(indexOffset, direction);
    if (start === end) {
      return;
    }
    const step = this.scrollStep(start, end);
    const modifyScroll = scrollModifiers[direction](step);
    const normalizeScroll = scrollNormalizers[direction](end);
    const isScrollValid = scrollValidators[direction](modifyScroll(end));
    this.zone.runOutsideAngular(() => {
      this.animationSubscription = combineLatest(of(start), interval(0, animationFrameScheduler)).pipe(map((stream) => stream[0]), scan(modifyScroll), takeWhile(isScrollValid), map(normalizeScroll)).subscribe((x) => this.scrollTo(x));
    });
  }
  scrollRange(indexOffset, direction) {
    const containerScroll = this.containerScrollPosition;
    if (parseInt(indexOffset, 10) === parseInt(containerScroll, 10)) {
      return {
        start: indexOffset,
        end: indexOffset
      };
    }
    const maxScroll = this.containerMaxScroll();
    const sign = direction === ScrollDirection.Backward ? 1 : -1;
    const difference = differenceToScroll(containerScroll, indexOffset, this.maxScrollDifference);
    const end = Math.min(indexOffset, maxScroll);
    const start = Math.min(Math.max(end + sign * difference, 0), maxScroll);
    return {
      start,
      end
    };
  }
  scrollStep(start, end) {
    return Math.abs(end - start) / (this.scrollDuration / FRAME_DURATION);
  }
  scroll$() {
    return isDocumentAvailable() ? fromEvent(this.container.nativeElement, "scroll") : EMPTY;
  }
  initServices() {
    this.rowHeightService = this.createRowHeightService();
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
    this.scrollSubscription = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total, this.topOffset, this.scrollOffsetSize, this.direction).subscribe((x) => {
      if (x instanceof PageAction) {
        this.pageChange.emit(x);
      } else {
        this.scrollChange.emit(x);
      }
    });
  }
  createRowHeightService() {
    const dimension = this.direction === "vertical" ? this.itemHeight : this.itemWidth;
    return new RowHeightService(this.total, dimension, 0);
  }
  emitActiveIndex() {
    const index = this.rowHeightService.index(this.containerScrollPosition - this.topOffset);
    if (this.lastActiveIndex !== index) {
      this.lastActiveIndex = index;
      this.activeIndexChange.emit(index);
    }
  }
  containerMaxScroll() {
    return this.containerScrollSize - this.containerOffsetSize;
  }
  getContainerScrollDirection(indexOffset) {
    return indexOffset < this.containerScrollPosition ? ScrollDirection.Backward : ScrollDirection.Forward;
  }
  static ɵfac = function VirtualizationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _VirtualizationComponent)(ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ScrollbarWidthService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _VirtualizationComponent,
    selectors: [["kendo-virtualization"]],
    hostVars: 8,
    hostBindings: function VirtualizationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-flex", ctx.wrapperClasses)("k-content", ctx.wrapperClasses)("k-scrollable", ctx.wrapperClasses)("k-scrollable-horizontal", ctx.horizontalClass);
      }
    },
    inputs: {
      direction: "direction",
      itemHeight: "itemHeight",
      itemWidth: "itemWidth",
      topOffset: "topOffset",
      bottomOffset: "bottomOffset",
      maxScrollDifference: "maxScrollDifference",
      scrollOffsetSize: "scrollOffsetSize",
      scrollDuration: "scrollDuration",
      skip: "skip",
      take: "take",
      total: "total"
    },
    outputs: {
      activeIndexChange: "activeIndexChange",
      pageChange: "pageChange",
      scrollChange: "scrollChange"
    },
    features: [ɵɵProvidersFeature([{
      provide: SCROLLER_FACTORY_TOKEN,
      useValue: DEFAULT_SCROLLER_FACTORY
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c8,
    decls: 2,
    vars: 3,
    consts: [[1, "k-scrollable-placeholder", 3, "ngStyle"]],
    template: function VirtualizationComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵelement(1, "div", 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("k-scrollable-horizontal-placeholder", ctx.direction === "horizontal");
        ɵɵproperty("ngStyle", ctx.totalVertexLength);
      }
    },
    dependencies: [NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VirtualizationComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SCROLLER_FACTORY_TOKEN,
        useValue: DEFAULT_SCROLLER_FACTORY
      }],
      selector: "kendo-virtualization",
      template: `
    <ng-content></ng-content>
    <div
        class="k-scrollable-placeholder"
        [class.k-scrollable-horizontal-placeholder]="direction === 'horizontal'"
        [ngStyle]="totalVertexLength"
    ></div>
  `,
      standalone: true,
      imports: [NgStyle]
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [SCROLLER_FACTORY_TOKEN]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ScrollbarWidthService
    }];
  }, {
    direction: [{
      type: Input
    }],
    itemHeight: [{
      type: Input
    }],
    itemWidth: [{
      type: Input
    }],
    topOffset: [{
      type: Input
    }],
    bottomOffset: [{
      type: Input
    }],
    maxScrollDifference: [{
      type: Input
    }],
    scrollOffsetSize: [{
      type: Input
    }],
    scrollDuration: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    take: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    activeIndexChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    scrollChange: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-flex"]
    }, {
      type: HostBinding,
      args: ["class.k-content"]
    }, {
      type: HostBinding,
      args: ["class.k-scrollable"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-scrollable-horizontal"]
    }]
  });
})();
var ITEMS_COUNT = 30;
var NavigationComponent = class _NavigationComponent {
  bus;
  dom;
  intl;
  cdr;
  renderer;
  activeView;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  focusedDate = /* @__PURE__ */ new Date();
  templateRef;
  valueChange = new EventEmitter();
  pageChange = new EventEmitter();
  virtualization;
  list;
  get getComponentClass() {
    return true;
  }
  activeViewValue;
  service;
  dates = [];
  style;
  take = ITEMS_COUNT;
  skip;
  total;
  itemHeight;
  topOffset;
  bottomOffset;
  maxViewHeight;
  indexToScroll = -1;
  intlSubscription;
  constructor(bus, dom, intl, cdr, renderer) {
    this.bus = bus;
    this.dom = dom;
    this.intl = intl;
    this.cdr = cdr;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.dom.ensureHeights();
    const calendarHeight = this.dom.calendarHeight;
    this.itemHeight = this.dom.navigationItemHeight;
    this.maxViewHeight = this.dom.monthViewHeight;
    this.topOffset = (calendarHeight - this.itemHeight) / 2;
    this.bottomOffset = calendarHeight - this.itemHeight;
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.activeViewValue = CalendarViewEnum[this.activeView];
    const viewDate = dateInRange(this.focusedDate, this.min, this.max);
    const total = this.service.total(this.min, this.max);
    const totalChanged = this.total && this.total !== total;
    this.skip = this.service.skip(viewDate, this.min);
    this.total = total;
    if (totalChanged || !this.service.isInArray(viewDate, this.dates)) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
    }
    if (!!changes.focusedDate || totalChanged) {
      this.indexToScroll = this.service.skip(this.focusedDate, this.min);
    }
  }
  ngOnDestroy() {
    if (this.intlSubscription) {
      this.intlSubscription.unsubscribe();
    }
  }
  ngAfterViewInit() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  ngAfterViewChecked() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  onPageChange({
    skip: skip3
  }) {
    this.dates = this.service.datesList(this.service.addToDate(this.min, skip3), this.getTake(skip3));
    this.pageChange.emit();
  }
  scrollChange({
    offset: offset2
  }) {
    const el = this.list.nativeElement;
    const translate = `translateY(${offset2}px)`;
    this.renderer.setStyle(el, "transform", translate);
    this.renderer.setStyle(el, "-ms-transform", translate);
  }
  handleDateChange(args) {
    const item = closestInScope(args.target, (node) => node.hasAttribute("data-date-index"), this.list.nativeElement);
    if (item) {
      const index = parseInt(item.getAttribute("data-date-index"), 10);
      const candidate = this.dates[index];
      this.valueChange.emit(cloneDate(candidate));
    }
  }
  getTake(skip3) {
    return Math.min(this.total - skip3, this.take);
  }
  intlChange() {
    if (this.activeView === CalendarViewEnum.month) {
      this.cdr.markForCheck();
    }
  }
  static ɵfac = function NavigationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NavigationComponent,
    selectors: [["kendo-calendar-navigation"]],
    viewQuery: function NavigationComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 5);
        ɵɵviewQuery(_c9, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function NavigationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-navigation", ctx.getComponentClass);
      }
    },
    inputs: {
      activeView: "activeView",
      min: "min",
      max: "max",
      focusedDate: "focusedDate",
      templateRef: "templateRef"
    },
    outputs: {
      valueChange: "valueChange",
      pageChange: "pageChange"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 12,
    consts: [["list", ""], [1, "k-calendar-navigation-highlight"], [3, "pageChange", "scrollChange", "skip", "take", "total", "itemHeight", "topOffset", "bottomOffset", "maxScrollDifference"], [1, "k-reset", 3, "kendoEventsOutsideAngular", "scope"], [4, "kFor", "kForOf"], [3, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function NavigationComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelement(0, "span", 1);
        ɵɵelementStart(1, "kendo-virtualization", 2);
        ɵɵlistener("pageChange", function NavigationComponent_Template_kendo_virtualization_pageChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onPageChange($event));
        })("scrollChange", function NavigationComponent_Template_kendo_virtualization_scrollChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.scrollChange($event));
        });
        ɵɵelementStart(2, "ul", 3, 0);
        ɵɵtemplate(4, NavigationComponent_li_4_Template, 4, 11, "li", 4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("skip", ctx.skip)("take", ctx.take)("total", ctx.total)("itemHeight", ctx.itemHeight)("topOffset", ctx.topOffset)("bottomOffset", ctx.bottomOffset)("maxScrollDifference", ctx.maxViewHeight);
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(10, _c5, ctx.handleDateChange))("scope", ctx);
        ɵɵadvance(2);
        ɵɵproperty("kForOf", ctx.dates);
      }
    },
    dependencies: [VirtualizationComponent, EventsOutsideAngularDirective, KForOf, NgIf, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-navigation",
      template: `
    <span class="k-calendar-navigation-highlight"></span>
    <kendo-virtualization
        [skip]="skip"
        [take]="take"
        [total]="total"
        [itemHeight]="itemHeight"
        [topOffset]="topOffset"
        [bottomOffset]="bottomOffset"
        [maxScrollDifference]="maxViewHeight"
        (pageChange)="onPageChange($event)"
        (scrollChange)="scrollChange($event)"
    >
        <ul #list class="k-reset" [kendoEventsOutsideAngular]="{ click: handleDateChange }" [scope]="this">
            <li *kFor="let date of dates; let index=index" [attr.data-date-index]="index">
                <span [class.k-calendar-navigation-marker]="service.isRangeStart(date)">
                    <ng-template [ngIf]="!templateRef">{{service.navigationTitle(date)}}</ng-template>
                    <ng-template
                        [ngIf]="templateRef"
                        [ngTemplateOutlet]="templateRef"
                        [ngTemplateOutletContext]="{ $implicit: service.navigationTitle(date), activeView: activeViewValue, date: date }"
                    ></ng-template>
                </span>
            </li>
        </ul>
    </kendo-virtualization>
  `,
      standalone: true,
      imports: [VirtualizationComponent, EventsOutsideAngularDirective, KForOf, NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: CalendarDOMService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    activeView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    templateRef: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: false
      }]
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-navigation"]
    }]
  });
})();
var VIEWS_COUNT = 5;
var isEqualMonthYear = (date1, date2) => date1 && date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
var ViewListComponent = class _ViewListComponent {
  bus;
  cdr;
  intl;
  dom;
  renderer;
  allowReverse;
  cellTemplateRef;
  weekNumberTemplateRef;
  headerTitleTemplateRef;
  headerTemplateRef;
  footerTemplateRef;
  showOtherMonthDays;
  activeView;
  cellUID;
  focusedDate;
  isActive = true;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  selectedDates = [];
  tabIndex = 0;
  disabled = false;
  id;
  showFooter = false;
  weekDaysFormat = "short";
  activeRangeEnd;
  selectionRange;
  size;
  get weekNumber() {
    return this.showWeekNumbers && this.isMonthView();
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  cellEnter = new EventEmitter();
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  activeDateChange = new EventEmitter();
  todayButtonClick = new EventEmitter();
  pageChange = new EventEmitter();
  focusCalendar = new EventEmitter();
  blurCalendar = new EventEmitter();
  focusedCellChange = new EventEmitter();
  virtualization;
  headerComponent;
  get headerTitle() {
    return this.headerComponent?.title;
  }
  list;
  getComponentClass = true;
  get getComponentMonthClass() {
    return this.activeView === CalendarViewEnum.month;
  }
  get getComponentYearClass() {
    return this.activeView === CalendarViewEnum.year;
  }
  get getComponentDecadeClass() {
    return this.activeView === CalendarViewEnum.decade;
  }
  get getComponentCenturyClass() {
    return this.activeView === CalendarViewEnum.century;
  }
  get activeViewValue() {
    return CalendarViewEnum[this.activeView];
  }
  service;
  activeDate;
  dates = [];
  cols = [];
  weekNames = [];
  wideWeekNames = [];
  take = VIEWS_COUNT;
  skip;
  total;
  bottomOffset;
  viewHeight;
  viewOffset;
  animateToIndex = true;
  indexToScroll = -1;
  showWeekNumbers;
  minViewsToRender = 1;
  intlSubscription;
  constructor(bus, cdr, intl, dom, renderer) {
    this.bus = bus;
    this.cdr = cdr;
    this.intl = intl;
    this.dom = dom;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    this.bottomOffset = this.getBottomOffset();
    this.viewOffset = -1 * this.dom.headerHeight;
    this.viewHeight = this.dom.viewHeight(this.activeView);
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.cols = new Array(this.service.rowLength({
      prependCell: this.weekNumber
    })).fill("");
    this.weekNames = hasChange(changes, "weekNumber") && this.weekNumber ? this.getWeekNames(this.weekDaysFormat) : this.weekNames;
    if (hasChange(changes, "weekDaysFormat") && !hasChange(changes, "weekNumber")) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
    }
    this.wideWeekNames = hasChange(changes, "weekNumber") && this.weekNumber ? this.getWeekNames("wide") : this.weekNames;
    const activeViewChanged = hasChange(changes, "activeView");
    const focusedDate = this.focusedDate;
    const viewDate = dateInRange(this.service.viewDate(focusedDate, this.max, this.minViewsToRender), this.min, this.max);
    const total = this.service.total(this.min, this.max);
    const totalChanged = this.total && this.total !== total;
    const generateDates = totalChanged || !this.service.isInArray(focusedDate, this.dates);
    this.skip = this.service.skip(viewDate, this.min);
    this.total = total;
    this.animateToIndex = !activeViewChanged;
    this.bottomOffset = this.getBottomOffset();
    this.viewHeight = this.dom.viewHeight(this.activeView);
    if (generateDates) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
    }
    if (!isEqualMonthYear(this.activeDate, focusedDate)) {
      this.activeDate = cloneDate(focusedDate);
    }
    const updateIndex = hasChange(changes, "focusedDate") || activeViewChanged;
    if (generateDates || updateIndex || this.virtualization.isIndexVisible(this.skip)) {
      this.indexToScroll = this.service.skip(focusedDate, this.min);
    }
  }
  ngOnDestroy() {
    if (this.intlSubscription) {
      this.intlSubscription.unsubscribe();
    }
  }
  ngAfterViewInit() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  ngAfterViewChecked() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization[this.animateToIndex ? "animateToIndex" : "scrollToIndex"](this.indexToScroll);
    this.animateToIndex = true;
    this.indexToScroll = -1;
  }
  onPageChange({
    skip: skip3
  }) {
    this.dates = this.service.datesList(this.service.addToDate(this.min, skip3), this.getTake(skip3));
    this.pageChange.emit();
  }
  scrollChange({
    offset: offset2
  }) {
    const el = this.list.nativeElement;
    const translate = `translateY(${offset2}px)`;
    this.renderer.setStyle(el, "transform", translate);
    this.renderer.setStyle(el, "-ms-transform", translate);
  }
  setActiveDate(index) {
    const candidate = this.service.addToDate(this.min, index);
    this.activeDate = candidate;
    this.activeDateChange.emit(candidate);
    this.cdr.detectChanges();
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  isScrolled() {
    return this.virtualization.isListScrolled(this.service.skip(this.focusedDate, this.min));
  }
  getTabIndex() {
    return this.disabled ? null : this.tabIndex;
  }
  getBottomOffset() {
    return this.getScrollableHeight() - this.dom.viewHeight(this.activeView);
  }
  getScrollableHeight() {
    return this.activeView === CalendarViewEnum.month ? this.dom.scrollableContentHeight : this.dom.scrollableYearContentHeight;
  }
  getTake(skip3) {
    return Math.min(this.total - skip3, this.take);
  }
  getWeekNames(nameType) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType,
      type: "days"
    }), this.intl.firstDay());
    return this.weekNumber ? [""].concat(weekNames) : weekNames;
  }
  intlChange() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    if (this.isMonthView()) {
      this.cdr.markForCheck();
    }
  }
  static ɵfac = function ViewListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewListComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ViewListComponent,
    selectors: [["kendo-calendar-viewlist"]],
    viewQuery: function ViewListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 5);
        ɵɵviewQuery(HeaderComponent, 5);
        ɵɵviewQuery(_c9, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
      }
    },
    hostVars: 12,
    hostBindings: function ViewListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-vstack", ctx.getComponentClass)("k-calendar-view", ctx.getComponentClass)("k-calendar-monthview", ctx.getComponentMonthClass)("k-calendar-yearview", ctx.getComponentYearClass)("k-calendar-decadeview", ctx.getComponentDecadeClass)("k-calendar-centuryview", ctx.getComponentCenturyClass);
      }
    },
    inputs: {
      allowReverse: "allowReverse",
      cellTemplateRef: "cellTemplateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      headerTitleTemplateRef: "headerTitleTemplateRef",
      headerTemplateRef: "headerTemplateRef",
      footerTemplateRef: "footerTemplateRef",
      showOtherMonthDays: "showOtherMonthDays",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      isActive: "isActive",
      min: "min",
      max: "max",
      selectedDates: "selectedDates",
      tabIndex: "tabIndex",
      disabled: "disabled",
      id: "id",
      showFooter: "showFooter",
      weekDaysFormat: "weekDaysFormat",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      size: "size",
      weekNumber: "weekNumber"
    },
    outputs: {
      cellEnter: "cellEnter",
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      activeDateChange: "activeDateChange",
      todayButtonClick: "todayButtonClick",
      pageChange: "pageChange",
      focusCalendar: "focusCalendar",
      blurCalendar: "blurCalendar",
      focusedCellChange: "focusedCellChange"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 23,
    consts: [["list", ""], [3, "todayButtonClick", "currentDate", "size", "min", "max", "id", "activeView", "titleTemplateRef", "headerTemplateRef"], ["class", "k-calendar-weekdays k-calendar-table", 3, "table-layout", 4, "ngIf"], [3, "pageChange", "scrollChange", "activeIndexChange", "tabindex", "skip", "take", "total", "itemHeight", "topOffset", "bottomOffset", "scrollOffsetSize", "maxScrollDifference"], ["role", "grid", 1, "k-calendar-table", 3, "focus", "blur"], [4, "ngFor", "ngForOf"], ["class", "k-calendar-tbody", "kendoCalendarView", "", "role", "rowgroup", 3, "allowReverse", "activeRangeEnd", "selectionRange", "showOtherMonthDays", "headerTitle", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate", "cellClick", "weekNumberCellClick", "focusedCellId", "cellEnter", 4, "kFor", "kForOf"], [3, "footerTemplateRef", "activeViewValue", "currentDate", 4, "ngIf"], [1, "k-calendar-weekdays", "k-calendar-table"], [1, "k-calendar-thead"], [1, "k-calendar-tr"], ["class", "k-calendar-th", "scope", "col", "role", "columnheader", 4, "ngFor", "ngForOf"], ["scope", "col", "role", "columnheader", 1, "k-calendar-th"], ["kendoCalendarView", "", "role", "rowgroup", 1, "k-calendar-tbody", 3, "cellClick", "weekNumberCellClick", "focusedCellId", "cellEnter", "allowReverse", "activeRangeEnd", "selectionRange", "showOtherMonthDays", "headerTitle", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate"], [3, "footerTemplateRef", "activeViewValue", "currentDate"]],
    template: function ViewListComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-calendar-header", 1);
        ɵɵlistener("todayButtonClick", function ViewListComponent_Template_kendo_calendar_header_todayButtonClick_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.todayButtonClick.emit($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(1, ViewListComponent_table_1_Template, 4, 3, "table", 2);
        ɵɵelementStart(2, "kendo-virtualization", 3);
        ɵɵlistener("pageChange", function ViewListComponent_Template_kendo_virtualization_pageChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onPageChange($event));
        })("scrollChange", function ViewListComponent_Template_kendo_virtualization_scrollChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.scrollChange($event));
        })("activeIndexChange", function ViewListComponent_Template_kendo_virtualization_activeIndexChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.setActiveDate($event));
        });
        ɵɵelementStart(3, "table", 4, 0);
        ɵɵlistener("focus", function ViewListComponent_Template_table_focus_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.focusCalendar.emit());
        })("blur", function ViewListComponent_Template_table_blur_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.blurCalendar.emit($event));
        });
        ɵɵelementStart(5, "colgroup");
        ɵɵtemplate(6, ViewListComponent_col_6_Template, 1, 0, "col", 5);
        ɵɵelementEnd();
        ɵɵtemplate(7, ViewListComponent_tbody_7_Template, 1, 16, "tbody", 6);
        ɵɵelementEnd()();
        ɵɵtemplate(8, ViewListComponent_kendo_calendar_footer_8_Template, 1, 3, "kendo-calendar-footer", 7);
      }
      if (rf & 2) {
        ɵɵproperty("currentDate", ctx.activeDate)("size", ctx.size)("min", ctx.min)("max", ctx.max)("id", ctx.id)("activeView", ctx.activeView)("titleTemplateRef", ctx.headerTitleTemplateRef)("headerTemplateRef", ctx.headerTemplateRef);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isMonthView());
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("skip", ctx.skip)("take", ctx.take)("total", ctx.total)("itemHeight", ctx.viewHeight)("topOffset", ctx.viewOffset)("bottomOffset", ctx.bottomOffset)("scrollOffsetSize", ctx.viewOffset)("maxScrollDifference", ctx.viewHeight);
        ɵɵadvance();
        ɵɵattribute("tabindex", ctx.getTabIndex())("aria-labelledby", ctx.id);
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.cols);
        ɵɵadvance();
        ɵɵproperty("kForOf", ctx.dates);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showFooter);
      }
    },
    dependencies: [HeaderComponent, NgIf, NgForOf, VirtualizationComponent, KForOf, ViewComponent, FooterComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewListComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-viewlist",
      template: `
    <kendo-calendar-header
        [currentDate]="activeDate"
        [size]="size"
        [min]="min"
        [max]="max"
        [id]="id"
        [activeView]="activeView"
        [titleTemplateRef]="headerTitleTemplateRef"
        [headerTemplateRef]="headerTemplateRef"
        (todayButtonClick)="todayButtonClick.emit($event)"
    >
    </kendo-calendar-header>
    <table class="k-calendar-weekdays k-calendar-table" [style.table-layout]="'auto'" *ngIf="isMonthView()">
        <thead class="k-calendar-thead">
            <tr class="k-calendar-tr">
                <th class="k-calendar-th" *ngFor="let name of weekNames; let i = index;" scope="col" [attr.aria-label]="wideWeekNames[i]" role="columnheader">{{name}}</th>
            </tr>
        </thead>
    </table>
    <kendo-virtualization
        [tabindex]="-1"
        [skip]="skip"
        [take]="take"
        [total]="total"
        [itemHeight]="viewHeight"
        [topOffset]="viewOffset"
        [bottomOffset]="bottomOffset"
        [scrollOffsetSize]="viewOffset"
        [maxScrollDifference]="viewHeight"
        (pageChange)="onPageChange($event)"
        (scrollChange)="scrollChange($event)"
        (activeIndexChange)="setActiveDate($event)"
        >
        <table
            #list
            role="grid"
            class="k-calendar-table"
            [attr.tabindex]="getTabIndex()"
            [attr.aria-labelledby]="id"
            (focus)="focusCalendar.emit()"
            (blur)="blurCalendar.emit($event)"
        >
            <colgroup><col *ngFor="let _ of cols" /></colgroup>

            <tbody class="k-calendar-tbody"
                   *kFor="let date of dates"
                   kendoCalendarView
                   [allowReverse]="allowReverse"
                   [activeRangeEnd]="activeRangeEnd"
                   [selectionRange]="selectionRange"
                   [showOtherMonthDays]="showOtherMonthDays"
                   [headerTitle]="headerTitle"
                   role="rowgroup"
                   [activeView]="activeView"
                   [isActive]="isActive"
                   [min]="min" [max]="max"
                   [cellUID]="cellUID"
                   [focusedDate]="focusedDate"
                   [selectedDates]="selectedDates"
                   [weekNumber]="weekNumber"
                   [templateRef]="cellTemplateRef"
                   [weekNumberTemplateRef]="weekNumberTemplateRef"
                   [viewDate]="date"
                   (cellClick)="cellClick.emit($event)"
                   (weekNumberCellClick)="weekNumberCellClick.emit($event)"
                   (focusedCellId)="focusedCellChange.emit($event)"
                   (cellEnter)="cellEnter.emit($event)"
            ></tbody>
        </table>
    </kendo-virtualization>
    <kendo-calendar-footer
        *ngIf="showFooter"
        [footerTemplateRef]="footerTemplateRef"
        [activeViewValue]="activeViewValue"
        [currentDate]="activeDate">
    </kendo-calendar-footer>
  `,
      standalone: true,
      imports: [HeaderComponent, NgIf, NgForOf, VirtualizationComponent, KForOf, ViewComponent, FooterComponent]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: ChangeDetectorRef
    }, {
      type: IntlService
    }, {
      type: CalendarDOMService
    }, {
      type: Renderer2
    }];
  }, {
    allowReverse: [{
      type: Input
    }],
    cellTemplateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    headerTitleTemplateRef: [{
      type: Input
    }],
    headerTemplateRef: [{
      type: Input
    }],
    footerTemplateRef: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    cellEnter: [{
      type: Output
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    activeDateChange: [{
      type: Output
    }],
    todayButtonClick: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    focusCalendar: [{
      type: Output
    }],
    blurCalendar: [{
      type: Output
    }],
    focusedCellChange: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: false
      }]
    }],
    headerComponent: [{
      type: ViewChild,
      args: [HeaderComponent, {
        static: false
      }]
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }, {
      type: HostBinding,
      args: ["class.k-calendar-view"]
    }],
    getComponentMonthClass: [{
      type: HostBinding,
      args: ["class.k-calendar-monthview"]
    }],
    getComponentYearClass: [{
      type: HostBinding,
      args: ["class.k-calendar-yearview"]
    }],
    getComponentDecadeClass: [{
      type: HostBinding,
      args: ["class.k-calendar-decadeview"]
    }],
    getComponentCenturyClass: [{
      type: HostBinding,
      args: ["class.k-calendar-centuryview"]
    }]
  });
})();
var divideByMagnitude = (magnitude) => (x) => Math.floor(x / magnitude);
var powerByMagnitude = (magnitude) => (x) => x * magnitude;
var ScrollSyncService = class _ScrollSyncService {
  dom;
  zone;
  divideByMagnitude;
  powerByMagnitude;
  navSubscription;
  viewSubscription;
  navigator;
  view;
  constructor(dom, zone) {
    this.dom = dom;
    this.zone = zone;
  }
  configure(activeView) {
    const magnitude = Math.max(this.dom.viewHeight(activeView) / this.dom.navigationItemHeight, 1);
    this.divideByMagnitude = divideByMagnitude(magnitude);
    this.powerByMagnitude = powerByMagnitude(magnitude);
  }
  sync(navigator2, view2) {
    this.unsubscribe();
    if (!navigator2 || !view2) {
      return;
    }
    this.navigator = navigator2;
    this.view = view2;
    this.zone.runOutsideAngular(() => {
      let navScrolled, monthScrolled;
      this.navSubscription = navigator2.scroll$().subscribe((e) => {
        if (monthScrolled) {
          monthScrolled = false;
          return;
        }
        navScrolled = true;
        this.scrollSiblingOf(e.target);
      });
      this.viewSubscription = view2.scroll$().subscribe((e) => {
        if (navScrolled) {
          navScrolled = false;
          return;
        }
        monthScrolled = true;
        this.scrollSiblingOf(e.target);
      });
    });
  }
  scrollSiblingOf(scrolledElement) {
    const component = this.siblingComponent(scrolledElement);
    const scrollTop = this.calculateScroll(component, scrolledElement.scrollTop);
    component.scrollTo(scrollTop);
  }
  siblingComponent(scrollableElement) {
    return this.navigator.container.nativeElement === scrollableElement ? this.view : this.navigator;
  }
  calculateScroll(component, scrollTop) {
    const modifier = component === this.navigator ? this.divideByMagnitude : this.powerByMagnitude;
    return modifier(scrollTop);
  }
  destroy() {
    this.unsubscribe();
  }
  unsubscribe() {
    if (this.navSubscription) {
      this.navSubscription.unsubscribe();
    }
    if (this.viewSubscription) {
      this.viewSubscription.unsubscribe();
    }
  }
  static ɵfac = function ScrollSyncService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollSyncService)(ɵɵinject(CalendarDOMService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollSyncService,
    factory: _ScrollSyncService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollSyncService, [{
    type: Injectable
  }], function() {
    return [{
      type: CalendarDOMService
    }, {
      type: NgZone
    }];
  }, null);
})();
var NavigationItemTemplateDirective = class _NavigationItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NavigationItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NavigationItemTemplateDirective,
    selectors: [["", "kendoCalendarNavigationItemTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarNavigationItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var PickerService = class {
  onFocus = new EventEmitter();
  onBlur = new EventEmitter();
  sameDateSelected = new EventEmitter();
  dateCompletenessChange = new EventEmitter();
  calendar;
  input;
  timeSelector;
};
var MultiViewCalendarCustomMessagesComponent = class _MultiViewCalendarCustomMessagesComponent extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function MultiViewCalendarCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiViewCalendarCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiViewCalendarCustomMessagesComponent,
    selectors: [["kendo-multiviewcalendar-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _MultiViewCalendarCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function MultiViewCalendarCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => MultiViewCalendarCustomMessagesComponent)
      }],
      selector: "kendo-multiviewcalendar-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var CalendarMessages = class _CalendarMessages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCalendarMessages_BaseFactory;
    return function CalendarMessages_Factory(__ngFactoryType__) {
      return (ɵCalendarMessages_BaseFactory || (ɵCalendarMessages_BaseFactory = ɵɵgetInheritedFactory(_CalendarMessages)))(__ngFactoryType__ || _CalendarMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CalendarMessages,
    selectors: [["kendo-calendar-messages-base"]],
    inputs: {
      today: "today",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-calendar-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }]
  });
})();
var CalendarLocalizedMessagesDirective = class _CalendarLocalizedMessagesDirective extends CalendarMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function CalendarLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CalendarLocalizedMessagesDirective,
    selectors: [["", "kendoCalendarLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: CalendarMessages,
      useExisting: forwardRef(() => _CalendarLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: CalendarMessages,
        useExisting: forwardRef(() => CalendarLocalizedMessagesDirective)
      }],
      selector: "[kendoCalendarLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var BOTTOM_VIEW_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview";
var TOP_VIEW_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview";
var MIN_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min";
var MAX_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max";
var VALUE_DOC_LINK$4 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json";
var virtualizationProp = (x) => x ? x.virtualization : null;
var CALENDAR_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CalendarComponent)
};
var CALENDAR_RANGE_VALIDATORS = {
  multi: true,
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CalendarComponent)
};
var KENDO_INPUT_PROVIDER = {
  provide: KendoInput,
  useExisting: forwardRef(() => CalendarComponent)
};
var CalendarComponent = class _CalendarComponent {
  bus;
  dom;
  element;
  navigator;
  renderer;
  cdr;
  ngZone;
  injector;
  scrollSyncService;
  disabledDatesService;
  localization;
  selectionService;
  pickerService;
  /**
   * Displays the days that fall out of the current month ([see example]({% slug viewoptions_calendar %}#toc-displaying-other-month-days)).
   * The default values per Calendar type are:
   * - `infinite` - false
   * - `classic` - true
   */
  set showOtherMonthDays(_showOtherMonthDays) {
    this._showOtherMonthDays = _showOtherMonthDays;
  }
  get showOtherMonthDays() {
    if (this._showOtherMonthDays === void 0) {
      return this.type === "classic";
    }
    return this._showOtherMonthDays;
  }
  _showOtherMonthDays;
  /**
   * @hidden
   */
  id;
  /**
   * @hidden
   */
  get popupId() {
    return `kendo-popup-${this.bus.calendarId}`;
  }
  /**
   * Sets or gets the `focusedDate` property of the Calendar and
   * defines the focused date of the component
   * ([see example]({% slug dates_calendar %}#toc-focused-dates)).
   *
   * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.
   */
  set focusedDate(focusedDate) {
    if (this.activeViewDate && !isEqual(this._focusedDate, focusedDate)) {
      const service = this.bus.service(this.activeViewEnum);
      const lastDayInPeriod = service.lastDayOfPeriod(this.activeViewDate);
      const isFocusedDateInRange = service.isInRange(focusedDate, this.activeViewDate, lastDayInPeriod);
      if (!isFocusedDateInRange) {
        this.emitNavigate(focusedDate);
      }
    }
    this._focusedDate = focusedDate || getToday();
    this.setAriaActivedescendant();
  }
  get focusedDate() {
    if (this._focusedDate > this.max) {
      return this.max;
    }
    if (this._focusedDate < this.min) {
      return this.min;
    }
    return this._focusedDate;
  }
  /**
   * @hidden
   */
  get headerId() {
    return this.id + "-header";
  }
  /**
   * Sets or gets the `min` property of the Calendar and
   * defines the minimum allowed date value
   * ([see example]({% slug dateranges_calendar %})).
   * By default, the `min` value is `1900-1-1`.
   */
  set min(min) {
    this._min = min || new Date(MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Sets or gets the `max` property of the Calendar and
   * defines the maximum allowed date value
   * ([see example]({% slug dateranges_calendar %})).
   * By default, the `max` value is `2099-12-31`.
   */
  set max(max) {
    this._max = max || new Date(MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form.
   */
  rangeValidation = false;
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Toggles the visibility of the footer.
   * @default false
   */
  footer = false;
  /**
   * Sets the Calendar selection mode
   * ([see example]({% slug selection_calendar %})).
   *
   * The available values are:
   * * `single` (default)
   * * `multiple`
   * * `range`
   */
  set selection(_selection) {
    this._selection = _selection;
    this.selectionSetter = true;
  }
  get selection() {
    return this._selection;
  }
  _selection = "single";
  /**
   * Allows reverse selection when using `range` selection.
   * If `allowReverse` is set to `true`, the component skips the validation of whether the start date is after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Sets or gets the `value` property of the Calendar and defines the selected value of the component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance when in `single` selection mode, an array of valid JavaScript Date instances when in `multiple` selection mode, or an object of type `SelectionRange` when in `range` selection mode.
   */
  set value(candidate) {
    this.valueSetter = true;
    this._value = candidate;
  }
  get value() {
    return this._value;
  }
  /**
   * Sets or gets the `disabled` property of the Calendar and
   * determines whether the component is active
   * ([see example]({% slug disabled_calendar %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_calendar#toc-managing-the-calendar-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets or gets the `tabindex` property of the Calendar. Based on the
   * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,
   * it determines whether the component is focusable.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the dates of the Calendar that will be disabled
   * ([see example]({% slug disabled_dates_calendar %})).
   */
  set disabledDates(value2) {
    this.disabledDatesService.initialize(value2);
    this._disabledDates = value2;
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Sets or gets the `navigation` property of the Calendar
   * and determines whether the navigation side-bar will be displayed
   * ([see example]({% slug sidebar_calendar %})).
   * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   */
  navigation = true;
  /**
   * Defines the active view that the Calendar initially renders
   * ([see example]({% slug viewoptions_calendar %})).
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost view to which the user can navigate
   * ([see example](slug:viewdepth_calendar)).
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost view to which the user can navigate
   * ([see example](slug:viewdepth_calendar)).
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Specifies the Calendar type.
   *
   * The possible values are:
   * - `infinite` (default)
   * - `classic`
   *
   */
  set type(type) {
    this.renderer.removeClass(this.element.nativeElement, `k-calendar-${this.type}`);
    if (type === "infinite") {
      this.renderer.addClass(this.element.nativeElement, `k-calendar-${type}`);
    }
    this._type = type;
  }
  get type() {
    return this._type;
  }
  /**
   * Determines whether to enable animation when navigating to previous/next view.
   * Applies to the [`classic`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateNavigation = false;
  /**
   * Determines whether to display a week number column in the `month` view
   * ([see example]({% slug weeknumcolumn_calendar %})).
   */
  weekNumber = false;
  /**
   * Fires when the active view is changed
   * ([see example](slug:events_calendar)).
   */
  activeViewChange = new EventEmitter();
  /**
   * Fires when navigating in the currently active view
   * ([see example](slug:events_calendar)).
   */
  navigate = new EventEmitter();
  /**
   * Fires when the active view date is changed
   * ([see example](slug:events_calendar)).
   * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   */
  activeViewDateChange = new EventEmitter();
  /**
   * Fires each time the Calendar gets blurred
   * ([see example](slug:events_calendar)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the Calendar gets focused
   * ([see example](slug:events_calendar)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the value is changed
   * ([see example](slug:events_calendar)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   *
   * Queries the template for a cell template declaration.
   * Ignored if a `[cellTemplate]` value is explicitly provided.
   */
  cellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set cellTemplateRef(template) {
    this._cellTemplateRef = template;
  }
  get cellTemplateRef() {
    return this._cellTemplateRef || this.cellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a month cell template declaration.
   * Ignored if a `[monthCellTemplate]` value is explicitly provided.
   */
  monthCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each month cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set monthCellTemplateRef(template) {
    this._monthCellTemplateRef = template;
  }
  get monthCellTemplateRef() {
    return this._monthCellTemplateRef || this.monthCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a year cell template declaration.
   * Ignored if a `[yearCellTemplate]` value is explicitly provided.
   */
  yearCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each year cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set yearCellTemplateRef(template) {
    this._yearCellTemplateRef = template;
  }
  get yearCellTemplateRef() {
    return this._yearCellTemplateRef || this.yearCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a decade cell template declaration.
   * Ignored if a `[decadeCellTemplate]` value is explicitly provided.
   */
  decadeCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each decade cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set decadeCellTemplateRef(template) {
    this._decadeCellTemplateRef = template;
  }
  get decadeCellTemplateRef() {
    return this._decadeCellTemplateRef || this.decadeCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a century cell template declaration.
   * Ignored if a `[centuryCellTemplate]` value is explicitly provided.
   */
  centuryCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each century cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set centuryCellTemplateRef(template) {
    this._centuryCellTemplateRef = template;
  }
  get centuryCellTemplateRef() {
    return this._centuryCellTemplateRef || this.centuryCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a week number cell template declaration.
   * Ignored if a `[weekNumberTemplate]` value is explicitly provided.
   */
  weekNumberTemplate;
  /**
   * @hidden
   *
   * Defines the template for the week cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set weekNumberTemplateRef(template) {
    this._weekNumberTemplateRef = template;
  }
  get weekNumberTemplateRef() {
    return this._weekNumberTemplateRef || this.weekNumberTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a header title template declaration.
   * Ignored if a `[headerTitleTemplate]` value is explicitly provided.
   */
  headerTitleTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   * Ignored if a `[headerTemplate]` value is explicitly provided.
   */
  headerTemplate;
  /**
   * @hidden
   *
   * Queries the template for a footer template declaration.
   * Ignored if a `[footerTemplate]` value is explicitly provided.
   */
  footerTemplate;
  /**
   * @hidden
   *
   * Defines the template for the header title.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set headerTitleTemplateRef(template) {
    this._headerTitleTemplateRef = template;
  }
  get headerTitleTemplateRef() {
    return this._headerTitleTemplateRef || this.headerTitleTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the header.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set headerTemplateRef(template) {
    this._headerTemplateRef = template;
  }
  get headerTemplateRef() {
    return this._headerTemplateRef || this.headerTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the footer.
   */
  set footerTemplateRef(template) {
    this._footerTemplateRef = template;
  }
  get footerTemplateRef() {
    return this._footerTemplateRef || this.footerTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a navigation item template declaration.
   * Ignored if a `[navigationItemTemplate]` value is explicitly provided.
   */
  navigationItemTemplate;
  /**
   * @hidden
   *
   * Defines the template for the navigation item.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set navigationItemTemplateRef(template) {
    this._navigationItemTemplateRef = template;
  }
  get navigationItemTemplateRef() {
    return this._navigationItemTemplateRef || this.navigationItemTemplate;
  }
  /**
   * @hidden
   *
   * TODO: Make visible when true sizing of all calendar elements is implemented
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this._size = size;
  }
  get size() {
    return this._size;
  }
  _size = DEFAULT_SIZE;
  /**
   * Specify, which end of the defined selection range should be marked as active.
   *
   * > Value will be ignored if the selection range is undefined.
   * > If range selection is used then the default value is 'start'.
   */
  set activeRangeEnd(_activeRangeEnd) {
    this._activeRangeEnd = _activeRangeEnd;
  }
  get activeRangeEnd() {
    return this._activeRangeEnd;
  }
  _activeRangeEnd = "start";
  navigationView;
  monthView;
  multiViewCalendar;
  isActive = false;
  cellUID = guid();
  selectionRange = {
    start: null,
    end: null
  };
  selectedDates = [];
  rangePivot;
  _disabledDates;
  _min = new Date(MIN_DATE);
  _max = new Date(MAX_DATE);
  _focusedDate = getToday();
  _value;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  changes = {};
  valueSetter = false;
  selectionSetter = false;
  syncNavigation = true;
  viewChangeSubscription;
  _type = "infinite";
  _cellTemplateRef;
  _monthCellTemplateRef;
  _yearCellTemplateRef;
  _decadeCellTemplateRef;
  _centuryCellTemplateRef;
  _weekNumberTemplateRef;
  _headerTitleTemplateRef;
  _headerTemplateRef;
  _footerTemplateRef;
  _navigationItemTemplateRef;
  get activeViewEnum() {
    const activeView = CalendarViewEnum[this.activeView];
    return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;
  }
  get bottomViewEnum() {
    return CalendarViewEnum[this.bottomView];
  }
  get topViewEnum() {
    return CalendarViewEnum[this.topView];
  }
  get widgetId() {
    return this.id;
  }
  get ariaDisabled() {
    return this.type === "classic" ? void 0 : this.disabled;
  }
  domEvents = [];
  control;
  pageChangeSubscription;
  resolvedPromise = Promise.resolve(null);
  destroyed = false;
  localizationChangeSubscription;
  activeViewDate;
  currentlyFocusedElement;
  canHover = false;
  constructor(bus, dom, element, navigator2, renderer, cdr, ngZone, injector, scrollSyncService, disabledDatesService, localization, selectionService, pickerService) {
    this.bus = bus;
    this.dom = dom;
    this.element = element;
    this.navigator = navigator2;
    this.renderer = renderer;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
    this.scrollSyncService = scrollSyncService;
    this.disabledDatesService = disabledDatesService;
    this.localization = localization;
    this.selectionService = selectionService;
    this.pickerService = pickerService;
    validatePackage(packageMetadata);
    this.id = `kendo-calendarid-${this.bus.calendarId}`;
    if (this.pickerService) {
      this.pickerService.calendar = this;
    }
  }
  ngOnInit() {
    this.setClasses(this.element.nativeElement);
    if (this.type === "infinite") {
      this.dom.calculateHeights(this.element.nativeElement);
      this.scrollSyncService.configure(this.activeViewEnum);
    }
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.viewChangeSubscription = this.bus.viewChanged.subscribe(({
      view: view2
    }) => this.handleActiveViewChange(CalendarViewEnum[view2]));
    this.control = this.injector.get(NgControl, null);
    if (this.element) {
      this.ngZone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnChanges(changes) {
    this.changes = changes;
    this.verifyChanges();
    this.bus.configure(this.bottomViewEnum, this.topViewEnum);
    this.scrollSyncService.configure(this.activeViewEnum);
  }
  ngDoCheck() {
    if (this.valueSetter || this.selectionSetter) {
      if (this.selection === "range" && (this.value?.start || this.value?.end) && this.focusedDate.getTime() !== this.value.start?.getTime() && this.focusedDate.getTime() !== this.value.end?.getTime()) {
        this.focusedDate = this.value.start || this.value.end || getToday();
      }
      this.setValue(this.value);
      this.valueSetter = false;
      this.selectionSetter = false;
    }
    if (hasExistingValue(this.changes, "focusedDate")) {
      const focusedDate = this.changes.focusedDate.currentValue;
      this.focusedDate = dateInRange(focusedDate, this.min, this.max);
    }
    if (this.changes.navigation) {
      this.syncNavigation = true;
    }
    if (this.changes.min || this.changes.max || this.changes.rangeValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.onValidatorChange();
    }
    this.changes = {};
  }
  ngAfterViewInit() {
    this.setAriaActivedescendant();
    if (this.size !== "none") {
      const element = this.type === "infinite" ? this.element : this.multiViewCalendar.element;
      this.renderer.removeClass(element.nativeElement, getSizeClass("calendar", this.size));
      this.renderer.addClass(element.nativeElement, getSizeClass("calendar", this.size));
    }
  }
  ngAfterViewChecked() {
    if (!this.syncNavigation) {
      return;
    }
    this.syncNavigation = false;
    this.scrollSyncService.sync(virtualizationProp(this.navigationView), virtualizationProp(this.monthView));
  }
  ngOnDestroy() {
    this.scrollSyncService.destroy();
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    if (this.pickerService) {
      this.pickerService.calendar = null;
    }
    if (this.viewChangeSubscription) {
      this.viewChangeSubscription.unsubscribe();
    }
    if (this.pageChangeSubscription) {
      this.pageChangeSubscription.unsubscribe();
    }
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    this.destroyed = true;
  }
  /**
   * @hidden
   */
  onCellEnter(date) {
    if (this.selection === "range" && this.canHover) {
      this.ngZone.run(() => {
        if (this.allowReverse) {
          if (this.activeRangeEnd === "end" && this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: date
            };
          }
          if (this.activeRangeEnd === "start" && this.selectionRange.end) {
            this.selectionRange = {
              start: date,
              end: this.selectionRange.end
            };
          }
        } else {
          if (this.activeRangeEnd === "end" && this.selectionRange.start && date >= this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: date
            };
          }
          if (this.selectionRange.start && date < this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: null
            };
          }
        }
      });
    }
  }
  /**
   * @hidden
   */
  onResize() {
    this.focusedDate = new Date(this.focusedDate);
    this.cdr.detectChanges();
  }
  /**
   * Focuses the Calendar by making the table.k-calendar-table element active.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="calendar.focus()">Focus calendar</button>
   *  <kendo-calendar #calendar></kendo-calendar>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    this.currentlyFocusedElement = this.type === "infinite" ? this.element?.nativeElement.querySelector(selectors.infiniteCalendarTable) : this.currentlyFocusedElement = this.element?.nativeElement.querySelector(selectors.multiViewCalendarTable);
    this.currentlyFocusedElement?.focus();
  }
  /**
   * Blurs the Calendar component.
   */
  blur() {
    const blurTarget = this.type === "infinite" ? this.currentlyFocusedElement : this.multiViewCalendar;
    if (isPresent2(blurTarget)) {
      blurTarget.blur();
    }
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.element.nativeElement));
  }
  /**
   * @hidden
   */
  handleNavigation(candidate) {
    if (this.disabled) {
      return;
    }
    const focusTarget = candidate ? new Date(cloneDate(candidate).setDate(1)) : this.focusedDate;
    this.focusedDate = dateInRange(focusTarget, this.min, this.max);
    this.detectChanges();
  }
  /**
   * @hidden
   */
  onPageChange() {
    if (!NgZone.isInAngularZone()) {
      if (this.pageChangeSubscription) {
        this.pageChangeSubscription.unsubscribe();
      }
      this.pageChangeSubscription = from(this.resolvedPromise).subscribe(() => {
        this.detectChanges();
      });
    }
  }
  /**
   * @hidden
   */
  handleMultiViewCalendarValueChange(value2, focusedDate) {
    if (this.selection === "range") {
      this.valueChange.emit(value2);
    } else {
      const selectedDates = Array.isArray(value2) ? value2 : [value2];
      this.handleDateChange({
        selectedDates,
        focusedDate
      });
    }
  }
  /**
   * @hidden
   */
  handleDateChange(args) {
    const selectedDates = Array.isArray(args.selectedDates) ? args.selectedDates : [args.selectedDates];
    const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);
    const availableDates = selectedDates.filter((date) => !this.disabledDatesService.isDateDisabled(date));
    this.focusedDate = args.focusedDate || this.focusedDate;
    if (this.disabled) {
      return;
    }
    if (!canNavigateDown && areDatesEqual(availableDates, this.selectedDates)) {
      this.emitSameDate();
      return;
    }
    if (canNavigateDown) {
      this.bus.moveDown(this.activeViewEnum);
      return;
    }
    if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {
      return;
    }
    if (this.selection === "range") {
      return;
    }
    this.ngZone.run(() => {
      this.selectedDates = availableDates.map((date) => cloneDate(date));
      this.value = this.parseSelectionToValue(availableDates);
      this.onControlChange(this.parseSelectionToValue(availableDates));
      this.valueChange.emit(this.parseSelectionToValue(availableDates));
      this.cdr.markForCheck();
    });
  }
  /**
   * @hidden
   */
  writeValue(candidate) {
    this.verifyValue(candidate);
    this.value = candidate;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  activeCellTemplate() {
    switch (this.activeViewEnum) {
      case CalendarViewEnum.month:
        return this.monthCellTemplateRef || this.cellTemplateRef;
      case CalendarViewEnum.year:
        return this.yearCellTemplateRef;
      case CalendarViewEnum.decade:
        return this.decadeCellTemplateRef;
      case CalendarViewEnum.century:
        return this.centuryCellTemplateRef;
      default:
        return null;
    }
  }
  /**
   * @hidden
   */
  handleNavigate(event2) {
    this.focusedDate = event2.focusedDate;
    this.activeView = event2.activeView;
    this.emitNavigate(this.focusedDate);
  }
  /**
   * @hidden
   */
  emitNavigate(focusedDate) {
    const activeView = CalendarViewEnum[this.activeViewEnum];
    this.navigate.emit({
      activeView,
      focusedDate
    });
  }
  /**
   * @hidden
   */
  emitEvent(emitter, args) {
    if (hasObservers(emitter)) {
      this.ngZone.run(() => {
        emitter.emit(args);
      });
    }
  }
  /**
   * @hidden
   */
  handleActiveDateChange(date) {
    this.activeViewDate = date;
    this.emitEvent(this.activeViewDateChange, date);
  }
  /**
   * @hidden
   */
  handleActiveViewChange(view2) {
    this.activeView = view2;
    this.emitEvent(this.activeViewChange, view2);
    if (this.type === "infinite") {
      this.scrollSyncService.configure(this.activeViewEnum);
    }
    this.detectChanges();
  }
  /**
   * @hidden
   */
  handleCellClick({
    date,
    modifiers
  }) {
    this.focus();
    if (this.selection === "range" && this.activeViewEnum === CalendarViewEnum[this.bottomView]) {
      this.performRangeSelection(date);
    } else {
      this.selectionService.lastClicked = date;
      this.performSelection(date, modifiers);
    }
  }
  /**
   * @hidden
   */
  handleWeekNumberClick(dates) {
    if (this.selection === "single") {
      return;
    }
    this.ngZone.run(() => {
      if (this.selection === "multiple") {
        this.handleDateChange({
          selectedDates: dates,
          focusedDate: last(dates)
        });
      }
      if (this.selection === "range") {
        this.canHover = false;
        this.activeRangeEnd = "start";
        const shouldEmitValueChange = this.selectionRange.start?.getTime() !== dates[0].getTime() || this.selectionRange.end?.getTime() !== last(dates).getTime();
        this.value = {
          start: dates[0],
          end: last(dates)
        };
        if (shouldEmitValueChange) {
          this.valueChange.emit(this.value);
        }
      }
    });
  }
  /**
   * @hidden
   */
  handleBlur(args) {
    if (this.element.nativeElement.contains(args.relatedTarget)) {
      return;
    }
    this.isActive = false;
    if (!this.pickerService && requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.onControlTouched();
        this.emitBlur(args);
        this.cdr.markForCheck();
      });
    } else {
      this.emitBlur(args);
      this.detectChanges();
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.isActive = true;
    if (!NgZone.isInAngularZone()) {
      this.detectChanges();
    }
    this.emitFocus();
  }
  /**
   * @hidden
   */
  handleMultiViewCalendarKeydown(args) {
    if (isPresent2(this.pickerService) && args.keyCode === Keys.Enter) {
      args.preventDefault();
    }
  }
  setClasses(element) {
    this.renderer.removeClass(element, `k-calendar-${this.type}`);
    if (this.type === "infinite") {
      this.renderer.addClass(element, "k-calendar");
      this.renderer.addClass(element, `k-calendar-${this.type}`);
    }
  }
  verifyChanges() {
    if (!isDevMode()) {
      return;
    }
    if (this.min > this.max) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$2} and ${MAX_DOC_LINK$2}.`);
    }
    if (this.bottomViewEnum > this.topViewEnum) {
      throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK} and ${TOP_VIEW_DOC_LINK}.`);
    }
  }
  verifyValue(candidate) {
    if (!isDevMode()) {
      return;
    }
    if (this.selection === "single" && candidate && !isNullOrDate(candidate)) {
      throw new Error(`When using 'single' selection the 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
    } else if (this.selection === "multiple" && candidate) {
      if (Array.isArray(candidate)) {
        const onlyDates = candidate.every((value2) => value2 instanceof Date);
        if (!onlyDates) {
          throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
        }
      }
      if (Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
        throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
      }
    } else if (this.selection === "range" && candidate && !(isNullOrDate(candidate["start"]) && isNullOrDate(candidate["end"]))) {
      throw new Error(`The 'value' should be an object with start and end dates. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
    }
  }
  bindEvents() {
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "focus", this.handleFocus.bind(this)), this.renderer.listen(element, "mousedown", preventDefault), this.renderer.listen(element, "click", this.handleComponentClick.bind(this)), this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)), this.renderer.listen(element, "mouseleave", this.setRangeSelectionToValue.bind(this)));
  }
  setRangeSelectionToValue() {
    if (this.selection === "range" && this.type === "infinite" && this.value) {
      this.ngZone.run(() => {
        this.selectionRange = this.value;
        this.cdr.markForCheck();
      });
    }
  }
  emitBlur(args) {
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
    this.onBlur.emit();
  }
  emitFocus() {
    if (this.pickerService) {
      this.pickerService.onFocus.emit();
    }
    this.onFocus.emit();
  }
  handleComponentClick() {
    if (!this.isActive) {
      if (this.type === "infinite" && this.monthView.isScrolled()) {
        this.focusedDate = cloneDate(this.focusedDate);
        this.detectChanges();
      }
      this.focus();
    }
  }
  handleKeydown(args) {
    if (this.type === "infinite") {
      const ctrlKey = args.ctrlKey || args.metaKey;
      const arrowKeyPressed = [Keys.ArrowUp, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowLeft].indexOf(args.keyCode) !== -1;
      const reserveKeyCommandsForPicker = isPresent2(this.pickerService) && arrowKeyPressed && args.altKey;
      if (reserveKeyCommandsForPicker) {
        return;
      }
      if (ctrlKey && arrowKeyPressed) {
        args.preventDefault();
      }
      const preventSubmitInDatePicker = isPresent2(this.pickerService) && args.keyCode === Keys.Enter;
      if (preventSubmitInDatePicker) {
        args.preventDefault();
      }
      const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(args), this.activeViewEnum), this.min, this.max);
      if (!isEqual(this.focusedDate, candidate)) {
        this.focusedDate = candidate;
        this.detectChanges();
        args.preventDefault();
      }
      if (args.keyCode === Keys.Enter) {
        this.selectionService.lastClicked = this.focusedDate;
        if (this.selection !== "range") {
          this.performSelection(this.focusedDate, args);
        } else {
          this.performRangeSelection(this.focusedDate);
        }
      }
      if (args.keyCode === Keys.KeyT) {
        this.focusToday();
      }
      if (isArrowWithShiftPressed(args) && this.selection !== "range") {
        args.anyArrow = true;
        this.performSelection(this.focusedDate, args);
      }
    }
  }
  focusToday() {
    this.focusedDate = getToday();
    this.bus.moveToBottom(this.activeViewEnum);
    this.cdr.detectChanges();
  }
  detectChanges() {
    if (!this.destroyed) {
      this.cdr.detectChanges();
    }
  }
  emitSameDate() {
    if (this.pickerService) {
      this.pickerService.sameDateSelected.emit();
    }
  }
  setAriaActivedescendant() {
    const infiniteCalendarTable = this.element.nativeElement?.querySelector(selectors.infiniteCalendarTable);
    const activedescendantHandledByInnerMultiViewCalendar = !isPresent2(infiniteCalendarTable) || this.type === "classic" && !infiniteCalendarTable.hasAttribute(attributeNames.ariaActiveDescendant);
    if (activedescendantHandledByInnerMultiViewCalendar) {
      return;
    }
    if (this.type === "classic") {
      this.renderer.removeAttribute(infiniteCalendarTable, attributeNames.ariaActiveDescendant);
      return;
    }
    const focusedCellId = this.cellUID + this.focusedDate.getTime();
    this.renderer.setAttribute(infiniteCalendarTable, attributeNames.ariaActiveDescendant, focusedCellId);
  }
  parseSelectionToValue(selection) {
    selection = selection || [];
    return this.selection === "single" ? cloneDate(last(selection)) : selection.map((date) => cloneDate(date));
  }
  setValue(candidate) {
    this.verifyValue(candidate);
    if (candidate === null) {
      this._value = null;
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
    } else if (Array.isArray(candidate)) {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = candidate.filter((date) => isPresent2(date)).map((element) => cloneDate(element));
    } else if (isObject(candidate) && Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = {
        start: null,
        end: null
      };
      this._value.start = candidate.start instanceof Date ? cloneDate(candidate.start) : null;
      this._value.end = candidate.end instanceof Date ? cloneDate(candidate.end) : null;
      this.selectionRange = Object.assign({}, this._value);
      if (this._value?.start && !this._value?.end) {
        this.activeRangeEnd = "end";
        this.canHover = true;
      }
      if (this._value?.end && !this._value?.start) {
        this.activeRangeEnd = "start";
        this.canHover = true;
      }
      if (this._value?.end && this._value?.start) {
        this.canHover = false;
      }
    } else {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = cloneDate(candidate);
    }
    if (this.selection !== "range") {
      const selection = [].concat(candidate).filter((date) => isPresent2(date)).map((date) => cloneDate(date));
      if (!areDatesEqual(selection, this.selectedDates)) {
        const lastSelected = last(selection);
        this.rangePivot = cloneDate(lastSelected);
        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;
        this.selectedDates = selection;
      }
    }
  }
  performRangeSelection(date) {
    this.focusedDate = date;
    const clonedRangeSelection = Object.assign({}, this.selectionRange);
    const emitValueChange = this.activeRangeEnd === "start" && this.value?.start?.getTime() !== date?.getTime() || this.activeRangeEnd === "end" && this.value?.end?.getTime() !== date?.getTime();
    this.ngZone.run(() => {
      const rangeSelection = handleRangeSelection(date, clonedRangeSelection, this.activeRangeEnd, this.allowReverse);
      this.activeRangeEnd = rangeSelection.activeRangeEnd;
      if (this.canHover && rangeSelection.activeRangeEnd === "end" && rangeSelection.selectionRange.end?.getTime() === date.getTime()) {
        this.activeRangeEnd = "start";
        rangeSelection.activeRangeEnd = "start";
      }
      this.canHover = this.activeRangeEnd === "end" && rangeSelection.selectionRange.start && !rangeSelection.selectionRange.end;
      if (emitValueChange && (this.value?.start?.getTime() !== rangeSelection.selectionRange?.start?.getTime() || this.value?.end?.getTime() !== rangeSelection.selectionRange?.end?.getTime())) {
        this.value = rangeSelection.selectionRange;
        this.valueChange.emit(this.value);
      }
      this.cdr.markForCheck();
    });
  }
  performSelection(date, selectionModifiers) {
    const selection = this.selectionService.performSelection({
      date,
      modifiers: selectionModifiers,
      selectionMode: this.selection,
      activeViewEnum: this.activeViewEnum,
      rangePivot: this.rangePivot,
      selectedDates: this.selectedDates
    });
    this.rangePivot = selection.rangePivot;
    this.handleDateChange({
      selectedDates: selection.selectedDates,
      focusedDate: date
    });
  }
  static ɵfac = function CalendarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ScrollSyncService), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CalendarComponent,
    selectors: [["kendo-calendar"]],
    contentQueries: function CalendarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);
      }
    },
    viewQuery: function CalendarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(NavigationComponent, 5);
        ɵɵviewQuery(ViewListComponent, 5);
        ɵɵviewQuery(MultiViewCalendarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationView = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthView = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiViewCalendar = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function CalendarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.widgetId)("aria-disabled", ctx.ariaDisabled);
        ɵɵclassProp("k-week-number", ctx.weekNumber)("k-disabled", ctx.ariaDisabled);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      id: "id",
      focusedDate: "focusedDate",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      weekDaysFormat: "weekDaysFormat",
      footer: "footer",
      selection: "selection",
      allowReverse: "allowReverse",
      value: "value",
      disabled: "disabled",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      disabledDates: "disabledDates",
      navigation: "navigation",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      type: "type",
      animateNavigation: "animateNavigation",
      weekNumber: "weekNumber",
      cellTemplateRef: [0, "cellTemplate", "cellTemplateRef"],
      monthCellTemplateRef: [0, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [0, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [0, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [0, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [0, "weekNumberTemplate", "weekNumberTemplateRef"],
      headerTitleTemplateRef: [0, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [0, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [0, "footerTemplate", "footerTemplateRef"],
      navigationItemTemplateRef: [0, "navigationItemTemplate", "navigationItemTemplateRef"],
      size: "size",
      activeRangeEnd: "activeRangeEnd"
    },
    outputs: {
      activeViewChange: "activeViewChange",
      navigate: "navigate",
      activeViewDateChange: "activeViewDateChange",
      onBlur: "blur",
      onFocus: "focus",
      valueChange: "valueChange"
    },
    exportAs: ["kendo-calendar"],
    features: [ɵɵProvidersFeature([BusViewService, CALENDAR_VALUE_ACCESSOR, CALENDAR_RANGE_VALIDATORS, KENDO_INPUT_PROVIDER, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.calendar"
    }, NavigationService, ScrollSyncService, SelectionService]), ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 2,
    consts: () => {
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_4 = goog.getMsg("Today");
        i18n_4 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.calendar.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_5 = goog.getMsg("Navigate to previous view");
        i18n_5 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_6 = goog.getMsg("Navigate to next view");
        i18n_6 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_7 = goog.getMsg("Navigate to parent view");
        i18n_7 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.calendar.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      return [["multiviewcalendar", ""], ["kendoCalendarLocalizedMessages", "", "today", i18n_4, "prevButtonTitle", i18n_5, "nextButtonTitle", i18n_6, "parentViewButtonTitle", i18n_7], [4, "ngIf"], [3, "activeView", "focusedDate", "min", "max", "templateRef", "valueChange", "pageChange", 4, "ngIf"], [3, "todayButtonClick", "cellClick", "weekNumberCellClick", "activeDateChange", "pageChange", "focusCalendar", "blurCalendar", "cellEnter", "activeView", "allowReverse", "showOtherMonthDays", "activeRangeEnd", "selectionRange", "size", "isActive", "id", "weekDaysFormat", "cellTemplateRef", "headerTitleTemplateRef", "headerTemplateRef", "showFooter", "footerTemplateRef", "weekNumberTemplateRef", "cellUID", "min", "max", "focusedDate", "weekNumber", "selectedDates", "tabIndex", "disabled"], [3, "resize"], [3, "valueChange", "pageChange", "activeView", "focusedDate", "min", "max", "templateRef"], [3, "activeViewChange", "navigate", "valueChange", "focusCalendar", "blur", "blurEvent", "keydown", "views", "min", "max", "size", "id", "activeRangeEnd", "selectionRange", "allowReverse", "disabled", "isActive", "showOtherMonthDays", "tabIndex", "activeView", "bottomView", "topView", "weekDaysFormat", "weekNumber", "animateNavigation", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "weekNumberTemplate", "focusedDate", "selection", "value", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"]];
    },
    template: function CalendarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 1);
        ɵɵtemplate(1, CalendarComponent_ng_container_1_Template, 4, 24, "ng-container", 2)(2, CalendarComponent_ng_container_2_Template, 4, 36, "ng-container", 2);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "infinite");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "classic");
      }
    },
    dependencies: [CalendarLocalizedMessagesDirective, NgIf, NavigationComponent, ViewListComponent, ResizeSensorComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-calendar",
      providers: [BusViewService, CALENDAR_VALUE_ACCESSOR, CALENDAR_RANGE_VALIDATORS, KENDO_INPUT_PROVIDER, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.calendar"
      }, NavigationService, ScrollSyncService, SelectionService],
      selector: "kendo-calendar",
      template: `
    <ng-container kendoCalendarLocalizedMessages
        i18n-today="kendo.calendar.today|The label for the today button in the calendar header"
        today="Today"

        i18n-prevButtonTitle="kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar"
        prevButtonTitle="Navigate to previous view"

        i18n-nextButtonTitle="kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar"
        nextButtonTitle="Navigate to next view"

        i18n-parentViewButtonTitle="kendo.calendar.parentViewButtonTitle|The title of the parent view button in the calendar header"
        parentViewButtonTitle="Navigate to parent view"
    >
    </ng-container>
    <ng-container *ngIf="type === 'infinite'">
        <kendo-calendar-navigation
            *ngIf="navigation"
            [activeView]="activeViewEnum"
            [focusedDate]="focusedDate"
            [min]="min"
            [max]="max"
            [templateRef]="navigationItemTemplateRef?.templateRef"
            (valueChange)="handleNavigation($event)"
            (pageChange)="onPageChange()"
        >
        </kendo-calendar-navigation>
        <kendo-calendar-viewlist
            [activeView]="activeViewEnum"
            [allowReverse]="allowReverse"
            [showOtherMonthDays]="showOtherMonthDays"
            [activeRangeEnd]="activeRangeEnd"
            [selectionRange]="selectionRange"
            [size]="size"
            [isActive]="isActive"
            [id]="headerId"
            [weekDaysFormat]="weekDaysFormat"
            [cellTemplateRef]="activeCellTemplate()?.templateRef"
            [headerTitleTemplateRef]="headerTitleTemplateRef?.templateRef"
            [headerTemplateRef]="headerTemplateRef?.templateRef"
            [showFooter]="footer"
            [footerTemplateRef]="footerTemplateRef?.templateRef"
            [weekNumberTemplateRef]="weekNumberTemplateRef?.templateRef"
            [cellUID]="cellUID"
            [min]="min"
            [max]="max"
            [focusedDate]="focusedDate"
            [weekNumber]="weekNumber"
            [selectedDates]="selectedDates"
            [tabIndex]="tabIndex"
            [disabled]="disabled"
            (todayButtonClick)="handleDateChange({
                selectedDates: [$event],
                focusedDate: $event
            })"
            (cellClick)="handleCellClick($event)"
            (weekNumberCellClick)="handleWeekNumberClick($event)"
            (activeDateChange)="handleActiveDateChange($event)"
            (pageChange)="onPageChange()"
            (focusCalendar)="handleFocus()"
            (blurCalendar)="handleBlur($event)"
            (cellEnter)="onCellEnter($event)"
        >
        </kendo-calendar-viewlist>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
    </ng-container>
    <ng-container *ngIf="type === 'classic'">
        <kendo-multiviewcalendar
            #multiviewcalendar
            [views]="1"
            [min]="min"
            [max]="max"
            [size]="size"
            [id]="id"
            [activeRangeEnd]="activeRangeEnd"
            [selectionRange]="selectionRange"
            [allowReverse]="allowReverse"
            [disabled]="disabled"
            [isActive]="isActive"
            [showOtherMonthDays]="showOtherMonthDays"
            [tabIndex]="tabIndex"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [weekDaysFormat]="weekDaysFormat"
            [weekNumber]="weekNumber"
            [animateNavigation]="animateNavigation"
            [cellTemplate]="activeCellTemplate()"
            [monthCellTemplate]="monthCellTemplateRef"
            [yearCellTemplate]="yearCellTemplateRef"
            [decadeCellTemplate]="decadeCellTemplateRef"
            [centuryCellTemplate]="centuryCellTemplateRef"
            [headerTitleTemplate]="headerTitleTemplateRef"
            [headerTemplate]="headerTemplateRef"
            [footerTemplate]="footerTemplateRef"
            [footer]="footer"
            [weekNumberTemplate]="weekNumberTemplateRef"
            [focusedDate]="focusedDate"
            [selection]="selection"
            [value]="value"
            [disabledDates]="disabledDates"
            (activeViewChange)="handleActiveViewChange($event)"
            (navigate)="handleNavigate($event)"
            (valueChange)="handleMultiViewCalendarValueChange($event, multiviewcalendar.focusedDate)"
            (focusCalendar)="handleFocus()"
            (blur)="handleBlur($event)"
            (blurEvent)="handleBlur($event)"
            (keydown)="handleMultiViewCalendarKeydown($event)"
        >
            <kendo-multiviewcalendar-messages
                [today]="localization.get('today')"
                [prevButtonTitle]="localization.get('prevButtonTitle')"
                [nextButtonTitle]="localization.get('nextButtonTitle')"
                [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
            >
            </kendo-multiviewcalendar-messages>
        </kendo-multiviewcalendar>
    </ng-container>
  `,
      standalone: true,
      imports: [CalendarLocalizedMessagesDirective, NgIf, NavigationComponent, ViewListComponent, ResizeSensorComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: CalendarDOMService
    }, {
      type: ElementRef
    }, {
      type: NavigationService
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: ScrollSyncService
    }, {
      type: DisabledDatesService
    }, {
      type: LocalizationService
    }, {
      type: SelectionService
    }, {
      type: PickerService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showOtherMonthDays: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    navigation: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-week-number"]
    }],
    activeViewChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    activeViewDateChange: [{
      type: Output
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    valueChange: [{
      type: Output
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    navigationItemTemplate: [{
      type: ContentChild,
      args: [NavigationItemTemplateDirective, {
        static: false
      }]
    }],
    navigationItemTemplateRef: [{
      type: Input,
      args: ["navigationItemTemplate"]
    }],
    size: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    navigationView: [{
      type: ViewChild,
      args: [NavigationComponent, {
        static: false
      }]
    }],
    monthView: [{
      type: ViewChild,
      args: [ViewListComponent, {
        static: false
      }]
    }],
    multiViewCalendar: [{
      type: ViewChild,
      args: [MultiViewCalendarComponent, {
        static: false
      }]
    }],
    widgetId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var incompleteDateValidator = () => {
  return (control, incomplete) => {
    if (!isPresent2(control.value) && incomplete) {
      return {
        incompleteDate: true
      };
    } else {
      return null;
    }
  };
};
var Arrow;
(function(Arrow2) {
  Arrow2[Arrow2["Up"] = 0] = "Up";
  Arrow2[Arrow2["Down"] = 1] = "Down";
  Arrow2[Arrow2["None"] = 2] = "None";
})(Arrow || (Arrow = {}));
var DateInputMessages = class _DateInputMessages extends ComponentMessages {
  /**
   * The title of the **Decrement** button of the DateInput.
   */
  decrement;
  /**
   * The title of the **Increment** button of the DateInput.
   */
  increment;
  /**
   * The title of the **Clear** button of the DateInput.
   */
  clearTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateInputMessages_BaseFactory;
    return function DateInputMessages_Factory(__ngFactoryType__) {
      return (ɵDateInputMessages_BaseFactory || (ɵDateInputMessages_BaseFactory = ɵɵgetInheritedFactory(_DateInputMessages)))(__ngFactoryType__ || _DateInputMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateInputMessages,
    selectors: [["kendo-dateinput-messages-base"]],
    inputs: {
      decrement: "decrement",
      increment: "increment",
      clearTitle: "clearTitle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-dateinput-messages-base"
    }]
  }], null, {
    decrement: [{
      type: Input
    }],
    increment: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }]
  });
})();
var DateInputLocalizedMessagesDirective = class _DateInputLocalizedMessagesDirective extends DateInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DateInputLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateInputLocalizedMessagesDirective,
    selectors: [["", "kendoDateInputLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: DateInputMessages,
      useExisting: forwardRef(() => _DateInputLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateInputMessages,
        useExisting: forwardRef(() => DateInputLocalizedMessagesDirective)
      }],
      selector: "[kendoDateInputLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var nextId = 0;
var MIN_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min";
var MAX_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max";
var VALUE_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json";
var TWO_DIGIT_YEAR_MAX$2 = 68;
var DEFAULT_FORMAT$1 = "d";
var DEFAULT_FORMAT_PLACEHOLDER = "wide";
var DATE_PART_REGEXP = /year|month|<day>/;
var TIME_PART_REGEXP = /hour|minute|second|millisecond/;
var DateInputIntl = class {
  service;
  format;
  toString;
  formatDate;
  parseDate;
  parseNumber;
  formatNumber;
  splitDateFormat;
  numberSymbols;
  firstDay;
  weekendRange;
  dateFieldName;
  dateFormatNames;
  cldr = {};
  localeId;
  constructor(service) {
    this.service = service;
    this.localeId = service["localeId"];
    this.format = service.format;
    this.toString = service.toString;
    this.formatDate = service.formatDate;
    this.parseDate = service.parseDate;
    this.parseNumber = service.parseNumber;
    this.formatNumber = service.formatNumber;
    this.splitDateFormat = service.splitDateFormat;
    this.numberSymbols = service.numberSymbols;
    this.firstDay = service.firstDay;
    this.weekendRange = service.weekendRange;
    this.dateFieldName = service.dateFieldName;
    this.dateFormatNames = (localeId, options) => this.service.dateFormatNames(options, localeId || this.localeId);
    const _localeData = localeData(this.localeId);
    this.cldr[_localeData.name] = _localeData;
  }
};
var DateInputComponent = class _DateInputComponent {
  cdr;
  intl;
  renderer;
  wrapper;
  ngZone;
  injector;
  localization;
  pickerService;
  /**
   * @hidden
   */
  caretAltUpIcon = caretAltUpIcon;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  set focusableId(_focusableId) {
    if (_focusableId) {
      this._focusableId = _focusableId;
    }
  }
  get focusableId() {
    return this._focusableId;
  }
  /**
   * @hidden
   */
  set pickerType(_pickerType) {
    if (_pickerType) {
      this.focusableId = `${_pickerType}-${nextId}`;
    }
  }
  /**
   * If set to `true`, renders a clear button after the input text or DateInput value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Sets or gets the `disabled` property of the DateInput and
   * determines whether the component is active
   * ([see example]({% slug disabled_dateinput %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_dateinput#toc-managing-the-dateinput-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets or gets the read-only state of the DateInput
   * ([see example]({% slug readonly_dateinput %})).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the title of the input element of the DateInput.
   */
  title = "";
  /**
   * Sets or gets the `tabIndex` property of the DateInput.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  role = "textbox";
  /**
   * @hidden
   */
  ariaReadOnly = false;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * @hidden
   */
  isRequired = false;
  /**
   * Specifies the date format that is used to display the input value
   * ([see example]({% slug formats_dateinput %})).
   *
   * Format value options:
   * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
   * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
   */
  format = DEFAULT_FORMAT$1;
  /**
   * Defines the descriptions of the format sections in the input field.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_dateinput %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   * <div class="row example-wrapper" [style.min-height.px]="450">
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Full-length format description:</p>
   *    <kendo-dateinput formatPlaceholder="wide"></kendo-dateinput>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Narrow-length format description:</p>
   *    <kendo-dateinput formatPlaceholder="narrow"></kendo-dateinput>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Short-length format description:</p>
   *    <kendo-dateinput formatPlaceholder="short"></kendo-dateinput>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Display defined format:</p>
   *    <kendo-dateinput format="MM/dd/yyyy" formatPlaceholder="formatPattern"></kendo-dateinput>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Custom defined format descriptions</p>
   *    <kendo-dateinput format="G"
   *      [formatPlaceholder]="{
   *        year: 'y', month: 'M', day: 'd',
   *        hour: 'h', minute: 'm', second: 's'
   *      }"
   *    ></kendo-dateinput>
   *  </div>
   * </div>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  set formatPlaceholder(format) {
    this._formatPlaceholder = format ? format : DEFAULT_FORMAT_PLACEHOLDER;
  }
  get formatPlaceholder() {
    return this._formatPlaceholder;
  }
  /**
   * Specifies the hint the DateInput displays when its value is `null`.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_dateinput %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-dateinput placeholder="Enter birth date..."></kendo-dateinput>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  placeholder = null;
  /**
   * Configures the incremental steps of the DateInput.
   * For more information, refer to the article on
   * [incremental steps]({% slug incrementalsteps_dateinput %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-dateinput [steps]="steps"></kendo-dateinput>
   * `
   * })
   * export class AppComponent {
   *   public steps = { year: 10, month: 1, day: 5 };
   * }
   * ```
   */
  steps = {};
  /**
   * Specifies the biggest date that is valid
   * ([see example]({% slug dateranges_dateinput %})).
   * By default, the `max` value is `2099-12-31`.
   */
  max;
  /**
   * Specifies the smallest date that is valid
   * ([see example]({% slug dateranges_dateinput %})).
   * By default, the `min` value is `1900-1-1`.
   */
  min;
  /**
   * Determines whether the built-in min or max validators are to be enforced when a form is being validated.
   */
  rangeValidation = true;
  /**
   * Determines whether to autocorrect invalid segments automatically.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * When enabled, the DateInput will autofill the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   */
  incompleteDateValidation = false;
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_dateinput %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX$2;
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Specifies the value of the DateInput component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value2) {
    this.verifyValue(value2);
    this.showClearButton = value2 || !value2 && this.isDateIncomplete ? true : false;
    this._value = cloneDate(value2);
    this.valueUpdate.emit(cloneDate(value2));
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies whether the **Up** and **Down** spin buttons will be rendered.
   * For more information, refer to the article on
   * [spinner buttons]({% slug spinbuttons_dateinput %}).
   */
  spinners = false;
  /**
   * @hidden
   */
  isPopupOpen;
  /**
   * @hidden
   */
  hasPopup;
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    const newSize = size ? size : DEFAULT_SIZE;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `solid` (Default)
   * * `flat`
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      if (this.spinners && this.spinup && this.spindown) {
        this.setSpinnerFill(this.spinup.nativeElement, newFillMode, this.fillMode);
        this.setSpinnerFill(this.spindown.nativeElement, newFillMode, this.fillMode);
      }
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.dateInput.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_dateinput)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   * Fires each time the user selects a new value
   * ([see example](slug:events_dateinput)).
   */
  valueUpdate = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_dateinput)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_dateinput)).
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  dateInput;
  get wrapperClass() {
    return true;
  }
  get disabledClass() {
    return this.disabled;
  }
  get inputElement() {
    return this.dateInput ? this.dateInput.nativeElement : null;
  }
  get inputValue() {
    return (this.inputElement || {}).value || "";
  }
  get isActive() {
    return this._active;
  }
  set isActive(value2) {
    this._active = value2;
    if (!this.wrapper) {
      return;
    }
    if (!isPresent2(this.pickerService)) {
      const element = this.wrapper.nativeElement;
      if (value2) {
        this.renderer.addClass(element, "k-focus");
      } else {
        this.renderer.removeClass(element, "k-focus");
      }
    }
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  get options() {
    return {
      format: this.format,
      steps: this.steps,
      readonly: this.readonly,
      formatPlaceholder: this.formatPlaceholder,
      placeholder: this.placeholder,
      autoCorrectParts: this.autoCorrectParts,
      autoSwitchParts: this.autoSwitchParts,
      selectPreviousSegmentOnBackspace: true,
      autoSwitchKeys: this.autoSwitchKeys,
      twoDigitYearMax: this.twoDigitYearMax,
      enableMouseWheel: this.enableMouseWheel,
      selectNearestSegmentOnFocus: true,
      allowCaretMode: this.allowCaretMode,
      autoFill: this.autoFill,
      value: this.value,
      intlService: new DateInputIntl(this.intl)
    };
  }
  arrow = Arrow;
  arrowDirection = Arrow.None;
  formatSections = {
    date: false,
    time: false
  };
  hasMousedown = false;
  focusedPriorToMousedown = false;
  showClearButton = false;
  /**
   * @hidden
   */
  isDateIncomplete = false;
  currentFormat = "";
  spinup;
  spindown;
  minValidator = noop$2;
  maxValidator = noop$2;
  incompleteValidator = noop$2;
  _value = null;
  _active = false;
  _focusableId = `dateinput-${nextId++}`;
  _formatPlaceholder = DEFAULT_FORMAT_PLACEHOLDER;
  kendoDate = null;
  kendoDateObject = null;
  domEvents = [];
  ngControl;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  control;
  subs = new Subscription();
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      "aria-readonly": this.ariaReadOnly,
      id: this.focusableId,
      title: this.title,
      tabindex: this.tabindex,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      placeholder: this.placeholder,
      "aria-expanded": this.isPopupOpen,
      "aria-haspopup": this.hasPopup,
      required: this.isControlRequired ? "" : null
    };
  }
  get mutableAttributes() {
    return {
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      spellcheck: "false",
      role: this.role
    };
  }
  constructor(cdr, intl, renderer, wrapper, ngZone, injector, localization, pickerService) {
    this.cdr = cdr;
    this.intl = intl;
    this.renderer = renderer;
    this.wrapper = wrapper;
    this.ngZone = ngZone;
    this.injector = injector;
    this.localization = localization;
    this.pickerService = pickerService;
    validatePackage(packageMetadata);
    if (this.pickerService) {
      this.pickerService.input = this;
    } else {
      this.ariaReadOnly = null;
    }
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty
   */
  isEmpty() {
    const currentValue = this.dateInput.nativeElement.value;
    return !currentValue || !String(currentValue).trim();
  }
  /**
   * @hidden
   */
  handleDragAndDrop(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.wrapper.nativeElement));
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (this.kendoDate) {
      this.kendoDate.destroy();
    }
    this.kendoDate = this.initKendoDate();
    this.kendoDateObject = this.kendoDate.dateObject;
    this.updateFormatSections();
    this.subs.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.ngControl = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    this.verifyRange();
    if (anyChanged(["min", "max", "rangeValidation", "incompleteDateValidation"], changes, false)) {
      this.minValidator = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (changes["clearButton"]) {
      this.showClearButton = this.clearButton && (isPresent2(this.value) || this.isDateIncomplete);
    }
    const isEqualToKendoDate = this.kendoDate && isEqual(this.value, this.kendoDate.value);
    if (!isEqualToKendoDate) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate.writeValue(this.value);
    }
    if (changes["format"] || changes["placeholder"]) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate?.setOptions(this.options, true);
      this.updateFormatSections();
    }
    if (anyChanged(["enableMouseWheel", "autoFill", "autoSwitchParts", "autoSwitchKeys", "twoDigitYearMax", "allowCaretMode", "autoCorrectParts", "readonly", "steps", "formatPlaceholder"], changes)) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate?.setOptions(this.options, true);
    }
  }
  updateFormatSections() {
    this.formatSections = this.intl.splitDateFormat(this.kendoDate.inputFormat).reduce(({
      date,
      time
    }, p) => {
      return {
        date: date || DATE_PART_REGEXP.test(p.type),
        time: time || TIME_PART_REGEXP.test(p.type)
      };
    }, {
      date: false,
      time: false
    });
  }
  updateIncompleteValidationStatus() {
    const previousValue = this.isDateIncomplete;
    this.isDateIncomplete = this.kendoDateObject.hasValue() && this.value === null;
    if (previousValue === this.isDateIncomplete || !this.incompleteDateValidation) {
      return;
    }
    if (isPresent2(this.ngControl) && !isPresent2(this.pickerService)) {
      this.cdr.markForCheck();
      this.ngZone.run(() => this.onValidatorChange());
    } else if (isPresent2(this.pickerService)) {
      this.pickerService.dateCompletenessChange.emit();
    }
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    const formControl = this.injector.get(NgControl, null)?.control;
    this.control = formControl;
    this.subs.add(this.formControl?.statusChanges.subscribe(() => this.setAriaInvalid()));
    this.setAriaInvalid();
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    if (this.pickerService) {
      this.pickerService.input = null;
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  /**
   * @hidden
   */
  setAriaInvalid() {
    if (!this.control) {
      return;
    }
    if (this.control.invalid) {
      this.renderer.setAttribute(this.inputElement, attributeNames.ariaInvalid, "true");
    } else {
      this.renderer.setAttribute(this.inputElement, attributeNames.ariaInvalid, "false");
    }
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl) || this.isRequired;
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidator(control) || this.maxValidator(control) || this.incompleteValidator(control, this.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  //ngModel binding
  /**
   * @hidden
   */
  writeValue(value2) {
    this.verifyValue(value2);
    this.value = cloneDate(value2);
    this.kendoDate?.setOptions(this.options, true);
    this.kendoDateObject?.setValue(this.value);
    this.kendoDate?.refreshElementValue();
  }
  resetInput() {
    this.writeValue(null);
    this.notify();
    this.showClearButton = false;
  }
  /**
   * @hidden
   */
  triggerChange() {
    const value2 = this.kendoDate.value;
    const oneValuePresent = isPresent2(value2) !== isPresent2(this.value);
    if (+value2 !== +this.value || oneValuePresent) {
      this.value = cloneDate(value2);
      this.notify();
    }
  }
  /**
   * @hidden
   */
  notify() {
    this.ngZone.run(() => {
      this.showClearButton = this.value ? true : false;
      this.onControlChange(cloneDate(this.value));
      this.valueChange.emit(cloneDate(this.value));
    });
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * Focuses the DateInput component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="dateinput.focus()">Focus date input</button>
   *  <kendo-dateinput #dateinput></kendo-dateinput>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    this.kendoDate && this.kendoDate.focus();
  }
  /**
   * Blurs the DateInput component.
   */
  blur() {
    const input = this.inputElement;
    if (input) {
      input.blur();
    }
  }
  /**
   * @hidden
   */
  handleButtonClick(offset2) {
    this.showClearButton = true;
    this.arrowDirection = Arrow.None;
    if (!this.isActive) {
      this.kendoDate.focus();
    }
    this.kendoDate.modifyDateSegmentValue(offset2);
  }
  initKendoDate() {
    const kendoDate = new DateInput(this.dateInput.nativeElement, __spreadProps(__spreadValues({}, this.options), {
      events: {
        valueChange: this.onWidgetValueChange.bind(this),
        inputEnd: this.onWidgetInputEnd.bind(this),
        focusEnd: this.onWidgetFocus.bind(this),
        blurEnd: this.onWidgetBlur.bind(this),
        keydown: this.onWidgetKeyDown.bind(this)
      }
    }));
    return kendoDate;
  }
  onWidgetValueChange() {
    this.triggerChange();
  }
  onWidgetKeyDown() {
    this.kendoDateObject = this.kendoDate.dateObject;
  }
  onWidgetInputEnd() {
    this.updateIncompleteValidationStatus();
    if (this.clearButton) {
      this.showClearButton = this.value || this.isDateIncomplete ? true : false;
      this.cdr.markForCheck();
    }
  }
  onWidgetFocus({
    event: FocuseEvent
  }) {
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.ngZone.run(() => {
        this.emitFocus(event);
      });
    } else {
      this.emitFocus(event);
    }
  }
  onWidgetBlur({
    event: FocuseEvent
  }) {
    this.isActive = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.ngControl)) {
      this.ngZone.run(() => {
        this.onControlTouched();
        this.emitBlur(event);
        this.cdr.markForCheck();
      });
    } else {
      this.emitBlur(event);
    }
  }
  verifyRange() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$1} and ${MAX_DOC_LINK$1}.`);
    }
  }
  verifyValue(value2) {
    if (!isDevMode()) {
      return;
    }
    if (value2 && !(value2 instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$3} for possible resolution.`);
    }
  }
  intlChange() {
    this.kendoDate.setOptions(this.options, true);
    this.updateFormatSections();
  }
  emitFocus(args) {
    this.onFocus.emit();
    if (this.pickerService) {
      this.pickerService.onFocus.emit(args);
    }
  }
  emitBlur(args) {
    this.onBlur.emit();
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
  }
  setSpinnerFill(spinner, fill, oldFill) {
    if (oldFill !== "none") {
      this.renderer.removeClass(spinner, `k-button-${oldFill}`);
      this.renderer.removeClass(spinner, `k-button-${oldFill}-base`);
    }
    this.renderer.addClass(spinner, `k-button-${fill}`);
    this.renderer.addClass(spinner, `k-button-${fill}-base`);
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
    if (this.spinners && this.fillMode !== "none") {
      this.setSpinnerFill(this.spinup.nativeElement, this.fillMode);
      this.setSpinnerFill(this.spindown.nativeElement, this.fillMode);
    }
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.dateInput.nativeElement, this.ngZone);
  }
  static ɵfac = function DateInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateInputComponent,
    selectors: [["kendo-dateinput"]],
    viewQuery: function DateInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c10, 7);
        ɵɵviewQuery(_c11, 5);
        ɵɵviewQuery(_c12, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.spinup = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.spindown = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DateInputComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-input", ctx.wrapperClass)("k-dateinput", ctx.wrapperClass)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      pickerType: "pickerType",
      clearButton: "clearButton",
      disabled: "disabled",
      readonly: "readonly",
      title: "title",
      tabindex: "tabindex",
      role: "role",
      ariaReadOnly: "ariaReadOnly",
      tabIndex: "tabIndex",
      isRequired: "isRequired",
      format: "format",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      steps: "steps",
      max: "max",
      min: "min",
      rangeValidation: "rangeValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      allowCaretMode: "allowCaretMode",
      autoFill: "autoFill",
      incompleteDateValidation: "incompleteDateValidation",
      twoDigitYearMax: "twoDigitYearMax",
      enableMouseWheel: "enableMouseWheel",
      value: "value",
      spinners: "spinners",
      isPopupOpen: "isPopupOpen",
      hasPopup: "hasPopup",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      valueUpdate: "valueUpdate",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendo-dateinput"],
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DateInputComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DateInputComponent),
      multi: true
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.dateinput"
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DateInputComponent)
    }, LocalizationService]), ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 18,
    consts: () => {
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_8 = goog.getMsg("Increase value");
        i18n_8 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.dateinput.increment|The label for the **Increment** button in the DateInput:Increase value`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_9 = goog.getMsg("Decrease value");
        i18n_9 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput:Decrease value`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_10 = goog.getMsg("clear");
        i18n_10 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.dateinput.clearTitle|The title of the clear button:clear`;
      }
      return [["dateInput", ""], ["spinup", ""], ["spindown", ""], ["kendoDateInputLocalizedMessages", "", "increment", i18n_8, "decrement", i18n_9, "clearTitle", i18n_10], ["autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-input-inner", 3, "id", "title", "tabindex", "disabled", "readonly", "placeholder", "kendoEventsOutsideAngular", "scope"], ["class", "k-clear-value", "role", "button", "tabindex", "-1", 3, "click", "mousedown", 4, "ngIf"], ["class", "k-input-spinner k-spin-button", 3, "mousedown", 4, "ngIf"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "click", "mousedown"], ["name", "x", 3, "svgIcon"], [1, "k-input-spinner", "k-spin-button", 3, "mousedown"], ["tabindex", "-1", 1, "k-spinner-increase", "k-button", "k-icon-button", 3, "mousedown", "mouseleave", "click", "title"], ["name", "caret-alt-up", "innerCssClass", "k-button-icon", 3, "svgIcon"], ["tabindex", "-1", 1, "k-spinner-decrease", "k-button", "k-icon-button", 3, "click", "mousedown", "mouseleave", "title"], ["name", "caret-alt-down", "innerCssClass", "k-button-icon", 3, "svgIcon"]];
    },
    template: function DateInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 3);
        ɵɵelement(1, "input", 4, 0);
        ɵɵtemplate(3, DateInputComponent_span_3_Template, 2, 2, "span", 5)(4, DateInputComponent_span_4_Template, 7, 10, "span", 6);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("title", ctx.title)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("readonly", ctx.readonly)("placeholder", ctx.placeholder)("kendoEventsOutsideAngular", ɵɵpureFunction2(15, _c13, ctx.handleDragAndDrop, ctx.handleDragAndDrop))("scope", ctx);
        ɵɵattribute("required", ctx.isControlRequired ? "" : null)("role", ctx.role)("aria-readonly", ctx.ariaReadOnly)("aria-expanded", ctx.isPopupOpen)("aria-haspopup", ctx.hasPopup);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.clearButton && ctx.showClearButton);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.spinners);
      }
    },
    dependencies: [DateInputLocalizedMessagesDirective, EventsOutsideAngularDirective, NgIf, IconWrapperComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-dateinput",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DateInputComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DateInputComponent),
        multi: true
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.dateinput"
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DateInputComponent)
      }, LocalizationService],
      selector: "kendo-dateinput",
      template: `
    <ng-container kendoDateInputLocalizedMessages
        i18n-increment="kendo.dateinput.increment|The label for the **Increment** button in the DateInput"
        increment="Increase value"

        i18n-decrement="kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput"
        decrement="Decrease value"

        i18n-clearTitle="kendo.dateinput.clearTitle|The title of the clear button"
        clearTitle="clear"
    >
    </ng-container>
    <input #dateInput
        class="k-input-inner"
        [attr.required]="isControlRequired ? '' : null"
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
        [attr.role]="role"
        [attr.aria-readonly]="ariaReadOnly"
        [id]="focusableId"
        [title]="title"
        [tabindex]="tabindex"
        [disabled]="disabled"
        [readonly]="readonly"
        [placeholder]="placeholder"
        [attr.aria-expanded]="isPopupOpen"
        [attr.aria-haspopup]="hasPopup"
        [kendoEventsOutsideAngular]="{
            dragstart: handleDragAndDrop,
            drop: handleDragAndDrop
        }"
        [scope]="this"
        />
    <span
        *ngIf="clearButton && showClearButton"
        class="k-clear-value"
        [attr.title]="localization.get('clearTitle')"
        role="button"
        tabindex="-1"
        (click)="resetInput()"
        (mousedown)="$event.preventDefault()"
    >
        <kendo-icon-wrapper
            name="x"
            [svgIcon]="xIcon"
        >
        </kendo-icon-wrapper>
    </span>
    <span *ngIf="spinners" class="k-input-spinner k-spin-button" (mousedown)="$event.preventDefault()">
        <button
            #spinup
            tabindex="-1"
            class="k-spinner-increase k-button k-icon-button"
            [class.k-active]="arrowDirection === arrow.Up"
            (mousedown)="arrowDirection = arrow.Up"
            (mouseleave)="arrowDirection = arrow.None"
            (click)="handleButtonClick(1)"
            [title]="localization.get('increment')"
            [attr.aria-label]="localization.get('increment')"
            >
                <kendo-icon-wrapper
                    name="caret-alt-up"
                    [svgIcon]="caretAltUpIcon"
                    innerCssClass="k-button-icon"
                >
                </kendo-icon-wrapper>
        </button>
        <button
            #spindown
            tabindex="-1"
            class="k-spinner-decrease k-button k-icon-button"
            (click)="handleButtonClick(-1)"
            [class.k-active]="arrowDirection === arrow.Down"
            (mousedown)="arrowDirection = arrow.Down"
            (mouseleave)="arrowDirection = arrow.None"
            [title]="localization.get('decrement')"
            [attr.aria-label]="localization.get('decrement')"
            >
                <kendo-icon-wrapper
                    name="caret-alt-down"
                    [svgIcon]="caretAltDownIcon"
                    innerCssClass="k-button-icon"
                >
                </kendo-icon-wrapper>
        </button>
    </span>
  `,
      standalone: true,
      imports: [DateInputLocalizedMessagesDirective, EventsOutsideAngularDirective, NgIf, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: IntlService
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: LocalizationService
    }, {
      type: PickerService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    pickerType: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    title: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    role: [{
      type: Input
    }],
    ariaReadOnly: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    isRequired: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    isPopupOpen: [{
      type: Input
    }],
    hasPopup: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    valueUpdate: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    dateInput: [{
      type: ViewChild,
      args: ["dateInput", {
        static: true
      }]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-dateinput"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    spinup: [{
      type: ViewChild,
      args: ["spinup", {
        static: false
      }]
    }],
    spindown: [{
      type: ViewChild,
      args: ["spindown", {
        static: false
      }]
    }]
  });
})();
var PreventableEvent2 = class {
  prevented = false;
  /** @hidden */
  constructor() {
  }
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var disabledDatesValidator = (isDateDisabled) => {
  return (control) => {
    if (!isDateDisabled || !control.value) {
      return null;
    }
    const error2 = {
      disabledDate: true
    };
    return isDateDisabled(control.value) ? error2 : null;
  };
};
var CalendarCustomMessagesComponent = class _CalendarCustomMessagesComponent extends CalendarMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CalendarCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CalendarCustomMessagesComponent,
    selectors: [["kendo-calendar-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: CalendarMessages,
      useExisting: forwardRef(() => _CalendarCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function CalendarCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: CalendarMessages,
        useExisting: forwardRef(() => CalendarCustomMessagesComponent)
      }],
      selector: "kendo-calendar-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DateInputCustomMessagesComponent = class _DateInputCustomMessagesComponent extends DateInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateInputCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateInputCustomMessagesComponent,
    selectors: [["kendo-dateinput-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: DateInputMessages,
      useExisting: forwardRef(() => _DateInputCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DateInputCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateInputMessages,
        useExisting: forwardRef(() => DateInputCustomMessagesComponent)
      }],
      selector: "kendo-dateinput-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DatePickerMessages = class _DatePickerMessages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The title of the **Toggle** button of the DatePicker.
   */
  toggle;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  /**
   * The title of the **Clear** button of the DatePicker.
   */
  clearTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDatePickerMessages_BaseFactory;
    return function DatePickerMessages_Factory(__ngFactoryType__) {
      return (ɵDatePickerMessages_BaseFactory || (ɵDatePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_DatePickerMessages)))(__ngFactoryType__ || _DatePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DatePickerMessages,
    selectors: [["kendo-datepicker-messages-base"]],
    inputs: {
      today: "today",
      toggle: "toggle",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle",
      clearTitle: "clearTitle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-datepicker-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    toggle: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }]
  });
})();
var DatePickerLocalizedMessagesDirective = class _DatePickerLocalizedMessagesDirective extends DatePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DatePickerLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePickerLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DatePickerLocalizedMessagesDirective,
    selectors: [["", "kendoDatePickerLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: DatePickerMessages,
      useExisting: forwardRef(() => _DatePickerLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DatePickerMessages,
        useExisting: forwardRef(() => DatePickerLocalizedMessagesDirective)
      }],
      selector: "[kendoDatePickerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var MIN_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-min";
var MAX_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-max";
var VALUE_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datepicker/#toc-using-with-json";
var DEFAULT_FORMAT = "d";
var TWO_DIGIT_YEAR_MAX$1 = 68;
var DatePickerComponent = class _DatePickerComponent extends MultiTabStop {
  zone;
  localization;
  cdr;
  popupService;
  wrapper;
  renderer;
  injector;
  pickerService;
  disabledDatesService;
  /**
   * @hidden
   */
  calendarIcon = calendarIcon;
  container;
  popupTemplate;
  toggleButton;
  actionSheet;
  /**
   * @hidden
   */
  focusableId;
  /**
   * @hidden
   */
  cellTemplate;
  /**
   * @hidden
   */
  set cellTemplateRef(template) {
    this.cellTemplate = template;
  }
  /**
   * If set to `true`, renders a clear button after the input text or DatePicker value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * @hidden
   */
  monthCellTemplate;
  /**
   * @hidden
   */
  set monthCellTemplateRef(template) {
    this.monthCellTemplate = template;
  }
  /**
   * @hidden
   */
  yearCellTemplate;
  /**
   * @hidden
   */
  set yearCellTemplateRef(template) {
    this.yearCellTemplate = template;
  }
  /**
   * @hidden
   */
  decadeCellTemplate;
  /**
   * @hidden
   */
  set decadeCellTemplateRef(template) {
    this.decadeCellTemplate = template;
  }
  /**
   * @hidden
   */
  centuryCellTemplate;
  /**
   * @hidden
   */
  set centuryCellTemplateRef(template) {
    this.centuryCellTemplate = template;
  }
  /**
   * @hidden
   */
  weekNumberTemplate;
  /**
   * @hidden
   */
  set weekNumberTemplateRef(template) {
    this.weekNumberTemplate = template;
  }
  /**
   * @hidden
   */
  headerTitleTemplate;
  /**
   * @hidden
   */
  set headerTitleTemplateRef(template) {
    this.headerTitleTemplate = template;
  }
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  set headerTemplateRef(template) {
    this.headerTemplate = template;
  }
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  set footerTemplateRef(template) {
    this.footerTemplate = template;
  }
  /**
   * Toggles the visibility of the Calendar footer.
   * @default false
   */
  footer = false;
  /**
   * @hidden
   */
  navigationItemTemplate;
  /**
   * @hidden
   */
  set navigationItemTemplateRef(template) {
    this.navigationItemTemplate = template;
  }
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Displays the days that fall out of the current month in the Calendar ([see example]({% slug viewoptions_calendar %}#toc-displaying-other-month-days)).
   * The default values per Calendar type are:
   * - `infinite` - false
   * - `classic` - true
   */
  showOtherMonthDays;
  /**
   * Defines the active view that the Calendar initially renders
   * ([see example]({% slug viewoptions_calendar %}#toc-active-view)).
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost Calendar view to which the user can navigate
   * ([see example](slug:datepicker_calendar_options#toc-view-selection-depth)).
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost Calendar view to which the user can navigate
   * ([see example](slug:datepicker_calendar_options#toc-view-selection-depth)).
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Specifies the Calendar type.
   *
   * The possible values are:
   * - `infinite` (default)
   * - `classic`
   *
   */
  calendarType = "infinite";
  /**
   * Determines whether to enable animation when navigating to previous/next Calendar view.
   * Applies to the [`classic`]({% slug api_dateinputs_datepickercomponent %}#toc-calendartype) Calendar only.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateCalendarNavigation = false;
  /**
   * Sets or gets the `disabled` property of the DatePicker and determines whether the component is active
   * ([see example]({% slug disabled_datepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_datepicker#toc-managing-the-datepicker-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the DatePicker
   * ([see example]({% slug readonly_datepicker %}#toc-read-only-datepicker)).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the read-only state of the DatePicker input field
   * ([see example]({% slug readonly_datepicker %}#toc-read-only-input)).
   *
   * > Note that if you set the [`readonly`]({% slug api_dateinputs_datepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   */
  readOnlyInput = false;
  /**
   * Configures the popup options of the DatePicker.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, {
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets or gets the `navigation` property of the Calendar
   * and determines whether the navigation side-bar is displayed.
   * ([see example]({% slug sidebar_datepicker %})).
   */
  set navigation(state) {
    this._navigation = state;
  }
  get navigation() {
    if (this.isAdaptive) {
      return;
    }
    return this._navigation;
  }
  _navigation = true;
  /**
   * Specifies the smallest valid date
   * ([see example]({% slug dateranges_datepicker %})).
   * By default, the `min` value is `1900-1-1`.
   */
  min = cloneDate(MIN_DATE);
  /**
   * Specifies the biggest valid date
   * ([see example]({% slug dateranges_datepicker %})).
   * By default, the `max` value is `2099-12-31`.
   */
  max = cloneDate(MAX_DATE);
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to autocorrect invalid segments automatically.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * When enabled, the DatePicker will autofill the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Specifies the focused date of the Calendar component
   * ([see example](slug:datepicker_calendar_options#toc-focused-dates)).
   */
  focusedDate = null;
  /**
   * Specifies the value of the DatePicker component.
   *
   * > The `value` has to be a valid
   * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value2) {
    this.verifyValue(value2);
    this._value = cloneDate(value2);
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the date format that is used to display the input value
   * ([see example]({% slug formats_datepicker %})).
   *
   * Format value options:
   * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
   * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
   */
  format = DEFAULT_FORMAT;
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_datepicker %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX$1;
  /**
   * Defines the descriptions of the format sections in the input field.
   * ([more information and examples]({% slug placeholders_datepicker %})).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   * <div class="row example-wrapper" [style.min-height.px]="450">
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Full-length format description:</p>
   *    <kendo-datepicker formatPlaceholder="wide"></kendo-datepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Narrow-length format description:</p>
   *    <kendo-datepicker formatPlaceholder="narrow"></kendo-datepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Short-length format description:</p>
   *    <kendo-datepicker formatPlaceholder="short"></kendo-datepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Display defined format:</p>
   *    <kendo-datepicker format="MM/dd/yyyy" formatPlaceholder="formatPattern"></kendo-datepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Custom defined format descriptions</p>
   *    <kendo-datepicker format="MM/dd/yyyy"
   *      [formatPlaceholder]="{ year: 'y', month: 'M', day: 'd' }"
   *    ></kendo-datepicker>
   *  </div>
   * </div>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  formatPlaceholder;
  /**
   * Specifies the hint the DatePicker displays when its value is `null`.
   * ([more information and exaples]({% slug placeholders_datepicker %})).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-datepicker placeholder="Enter birth date..."></kendo-datepicker>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  placeholder = null;
  /**
   * Sets or gets the `tabindex` property of the DatePicker.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the dates of the DatePicker that will be disabled
   * ([see example]({% slug disabled_dates_datepicker %})).
   */
  set disabledDates(value2) {
    this._disabledDates = value2;
    this.disabledDatesService.initialize(value2);
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Sets the title of the input element of the DatePicker and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  title = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  set subtitle(subtitle) {
    this._subtitle = subtitle;
  }
  get subtitle() {
    return this._subtitle || this.placeholder;
  }
  _subtitle;
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form.
   */
  rangeValidation = true;
  /**
   * Determines whether the built-in validator for disabled
   * date ranges is enforced when validating a form
   * ([see example]( slug:disabled_dates_datepicker#toc-using-a-function)).
   */
  disabledDatesValidation = true;
  /**
   * Determines whether to display a week number column in the `month` view of the Calendar
   * ([see example](slug:datepicker_calendar_options#toc-week-number-column)).
   */
  weekNumber = false;
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size ? size : DEFAULT_SIZE;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `solid` (Default)
   * * `flat`
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_datepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_datepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_datepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_datepicker)).
   * This event is preventable. If you cancel the event, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_datepicker)).
   * This event is preventable. If you cancel the event, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * @hidden
   */
  wrapperClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  get popupUID() {
    return this.calendar?.popupId;
  }
  popupRef;
  get isActive() {
    return this._active;
  }
  set isActive(value2) {
    this._active = value2;
    if (!this.wrapper) {
      return;
    }
    const element = this.wrapper.nativeElement;
    if (value2) {
      this.renderer.addClass(element, "k-focus");
    } else {
      this.renderer.removeClass(element, "k-focus");
    }
  }
  get show() {
    return this._show;
  }
  set show(show) {
    if (show && (this.disabled || this.readonly)) {
      return;
    }
    const skipZone = !show && (!this._show || !hasObservers(this.close) && !hasObservers(this.open));
    if (!skipZone) {
      this.zone.run(() => {
        const event2 = new PreventableEvent2();
        if (!this._show && show) {
          this.open.emit(event2);
        } else if (this._show && !show) {
          this.close.emit(event2);
        }
        if (event2.isDefaultPrevented()) {
          return;
        }
        this.toggleCalendar(show);
      });
    } else {
      this.toggleCalendar(show);
    }
  }
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control);
  }
  _popupSettings = {
    animate: true
  };
  _show = false;
  _value = null;
  _active = false;
  _disabledDates;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesValidateFn = noop$2;
  incompleteValidator = noop$2;
  resolvedPromise = Promise.resolve(null);
  subscription;
  pickerSubscriptions;
  localizationChangeSubscription;
  windowBlurSubscription;
  ariaActiveDescendantSubscription;
  control;
  domEvents = [];
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  windowSize;
  constructor(zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, disabledDatesService) {
    super();
    this.zone = zone;
    this.localization = localization;
    this.cdr = cdr;
    this.popupService = popupService;
    this.wrapper = wrapper;
    this.renderer = renderer;
    this.injector = injector;
    this.pickerService = pickerService;
    this.disabledDatesService = disabledDatesService;
    validatePackage(packageMetadata);
    this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));
    this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleSameSelection.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty.
   */
  isEmpty() {
    return !this.value && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.control = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
    this.focusableId = this.dateInput?.focusableId;
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    this.verifySettings();
    if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (!this.focusableId || changes.focusableId) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.isAdaptive && this.isOpen) {
      this.toggleActionSheet(false);
    }
    this.isActive = false;
    this.show = false;
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    this.pickerSubscriptions.unsubscribe();
  }
  /**
   * Indicates whether the component is currently open. That is when the popup or actionSheet is open.
   */
  get isOpen() {
    return this.show;
  }
  /**
   * @hidden
   */
  writeValue(value2) {
    this.verifyValue(value2);
    this.value = cloneDate(value2);
    this.cdr.markForCheck();
    if (!value2 && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value2);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleActionSheetClick(e) {
    e.preventDefault();
  }
  /**
   * Focuses the DatePicker component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="datepicker.focus()">Focus date picker</button>
   *  <kendo-datepicker #datepicker></kendo-datepicker>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    this.dateInput.focus();
  }
  /**
   * Blurs the DatePicker component.
   */
  blur() {
    (this.calendar || this.dateInput)["blur"]();
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show - The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.resolvedPromise.then(() => {
      this.toggleCalendar(show === void 0 ? !this.show : show);
    });
  }
  /**
   * @hidden
   */
  handleIconClick(event2) {
    if (this.disabled || this.readonly) {
      return;
    }
    event2.preventDefault();
    this.focusInput();
    this.handleFocus();
    this.show = !this.show;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = windowSize();
    if (this.isAdaptive) {
      this.show = true;
    }
  }
  /**
   * @hidden
   */
  handleMousedown(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  handleChange(value2, isInputValueChange) {
    this.value = value2;
    if (this.show) {
      if (!isInputValueChange) {
        this.focusInput();
      }
      this.show = false;
    }
    this.onControlChange(cloneDate(value2));
    this.valueChange.emit(cloneDate(value2));
  }
  /**
   * @hidden
   */
  handleInputChange(value2) {
    this.handleChange(this.dateInput.formatSections["time"] ? value2 : this.mergeTime(value2), true);
  }
  /**
   * @hidden
   */
  get popupClasses() {
    return ["k-datepicker-popup", "k-calendar-container"].concat(this.popupSettings.popupClass || []);
  }
  /**
   * @hidden
   */
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  get dateInput() {
    return this.pickerService.input;
  }
  get calendar() {
    return this.pickerService.calendar;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  onResize() {
    if (!this.isOpen || this.windowSize === windowSize()) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = windowSize();
  }
  /**
   * @hidden
   */
  mergeTime(value2) {
    return this.value && value2 ? setTime(value2, this.value) : value2;
  }
  /**
   * @hidden
   */
  handleKeydown(e) {
    const {
      altKey,
      shiftKey,
      keyCode,
      target
    } = e;
    if (keyCode === Keys.Escape) {
      this.dateInput.focus();
      this.show = false;
      hasObservers(this.escape) && this.escape.emit();
    }
    if (altKey) {
      if (keyCode === Keys.ArrowDown && !this.show) {
        this.show = true;
      }
      if (keyCode === Keys.ArrowUp) {
        this.dateInput.focus();
        this.show = false;
      }
    }
    if (keyCode === Keys.Tab && this.show && this.calendar.isActive && isTabExitingCalendar(this.calendarType, target, shiftKey)) {
      this.dateInput.focus();
      this.show = false;
    }
  }
  toggleCalendar(show) {
    this.windowSize = windowSize();
    if (this.isAdaptive) {
      this.toggleActionSheet(show);
    } else {
      this.togglePopup(show);
    }
    this.toggleFocus();
  }
  togglePopup(show) {
    if (show === this._show) {
      return;
    }
    this._show = show;
    if (show) {
      const direction = this.localization.rtl ? "right" : "left";
      const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
      this.popupRef = this.popupService.open({
        anchor: this.wrapper,
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.popupSettings.animate,
        appendTo: this.appendTo,
        content: this.popupTemplate,
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        popupClass: this.popupClasses,
        positionMode: appendToComponent ? "fixed" : "absolute"
      });
      this.setAriaActiveDescendant();
      this.popupRef.popupElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.subscription = this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);
    } else {
      this.popupRef.close();
      this.popupRef = null;
      this.subscription.unsubscribe();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
      }
      this.cdr.detectChanges();
    }
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.isOpen) {
      this.actionSheet.toggle();
      this.updateActionSheetAdaptiveAppearance();
      this.setAriaActiveDescendant();
      this.actionSheet.element.nativeElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    } else if (!show && this.isOpen) {
      this.actionSheet.toggle();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
      }
    }
    this._show = show;
  }
  updateActionSheetAdaptiveAppearance() {
    let element;
    let animationContainer;
    if (this.actionSheet) {
      element = this.actionSheet["element"].nativeElement.querySelector(".k-actionsheet");
      animationContainer = this.actionSheet["element"].nativeElement.querySelector(".k-child-animation-container");
      if (this.windowSize === "medium") {
        this.renderer.removeClass(element, "k-actionsheet-fullscreen");
        this.renderer.removeStyle(animationContainer, "height");
      } else if (this.windowSize === "small") {
        this.renderer.addClass(element, "k-actionsheet-fullscreen");
        this.renderer.setStyle(animationContainer, "height", "100%");
      }
      this.renderer.addClass(element, "k-adaptive-actionsheet");
      this.renderer.addClass(element, "k-actionsheet-bottom");
      this.renderer.setStyle(animationContainer, "bottom", "0px");
    }
  }
  setAriaActiveDescendant() {
    const focusedCellChangeEvent = this.calendar.type === "infinite" ? this.calendar.monthView.focusedCellChange : this.calendar.multiViewCalendar.viewList.focusedCellChange;
    this.ariaActiveDescendantSubscription = focusedCellChangeEvent.subscribe((id) => this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant, id));
  }
  focusInput() {
    if (touchEnabled) {
      return;
    }
    this.dateInput.focus();
  }
  toggleFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.show) {
      if (!this.calendar) {
        this.cdr.detectChanges();
      }
      if (this.calendar) {
        this.calendar.focus();
      }
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
    }
  }
  verifyValue(value2) {
    if (!isDevMode()) {
      return;
    }
    if (value2 && !(value2 instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$2} for possible resolution.`);
    }
  }
  bindEvents() {
    const element = this.wrapper.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)));
    if (isWindowAvailable()) {
      this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this));
    }
  }
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.zone.run(() => {
        this.onFocus.emit();
      });
    }
  }
  handleWindowBlur() {
    if (!this.isOpen || this.actionSheet.expanded) {
      return;
    }
    this.show = false;
  }
  handleBlur(args) {
    const currentTarget = args && currentFocusTarget(args);
    const target = args && args.target;
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(target) || this.actionSheet.element.nativeElement.contains(currentTarget));
    if (currentTarget && (this.dateInput.containsElement(currentTarget) || this.calendar && this.calendar.containsElement(currentTarget) || isInsideActionSheet)) {
      return;
    }
    if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {
      this.zone.run(() => {
        this.blurComponent();
        this.cdr.markForCheck();
      });
    } else {
      this.blurComponent();
    }
  }
  blurComponent() {
    this.isActive = false;
    this.show = false;
    this.cdr.detectChanges();
    this.onControlTouched();
    this.onBlur.emit();
  }
  handleSameSelection() {
    if (this.show) {
      this.focusInput();
      this.show = false;
    }
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.zone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function DatePickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePickerComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(DisabledDatesService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DatePickerComponent,
    selectors: [["kendo-datepicker"]],
    contentQueries: function DatePickerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);
      }
    },
    viewQuery: function DatePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 7, ViewContainerRef);
        ɵɵviewQuery(_c15, 7);
        ɵɵviewQuery(_c16, 7);
        ɵɵviewQuery(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DatePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-datepicker", ctx.wrapperClasses)("k-input", ctx.wrapperClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      cellTemplateRef: [0, "cellTemplate", "cellTemplateRef"],
      clearButton: "clearButton",
      inputAttributes: "inputAttributes",
      monthCellTemplateRef: [0, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [0, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [0, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [0, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [0, "weekNumberTemplate", "weekNumberTemplateRef"],
      headerTitleTemplateRef: [0, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [0, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [0, "footerTemplate", "footerTemplateRef"],
      footer: "footer",
      navigationItemTemplateRef: [0, "navigationItemTemplate", "navigationItemTemplateRef"],
      weekDaysFormat: "weekDaysFormat",
      showOtherMonthDays: "showOtherMonthDays",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      calendarType: "calendarType",
      animateCalendarNavigation: "animateCalendarNavigation",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      popupSettings: "popupSettings",
      navigation: "navigation",
      min: "min",
      max: "max",
      incompleteDateValidation: "incompleteDateValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      autoFill: "autoFill",
      focusedDate: "focusedDate",
      value: "value",
      format: "format",
      twoDigitYearMax: "twoDigitYearMax",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      disabledDates: "disabledDates",
      title: "title",
      subtitle: "subtitle",
      rangeValidation: "rangeValidation",
      disabledDatesValidation: "disabledDatesValidation",
      weekNumber: "weekNumber",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      adaptiveMode: "adaptiveMode"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur",
      open: "open",
      close: "close",
      escape: "escape"
    },
    exportAs: ["kendo-datepicker"],
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DatePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DatePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DatePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _DatePickerComponent)
    }, LocalizationService, PickerService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.datepicker"
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 17,
    vars: 41,
    consts: () => {
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_11 = goog.getMsg("Today");
        i18n_11 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.datepicker.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_12 = goog.getMsg("Toggle calendar");
        i18n_12 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.datepicker.toggle|The title of the toggle button in the datepicker component:Toggle calendar`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_13 = goog.getMsg("Navigate to previous view");
        i18n_13 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_14 = goog.getMsg("Navigate to next view");
        i18n_14 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_15 = goog.getMsg("Navigate to parent view");
        i18n_15 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.datepicker.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_16 = goog.getMsg("clear");
        i18n_16 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.datepicker.clearTitle|The title of the clear button:clear`;
      }
      return [["input", ""], ["toggleButton", ""], ["container", ""], ["popupTemplate", ""], ["actionSheet", ""], ["calendarTemplate", ""], ["calendar", ""], ["kendoDatePickerLocalizedMessages", "", "today", i18n_11, "toggle", i18n_12, "prevButtonTitle", i18n_13, "nextButtonTitle", i18n_14, "parentViewButtonTitle", i18n_15, "clearTitle", i18n_16], ["pickerType", "datepicker", "hasPopup", "grid", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "role", "isPopupOpen", "clearButton", "disabled", "readonly", "ariaReadOnly", "tabindex", "isRequired", "title", "focusableId", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "inputAttributes", "value"], [3, "clearTitle"], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "tabindex", "kendoEventsOutsideAngular", "scope"], ["name", "calendar", "innerCssClass", "k-button-icon", 3, "svgIcon"], [3, "resize", 4, "ngIf"], [3, "overlayClick", "collapse", "kendoEventsOutsideAngular", "scope", "titleId"], ["kendoActionSheetTemplate", ""], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group", "k-hbox"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "x", "fillMode", "flat", "aria-hidden", "true", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content", "!k-overflow-hidden"], [3, "valueChange", "type", "size", "min", "max", "weekDaysFormat", "navigation", "animateNavigation", "activeView", "bottomView", "showOtherMonthDays", "topView", "weekNumber", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "focusedDate", "value", "kendoEventsOutsideAngular", "scope", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"]];
    },
    template: function DatePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8, 0);
        ɵɵlistener("valueChange", function DatePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputChange($event));
        })("click", function DatePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(3, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 10, 1);
        ɵɵelement(6, "kendo-icon-wrapper", 11);
        ɵɵelementEnd();
        ɵɵelementContainer(7, null, 2);
        ɵɵtemplate(9, DatePickerComponent_ng_template_9_Template, 1, 1, "ng-template", null, 3, ɵɵtemplateRefExtractor)(11, DatePickerComponent_kendo_resize_sensor_11_Template, 1, 0, "kendo-resize-sensor", 12);
        ɵɵelementStart(12, "kendo-actionsheet", 13, 4);
        ɵɵlistener("overlayClick", function DatePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function DatePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, DatePickerComponent_ng_template_14_Template, 11, 6, "ng-template", 14);
        ɵɵelementEnd();
        ɵɵtemplate(15, DatePickerComponent_ng_template_15_Template, 3, 34, "ng-template", null, 5, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("role", "combobox")("isPopupOpen", ctx.show)("clearButton", ctx.clearButton)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.readOnlyInput)("ariaReadOnly", ctx.readonly)("tabindex", ctx.tabindex)("isRequired", ctx.isControlRequired)("title", ctx.title)("focusableId", ctx.focusableId)("format", ctx.format)("twoDigitYearMax", ctx.twoDigitYearMax)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("incompleteDateValidation", ctx.incompleteDateValidation)("autoCorrectParts", ctx.autoCorrectParts)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("autoFill", ctx.autoFill)("inputAttributes", ctx.inputAttributes)("value", ctx.value);
        ɵɵadvance(2);
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("kendoEventsOutsideAngular", ɵɵpureFunction2(36, _c18, ctx.handleIconClick, ctx.handleMousedown))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"));
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.calendarIcon);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(39, _c5, ctx.handleActionSheetClick))("scope", ctx)("titleId", ctx.calendar == null ? null : ctx.calendar.headerId);
      }
    },
    dependencies: [DatePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, NgIf, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, CalendarComponent, CalendarCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-datepicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DatePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DatePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DatePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => DatePickerComponent)
      }, LocalizationService, PickerService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.datepicker"
      }],
      selector: "kendo-datepicker",
      template: `
        <ng-container kendoDatePickerLocalizedMessages
            i18n-today="kendo.datepicker.today|The label for the today button in the calendar header"
            today="Today"

            i18n-toggle="kendo.datepicker.toggle|The title of the toggle button in the datepicker component"
            toggle="Toggle calendar"

            i18n-prevButtonTitle="kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar"
            prevButtonTitle="Navigate to previous view"

            i18n-nextButtonTitle="kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar"
            nextButtonTitle="Navigate to next view"

            i18n-parentViewButtonTitle="kendo.datepicker.parentViewButtonTitle|The title of the parent view button in the calendar header"
            parentViewButtonTitle="Navigate to parent view"

            i18n-clearTitle="kendo.datepicker.clearTitle|The title of the clear button"
            clearTitle="clear"
        >
        </ng-container>
        <kendo-dateinput
            #input
            [role]="'combobox'"
            pickerType="datepicker"
            hasPopup="grid"
            [isPopupOpen]="show"
            [clearButton]="clearButton"
            [disabled]="disabled"
            [readonly]="readonly || readOnlyInput"
            [ariaReadOnly]="readonly"
            [tabindex]="tabindex"
            [isRequired]="isControlRequired"
            [title]="title"
            [focusableId]="focusableId"
            [format]="format"
            [twoDigitYearMax]="twoDigitYearMax"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [incompleteDateValidation]="incompleteDateValidation"
            [autoCorrectParts]="autoCorrectParts"
            [autoSwitchParts]="autoSwitchParts"
            [autoSwitchKeys]="autoSwitchKeys"
            [enableMouseWheel]="enableMouseWheel"
            [allowCaretMode]="allowCaretMode"
            [autoFill]="autoFill"
            fillMode="none"
            rounded="none"
            size="none"
            [inputAttributes]="inputAttributes"
            [value]="value"
            (valueChange)="handleInputChange($event)"
            (click)="handleDateInputClick()"
        >
            <kendo-dateinput-messages
                [clearTitle]="localization.get('clearTitle')"
            >
            </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
            #toggleButton
            type="button"
            class="k-input-button k-button k-icon-button"
            [tabindex]="-1"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [kendoEventsOutsideAngular]="{
                click: handleIconClick,
                mousedown: handleMousedown
            }"
            [scope]="this"
        >
            <kendo-icon-wrapper
                name="calendar"
                [svgIcon]="calendarIcon"
                innerCssClass="k-button-icon"
            >
            </kendo-icon-wrapper>
        </button>

        <ng-container #container></ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="calendarTemplate"></ng-container>
        </ng-template>

        <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <kendo-actionsheet
            #actionSheet
            (overlayClick)="show=false"
            [kendoEventsOutsideAngular]="{
                click: handleActionSheetClick
            }"
            [scope]="this"
            (collapse)="handleActionSheetCollapse()"
            [titleId]="calendar?.headerId"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group k-hbox">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ title }}</div>
                            <div class="k-actionsheet-subtitle k-text-center">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="x"
                                [attr.title]="localization.get('clearTitle')"
                                [svgIcon]="xIcon"
                                fillMode="flat"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                size="large"
                                innerCssClass="k-button-icon"
                                (click)="show = false">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content !k-overflow-hidden">
                    <ng-container *ngTemplateOutlet="calendarTemplate"></ng-container>
                </div>
            </ng-template>
        </kendo-actionsheet>

        <ng-template #calendarTemplate>
            <kendo-calendar
                #calendar
                [type]="calendarType"
                [size]="isAdaptive ? 'large' : size"
                [min]="min"
                [max]="max"
                [weekDaysFormat]="weekDaysFormat"
                [navigation]="navigation"
                [animateNavigation]="animateCalendarNavigation"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [showOtherMonthDays]="showOtherMonthDays"
                [topView]="topView"
                [weekNumber]="weekNumber"
                [cellTemplate]="cellTemplate"
                [monthCellTemplate]="monthCellTemplate"
                [yearCellTemplate]="yearCellTemplate"
                [decadeCellTemplate]="decadeCellTemplate"
                [centuryCellTemplate]="centuryCellTemplate"
                [weekNumberTemplate]="weekNumberTemplate"
                [headerTitleTemplate]="headerTitleTemplate"
                [headerTemplate]="headerTemplate"
                [footerTemplate]="footerTemplate"
                [footer]="footer"
                [navigationItemTemplate]="navigationItemTemplate"
                [focusedDate]="focusedDate"
                [value]="value"
                (valueChange)="handleChange(mergeTime($event))"
                [kendoEventsOutsideAngular]="{
                    keydown: handleKeydown
                }"
                [scope]="this"
                [disabledDates]="disabledDates"
            >
                <kendo-calendar-messages
                    [today]="localization.get('today')"
                    [prevButtonTitle]="localization.get('prevButtonTitle')"
                    [nextButtonTitle]="localization.get('nextButtonTitle')"
                    [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
                >
                </kendo-calendar-messages>
            </kendo-calendar>
        </ng-template>
    `,
      standalone: true,
      imports: [DatePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, NgIf, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, CalendarComponent, CalendarCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PopupService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: PickerService
    }, {
      type: DisabledDatesService
    }];
  }, {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    focusableId: [{
      type: Input
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    clearButton: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    footer: [{
      type: Input
    }],
    navigationItemTemplate: [{
      type: ContentChild,
      args: [NavigationItemTemplateDirective, {
        static: false
      }]
    }],
    navigationItemTemplateRef: [{
      type: Input,
      args: ["navigationItemTemplate"]
    }],
    weekDaysFormat: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    animateCalendarNavigation: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    navigation: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesValidation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    escape: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-datepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var TIME_PART = {
  dayperiod: "dayperiod",
  hour: "hour",
  millisecond: "millisecond",
  minute: "minute",
  second: "second"
};
var div = domContainerFactory("div");
var ul = domContainerFactory("ul");
var li = domContainerFactory("li");
var span = domContainerFactory("span");
var listTitle = () => span("hour", "k-title k-timeselector-title");
var listItem = () => li("<span>02</span>", "k-item");
var list = () => ul([listItem()], "k-reset");
var scrollable = () => div([list()], "k-time-container k-flex k-content k-scrollable");
var actionSheetContent = (isDateTimePicker) => [isDateTimePicker ? div([div("button", "k-button k-button-lg")], "k-datetime-buttongroup") : null, div([div([span("title", "k-title")], "k-time-header"), div([listTitle(), div([scrollable()], "k-time-list")], "k-time-list-wrapper")], "k-timeselector k-timeselector-lg")];
var timeListWrapper = (isAdaptiveEnabled = false, windowSize2, isDateTimePicker) => {
  if (!isDocumentAvailable()) {
    return null;
  }
  if (!isAdaptiveEnabled) {
    return div([listTitle(), div([scrollable()], "k-time-list")], "k-time-list-wrapper", {
      left: "-10000px",
      position: "absolute"
    });
  }
  return div([div([div([div([div([], "k-i-x k-button-icon k-icon")], "k-icon-wrapper-host")], "k-button k-icon-button k-button-lg")], "k-actionsheet-titlebar"), div([isDateTimePicker ? div([...actionSheetContent(isDateTimePicker)], "k-datetime-wrap k-time-tab") : actionSheetContent(isDateTimePicker)[1]], "k-actionsheet-content"), div([div("button", "k-button k-button-lg")], "k-adaptive-actionsheet k-actionsheet-footer")], `k-actionsheet k-adaptive-actionsheet ${windowSize2 === "small" ? "k-actionsheet-fullscreen" : ""}`, {
    height: windowSize2 === "small" ? "100%" : "60vh",
    left: "-10000px",
    position: "absolute",
    top: 0
  });
};
var TimePickerDOMService = class _TimePickerDOMService {
  itemHeight;
  timeListHeight;
  isAdaptiveEnabled;
  isDateTimePicker;
  get windowSize() {
    return windowSize();
  }
  ensureHeights() {
    if (this.timeListHeight !== void 0) {
      return;
    }
    this.calculateHeights();
  }
  calculateHeights(container) {
    if (!isDocumentAvailable()) {
      return;
    }
    let wrapper;
    let hostContainer;
    if (!this.isAdaptiveEnabled || this.windowSize === "large") {
      const listContainer = container && container.querySelector(".k-time-list-container");
      hostContainer = listContainer || document.body;
      wrapper = hostContainer.appendChild(timeListWrapper());
    } else {
      hostContainer = document.body;
      wrapper = hostContainer.appendChild(timeListWrapper(true, this.windowSize, this.isDateTimePicker));
    }
    this.timeListHeight = wrapper.querySelector(".k-scrollable").offsetHeight;
    this.itemHeight = wrapper.querySelector("li").offsetHeight;
    hostContainer.removeChild(wrapper);
  }
  isActive(element) {
    if (!isDocumentAvailable() || !element) {
      return false;
    }
    return (element.nativeElement || element) === document.activeElement;
  }
  static ɵfac = function TimePickerDOMService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerDOMService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TimePickerDOMService,
    factory: _TimePickerDOMService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerDOMService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var HOURS_IN_DAY = 24;
var clampToRange$3 = (rangeValue) => (value2) => value2 % rangeValue;
var clamp$3 = clampToRange$3(HOURS_IN_DAY);
var stepper$3 = (start, step) => (idx2) => clamp$3(start + idx2 * step);
var distanceFromMin$3 = (value2, min) => clamp$3(HOURS_IN_DAY + value2 - min);
var limit$3 = (borderValue) => (barrier, value2) => {
  const useBarrier = !value2 || getDate(barrier).getTime() === getDate(value2).getTime();
  return useBarrier ? barrier : setHours$1(barrier, borderValue);
};
var limitDown$3 = limit$3(0);
var limitUp$3 = limit$3(HOURS_IN_DAY - 1);
var HoursService = class _HoursService {
  intl;
  boundRange = false;
  insertUndividedMax = false;
  min;
  max;
  step;
  toListItem;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value2, candidate) {
    return setHours$1(value2, candidate.getHours());
  }
  configure(settings) {
    const {
      boundRange = this.boundRange,
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.boundRange = boundRange;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (hour) => {
      const date = setHours$1(MIDNIGHT_DATE, hour);
      return {
        text: this.intl.formatDate(date, part.pattern),
        value: date
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getHour = stepper$3(min, this.step);
    const convertToItem = (idx2) => this.toListItem(getHour(idx2));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value2) {
    return this.boundRange ? [limitDown$3(min, value2), limitUp$3(max, value2)] : [min, max];
  }
  total(value2) {
    const last3 = this.insertUndividedMax && this.isLastMissing(value2) ? 1 : 0;
    const missing = this.isMissing(value2) ? 1 : 0;
    return this.countFromMin(value2) + missing + last3;
  }
  selectedIndex(value2) {
    return Math.ceil(this.divideByStep(value2));
  }
  valueInList(value2) {
    if (!value2) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastHour(value2) === value2.getHours();
    return matchMax || !this.isMissing(value2);
  }
  addLast(data, value2) {
    if (this.insertUndividedMax && this.isLastMissing(value2)) {
      data.push(this.toListItem(this.lastHour(value2)));
    }
    return data;
  }
  addMissing(data, value2) {
    if (this.valueInList(value2)) {
      return data;
    }
    const missingItem = this.toListItem(value2.getHours());
    data.splice(this.selectedIndex(value2), 0, missingItem);
    return data;
  }
  countFromMin(value2) {
    const [min, max] = this.range(value2);
    return Math.floor(distanceFromMin$3(max, min) / this.step) + 1;
  }
  isMissing(value2) {
    if (!value2) {
      return false;
    }
    return this.selectedIndex(value2) !== this.divideByStep(value2);
  }
  isLastMissing(value2) {
    return this.isMissing(setHours$1(this.max, this.lastHour(value2)));
  }
  divideByStep(value2) {
    return distanceFromMin$3(value2.getHours(), this.min.getHours()) / this.step;
  }
  lastHour(value2) {
    return this.range(value2)[1];
  }
  range(value2) {
    const [min, max] = this.limitRange(this.min, this.max, value2);
    return [min.getHours(), max.getHours()];
  }
  static ɵfac = function HoursService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HoursService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _HoursService,
    factory: _HoursService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HoursService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var MINUTES_IN_HOUR = 60;
var clampToRange$2 = (rangeValue) => (value2) => value2 % rangeValue;
var clamp$2 = clampToRange$2(MINUTES_IN_HOUR);
var stepper$2 = (start, step) => (idx2) => clamp$2(start + idx2 * step);
var distanceFromMin$2 = (value2, min) => clamp$2(MINUTES_IN_HOUR + value2 - min);
var limit$2 = (borderValue) => (barrier, value2) => {
  const useBarrier = !value2 || barrier.getHours() === value2.getHours();
  return useBarrier ? barrier : setMinutes(barrier, borderValue);
};
var limitDown$2 = limit$2(0);
var limitUp$2 = limit$2(MINUTES_IN_HOUR - 1);
var MinutesService = class _MinutesService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value2, candidate) {
    return setMinutes(value2, candidate.getMinutes());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (minute) => {
      const date = setMinutes(MIDNIGHT_DATE, minute);
      return {
        text: this.intl.formatDate(date, part.pattern),
        value: date
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getMinute = stepper$2(min, this.step);
    const convertToItem = (idx2) => this.toListItem(getMinute(idx2));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value2) {
    return [limitDown$2(min, value2), limitUp$2(max, value2)];
  }
  total(value2) {
    const last3 = this.insertUndividedMax && this.isLastMissing(value2) ? 1 : 0;
    const missing = this.isMissing(value2) ? 1 : 0;
    return this.countFromMin(value2) + missing + last3;
  }
  selectedIndex(value2) {
    return Math.ceil(this.divideByStep(value2));
  }
  valueInList(value2) {
    if (!value2) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastMinute(value2) === value2.getMinutes();
    return matchMax || !this.isMissing(value2);
  }
  addLast(data, value2) {
    if (this.insertUndividedMax && this.isLastMissing(value2)) {
      data.push(this.toListItem(this.lastMinute(value2)));
    }
    return data;
  }
  addMissing(data, value2) {
    if (this.valueInList(value2)) {
      return data;
    }
    const missingItem = this.toListItem(value2.getMinutes());
    data.splice(this.selectedIndex(value2), 0, missingItem);
    return data;
  }
  countFromMin(value2) {
    const [min, max] = this.range(value2);
    return Math.floor(distanceFromMin$2(max, min) / this.step) + 1;
  }
  isMissing(value2) {
    if (!value2) {
      return false;
    }
    return this.selectedIndex(value2) !== this.divideByStep(value2);
  }
  isLastMissing(value2) {
    return this.isMissing(setMinutes(this.max, this.lastMinute(value2)));
  }
  divideByStep(value2) {
    return distanceFromMin$2(value2.getMinutes(), this.min.getMinutes()) / this.step;
  }
  lastMinute(value2) {
    return this.range(value2)[1];
  }
  range(value2) {
    const [min, max] = this.limitRange(this.min, this.max, value2);
    return [min.getMinutes(), max.getMinutes()];
  }
  static ɵfac = function MinutesService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MinutesService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MinutesService,
    factory: _MinutesService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinutesService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var SECONDS_IN_HOUR = 60;
var clampToRange$1 = (rangeValue) => (value2) => value2 % rangeValue;
var clamp$1 = clampToRange$1(SECONDS_IN_HOUR);
var stepper$1 = (start, step) => (idx2) => clamp$1(start + idx2 * step);
var distanceFromMin$1 = (value2, min) => clamp$1(SECONDS_IN_HOUR + value2 - min);
var limit$1 = (borderValue) => (barrier, value2) => {
  const useBarrier = !value2 || barrier.getHours() === value2.getHours() && barrier.getMinutes() === value2.getMinutes();
  return useBarrier ? barrier : setSeconds(barrier, borderValue);
};
var limitDown$1 = limit$1(0);
var limitUp$1 = limit$1(SECONDS_IN_HOUR - 1);
var SecondsService = class _SecondsService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value2, candidate) {
    return setSeconds(value2, candidate.getSeconds());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (second) => {
      const date = setSeconds(MIDNIGHT_DATE, second);
      return {
        text: this.intl.formatDate(date, part.pattern),
        value: date
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getSecond = stepper$1(min, this.step);
    const convertToItem = (idx2) => this.toListItem(getSecond(idx2));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value2) {
    return [limitDown$1(min, value2), limitUp$1(max, value2)];
  }
  total(value2) {
    const last3 = this.insertUndividedMax && this.isLastMissing(value2) ? 1 : 0;
    const missing = this.isMissing(value2) ? 1 : 0;
    return this.countFromMin(value2) + missing + last3;
  }
  selectedIndex(value2) {
    return Math.ceil(this.divideByStep(value2));
  }
  valueInList(value2) {
    if (!value2) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastSecond(value2) === value2.getSeconds();
    return matchMax || !this.isMissing(value2);
  }
  divideByStep(value2) {
    return distanceFromMin$1(value2.getSeconds(), this.min.getSeconds()) / this.step;
  }
  addLast(data, value2) {
    if (this.insertUndividedMax && this.isLastMissing(value2)) {
      data.push(this.toListItem(this.lastSecond(value2)));
    }
    return data;
  }
  addMissing(data, value2) {
    if (this.valueInList(value2)) {
      return data;
    }
    const missingItem = this.toListItem(value2.getSeconds());
    data.splice(this.selectedIndex(value2), 0, missingItem);
    return data;
  }
  countFromMin(value2) {
    const [min, max] = this.range(value2);
    return Math.floor(distanceFromMin$1(max, min) / this.step) + 1;
  }
  isMissing(value2) {
    if (!value2) {
      return false;
    }
    return this.selectedIndex(value2) !== this.divideByStep(value2);
  }
  isLastMissing(value2) {
    return this.isMissing(setSeconds(this.max, this.lastSecond(value2)));
  }
  lastSecond(value2) {
    return this.range(value2)[1];
  }
  range(value2) {
    const [min, max] = this.limitRange(this.min, this.max, value2);
    return [min.getSeconds(), max.getSeconds()];
  }
  static ɵfac = function SecondsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SecondsService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SecondsService,
    factory: _SecondsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SecondsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var MILLISECONDS_IN_SECOND = 1e3;
var clampToRange = (rangeValue) => (value2) => value2 % rangeValue;
var clamp2 = clampToRange(MILLISECONDS_IN_SECOND);
var stepper = (start, step) => (idx2) => clamp2(start + idx2 * step);
var distanceFromMin = (value2, min) => clamp2(MILLISECONDS_IN_SECOND + value2 - min);
var limit = (borderValue) => (barrier, value2) => {
  const useBarrier = !value2 || barrier.getHours() === value2.getHours() && barrier.getMinutes() === value2.getMinutes() && barrier.getSeconds() === value2.getSeconds();
  return useBarrier ? barrier : setMilliseconds(barrier, borderValue);
};
var limitDown = limit(0);
var limitUp = limit(MILLISECONDS_IN_SECOND - 1);
var MillisecondsService = class _MillisecondsService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value2, candidate) {
    return setMilliseconds(value2, candidate.getMilliseconds());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (millisecond) => {
      const date = setMilliseconds(MIDNIGHT_DATE, millisecond);
      return {
        text: this.intl.formatDate(date, "SSS"),
        value: date
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getMillisecond = stepper(min, this.step);
    const convertToItem = (idx2) => this.toListItem(getMillisecond(idx2));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value2) {
    return [limitDown(min, value2), limitUp(max, value2)];
  }
  total(value2) {
    const last3 = this.insertUndividedMax && this.isLastMissing(value2) ? 1 : 0;
    const missing = this.isMissing(value2) ? 1 : 0;
    return this.countFromMin(value2) + missing + last3;
  }
  selectedIndex(value2) {
    return Math.ceil(this.divideByStep(value2));
  }
  valueInList(value2) {
    if (!value2) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastMillisecond(value2) === value2.getMilliseconds();
    return matchMax || !this.isMissing(value2);
  }
  divideByStep(value2) {
    return distanceFromMin(value2.getMilliseconds(), this.min.getMilliseconds()) / this.step;
  }
  addLast(data, value2) {
    if (this.insertUndividedMax && this.isLastMissing(value2)) {
      data.push(this.toListItem(this.lastMillisecond(value2)));
    }
    return data;
  }
  addMissing(data, value2) {
    if (this.valueInList(value2)) {
      return data;
    }
    const missingItem = this.toListItem(value2.getMilliseconds());
    data.splice(this.selectedIndex(value2), 0, missingItem);
    return data;
  }
  countFromMin(value2) {
    const [min, max] = this.range(value2);
    return Math.floor(distanceFromMin(max, min) / this.step) + 1;
  }
  isMissing(value2) {
    if (!value2) {
      return false;
    }
    return this.selectedIndex(value2) !== this.divideByStep(value2);
  }
  isLastMissing(value2) {
    return this.isMissing(setMilliseconds(this.max, this.lastMillisecond(value2)));
  }
  lastMillisecond(value2) {
    return this.range(value2)[1];
  }
  range(value2) {
    const [min, max] = this.limitRange(this.min, this.max, value2);
    return [min.getMilliseconds(), max.getMilliseconds()];
  }
  static ɵfac = function MillisecondsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MillisecondsService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MillisecondsService,
    factory: _MillisecondsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MillisecondsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var setHours = (date, hours) => {
  const clone2 = cloneDate(date);
  clone2.setHours(hours);
  return clone2;
};
var isAM = (value2) => value2 !== null && value2 < 12;
var isPM = (value2) => value2 !== null && (!value2 || value2 > 11);
var inRange = (value2, min, max) => !min && !max || value2 >= min && value2 <= max;
var inReverseRange = (value2, min, max) => !min && !max || value2 >= min || value2 <= max;
var DayPeriodService = class _DayPeriodService {
  intl;
  min;
  max;
  part;
  constructor(intl) {
    this.intl = intl;
  }
  /**
   * @hidden
   */
  apply(value2, candidate) {
    const hour = value2.getHours();
    const hourAM = isAM(hour);
    const candidateAM = isAM(candidate.getHours());
    if (hourAM && candidateAM || !hourAM && !candidateAM) {
      return value2;
    }
    const [min, max = 24] = this.normalizedRange();
    const result = hour + (candidateAM ? -12 : 12);
    return setHours(value2, Math.min(Math.max(min, result), max || 24));
  }
  /**
   * @hidden
   */
  configure(settings) {
    const {
      min = this.min,
      max = this.max,
      part = this.part
    } = settings;
    this.min = min;
    this.max = max;
    this.part = part;
  }
  /**
   * @hidden
   */
  data(_) {
    const names = this.part.names;
    if (!names) {
      return [];
    }
    const data = [];
    const [min, max] = this.normalizedRange();
    const dayPeriod = this.intl.dateFormatNames(names);
    if (isAM(min)) {
      data.push({
        text: dayPeriod.am,
        value: setHours(this.min, min)
      });
    }
    if (isPM(max)) {
      data.push({
        text: dayPeriod.pm,
        value: setHours(this.min, Math.max(12, max))
      });
    }
    return this.min.getHours() !== min ? data.reverse() : data;
  }
  /**
   * @hidden
   */
  isRangeChanged(_, __) {
    return false;
  }
  /**
   * @hidden
   */
  limitRange(min, max, _) {
    return [min, max];
  }
  /**
   * @hidden
   */
  total() {
    const [min, max] = this.normalizedRange();
    if (!min && !max) {
      return 2;
    }
    if (min > 11 || max < 12) {
      return 1;
    }
    return 2;
  }
  /**
   * @hidden
   */
  selectedIndex(value2) {
    if (!this.valueInList(value2)) {
      return -1;
    }
    const index = Math.floor(value2.getHours() / 12);
    return this.min.getHours() === this.normalizedRange()[0] ? index : index === 0 ? 1 : 0;
  }
  /**
   * @hidden
   */
  valueInList(value2) {
    const reverse = this.min.getHours() !== this.normalizedRange()[0];
    const isInRange2 = reverse ? inReverseRange : inRange;
    return isInRange2(value2.getHours(), this.min.getHours(), this.max.getHours());
  }
  normalizedRange() {
    const minHour = this.min.getHours();
    const maxHour = this.max.getHours();
    return [Math.min(minHour, maxHour), Math.max(minHour, maxHour)];
  }
  static ɵfac = function DayPeriodService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DayPeriodService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DayPeriodService,
    factory: _DayPeriodService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DayPeriodService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var SNAP_THRESHOLD = 0.05;
var SCROLL_THRESHOLD = 2;
var nil = () => null;
var getters = {
  35: (data, _) => data[data.length - 1],
  36: (data, _) => data[0],
  38: (data, index) => data[index - 1],
  40: (data, index) => data[index + 1]
};
var services = {
  [TIME_PART.dayperiod]: DayPeriodService,
  [TIME_PART.hour]: HoursService,
  [TIME_PART.minute]: MinutesService,
  [TIME_PART.second]: SecondsService,
  [TIME_PART.millisecond]: MillisecondsService
};
var TimeListComponent = class _TimeListComponent {
  element;
  injector;
  dom;
  renderer;
  zone;
  localization;
  min = cloneDate(MIDNIGHT_DATE);
  max = cloneDate(MAX_TIME);
  part;
  step = 1;
  disabled = false;
  value;
  isLast = false;
  isFirst = false;
  valueChange = new EventEmitter();
  tabOutLastPart = new EventEmitter();
  tabOutFirstPart = new EventEmitter();
  virtualization;
  get tabIndex() {
    return this.disabled ? void 0 : 0;
  }
  componentClass = true;
  get isDayPeriod() {
    return this.part?.type === "dayperiod";
  }
  get currentSelectedIndex() {
    return this.selectedIndex(this.value);
  }
  get roleAttribute() {
    return "listbox";
  }
  get ariaLabel() {
    return this.localization.get(this.part?.type);
  }
  animateToIndex = true;
  isActive = false;
  skip = 0;
  total = 60;
  service;
  itemHeight;
  listHeight;
  topOffset;
  bottomOffset;
  bottomThreshold;
  topThreshold;
  style;
  data = [];
  indexToScroll = -1;
  scrollSubscription;
  domEvents = [];
  constructor(element, injector, dom, renderer, zone, localization) {
    this.element = element;
    this.injector = injector;
    this.dom = dom;
    this.renderer = renderer;
    this.zone = zone;
    this.localization = localization;
  }
  ngOnChanges(changes) {
    if (changes.part) {
      this.service = this.injector.get(services[this.part.type]);
      this.service.configure(this.serviceSettings());
    }
    const value2 = this.value;
    const valueChanges = changes.value || {};
    const [min, max] = this.service.limitRange(this.min, this.max, value2);
    if (this.service.isRangeChanged(min, max) || changes.min || changes.max || changes.step) {
      this.data = [];
      this.service.configure(this.serviceSettings({
        min,
        max
      }));
    }
    if (!this.data.length || this.hasMissingValue(valueChanges)) {
      this.animateToIndex = false;
      this.data = this.service.data(value2);
    }
    this.animateToIndex = this.animateToIndex && this.textHasChanged(valueChanges);
    this.total = this.service.total(value2);
    this.indexToScroll = this.selectedIndex(value2);
  }
  ngOnInit() {
    this.animateToIndex = true;
    this.dom.ensureHeights();
    this.itemHeight = this.dom.itemHeight;
    this.listHeight = this.dom.timeListHeight;
    this.topOffset = (this.listHeight - this.itemHeight) / 2;
    this.bottomOffset = this.listHeight - this.itemHeight;
    this.topThreshold = this.itemHeight * SNAP_THRESHOLD;
    this.bottomThreshold = this.itemHeight * (1 - SNAP_THRESHOLD);
    const translate = `translateY(${this.topOffset}px)`;
    this.style = {
      transform: translate,
      "-ms-transform": translate
    };
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnDestroy() {
    this.scrollSubscription.unsubscribe();
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  ngAfterViewInit() {
    this.scrollOnce((index) => this.virtualization.scrollToIndex(index));
  }
  ngAfterViewChecked() {
    this.scrollOnce((index) => {
      const action = this.animateToIndex ? "animateToIndex" : "scrollToIndex";
      this.virtualization[action](index);
      this.animateToIndex = true;
    });
  }
  getCurrentItem() {
    return this.indexToScroll >= 0 ? this.data[this.indexToScroll] : null;
  }
  handleChange(dataItem) {
    const candidate = this.service.apply(this.value, dataItem.value);
    if (this.value.getTime() === candidate.getTime()) {
      return;
    }
    this.indexToScroll = this.data.indexOf(dataItem);
    this.value = candidate;
    this.valueChange.emit(candidate);
  }
  handleItemClick(args) {
    const item = closestInScope(args.target, (node) => node.hasAttribute("data-timelist-item-index"), this.element.nativeElement);
    if (item) {
      const index = item.getAttribute("data-timelist-item-index");
      this.handleChange(this.data[index]);
    }
  }
  /**
   * Focuses the host element of the TimeList.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="timelist.focus()">Focus TimeList</button>
   *  <kendo-timelist #timelist></kendo-timelist>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.focus();
  }
  /**
   * Blurs the TimeList component.
   */
  blur() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.blur();
  }
  itemOffset(scrollTop) {
    const valueIndex = this.selectedIndex(this.value);
    const activeIndex = this.virtualization.activeIndex();
    const offset2 = this.virtualization.itemOffset(activeIndex);
    const distance = Math.abs(Math.ceil(scrollTop) - offset2);
    if (valueIndex === activeIndex && distance < SCROLL_THRESHOLD) {
      return offset2;
    }
    const scrollUp = valueIndex > activeIndex;
    const moveToNext = scrollUp && distance >= this.bottomThreshold || !scrollUp && distance > this.topThreshold;
    return moveToNext ? this.virtualization.itemOffset(activeIndex + 1) : offset2;
  }
  hasMissingValue({
    previousValue,
    currentValue
  }) {
    const isPreviousMissing = previousValue && !this.service.valueInList(previousValue);
    const isCurrentMissing = currentValue && !this.service.valueInList(currentValue);
    return isPreviousMissing || isCurrentMissing;
  }
  scrollOnce(action) {
    if (this.indexToScroll !== -1) {
      action(this.indexToScroll);
      this.indexToScroll = -1;
    }
  }
  serviceSettings(settings) {
    const defaults = {
      boundRange: false,
      insertUndividedMax: false,
      max: this.max,
      min: this.min,
      part: this.part,
      step: this.step
    };
    const result = Object.assign({}, defaults, settings);
    result.boundRange = result.part.type !== "hour";
    return result;
  }
  selectedIndex(value2) {
    if (!value2) {
      return -1;
    }
    return this.service.selectedIndex(value2);
  }
  textHasChanged({
    previousValue,
    currentValue
  }) {
    if (!previousValue || !currentValue) {
      return false;
    }
    const oldData = this.data[this.selectedIndex(previousValue)];
    const newData = this.data[this.selectedIndex(currentValue)];
    return oldData && newData && oldData.text !== newData.text;
  }
  handleKeyDown(e) {
    if (e.keyCode === Keys.Tab && !e.shiftKey && this.isLast) {
      e.preventDefault();
      this.tabOutLastPart.emit();
    }
    if (e.keyCode === Keys.Tab && e.shiftKey && this.isFirst) {
      e.preventDefault();
      this.tabOutFirstPart.emit();
    }
    const getter3 = getters[e.keyCode] || nil;
    const dataItem = getter3(this.data, this.service.selectedIndex(this.value));
    if (dataItem) {
      this.handleChange(dataItem);
      e.preventDefault();
    }
  }
  bindEvents() {
    this.scrollSubscription = this.virtualization.scroll$().pipe(debounceTime(100), map((e) => e.target.scrollTop), map((top) => this.itemOffset(top)), map((itemOffset) => this.virtualization.itemIndex(itemOffset))).subscribe((index) => {
      this.virtualization.scrollToIndex(index);
      this.handleChange(this.data[index]);
    });
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "mouseover", () => !this.isActive && this.focus()), this.renderer.listen(element, "click", () => this.focus()), this.renderer.listen(element, "blur", () => this.isActive = false), this.renderer.listen(element, "focus", () => this.isActive = true), this.renderer.listen(element, "keydown", this.handleKeyDown.bind(this)));
  }
  static ɵfac = function TimeListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(TimePickerDOMService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeListComponent,
    selectors: [["kendo-timelist"]],
    viewQuery: function TimeListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function TimeListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("tabindex", ctx.tabIndex);
        ɵɵclassProp("k-time-list", ctx.componentClass);
      }
    },
    inputs: {
      min: "min",
      max: "max",
      part: "part",
      step: "step",
      disabled: "disabled",
      value: "value",
      isLast: "isLast",
      isFirst: "isFirst"
    },
    outputs: {
      valueChange: "valueChange",
      tabOutLastPart: "tabOutLastPart",
      tabOutFirstPart: "tabOutFirstPart"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 16,
    consts: [["tabindex", "-1", 1, "k-time-container", 3, "skip", "take", "total", "itemHeight", "maxScrollDifference", "topOffset", "bottomOffset"], [1, "k-reset", 3, "ngStyle", "kendoEventsOutsideAngular", "scope"], ["class", "k-item", 4, "ngFor", "ngForOf"], [1, "k-item"]],
    template: function TimeListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-virtualization", 0)(1, "ul", 1);
        ɵɵtemplate(2, TimeListComponent_li_2_Template, 3, 4, "li", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("skip", ctx.skip)("take", ctx.total)("total", ctx.total)("itemHeight", ctx.itemHeight)("maxScrollDifference", ctx.listHeight)("topOffset", ctx.topOffset)("bottomOffset", ctx.bottomOffset);
        ɵɵattribute("role", ctx.roleAttribute)("aria-label", ctx.ariaLabel);
        ɵɵadvance();
        ɵɵproperty("ngStyle", ctx.style)("kendoEventsOutsideAngular", ɵɵpureFunction1(14, _c5, ctx.handleItemClick))("scope", ctx);
        ɵɵattribute("role", "presentation");
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.data);
      }
    },
    dependencies: [VirtualizationComponent, NgStyle, EventsOutsideAngularDirective, NgForOf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-timelist",
      template: `
    <kendo-virtualization
        [attr.role]="roleAttribute"
        [attr.aria-label]="ariaLabel"
        [skip]="skip"
        [take]="total"
        [total]="total"
        [itemHeight]="itemHeight"
        [maxScrollDifference]="listHeight"
        [topOffset]="topOffset"
        [bottomOffset]="bottomOffset"
        class="k-time-container"
        tabindex="-1"
    >
        <ul [ngStyle]="style" class="k-reset"
            [kendoEventsOutsideAngular]="{
                click: handleItemClick
            }"
            [scope]="this"
            [attr.role]="'presentation'"
        >
            <li *ngFor="let item of data; let index = index;" class="k-item"
                [attr.data-timelist-item-index]="index"
                [attr.role]="'option'"
                [attr.aria-selected]="index === currentSelectedIndex"
                >
                <span>{{item.text}}</span>
            </li>
        </ul>
    </kendo-virtualization>
  `,
      standalone: true,
      imports: [VirtualizationComponent, NgStyle, EventsOutsideAngularDirective, NgForOf]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Injector
    }, {
      type: TimePickerDOMService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: LocalizationService
    }];
  }, {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    part: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isFirst: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    tabOutLastPart: [{
      type: Output
    }],
    tabOutFirstPart: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: true
      }]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    componentClass: [{
      type: HostBinding,
      args: ["class.k-time-list"]
    }]
  });
})();
var isEqualTillMinute = (value2, min) => value2.getHours() === min.getHours() && value2.getMinutes() === min.getMinutes();
var isEqualTillSecond = (value2, min) => isEqualTillMinute(value2, min) && value2.getSeconds() === min.getSeconds();
var isEqualTillMillisecond = (value2, min) => isEqualTillSecond(value2, min) && value2.getMilliseconds() === min.getMilliseconds();
var defaultGetters = [{
  type: TIME_PART.hour,
  getter: (value2) => value2.getHours(),
  minGetter: (_, min) => min.getHours()
}, {
  type: TIME_PART.minute,
  getter: (value2) => value2.getMinutes(),
  minGetter: (value2, min) => isEqualTillMinute(value2, min) ? min.getMinutes() : 0
}, {
  type: TIME_PART.second,
  getter: (value2) => value2.getSeconds(),
  minGetter: (value2, min) => isEqualTillSecond(value2, min) ? min.getSeconds() : 0
}, {
  type: TIME_PART.millisecond,
  getter: (value2) => value2.getMilliseconds(),
  minGetter: (value2, min) => isEqualTillMillisecond(value2, min) ? min.getMilliseconds() : 0
}];
var left = (getter3) => (origin, _) => getter3(origin);
var right = (getter3) => (_, candidate) => getter3(candidate);
var convertToObject = (parts) => parts.reduce((obj, p) => {
  obj[p.type] = p.type;
  return obj;
}, {});
var getterByPart = (parts) => (g) => parts[g.type] ? right(g.getter) : left(g.getter);
var gettersFactory = (getters2) => (parts) => getters2.map(getterByPart(convertToObject(parts)));
var snapValue = (getter3, minGetter, step) => (date, min) => {
  const value2 = getter3(date);
  const minValue = minGetter(date, min);
  const rest = value2 - minValue;
  if (rest < 0) {
    return minValue;
  }
  const mod = rest % step;
  return value2 - mod + (mod > step / 2 ? step : 0);
};
var snappersFactory = (getters2) => (steps) => getters2.map((g) => {
  const step = steps[g.type];
  return step ? snapValue(g.getter, g.minGetter, step) : g.getter;
});
var generateGetters = gettersFactory(defaultGetters);
var generateSnappers = snappersFactory(defaultGetters);
var valueMerger = (getters2) => (origin, candidate) => {
  origin.setHours(...getters2.map((g) => g(origin, candidate)));
  return origin;
};
var snapTime = (snappers) => (candidate, min) => {
  const date = cloneDate(candidate);
  date.setHours(...snappers.map((s) => s(date, min)));
  return date;
};
var TimePickerMessages = class _TimePickerMessages extends ComponentMessages {
  /**
   * The text of the **Accept** button in the popup footer of the TimeList.
   */
  accept;
  /**
   * The label of the **Accept** button in the popup footer of the TimeList.
   */
  acceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the TimeList.
   */
  cancel;
  /**
   * The label of the **Cancel** button in the popup footer of the TimeList.
   */
  cancelLabel;
  /**
   * The text of the **Now** button in the popup header of the TimeList.
   */
  now;
  /**
   * The label of the **Now** button in the popup header of the TimeList.
   */
  nowLabel;
  /**
   * The title of the **Toggle** button of the TimePicker.
   */
  toggle;
  /**
   * The label of the **Hour** part in the TimePicker.
   */
  hour;
  /**
   * The label of the **Minute** part in the TimePicker.
   */
  minute;
  /**
   * The label of the **Second** part in the TimePicker.
   */
  second;
  /**
   * The label of the **Millisecond** part in the TimePicker.
   */
  millisecond;
  /**
   * The label of the **Dayperiod** part in the TimePicker.
   */
  dayperiod;
  /**
   * The title of the **Clear** button of the TimePicker.
   */
  clearTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTimePickerMessages_BaseFactory;
    return function TimePickerMessages_Factory(__ngFactoryType__) {
      return (ɵTimePickerMessages_BaseFactory || (ɵTimePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_TimePickerMessages)))(__ngFactoryType__ || _TimePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TimePickerMessages,
    selectors: [["kendo-timepicker-messages-base"]],
    inputs: {
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel",
      now: "now",
      nowLabel: "nowLabel",
      toggle: "toggle",
      hour: "hour",
      minute: "minute",
      second: "second",
      millisecond: "millisecond",
      dayperiod: "dayperiod",
      clearTitle: "clearTitle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-timepicker-messages-base"
    }]
  }], null, {
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    now: [{
      type: Input
    }],
    nowLabel: [{
      type: Input
    }],
    toggle: [{
      type: Input
    }],
    hour: [{
      type: Input
    }],
    minute: [{
      type: Input
    }],
    second: [{
      type: Input
    }],
    millisecond: [{
      type: Input
    }],
    dayperiod: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }]
  });
})();
var TimeSelectorLocalizedMessagesDirective = class _TimeSelectorLocalizedMessagesDirective extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function TimeSelectorLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeSelectorLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimeSelectorLocalizedMessagesDirective,
    selectors: [["", "kendoTimeSelectorLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimeSelectorLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimeSelectorLocalizedMessagesDirective)
      }],
      selector: "[kendoTimeSelectorLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var listReducer = (state, list2, idx2, all) => {
  if (state.length || !list2.isActive) {
    return state;
  }
  return [{
    next: all[idx2 + 1] || list2,
    prev: all[idx2 - 1] || list2
  }];
};
var Direction2;
(function(Direction3) {
  Direction3[Direction3["Left"] = 0] = "Left";
  Direction3[Direction3["Right"] = 1] = "Right";
})(Direction2 || (Direction2 = {}));
var TimeSelectorComponent = class _TimeSelectorComponent {
  localization;
  cdr;
  element;
  intl;
  dom;
  zone;
  renderer;
  pickerService;
  accept;
  cancel;
  now;
  timeLists;
  timeListWrappers;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * Specifies the time format used to display the time list columns.
   */
  format = "t";
  /**
   * Specifies the smallest valid time value.
   */
  min = cloneDate(MIN_TIME);
  /**
   * Specifies the biggest valid time value.
   */
  max = cloneDate(MAX_TIME);
  /**
   * Determines whether to display the **Cancel** button in the popup.
   */
  cancelButton = true;
  /**
   * Determines whether to display the **Set** button in the popup.
   */
  setButton = true;
  /**
   * Determines whether to display the **Now** button in the popup.
   *
   * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.
   */
  nowButton = true;
  /**
   * Sets or gets the `disabled` property of the TimeSelector and determines whether the component is active.
   */
  disabled = false;
  /**
   * Needed in order to set it in the dom service so that timeselector height can be properly calculated
   */
  isAdaptiveEnabled;
  isDateTimePicker;
  /**
   * Configures the incremental steps of the TimeSelector.
   *
   * The available options are:
   * - `hour: Number`&mdash;Controls the incremental step of the hour value.
   * - `minute: Number`&mdash;Controls the incremental step of the minute value.
   * - `second: Number`&mdash;Controls the incremental step of the second value.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-timeselector format="HH:mm:ss" [steps]="steps"></kendo-timeselector>
   * `
   * })
   * export class AppComponent {
   *   public steps = { hour: 2, minute: 15, second: 15 };
   * }
   * ```
   *
   * > If the incremental step is greater than `1`, the **Now** button will be hidden.
   */
  set steps(steps) {
    this._steps = steps || {};
  }
  get steps() {
    return this._steps;
  }
  /**
   * Specifies the value of the TimeSelector component.
   */
  value = null;
  /**
   * Fires each time the user selects a new value.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user cancels the selected value.
   */
  valueReject = new EventEmitter();
  tabOutLastPart = new EventEmitter();
  tabOutFirstPart = new EventEmitter();
  tabOutNow = new EventEmitter();
  dateFormatParts;
  isActive = false;
  showNowButton = true;
  set current(value2) {
    this._current = timeInRange(this.snapTime(cloneDate(value2 || MIDNIGHT_DATE), this.min), this.min, this.max);
    if (!NgZone.isInAngularZone()) {
      this.cdr.detectChanges();
    }
  }
  get current() {
    return this._current;
  }
  get activeListIndex() {
    return this._activeListIndex;
  }
  set activeListIndex(value2) {
    this._activeListIndex = value2;
    if (!this.timeListWrappers || !this.timeListWrappers.length) {
      return;
    }
    this.timeListWrappers.forEach((listWrapper) => {
      this.renderer.removeClass(listWrapper.nativeElement, "k-focus");
    });
    if (value2 >= 0) {
      const listIndex = this.listIndex(value2);
      const focusedWrapper = this.timeListWrappers.toArray()[listIndex];
      if (focusedWrapper) {
        this.renderer.addClass(focusedWrapper.nativeElement, "k-focus");
      }
    }
  }
  mergeValue;
  snapTime;
  _activeListIndex = -1;
  _current;
  _steps = {};
  subscriptions;
  domEvents = [];
  constructor(localization, cdr, element, intl, dom, zone, renderer, pickerService) {
    this.localization = localization;
    this.cdr = cdr;
    this.element = element;
    this.intl = intl;
    this.dom = dom;
    this.zone = zone;
    this.renderer = renderer;
    this.pickerService = pickerService;
    if (this.pickerService) {
      this.pickerService.timeSelector = this;
    }
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));
    if (this.localization) {
      this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    }
    this.renderer.addClass(this.element.nativeElement, "k-timeselector");
    this.dom.isAdaptiveEnabled = this.isAdaptiveEnabled;
    this.dom.isDateTimePicker = this.isDateTimePicker;
    this.dom.calculateHeights(this.element.nativeElement);
    this.init();
    this.bindEvents();
  }
  /**
   * @hidden
   */
  ngOnChanges(_) {
    this.init();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.pickerService) {
      this.pickerService.timeSelector = null;
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  /**
   * Focuses the TimeSelector component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="timeselector.focus()">Focus time picker</button>
   *  <kendo-timeselector #timeselector></kendo-timeselector>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    const list2 = this.timeLists.first;
    if (!list2) {
      return;
    }
    list2.focus();
  }
  /**
   * Blurs the TimeSelector component.
   */
  blur() {
    const list2 = this.timeLists.first;
    if (!list2) {
      return;
    }
    list2.blur();
  }
  /**
   * @hidden
   */
  handleAccept() {
    this.handleChange(this.mergeValue(cloneDate(this.value || getDate(getNow())), this.current));
  }
  /**
   * @hidden
   */
  handleNow() {
    this.current = getNow();
    this.handleChange(this.current);
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleReject() {
    this.current = this.value;
    this.valueReject.emit();
  }
  /**
   * @hidden
   */
  handleFocus(args) {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    this.emitFocus(args);
  }
  /**
   * @hidden
   */
  handleListFocus(args) {
    const index = parseInt(args.target.getAttribute("data-timelist-index"), 10);
    this.activeListIndex = index;
    this.handleFocus(args);
  }
  /**
   * @hidden
   */
  handleBlur(args) {
    const currentTarget = currentFocusTarget(args);
    if (currentTarget && this.containsElement(currentTarget)) {
      return;
    }
    this.activeListIndex = -1;
    this.isActive = false;
    this.emitBlur(args);
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.element.nativeElement));
  }
  /**
   * @hidden
   */
  handleTabOut(event2) {
    const {
      keyCode,
      shiftKey
    } = event2;
    if (event2.target === this.now?.nativeElement && keyCode === Keys.Tab && shiftKey) {
      event2.preventDefault();
      if (this.isDateTimePicker) {
        this.tabOutNow.emit();
      } else {
        this.cancel ? this.cancel.nativeElement.focus() : this.accept?.nativeElement.focus();
      }
      return;
    }
    if (keyCode === Keys.Tab && !shiftKey && event2.target !== this.now?.nativeElement) {
      event2.preventDefault();
      if (document.activeElement === this.accept.nativeElement) {
        if (this.cancel) {
          this.cancel.nativeElement.focus();
        } else {
          this.now ? this.now.nativeElement.focus() : this.timeLists.first.focus();
        }
      } else {
        this.now ? this.now.nativeElement.focus() : this.timeLists.first.focus();
      }
    }
  }
  partStep(part) {
    return this.steps[part.type] || 1;
  }
  init(changes) {
    if (!changes || hasChange(changes, "format")) {
      this.dateFormatParts = this.intl.splitDateFormat(this.format);
      this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
    }
    if (!changes || hasChange(changes, "steps")) {
      this.snapTime = snapTime(generateSnappers(this.steps));
    }
    if (!changes || hasChange(changes, "value")) {
      this.current = this.value;
    }
    this.showNowButton = !this.hasSteps() && this.nowButton && isInTimeRange(getNow(), this.min, this.max);
  }
  focusList(dir) {
    if (!this.timeLists.length) {
      return;
    }
    this.timeLists.reduce(listReducer, []).map((state) => dir === Direction2.Right ? state.next : state.prev).map((list2) => list2 && list2.focus());
  }
  handleChange(value2) {
    this.value = value2;
    this.valueChange.emit(cloneDate(value2));
  }
  hasActiveButton() {
    if (!this.accept) {
      return false;
    }
    return [this.accept, this.cancel, this.now].reduce((isActive2, el) => isActive2 || this.dom.isActive(el), false);
  }
  hasSteps() {
    const keys = Object.keys(this.steps);
    return keys.length !== keys.reduce((acc, k) => acc + this.steps[k], 0);
  }
  intlChange() {
    this.dateFormatParts = this.intl.splitDateFormat(this.format);
    this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
    this.cdr.markForCheck();
  }
  bindEvents() {
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.domEvents.push(this.renderer.listen(this.element.nativeElement, "keydown", this.handleKeydown.bind(this)));
      });
    }
  }
  handleKeydown(args) {
    const {
      keyCode,
      altKey
    } = args;
    const arrowKeyPressed = [Keys.ArrowLeft, Keys.ArrowRight].indexOf(keyCode) !== -1;
    if (isPresent2(this.pickerService) && arrowKeyPressed && altKey) {
      return;
    }
    if (keyCode === Keys.Enter && !this.hasActiveButton()) {
      this.handleAccept();
    } else if (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight) {
      this.focusList(keyCode === Keys.ArrowLeft ? Direction2.Left : Direction2.Right);
    }
  }
  emitBlur(args) {
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
  }
  emitFocus(args) {
    if (this.pickerService) {
      this.pickerService.onFocus.emit(args);
    }
  }
  listIndex(partIndex) {
    let listIdx = 0;
    let partIdx = 0;
    while (partIdx < partIndex) {
      if (this.dateFormatParts[partIdx].type !== "literal") {
        listIdx++;
      }
      partIdx++;
    }
    return listIdx;
  }
  static ɵfac = function TimeSelectorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeSelectorComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(TimePickerDOMService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeSelectorComponent,
    selectors: [["kendo-timeselector"]],
    viewQuery: function TimeSelectorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c20, 5);
        ɵɵviewQuery(_c21, 5);
        ɵɵviewQuery(_c22, 5);
        ɵɵviewQuery(TimeListComponent, 5);
        ɵɵviewQuery(_c23, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accept = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cancel = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.now = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timeLists = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timeListWrappers = _t);
      }
    },
    hostVars: 2,
    hostBindings: function TimeSelectorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      format: "format",
      min: "min",
      max: "max",
      cancelButton: "cancelButton",
      setButton: "setButton",
      nowButton: "nowButton",
      disabled: "disabled",
      isAdaptiveEnabled: "isAdaptiveEnabled",
      isDateTimePicker: "isDateTimePicker",
      steps: "steps",
      value: "value"
    },
    outputs: {
      valueChange: "valueChange",
      valueReject: "valueReject",
      tabOutLastPart: "tabOutLastPart",
      tabOutFirstPart: "tabOutFirstPart",
      tabOutNow: "tabOutNow"
    },
    exportAs: ["kendo-timeselector"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.timeselector"
    }]), ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 4,
    consts: () => {
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_17 = goog.getMsg("Set");
        i18n_17 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.timeselector.accept|The Accept button text in the timeselector component:Set`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_18 = goog.getMsg("Set time");
        i18n_18 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component:Set time`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_19 = goog.getMsg("Cancel");
        i18n_19 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.timeselector.cancel|The Cancel button text in the timeselector component:Cancel`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_20 = goog.getMsg("Cancel changes");
        i18n_20 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component:Cancel changes`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_21 = goog.getMsg("Now");
        i18n_21 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.timeselector.now|The Now button text in the timeselector component:Now`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_22 = goog.getMsg("Select now");
        i18n_22 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.timeselector.nowLabel|The label for the Now button in the timeselector component:Select now`;
      }
      return [["now", ""], ["listWrapper", ""], ["accept", ""], ["cancel", ""], ["kendoTimeSelectorLocalizedMessages", "", "accept", i18n_17, "acceptLabel", i18n_18, "cancel", i18n_19, "cancelLabel", i18n_20, "now", i18n_21, "nowLabel", i18n_22], [1, "k-time-header"], [1, "k-title", "k-timeselector-title"], ["type", "button", "class", "k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary k-time-now", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], [1, "k-time-list-container"], [1, "k-time-highlight"], ["ngFor", "", 3, "ngForOf"], ["class", "k-time-footer k-actions k-actions-stretched k-actions-horizontal", 4, "ngIf"], ["type", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-primary", "k-time-now", 3, "kendoEventsOutsideAngular", "scope", "disabled"], ["class", "k-time-list-wrapper", "role", "presentation", "tabindex", "-1", 4, "ngIf"], ["class", "k-time-separator", 4, "ngIf"], ["role", "presentation", "tabindex", "-1", 1, "k-time-list-wrapper"], [3, "valueChange", "tabOutLastPart", "tabOutFirstPart", "isLast", "isFirst", "min", "max", "part", "step", "disabled", "value", "kendoEventsOutsideAngular", "scope"], [1, "k-time-separator"], [1, "k-time-footer", "k-actions", "k-actions-stretched", "k-actions-horizontal"], ["type", "button", "class", "k-button k-time-accept k-button-md k-rounded-md k-button-solid k-button-solid-primary", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], ["class", "k-button k-time-cancel k-button-md k-rounded-md k-button-solid k-button-solid-base", "type", "button", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], ["type", "button", 1, "k-button", "k-time-accept", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-primary", 3, "kendoEventsOutsideAngular", "scope", "disabled"], ["type", "button", 1, "k-button", "k-time-cancel", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "scope", "disabled"]];
    },
    template: function TimeSelectorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 4);
        ɵɵelementStart(1, "div", 5)(2, "span", 6);
        ɵɵtext(3);
        ɵɵelementEnd();
        ɵɵtemplate(4, TimeSelectorComponent_button_4_Template, 3, 11, "button", 7);
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 8);
        ɵɵelement(6, "span", 9);
        ɵɵtemplate(7, TimeSelectorComponent_ng_template_7_Template, 2, 2, "ng-template", 10);
        ɵɵelementEnd();
        ɵɵtemplate(8, TimeSelectorComponent_div_8_Template, 3, 2, "div", 11);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵtextInterpolate1(" ", ctx.intl.formatDate(ctx.current, ctx.format), " ");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showNowButton);
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.dateFormatParts);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.setButton || ctx.cancelButton);
      }
    },
    dependencies: [TimeSelectorLocalizedMessagesDirective, NgIf, EventsOutsideAngularDirective, NgForOf, TimeListComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-timeselector",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.timeselector"
      }],
      selector: "kendo-timeselector",
      template: `
        <ng-container kendoTimeSelectorLocalizedMessages
            i18n-accept="kendo.timeselector.accept|The Accept button text in the timeselector component"
            accept="Set"

            i18n-acceptLabel="kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component"
            acceptLabel="Set time"

            i18n-cancel="kendo.timeselector.cancel|The Cancel button text in the timeselector component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component"
            cancelLabel="Cancel changes"

            i18n-now="kendo.timeselector.now|The Now button text in the timeselector component"
            now="Now"

            i18n-nowLabel="kendo.timeselector.nowLabel|The label for the Now button in the timeselector component"
            nowLabel="Select now"
        >
        </ng-container>
        <div class="k-time-header">
            <span class="k-title k-timeselector-title">
                {{ intl.formatDate(current, format) }}
            </span>
            <button
                #now
                *ngIf="showNowButton"
                type="button"
                class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary k-time-now"
                [attr.title]="localization.get('nowLabel')"
                [attr.aria-label]="localization.get('nowLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleNow,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('now')}}</button>
        </div>
        <div class="k-time-list-container">
            <span class="k-time-highlight"></span>
            <ng-template ngFor [ngForOf]="dateFormatParts" let-part let-idx="index">
                <div
                    #listWrapper
                    class="k-time-list-wrapper"
                    role="presentation" tabindex="-1"
                    *ngIf="part.type !== 'literal'"
                >
                    <span class="k-title k-timeselector-title">{{intl.dateFieldName(part)}}</span>
                    <kendo-timelist
                        [isLast]="idx === dateFormatParts.length - 1"
                        [isFirst]="idx === 0"
                        [min]="min"
                        [max]="max"
                        [part]="part"
                        [step]="partStep(part)"
                        [disabled]="disabled"
                        [(value)]="current"
                        (tabOutLastPart)="tabOutLastPart.emit()"
                        (tabOutFirstPart)="tabOutFirstPart.emit()"
                        [kendoEventsOutsideAngular]="{
                            focus: handleListFocus,
                            blur: handleBlur
                        }"
                        [scope]="this"
                        [attr.data-timelist-index]="idx"
                    ></kendo-timelist>
                </div>
                <div class="k-time-separator" *ngIf="part.type === 'literal'">
                    {{part.pattern}}
                </div>
            </ng-template>
        </div>
        <div class="k-time-footer k-actions k-actions-stretched k-actions-horizontal" *ngIf="setButton || cancelButton">
            <button
                #accept
                *ngIf="setButton"
                type="button"
                class="k-button k-time-accept k-button-md k-rounded-md k-button-solid k-button-solid-primary"
                [attr.title]="localization.get('acceptLabel')"
                [attr.aria-label]="localization.get('acceptLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleAccept,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('accept')}}</button>
            <button
                #cancel
                *ngIf="cancelButton"
                class="k-button k-time-cancel k-button-md k-rounded-md k-button-solid k-button-solid-base"
                type="button"
                [attr.title]="localization.get('cancelLabel')"
                [attr.aria-label]="localization.get('cancelLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleReject,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('cancel')}}</button>
        </div>
    `,
      standalone: true,
      imports: [TimeSelectorLocalizedMessagesDirective, NgIf, EventsOutsideAngularDirective, NgForOf, TimeListComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: IntlService
    }, {
      type: TimePickerDOMService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: PickerService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    accept: [{
      type: ViewChild,
      args: ["accept", {
        static: false
      }]
    }],
    cancel: [{
      type: ViewChild,
      args: ["cancel", {
        static: false
      }]
    }],
    now: [{
      type: ViewChild,
      args: ["now", {
        static: false
      }]
    }],
    timeLists: [{
      type: ViewChildren,
      args: [TimeListComponent]
    }],
    timeListWrappers: [{
      type: ViewChildren,
      args: ["listWrapper"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    format: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    setButton: [{
      type: Input
    }],
    nowButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    isAdaptiveEnabled: [{
      type: Input
    }],
    isDateTimePicker: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    valueReject: [{
      type: Output
    }],
    tabOutLastPart: [{
      type: Output
    }],
    tabOutFirstPart: [{
      type: Output
    }],
    tabOutNow: [{
      type: Output
    }]
  });
})();
var timeRangeValidator = (min, max) => {
  return (control) => {
    if (!min || !max || !control.value) {
      return null;
    }
    const err = {
      timeRangeError: {
        maxValue: max,
        minValue: min,
        value: control.value
      }
    };
    return isInTimeRange(control.value, min, max) ? null : err;
  };
};
var TimeSelectorCustomMessagesComponent = class _TimeSelectorCustomMessagesComponent extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TimeSelectorCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeSelectorCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeSelectorCustomMessagesComponent,
    selectors: [["kendo-timeselector-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimeSelectorCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function TimeSelectorCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimeSelectorCustomMessagesComponent)
      }],
      selector: "kendo-timeselector-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var TimePickerLocalizedMessagesDirective = class _TimePickerLocalizedMessagesDirective extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function TimePickerLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimePickerLocalizedMessagesDirective,
    selectors: [["", "kendoTimePickerLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimePickerLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimePickerLocalizedMessagesDirective)
      }],
      selector: "[kendoTimePickerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var VALUE_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/timepicker/#toc-integration-with-json";
var INTL_DATE_FORMAT = "https://github.com/telerik/kendo-intl/blob/master/docs/date-formatting/index.md";
var formatRegExp2 = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.millisecond}|${TIME_PART.dayperiod}|literal`);
var ACCEPT_BUTTON_SELECTOR$1 = ".k-button.k-time-accept";
var CANCEL_BUTTON_SELECTOR = ".k-button.k-time-cancel";
var TimePickerComponent = class _TimePickerComponent extends MultiTabStop {
  bus;
  zone;
  localization;
  cdr;
  popupService;
  wrapper;
  renderer;
  injector;
  pickerService;
  intl;
  /**
   * @hidden
   */
  clockIcon = clockIcon;
  container;
  popupTemplate;
  toggleButton;
  actionSheet;
  /**
   * @hidden
   */
  focusableId;
  /**
   * Sets or gets the `disabled` property of the TimePicker and
   * determines whether the component is active
   * ([see example]({% slug disabled_timepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_timepicker#toc-managing-the-timepicker-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the TimePicker
   * ([see example]({% slug readonly_timepicker %}#toc-read-only-timepicker)).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the read-only state of the TimePicker input field
   * ([see example]({% slug readonly_timepicker %}#toc-read-only-input)).
   *
   * > Note that if you set the [`readonly`]({% slug api_dateinputs_timepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   */
  readOnlyInput = false;
  /**
   * If set to `true`, renders a clear button after the input text or TimePicker value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Specifies the time format that is used to display the input value
   * ([see example]({% slug formats_timepicker %})).
   */
  format = "t";
  /**
   * Defines the descriptions of the format sections in the input field.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_timepicker %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   * <div class="row example-wrapper" [style.min-height.px]="450">
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Full-length format description:</p>
   *    <kendo-timepicker formatPlaceholder="wide"></kendo-timepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Narrow-length format description:</p>
   *    <kendo-timepicker formatPlaceholder="narrow"></kendo-timepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Short-length format description:</p>
   *    <kendo-timepicker formatPlaceholder="short"></kendo-timepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Display defined format:</p>
   *    <kendo-timepicker format="HH:mm:ss" formatPlaceholder="formatPattern"></kendo-timepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Custom defined format descriptions</p>
   *    <kendo-timepicker format="HH:mm:ss"
   *      [formatPlaceholder]="{ hour: 'H', minute: 'm', second: 's' }"
   *    ></kendo-timepicker>
   *  </div>
   * </div>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  formatPlaceholder;
  /**
   * Specifies the hint the TimePicker displays when its value is `null`.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_timepicker %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-timepicker placeholder="Enter start..."></kendo-timepicker>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  placeholder = null;
  /**
   * Specifies the smallest valid time value
   * ([see example]({% slug timeranges_timepicker %})).
   */
  set min(min) {
    this._min = cloneDate(min || MIN_TIME);
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies the biggest valid time value
   * ([see example]({% slug timeranges_timepicker %})).
   */
  set max(max) {
    this._max = cloneDate(max || MAX_TIME);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * Determines whether to display the **Cancel** button in the popup.
   */
  cancelButton = true;
  /**
   * Determines whether to display the **Now** button in the popup.
   *
   * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.
   */
  nowButton = true;
  /**
   * Configures the incremental steps of the TimePicker.
   * For more information, refer to the article on
   * [incremental steps]({% slug incrementalsteps_timepicker %}).
   *
   * > If the incremental step is greater than `1`, the **Now** button will be hidden.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-timepicker format="HH:mm:ss" [steps]="steps"></kendo-timepicker>
   * `
   * })
   * class AppComponent {
   *   public steps = { hour: 2, minute: 15, second: 15, millisecond: 10 };
   * }
   * ```
   *
   */
  set steps(steps) {
    this._steps = steps || {};
  }
  get steps() {
    return this._steps;
  }
  /**
   * Configures the popup of the TimePicker.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, {
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets or gets the `tabindex` property of the TimePicker.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the title of the input element of the TimePicker and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  title = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  set subtitle(subtitle) {
    this._subtitle = subtitle;
  }
  get subtitle() {
    return this._subtitle || this.placeholder;
  }
  _subtitle;
  /**
   * Determines whether the built-in min or max validators are enforced when a form is being validated.
   */
  rangeValidation = true;
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Specifies the value of the TimePicker component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value2) {
    this.verifyValue(value2);
    this._value = cloneDate(value2);
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size ? size : DEFAULT_SIZE;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `solid` (Default)
   * * `flat`
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_timepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_timepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_timepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_timepicker)).
   * This event is preventable. If you cancel the event, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_timepicker)).
   * This event is preventable. If you cancel the event, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * @hidden
   */
  wrapperClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  get popupUID() {
    return `k-timepicker-popup-${this.bus.calendarId}-`;
  }
  popupRef;
  /**
   * @hidden
   */
  xIcon = xIcon;
  get isActive() {
    return this._active;
  }
  set isActive(value2) {
    this._active = value2;
    if (!this.wrapper) {
      return;
    }
    const element = this.wrapper.nativeElement;
    if (value2) {
      this.renderer.addClass(element, "k-focus");
    } else {
      this.renderer.removeClass(element, "k-focus");
    }
  }
  get show() {
    return this._show;
  }
  set show(show) {
    if (show && (this.disabled || this.readonly)) {
      return;
    }
    const skipZone = !show && (!this._show || !hasObservers(this.close) && !hasObservers(this.open));
    if (!skipZone) {
      this.zone.run(() => {
        const event2 = new PreventableEvent2();
        if (!this._show && show) {
          this.open.emit(event2);
        } else if (this._show && !show) {
          this.close.emit(event2);
        }
        if (event2.isDefaultPrevented()) {
          return;
        }
        this.toggleTimeSelector(show);
      });
    } else {
      this.toggleTimeSelector(show);
    }
  }
  get dateInput() {
    return this.pickerService.input;
  }
  get timeSelector() {
    return this.pickerService.timeSelector;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control);
  }
  get adaptiveAcceptButton() {
    return this.actionSheet.element.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR$1);
  }
  get adaptiveCancelButton() {
    return this.actionSheet.element.nativeElement.querySelector(CANCEL_BUTTON_SELECTOR);
  }
  get inputElement() {
    return this.wrapper.nativeElement.querySelector("input");
  }
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  resolvedPromise = Promise.resolve(null);
  timeRangeValidateFn = noop$2;
  incompleteValidator = noop$2;
  _min = cloneDate(MIN_TIME);
  _max = cloneDate(MAX_TIME);
  _popupSettings = {
    animate: true
  };
  _show = false;
  _steps = {};
  _value = null;
  _active = false;
  localizationChangeSubscription;
  pickerSubscriptions;
  windowBlurSubscription;
  control;
  domEvents = [];
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  windowSize;
  constructor(bus, zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, intl) {
    super();
    this.bus = bus;
    this.zone = zone;
    this.localization = localization;
    this.cdr = cdr;
    this.popupService = popupService;
    this.wrapper = wrapper;
    this.renderer = renderer;
    this.injector = injector;
    this.pickerService = pickerService;
    this.intl = intl;
    validatePackage(packageMetadata);
    this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));
    this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty
   */
  isEmpty() {
    return !this.value && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.control = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
    this.focusableId = this.dateInput?.focusableId;
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    this.setComponentClasses();
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {
      this.timeRangeValidateFn = this.rangeValidation ? timeRangeValidator(this.min, this.max) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (changes.format) {
      this.verifyFormat();
    }
    if (!this.focusableId || changes.focusableId) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.isActive = false;
    this.show = false;
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    this.pickerSubscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  handleKeydown(event2) {
    const {
      altKey,
      keyCode
    } = event2;
    if (keyCode === Keys.Escape) {
      this.focusInput();
      this.show = false;
      hasObservers(this.escape) && this.escape.emit();
      this.cdr.detectChanges();
      return;
    }
    if (altKey) {
      if (keyCode === Keys.ArrowUp) {
        event2.preventDefault();
        this.focusInput();
        this.show = false;
        this.cdr.detectChanges();
      }
      if (keyCode === Keys.ArrowDown && !this.show) {
        event2.preventDefault();
        this.show = true;
      }
    }
  }
  /**
   * @hidden
   */
  writeValue(value2) {
    this.verifyValue(value2);
    this.value = cloneDate(value2);
    this.cdr.markForCheck();
    if (!value2 && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value2);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.timeRangeValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * Focuses the TimePicker component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="timepicker.focus()">Focus time picker</button>
   *  <kendo-timepicker #timepicker></kendo-timepicker>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    this.dateInput.focus();
  }
  /**
   * Blurs the TimePicker component.
   */
  blur() {
    (this.timeSelector || this.dateInput)["blur"]();
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show - The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.resolvedPromise.then(() => {
      this.toggleTimeSelector(show === void 0 ? !this.show : show);
    });
  }
  /**
   * Indicates whether the component is currently open. That is when the popup or actionSheet is open.
   */
  get isOpen() {
    return this.show;
  }
  /**
   * @hidden
   */
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  handleChange(value2) {
    if (isEqual(this.value, value2)) {
      if (this.show) {
        this.focusInput();
        this.show = false;
      }
      return;
    }
    this.value = cloneDate(value2);
    this.zone.run(() => {
      if (this.show) {
        this.focusInput();
        this.show = false;
      }
      this.dateInput.showClearButton = true;
      this.onControlChange(cloneDate(value2));
      this.valueChange.emit(cloneDate(value2));
    });
  }
  /**
   * @hidden
   */
  handleActionSheetAccept() {
    this.timeSelector.handleAccept();
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleReject() {
    this.focusInput();
    this.show = false;
  }
  /**
   * @hidden
   */
  handleInputChange(value2) {
    const val = this.dateInput.formatSections["date"] ? value2 : this.mergeTime(value2);
    this.handleChange(val);
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = windowSize();
    if (this.isAdaptive) {
      this.show = true;
    }
  }
  /**
   * @hidden
   */
  onTabOutNow() {
    if (!this.timeSelector.showNowButton) {
      this.cancelButton ? this.timeSelector.cancel.nativeElement.focus() : this.timeSelector.accept.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  handleMousedown(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  handleIconClick(event2) {
    if (this.disabled || this.readonly) {
      return;
    }
    event2.preventDefault();
    this.focusInput();
    this.handleFocus();
    this.show = !this.show;
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  get popupClasses() {
    return ["k-timepicker-popup"].concat(this.popupSettings.popupClass || []);
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  normalizeTime(date) {
    return setTime(MIDNIGHT_DATE, date);
  }
  /**
   * @hidden
   */
  mergeTime(value2) {
    return this.value && value2 ? setTime(this.value, value2) : value2;
  }
  /**
   * @hidden
   */
  onResize() {
    if (!this.isOpen || this.windowSize === windowSize()) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = windowSize();
  }
  /**
   * @hidden
   */
  onTabOutLastPart() {
    this.renderer.removeClass(this.timeSelector.timeListWrappers.last.nativeElement, "k-focus");
    if (this.isAdaptive) {
      this.cancelButton ? this.adaptiveCancelButton.focus() : this.adaptiveAcceptButton.focus();
    } else {
      this.timeSelector.accept.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutFirstPart() {
    this.renderer.removeClass(this.timeSelector.timeListWrappers.first.nativeElement, "k-focus");
    if (this.timeSelector.showNowButton) {
      this.timeSelector.now.nativeElement.focus();
    } else {
      this.cancelButton ? this.timeSelector.cancel.nativeElement.focus() : this.timeSelector.accept.nativeElement.focus();
    }
  }
  toggleTimeSelector(show) {
    this.windowSize = windowSize();
    if (this.isAdaptive) {
      this.toggleActionSheet(show);
    } else {
      this.togglePopup(show);
    }
    this.toggleFocus();
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.isOpen) {
      this.actionSheet.toggle();
      this.updateActionSheetAdaptiveAppearance();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    } else if (!show && this.isOpen) {
      this.renderer.setStyle(this.timeSelector.element.nativeElement, "pointer-events", "none");
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
      }
      this.actionSheet.toggle();
    }
    this._show = show;
  }
  togglePopup(show) {
    if (show === this.isOpen) {
      return;
    }
    this._show = show;
    this.cdr.markForCheck();
    if (show) {
      const direction = this.localization.rtl ? "right" : "left";
      const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
      this.popupRef = this.popupService.open({
        anchor: this.wrapper,
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.popupSettings.animate,
        appendTo: this.appendTo,
        content: this.popupTemplate,
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        popupClass: this.popupClasses,
        positionMode: appendToComponent ? "fixed" : "absolute"
      });
      this.popupRef.popupElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);
    } else {
      this.popupRef.close();
      this.popupRef = null;
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaControls);
      }
    }
  }
  updateActionSheetAdaptiveAppearance() {
    let element;
    let animationContainer;
    if (this.actionSheet) {
      element = this.actionSheet["element"].nativeElement.querySelector(".k-actionsheet");
      animationContainer = this.actionSheet["element"].nativeElement.querySelector(".k-child-animation-container");
      if (this.windowSize === "medium") {
        this.renderer.removeClass(element, "k-actionsheet-fullscreen");
        this.renderer.removeStyle(animationContainer, "height");
      } else if (this.windowSize === "small") {
        this.renderer.addClass(element, "k-actionsheet-fullscreen");
        this.renderer.setStyle(animationContainer, "height", "100%");
      }
      this.renderer.addClass(element, "k-adaptive-actionsheet");
      this.renderer.addClass(element, "k-actionsheet-bottom");
      this.renderer.setStyle(animationContainer, "bottom", "0px");
    }
  }
  focusInput() {
    if (touchEnabled) {
      return;
    }
    this.dateInput.focus();
  }
  toggleFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.show) {
      if (!this.timeSelector) {
        this.cdr.detectChanges();
      }
      if (this.isActive) {
        this.timeSelector.focus();
      }
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  verifyValue(value2) {
    if (!isDevMode()) {
      return;
    }
    if (value2 && !(value2 instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$1} for possible resolution.`);
    }
  }
  verifyFormat() {
    if (!isDevMode()) {
      return;
    }
    const formatContainsDateParts = this.intl.splitDateFormat(this.format).some((part) => !formatRegExp2.test(part.type));
    if (formatContainsDateParts) {
      throw new Error(`Provided format is not supported. Supported specifiers are T|t|H|h|m|s|S|a. See ${INTL_DATE_FORMAT}`);
    }
  }
  bindEvents() {
    const element = this.wrapper.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)));
    if (isWindowAvailable()) {
      this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this));
    }
  }
  handleWindowBlur() {
    if (!this.isOpen || this.actionSheet.expanded) {
      return;
    }
    this.show = false;
  }
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.zone.run(() => {
        this.onFocus.emit();
      });
    }
  }
  handleBlur(args) {
    const currentTarget = args && currentFocusTarget(args);
    const target = args && args.target;
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(target) || this.actionSheet.element.nativeElement.contains(currentTarget));
    if (currentTarget && (this.dateInput.containsElement(currentTarget) || this.timeSelector && this.timeSelector.containsElement(currentTarget) || isInsideActionSheet)) {
      return;
    }
    if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {
      this.zone.run(() => {
        this.blurComponent();
        this.cdr.markForCheck();
      });
    } else {
      this.blurComponent();
    }
    this.cdr.detectChanges();
  }
  blurComponent() {
    this.isActive = false;
    this.show = false;
    this.onControlTouched();
    this.onBlur.emit();
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.zone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function TimePickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(IntlService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimePickerComponent,
    selectors: [["kendo-timepicker"]],
    viewQuery: function TimePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 5, ViewContainerRef);
        ɵɵviewQuery(_c15, 5);
        ɵɵviewQuery(_c16, 7);
        ɵɵviewQuery(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function TimePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-timepicker", ctx.wrapperClasses)("k-input", ctx.wrapperClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      clearButton: "clearButton",
      format: "format",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      min: "min",
      max: "max",
      incompleteDateValidation: "incompleteDateValidation",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      cancelButton: "cancelButton",
      nowButton: "nowButton",
      steps: "steps",
      popupSettings: "popupSettings",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      title: "title",
      subtitle: "subtitle",
      rangeValidation: "rangeValidation",
      adaptiveMode: "adaptiveMode",
      value: "value",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur",
      open: "open",
      close: "close",
      escape: "escape"
    },
    exportAs: ["kendo-timepicker"],
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TimePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _TimePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TimePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _TimePickerComponent)
    }, LocalizationService, BusViewService, {
      provide: L10N_PREFIX,
      useValue: "kendo.timepicker"
    }, PickerService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 17,
    vars: 34,
    consts: () => {
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_23 = goog.getMsg("Set");
        i18n_23 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.timepicker.accept|The Accept button text in the timepicker component:Set`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_24 = goog.getMsg("Set time");
        i18n_24 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component:Set time`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_25 = goog.getMsg("Cancel");
        i18n_25 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.timepicker.cancel|The Cancel button text in the timepicker component:Cancel`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_26 = goog.getMsg("Cancel changes");
        i18n_26 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component:Cancel changes`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_27 = goog.getMsg("Now");
        i18n_27 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.timepicker.now|The Now button text in the timepicker component:Now`;
      }
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_28 = goog.getMsg("Select now");
        i18n_28 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.timepicker.nowLabel|The label for the Now button in the timepicker component:Select now`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_29 = goog.getMsg("Toggle time list");
        i18n_29 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.timepicker.toggle|The label for the toggle button in the timepicker component:Toggle time list`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_30 = goog.getMsg("Hour");
        i18n_30 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.timepicker.hour|The label for the hour part in the timepicker component:Hour`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_31 = goog.getMsg("Minute");
        i18n_31 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.timepicker.minute|The label for the minute part in the timepicker component:Minute`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_32 = goog.getMsg("Second");
        i18n_32 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.timepicker.second|The label for the second part in the timepicker component:Second`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_33 = goog.getMsg("Millisecond");
        i18n_33 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.timepicker.millisecond|The label for the millisecond part in the timepicker component:Millisecond`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_34 = goog.getMsg("Dayperiod");
        i18n_34 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.timepicker.dayperiod|The label for the dayperiod part in the timepicker component:Dayperiod`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_35 = goog.getMsg("clear");
        i18n_35 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.timepicker.clearTitle|The title of the clear button:clear`;
      }
      return [["input", ""], ["toggleButton", ""], ["popupTemplate", ""], ["container", ""], ["actionSheet", ""], ["timeSelectorTemplate", ""], ["timeSelector", ""], ["kendoTimePickerLocalizedMessages", "", "accept", i18n_23, "acceptLabel", i18n_24, "cancel", i18n_25, "cancelLabel", i18n_26, "now", i18n_27, "nowLabel", i18n_28, "toggle", i18n_29, "hour", i18n_30, "minute", i18n_31, "second", i18n_32, "millisecond", i18n_33, "dayperiod", i18n_34, "clearTitle", i18n_35], ["pickerType", "timepicker", "hasPopup", "dialog", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "isPopupOpen", "disabled", "clearButton", "readonly", "role", "ariaReadOnly", "format", "formatPlaceholder", "placeholder", "focusableId", "min", "max", "incompleteDateValidation", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "steps", "tabindex", "isRequired", "title", "inputAttributes", "value"], [3, "clearTitle"], ["type", "button", "tabindex", "-1", 1, "k-input-button", "k-button", "k-icon-button", 3, "kendoEventsOutsideAngular", "scope"], ["name", "clock", "innerCssClass", "k-button-icon", 3, "svgIcon"], [3, "resize", 4, "ngIf"], [3, "overlayClick", "collapse", "titleId"], ["kendoActionSheetTemplate", ""], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group", "k-hbox"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "x", "fillMode", "flat", "size", "large", "aria-hidden", "true", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content", "!k-overflow-hidden"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel", 3, "click"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 1, "k-time-accept", 3, "click"], [3, "valueChange", "valueReject", "tabOutLastPart", "tabOutFirstPart", "tabOutNow", "cancelButton", "setButton", "nowButton", "format", "min", "max", "steps", "value", "isAdaptiveEnabled", "kendoEventsOutsideAngular", "scope"], [3, "acceptLabel", "accept", "cancelLabel", "cancel", "nowLabel", "now", "hour", "minute", "second", "millisecond", "dayperiod"]];
    },
    template: function TimePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8, 0);
        ɵɵlistener("valueChange", function TimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputChange($event));
        })("click", function TimePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(3, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 10, 1);
        ɵɵelement(6, "kendo-icon-wrapper", 11);
        ɵɵelementEnd();
        ɵɵtemplate(7, TimePickerComponent_ng_template_7_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(9, null, 3);
        ɵɵtemplate(11, TimePickerComponent_kendo_resize_sensor_11_Template, 1, 0, "kendo-resize-sensor", 12);
        ɵɵelementStart(12, "kendo-actionsheet", 13, 4);
        ɵɵlistener("overlayClick", function TimePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function TimePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, TimePickerComponent_ng_template_14_Template, 16, 12, "ng-template", 14);
        ɵɵelementEnd();
        ɵɵtemplate(15, TimePickerComponent_ng_template_15_Template, 3, 27, "ng-template", null, 5, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("isPopupOpen", ctx.show)("disabled", ctx.disabled)("clearButton", ctx.clearButton)("readonly", ctx.readonly || ctx.readOnlyInput)("role", "combobox")("ariaReadOnly", ctx.readonly)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("focusableId", ctx.focusableId)("min", ctx.normalizeTime(ctx.min))("max", ctx.normalizeTime(ctx.max))("incompleteDateValidation", ctx.incompleteDateValidation)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("steps", ctx.steps)("tabindex", !ctx.show ? ctx.tabindex : -1)("isRequired", ctx.isControlRequired)("title", ctx.title)("inputAttributes", ctx.inputAttributes)("value", ctx.value);
        ɵɵadvance(2);
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(31, _c18, ctx.handleIconClick, ctx.handleMousedown))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"));
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.clockIcon);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("titleId", ctx.focusableId);
      }
    },
    dependencies: [TimePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, NgIf, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-timepicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TimePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => TimePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TimePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => TimePickerComponent)
      }, LocalizationService, BusViewService, {
        provide: L10N_PREFIX,
        useValue: "kendo.timepicker"
      }, PickerService],
      selector: "kendo-timepicker",
      template: `
        <ng-container kendoTimePickerLocalizedMessages
            i18n-accept="kendo.timepicker.accept|The Accept button text in the timepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component"
            acceptLabel="Set time"

            i18n-cancel="kendo.timepicker.cancel|The Cancel button text in the timepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component"
            cancelLabel="Cancel changes"

            i18n-now="kendo.timepicker.now|The Now button text in the timepicker component"
            now="Now"

            i18n-nowLabel="kendo.timepicker.nowLabel|The label for the Now button in the timepicker component"
            nowLabel="Select now"

            i18n-toggle="kendo.timepicker.toggle|The label for the toggle button in the timepicker component"
            toggle="Toggle time list"

            i18n-hour="kendo.timepicker.hour|The label for the hour part in the timepicker component"
            hour="Hour"

            i18n-minute="kendo.timepicker.minute|The label for the minute part in the timepicker component"
            minute="Minute"

            i18n-second="kendo.timepicker.second|The label for the second part in the timepicker component"
            second="Second"

            i18n-millisecond="kendo.timepicker.millisecond|The label for the millisecond part in the timepicker component"
            millisecond="Millisecond"

            i18n-dayperiod="kendo.timepicker.dayperiod|The label for the dayperiod part in the timepicker component"
            dayperiod="Dayperiod"

            i18n-clearTitle="kendo.timepicker.clearTitle|The title of the clear button"
            clearTitle="clear"
        >
        </ng-container>
        <kendo-dateinput
            #input
            pickerType="timepicker"
            hasPopup="dialog"
            [isPopupOpen]="show"
            [disabled]="disabled"
            [clearButton]="clearButton"
            [readonly]="readonly || readOnlyInput"
            [role]="'combobox'"
            [ariaReadOnly]="readonly"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [focusableId]="focusableId"
            [min]="normalizeTime(min)"
            [max]="normalizeTime(max)"
            [incompleteDateValidation]="incompleteDateValidation"
            [autoSwitchParts]="autoSwitchParts"
            [autoSwitchKeys]="autoSwitchKeys"
            [enableMouseWheel]="enableMouseWheel"
            [allowCaretMode]="allowCaretMode"
            fillMode="none"
            rounded="none"
            size="none"
            [steps]="steps"
            [tabindex]="!show ? tabindex : -1"
            [isRequired]="isControlRequired"
            [title]="title"
            [inputAttributes]="inputAttributes"
            [value]="value"
            (valueChange)="handleInputChange($event)"
            (click)="handleDateInputClick()"
        >
            <kendo-dateinput-messages
                [clearTitle]="localization.get('clearTitle')"
            >
            </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
            #toggleButton
            type="button"
            tabindex="-1"
            class="k-input-button k-button k-icon-button"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [kendoEventsOutsideAngular]="{
                click: handleIconClick,
                mousedown: handleMousedown
            }"
            [scope]="this"
        >
            <kendo-icon-wrapper
                name="clock"
                [svgIcon]="clockIcon"
                innerCssClass="k-button-icon"
            >
            </kendo-icon-wrapper>
        </button>
        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="timeSelectorTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>

        <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <kendo-actionsheet 
            #actionSheet
            (overlayClick)="show=false"
            (collapse)="handleActionSheetCollapse()"
            [titleId]="focusableId"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group k-hbox">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ title }}</div>
                            <div class="k-actionsheet-subtitle k-text-center">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="x"
                                [attr.title]="localization.get('clearTitle')"
                                [svgIcon]="xIcon"
                                fillMode="flat"
                                size="large"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                innerCssClass="k-button-icon"
                                (click)="show = false">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content !k-overflow-hidden">
                    <ng-container *ngTemplateOutlet="timeSelectorTemplate"></ng-container>
                </div>
                <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button kendoButton 
                        type="button"
                        (click)="handleReject()"
                        size="large"
                        class="k-time-cancel"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                    >
                        {{localization.get('cancel')}}
                    </button>

                    <button kendoButton
                        type="button"
                        (click)="handleActionSheetAccept()"
                        size="large"
                        class="k-time-accept"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>

        <ng-template #timeSelectorTemplate>
            <kendo-timeselector
                #timeSelector
                [class.k-timeselector-lg]="isAdaptive"
                [cancelButton]="cancelButton && !this.isAdaptive"
                [setButton]="!isAdaptive"
                [nowButton]="nowButton"
                [format]="format"
                [min]="min"
                [max]="max"
                [steps]="steps"
                [value]="value"
                [isAdaptiveEnabled]="isAdaptiveModeEnabled"
                [kendoEventsOutsideAngular]="{
                    keydown: handleKeydown,
                    mousedown: handleMousedown
                }"
                [scope]="this"
                (valueChange)="handleChange($event)"
                (valueReject)="handleReject()"
                (tabOutLastPart)="onTabOutLastPart()"
                (tabOutFirstPart)="onTabOutFirstPart()"
                (tabOutNow)="onTabOutNow()"
            >
                <kendo-timeselector-messages
                    [acceptLabel]="localization.get('acceptLabel')"
                    [accept]="localization.get('accept')"
                    [cancelLabel]="localization.get('cancelLabel')"
                    [cancel]="localization.get('cancel')"
                    [nowLabel]="localization.get('nowLabel')"
                    [now]="localization.get('now')"
                    [hour]="localization.get('hour')"
                    [minute]="localization.get('minute')"
                    [second]="localization.get('second')"
                    [millisecond]="localization.get('millisecond')"
                    [dayperiod]="localization.get('dayperiod')"
                >
                </kendo-timeselector-messages>
            </kendo-timeselector>
        </ng-template>
    `,
      standalone: true,
      imports: [TimePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, NgIf, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: NgZone
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PopupService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: PickerService
    }, {
      type: IntlService
    }];
  }, {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: false
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: false
      }]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    focusableId: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    nowButton: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    escape: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-timepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var DateTimePickerMessages = class _DateTimePickerMessages extends ComponentMessages {
  /**
   * The title of the **Toggle** button of the DateTimePicker.
   */
  toggle;
  /**
   * The text of the **Date** tab in the popup header of the DateTimePicker.
   */
  dateTab;
  /**
   * The label of the **Date** tab in the popup header of the DateTimePicker.
   */
  dateTabLabel;
  /**
   * The text of the **Time** tab in the popup header of the DateTimePicker.
   */
  timeTab;
  /**
   * The label of the **Time** tab in the popup header of the DateTimePicker.
   */
  timeTabLabel;
  /**
   * The text of the **Accept** button in the popup footer of the DateTimePicker.
   */
  accept;
  /**
   * The label of the **Accept** button in the popup footer of the DateTimePicker.
   */
  acceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the DateTimePicker.
   */
  cancel;
  /**
   * The label of the **Cancel** button in the popup footer of the DateTimePicker.
   */
  cancelLabel;
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The text of the **Now** button in the popup header of the TimePicker.
   */
  now;
  /**
   * The label of the **Now** button in the popup header of the TimePicker.
   */
  nowLabel;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  /**
   * The label of the **Hour** part in the TimePicker.
   */
  hour;
  /**
   * The label of the **Minute** part in the TimePicker.
   */
  minute;
  /**
   * The label of the **Second** part in the TimePicker.
   */
  second;
  /**
   * The label of the **Millisecond** part in the TimePicker.
   */
  millisecond;
  /**
   * The label of the **Dayperiod** part in the TimePicker.
   */
  dayperiod;
  /**
   * The title of the **Clear** button of the DateTimePicker.
   */
  clearTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateTimePickerMessages_BaseFactory;
    return function DateTimePickerMessages_Factory(__ngFactoryType__) {
      return (ɵDateTimePickerMessages_BaseFactory || (ɵDateTimePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_DateTimePickerMessages)))(__ngFactoryType__ || _DateTimePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateTimePickerMessages,
    selectors: [["kendo-datetimepicker-messages-base"]],
    inputs: {
      toggle: "toggle",
      dateTab: "dateTab",
      dateTabLabel: "dateTabLabel",
      timeTab: "timeTab",
      timeTabLabel: "timeTabLabel",
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel",
      today: "today",
      now: "now",
      nowLabel: "nowLabel",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle",
      hour: "hour",
      minute: "minute",
      second: "second",
      millisecond: "millisecond",
      dayperiod: "dayperiod",
      clearTitle: "clearTitle"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-datetimepicker-messages-base"
    }]
  }], null, {
    toggle: [{
      type: Input
    }],
    dateTab: [{
      type: Input
    }],
    dateTabLabel: [{
      type: Input
    }],
    timeTab: [{
      type: Input
    }],
    timeTabLabel: [{
      type: Input
    }],
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    today: [{
      type: Input
    }],
    now: [{
      type: Input
    }],
    nowLabel: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }],
    hour: [{
      type: Input
    }],
    minute: [{
      type: Input
    }],
    second: [{
      type: Input
    }],
    millisecond: [{
      type: Input
    }],
    dayperiod: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective = class _LocalizedMessagesDirective extends DateTimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoDateTimePickerLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: DateTimePickerMessages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateTimePickerMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective)
      }],
      selector: "[kendoDateTimePickerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var timeFormatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.dayperiod}|literal`);
var VALUE_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/integration-with-json/";
var MIN_MAX_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/date-time-limits/";
var DEFAULT_ACTIVE_TAB = "date";
var DEFAULT_DATEINPUT_FORMAT = "g";
var DEFAULT_TIMESELECTOR_FORMAT = "t";
var TWO_DIGIT_YEAR_MAX = 68;
var ACCEPT_BUTTON_SELECTOR = ".k-button.k-time-accept";
var CANCEL_BUTTON_SELECOTR = ".k-button.k-time-cancel";
var DATE_TAB_BUTTON_SELECTOR = ".k-button.k-group-start";
var TIME_TAB_BUTTON_SELECTOR = ".k-button.k-group-end";
var TODAY_BUTTON_SELECTOR = ".k-button.k-calendar-nav-today";
var DateTimePickerComponent = class _DateTimePickerComponent extends MultiTabStop {
  popupService;
  intl;
  cdr;
  pickerService;
  ngZone;
  wrapper;
  localization;
  disabledDatesService;
  renderer;
  injector;
  /**
   * @hidden
   */
  calendarIcon = calendarIcon;
  /**
   * @hidden
   */
  clockIcon = clockIcon;
  /**
   * @hidden
   */
  hostClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  toggleButton;
  /**
   * @hidden
   */
  get dateInput() {
    return this.pickerService.input;
  }
  /**
   * @hidden
   */
  get calendar() {
    return this.pickerService.calendar;
  }
  /**
   * @hidden
   */
  get timeSelector() {
    return this.pickerService.timeSelector;
  }
  /**
   * @hidden
   */
  focusableId;
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Displays the days that fall out of the current month in the Calendar ([see example]({% slug datetimepicker_calendar_options %}#toc-displaying-other-month-days)).
   * The default values per Calendar type are:
   * - `infinite` - false
   * - `classic` - true
   */
  showOtherMonthDays;
  /**
   * Specifies the value of the DateTimePicker component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value2) {
    this.verifyValue(value2);
    this._value = cloneDate(value2);
    this.setCalendarValue(value2);
    this.cdr.markForCheck();
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the date format for displaying the input value
   * ([see example]({% slug formats_datetimepicker %}))
   *
   * Format value options:
   * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
   * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
   *
   * > If a [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) object is provided, the `displayFormat` value will be used for the popup TimePicker.
   */
  set format(format) {
    this._format = format;
    const displayFormat = this.getDisplayFormat(format);
    this.timeSelectorFormat = this.getTimeSelectorFormat(displayFormat);
  }
  get format() {
    return this._format;
  }
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_datetimepicker %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the DateTimePicker.
   */
  set tabindex(value2) {
    const tabindex = Number(value2);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return this.disabled ? -1 : this._tabindex;
  }
  /**
   * Sets the dates of the DateTimePicker that will be disabled
   * ([see example]({% slug disabled_dates_datetimepicker %})).
   */
  set disabledDates(value2) {
    this._disabledDates = value2;
    this.disabledDatesService.initialize(value2);
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Configures the popup settings of the DateTimePicker
   * ([see example]({% slug datetimepicker_popup_options %}#toc-customizing-the-popup)).
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, {
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the title of the input element of the DateTimePicker and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  title = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  set subtitle(subtitle) {
    this._subtitle = subtitle;
  }
  get subtitle() {
    return this._subtitle || this.placeholder;
  }
  _subtitle;
  /**
   * Sets or gets the `disabled` property of the DateTimePicker and determines whether the component is active
   * ([see example]({% slug disabled_datetimepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_datetimepicker#toc-managing-the-datetimepicker-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the DateTimePicker
   * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-datetimepicker)).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the read-only state of the DateTimePicker input field
   * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-input)).
   *
   * > Note that if you set the [`readonly`]({% slug api_dateinputs_datetimepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   */
  readOnlyInput = false;
  /**
   * Determines whether to display the **Cancel** button in the popup
   * ([see example]({% slug datetimepicker_popup_options %}#toc-toggling-the-cancel-button)).
   */
  cancelButton = true;
  /**
   * Defines the descriptions of the format sections in the input field
   * ([see example]({% slug placeholders_datetimepicker %}#toc-format-sections-description)).
   */
  formatPlaceholder;
  /**
   * Specifies the hint which is displayed by the DateTimePicker when its value is `null`
   * ([see example]({% slug placeholders_datetimepicker %}#toc-text-hints)).
   */
  placeholder;
  /**
   * Configures the incremental steps of the DateInput and the popup component of the TimePicker
   * ([see example]({% slug incrementalsteps_datetimepicker %})).
   */
  steps = {};
  /**
   * Specifies the focused date of the popup Calendar
   * ([see example]({% slug datetimepicker_calendar_options %}#toc-focused-dates)).
   */
  focusedDate;
  /**
   * Specifies the Calendar type.
   *
   * The possible values are:
   * - `infinite` (default)
   * - `classic`
   *
   */
  calendarType = "infinite";
  /**
   * Determines whether to enable animation when navigating to previous/next Calendar view.
   * Applies to the [`classic`]({% slug api_dateinputs_datetimepickercomponent %}#toc-calendartype) Calendar only.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateCalendarNavigation = false;
  /**
   * Determines whether to display a week number column in the `month` view of the popup Calendar
   * ([see example]({% slug datetimepicker_calendar_options %}#toc-week-number-column)).
   */
  weekNumber = false;
  /**
   * Specifies the smallest valid date.
   * The Calendar will not display dates before this value.
   * If the `min` value of the Calendar is selected, the TimePicker will not display
   * time entries before the specified time portion of this value
   * ([see example]({% slug dateranges_datetimepicker %})).
   */
  set min(value2) {
    this._min = cloneDate(value2);
    this.calendarMin = getDate(value2 || MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies the biggest valid date.
   * The Calendar will not display dates after this value.
   * If the `max` value of the Calendar is selected, the TimePicker will not display
   * time entries after the specified time portion of this value
   * ([see example]({% slug dateranges_datetimepicker %})).
   */
  set max(value2) {
    this._max = cloneDate(value2);
    this.calendarMax = lastMillisecondOfDate(value2 || MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form
   * ([see example](slug:dateranges_datetimepicker)).
   */
  rangeValidation = true;
  /**
   * Determines whether the built-in validator for disabled
   * date ranges is enforced when validating a form
   * ([see example](slug:disabled_dates_datetimepicker)).
   */
  disabledDatesValidation = true;
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to autocorrect invalid segments automatically.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * If set to `true`, renders a clear button after the input text or DateTimePicker value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * When enabled, the DateTimePicker will autofill the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_datetimepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_datetimepicker)).
   * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_datetimepicker)).
   * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires each time the user focuses the component
   * ([see example](slug:events_datetimepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the user blurs the component
   * ([see example](slug:events_datetimepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * Indicates whether the component is currently open. That is when the popup or actionSheet is open.
   */
  get isOpen() {
    if (!this.isAdaptive) {
      return isPresent2(this.popupRef);
    }
    return isTruthy(this.actionSheet?.expanded);
  }
  /**
   * Indicates whether the component or its popup content is focused.
   */
  get isActive() {
    return this._isActive;
  }
  set isActive(value2) {
    if (value2) {
      this.renderer.addClass(this.wrapper.nativeElement, "k-focus");
    } else {
      this.renderer.removeClass(this.wrapper.nativeElement, "k-focus");
    }
    this._isActive = value2;
  }
  /**
   * Sets the active tab on opening the popup
   * ([see example]({% slug datetimepicker_popup_options %}#toc-setting-the-default-tab)).
   */
  set defaultTab(tab) {
    this._defaultTab = tab || DEFAULT_ACTIVE_TAB;
    this.activeTab = this.defaultTab;
  }
  get defaultTab() {
    return this._defaultTab;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size ? size : DEFAULT_SIZE;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `solid` (Default)
   * * `flat`
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * @hidden
   */
  get tabSwitchTransition() {
    return this.isOpen ? null : "none";
  }
  /**
   * @hidden
   *
   * Indicates whether the Calendar will be disabled.
   * The inactive tab component gets disabled and becomes inaccessible on tab click.
   */
  get disableCalendar() {
    return this.activeTab !== "date" && !this.calendar.isActive;
  }
  /**
   * @hidden
   *
   * Indicates whether the TimeSelector will be disabled.
   * The inactive tab component gets disabled and becomes inaccessible on tab click.
   */
  get disableTimeSelector() {
    return this.activeTab !== "time" && !this.timeSelector.isActive;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  onResize() {
    if (!this.isOpen || this.windowSize === windowSize()) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this._togglePopup(false);
    }
    this.windowSize = windowSize();
  }
  /**
   * @hidden
   *
   * Controls whether the Calendar or the TimeSelector will be displayed.
   */
  activeTab = DEFAULT_ACTIVE_TAB;
  /**
   * @hidden
   *
   * Specifies the stripped time-related format that is used in the TimeSelector.
   * Updates each time the `format` property value changes.
   */
  timeSelectorFormat = DEFAULT_TIMESELECTOR_FORMAT;
  /**
   * @hidden
   */
  timeSelectorMin = cloneDate(MIN_TIME);
  /**
   * @hidden
   */
  timeSelectorMax = cloneDate(MAX_TIME);
  /**
   * @hidden
   */
  calendarValue = null;
  /**
   * @hidden
   */
  calendarMin = cloneDate(MIN_DATE);
  /**
   * @hidden
   */
  calendarMax = lastMillisecondOfDate(MAX_DATE);
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  cellTemplate;
  /**
   * @hidden
   */
  monthCellTemplate;
  /**
   * @hidden
   */
  yearCellTemplate;
  /**
   * @hidden
   */
  decadeCellTemplate;
  /**
   * @hidden
   */
  centuryCellTemplate;
  /**
   * @hidden
   */
  weekNumberTemplate;
  /**
   * @hidden
   */
  headerTitleTemplate;
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  set headerTemplateRef(template) {
    this.headerTemplate = template;
  }
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  set footerTemplateRef(template) {
    this.footerTemplate = template;
  }
  /**
   * Toggles the visibility of the Calendar footer.
   * @default false
   */
  footer = false;
  get activeTabComponent() {
    if (!this.isOpen) {
      return;
    }
    if (!(isPresent2(this.calendar) || isPresent2(this.timeSelector))) {
      this.cdr.detectChanges();
    }
    return this.activeTab === "date" ? this.calendar : this.timeSelector;
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!isPresent2(appendTo) || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  container;
  popupTemplate;
  actionSheet;
  get popupUID() {
    return this.calendar?.popupId;
  }
  get acceptButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR);
    }
  }
  get cancelButtonElement() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(CANCEL_BUTTON_SELECOTR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(CANCEL_BUTTON_SELECOTR);
    }
  }
  get dateTabButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(DATE_TAB_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(DATE_TAB_BUTTON_SELECTOR);
    }
  }
  get timeTabButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(TIME_TAB_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(TIME_TAB_BUTTON_SELECTOR);
    }
  }
  get todayButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(TODAY_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(TODAY_BUTTON_SELECTOR);
    }
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  popupRef;
  _popupSettings = {
    animate: true
  };
  _value = null;
  _format = DEFAULT_DATEINPUT_FORMAT;
  _tabindex = 0;
  _defaultTab = DEFAULT_ACTIVE_TAB;
  _min = mergeDateAndTime(MIN_DATE, MIN_TIME);
  _max = mergeDateAndTime(MAX_DATE, MAX_TIME);
  _disabledDates;
  _isActive = false;
  onControlTouched = noop$2;
  onControlChange = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesValidateFn = noop$2;
  incompleteValidator = noop$2;
  subscriptions = new Subscription();
  ariaActiveDescendantSubscription;
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  windowSize;
  constructor(popupService, intl, cdr, pickerService, ngZone, wrapper, localization, disabledDatesService, renderer, injector) {
    super();
    this.popupService = popupService;
    this.intl = intl;
    this.cdr = cdr;
    this.pickerService = pickerService;
    this.ngZone = ngZone;
    this.wrapper = wrapper;
    this.localization = localization;
    this.disabledDatesService = disabledDatesService;
    this.renderer = renderer;
    this.injector = injector;
    validatePackage(packageMetadata);
  }
  ngOnInit() {
    this.subscriptions.add(this.pickerService.onFocus.pipe(tap(this.detectPopupChanges.bind(this))).subscribe(this.handleFocus.bind(this)));
    this.subscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.subscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleCalendarValueChange.bind(this)));
    this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    this.subscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
    if (isWindowAvailable()) {
      this.subscriptions.add(this.ngZone.runOutsideAngular(() => fromEvent(window, "blur").subscribe(() => {
        if (!this.isAdaptive) {
          this.handleCancel();
        }
      })));
    }
    this.focusableId = this.dateInput?.focusableId;
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  ngOnChanges(changes) {
    if (isPresent2(changes["min"]) || isPresent2(changes["max"])) {
      this.verifyMinMaxRange();
    }
    if (changes["min"] || changes["max"] || changes["rangeValidation"] || changes["disabledDatesValidation"] || changes["disabledDates"] || changes["incompleteDateValidation"]) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (!this.focusableId || changes["focusableId"]) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  ngOnDestroy() {
    if (this.isOpen && !this.isAdaptive) {
      this.closePopup();
    }
    this.subscriptions.unsubscribe();
  }
  /**
   * * If the popup is closed, focuses the DateTimePicker input.
   * * If the popup is open, the focus is moved to its content.
   */
  focus() {
    if (this.disabled) {
      return;
    }
    if (this.isOpen) {
      this.activeTabComponent.focus();
    } else {
      this.dateInput.focus();
    }
  }
  /**
   * Blurs the DateTimePicker.
   */
  blur() {
    if (this.isOpen && this.activeTabComponent.isActive) {
      this.activeTabComponent.blur();
    } else {
      this.dateInput.blur();
    }
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show - The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly || show === this.isOpen) {
      return;
    }
    this.windowSize = windowSize();
    if (this.isAdaptive) {
      this.toggleActionSheet(show);
    } else {
      this._togglePopup(show);
    }
  }
  /**
   * @hidden
   */
  writeValue(value2) {
    this.verifyValue(value2);
    this.value = cloneDate(value2);
    this.cdr.markForCheck();
    if (!value2 && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value2);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(disabled) {
    this.disabled = disabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   *
   * Used by the TextBoxContainer to determine if the floating label will render in the input.
   */
  isEmpty() {
    return !isPresent2(this.value) && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  handleIconClick(event2) {
    if (this.disabled || this.readonly) {
      return;
    }
    event2.preventDefault();
    const runInZone = !this.isOpen || hasObservers(this.close);
    this.run(runInZone, () => {
      const shouldOpen = !this.isOpen;
      this.handleFocus();
      if (!shouldOpen) {
        this.dateInput.focus();
      }
      this.toggleDateTime(shouldOpen);
      this.switchFocus();
    });
  }
  /**
   * @hidden
   */
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.ngZone.run(() => this.onFocus.emit());
    }
  }
  /**
   * @hidden
   */
  handleBlur(event2) {
    if (!this.isActive || this.focusTargetInComponent(event2)) {
      return;
    }
    this.isActive = false;
    const isNgControlUntouched = this.wrapper.nativeElement.classList.contains("ng-untouched");
    const runInZone = isNgControlUntouched || hasObservers(this.onBlur) || this.isOpen && hasObservers(this.close);
    this.run(runInZone, () => {
      this.onBlur.emit();
      this.onControlTouched();
      this.toggleDateTime(false);
      this.cdr.markForCheck();
    });
  }
  /**
   * @hidden
   */
  changeActiveTab(tab) {
    if (!this.isOpen || this.activeTab === tab) {
      return;
    }
    if (!isEqual(this.timeSelector.value, this.timeSelector.current)) {
      this.timeSelector.handleAccept();
    }
    this.activeTab = tab;
    this.cdr.detectChanges();
    this.detectPopupChanges();
  }
  /**
   * @hidden
   */
  handleTabChangeTransitionEnd(dateTimeSelector, event2) {
    if (event2.target !== dateTimeSelector) {
      return;
    }
    if (this.activeTab === "time") {
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant);
    }
    this.activeTabComponent.focus();
  }
  /**
   * @hidden
   */
  onTabOutLastPart() {
    if (this.calendarValue) {
      this.acceptButton.focus();
    } else if (!this.calendarValue && this.cancelButton) {
      this.cancelButtonElement.focus();
    } else {
      this.dateTabButton.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutFirstPart() {
    if (this.activeTab === "time") {
      this.renderer.removeClass(this.timeSelector.timeListWrappers.first.nativeElement, "k-focus");
      this.timeSelector.showNowButton ? this.timeSelector.now.nativeElement.focus() : this.timeTabButton.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutNow() {
    this.timeTabButton.focus();
  }
  /**
   * @hidden
   */
  handleAccept() {
    if (!this.isOpen) {
      return;
    }
    const candidate = mergeDateAndTime(this.calendar.value, this.timeSelector.current);
    const valueChangePresent = !isEqual(this.value, candidate);
    const runInZone = valueChangePresent || hasObservers(this.close);
    this.run(runInZone, () => {
      this.handleValueChange(candidate);
      this.dateInput.focus();
      this.toggleDateTime(false);
    });
  }
  /**
   * @hidden
   */
  handleCancel() {
    if (!this.isOpen) {
      return;
    }
    const runInZone = hasObservers(this.close);
    this.dateInput.focus();
    this.run(runInZone, () => this.toggleDateTime(false));
    hasObservers(this.escape) && this.escape.emit();
  }
  /**
   * @hidden
   */
  handleInputValueChange(value2) {
    this.handleValueChange(value2);
    if (this.isOpen) {
      this.toggleDateTime(false);
    }
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = windowSize();
    if (this.isAdaptive) {
      this.toggleDateTime(true);
    }
  }
  /**
   * @hidden
   */
  handleCalendarValueChange() {
    this.setTimeSelectorMinMax(this.calendar.value);
    this.changeActiveTab("time");
  }
  /**
   * @hidden
   */
  handleKeyDown(event2) {
    if (this.disabled || this.readonly) {
      return;
    }
    const {
      keyCode,
      altKey
    } = event2;
    switch (keyCode) {
      case (altKey && Keys.ArrowUp):
      case Keys.Escape:
        this.handleCancel();
        break;
      case (!this.isOpen && altKey && Keys.ArrowDown):
        this.ngZone.run(() => this.toggleDateTime(true));
        break;
      case (altKey && Keys.ArrowRight):
        this.changeActiveTab("time");
        break;
      case (altKey && Keys.ArrowLeft):
        this.changeActiveTab("date");
        break;
      case (this.isOpen && this.timeSelector.isActive && isPresent2(this.calendarValue) && Keys.Enter):
        this.handleAccept();
        break;
      default:
        return;
    }
  }
  /**
   * @hidden
   */
  handleTab(event2) {
    event2.preventDefault();
    const {
      shiftKey
    } = event2;
    switch (event2.target) {
      case this.acceptButton:
        if (!shiftKey) {
          this.cancelButton ? this.cancelButtonElement.focus() : this.dateTabButton.focus();
        } else {
          if (this.activeTab === "date") {
            this.calendar.monthView.list.nativeElement.focus();
          } else {
            this.timeSelector.timeLists.last.focus();
          }
        }
        break;
      case this.cancelButtonElement:
        if (this.calendarValue) {
          shiftKey ? this.acceptButton.focus() : this.dateTabButton.focus();
        } else {
          if (shiftKey) {
            if (this.activeTab === "date") {
              this.calendar.monthView.list.nativeElement.focus();
            } else {
              this.timeSelector.timeLists.last.focus();
            }
          } else {
            this.dateTabButton.focus();
          }
        }
        break;
      case this.dateTabButton:
        if (this.cancelButton) {
          this.cancelButtonElement.focus();
        }
        if (!this.cancelButton && this.calendarValue) {
          this.acceptButton.focus();
        }
        if (!this.cancelButton && !this.calendarValue) {
          if (this.activeTab === "date") {
            this.calendar.monthView.list.nativeElement.focus();
          } else {
            this.timeSelector.timeLists.last.focus();
          }
        }
        break;
      case this.timeTabButton:
        if (this.activeTab === "time") {
          this.timeSelector.showNowButton ? this.timeSelector.now.nativeElement.focus() : this.timeSelector.timeLists.first.focus();
        } else {
          this.todayButton.focus();
        }
        break;
      default:
        break;
    }
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
    this.resetActiveTab();
  }
  /**
   * @hidden
   */
  popupButtonsClasses(type) {
    const buttonType = type ? type : "base";
    const sizeClass = `${this.isAdaptive ? getSizeClass("button", "large") : this.size ? getSizeClass("button", this.size) : ""}`;
    return `${sizeClass} ${this.rounded ? getRoundedClass(this.rounded) : ""} ${this.fillMode ? "k-button-" + this.fillMode + " k-button-" + this.fillMode + "-" + buttonType : ""}`;
  }
  /**
   * @hidden
   *
   * Prevents the diversion of the focus from the currently active element in the component.
   */
  preventMouseDown(event2) {
    event2.preventDefault();
  }
  _togglePopup(show) {
    const shouldOpen = isPresent2(show) ? show : !this.isOpen;
    if (shouldOpen) {
      this.openPopup();
      return;
    }
    this.closePopup();
    this.resetActiveTab();
  }
  toggleActionSheet(show) {
    if (isPresent2(show) && show && !this.isOpen) {
      this.actionSheet.toggle();
      this.updateActionSheetAdaptiveAppearance();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.setAriaActiveDescendant();
    } else if (isPresent2(show) && !show && this.isOpen) {
      this.actionSheet.toggle();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
      }
    }
  }
  updateActionSheetAdaptiveAppearance() {
    let element;
    let animationContainer;
    if (this.actionSheet) {
      element = this.actionSheet["element"].nativeElement.querySelector(".k-actionsheet");
      animationContainer = this.actionSheet["element"].nativeElement.querySelector(".k-child-animation-container");
      if (this.windowSize === "medium") {
        this.renderer.removeClass(element, "k-actionsheet-fullscreen");
        this.renderer.removeStyle(animationContainer, "height");
      } else if (this.windowSize === "small") {
        this.renderer.addClass(element, "k-actionsheet-fullscreen");
        this.renderer.setStyle(animationContainer, "height", "100%");
      }
      this.renderer.addClass(element, "k-adaptive-actionsheet");
      this.renderer.addClass(element, "k-actionsheet-bottom");
      this.renderer.setStyle(animationContainer, "bottom", "0px");
    }
  }
  /**
   * Changes the tab and the calendar or clock icon to the designated default.
   */
  resetActiveTab() {
    if (this.activeTab !== this.defaultTab) {
      this.activeTab = this.defaultTab;
      this.cdr.detectChanges();
    }
  }
  verifyValue(value2) {
    if (!isDevMode()) {
      return;
    }
    if (isPresent2(value2) && !(value2 instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK} for possible resolution.`);
    }
  }
  verifyMinMaxRange() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_MAX_DOC_LINK}.`);
    }
  }
  /**
   * Extracts the time slots and the literals that are not preceded by date parts
   * and concatenates the resulting parts into a string.
   * If the provided format value does not contain any time parts,
   * returns the designated format of the default popup component of the TimePicker.
   */
  getTimeSelectorFormat(format) {
    const timeSelectorFormat = this.intl.splitDateFormat(format).filter(this.timeFormatPartFilter).reduce((format2, part) => format2 += part.pattern, "");
    return timeSelectorFormat || DEFAULT_TIMESELECTOR_FORMAT;
  }
  /**
   * Extracts the `displayFormat` from the provided `string | FormatSettings` value.
   * Fallbacks to the default input value, if a falsy value param is passed.
   */
  getDisplayFormat(format) {
    if (!format) {
      return DEFAULT_DATEINPUT_FORMAT;
    }
    if (typeof format === "string") {
      return format;
    } else {
      return format.displayFormat;
    }
  }
  /**
   * The filter expression that filters out all format parts
   * except for `hour`, `minute`, `second`, `dayperiod`, and specific literals.
   * Literals will be left only if they are not preceded by date parts.
   */
  timeFormatPartFilter(part, index, parts) {
    const previousPart = index >= 1 && parts[index - 1];
    if (previousPart && part.type === "literal") {
      return timeFormatRegExp.test(previousPart.type);
    }
    return timeFormatRegExp.test(part.type);
  }
  /**
   * @hidden
   */
  toggleDateTime(open) {
    if (open === this.isOpen) {
      return;
    }
    const event2 = new PreventableEvent2();
    if (open) {
      this.open.emit(event2);
    } else {
      this.close.emit(event2);
    }
    if (event2.isDefaultPrevented()) {
      return;
    }
    this.toggle(open);
    this.switchFocus();
  }
  switchFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.isOpen) {
      this.activeTabComponent.focus();
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  openPopup() {
    this.setCalendarValue(this.value);
    this.setTimeSelectorMinMax(this.value);
    const direction = this.localization.rtl ? "right" : "left";
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      content: this.popupTemplate,
      positionMode: appendToComponent ? "fixed" : "absolute",
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      popupClass: `k-datetime-container k-datetimepicker-popup ${this.popupSettings.popupClass || ""}`,
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      }
    });
    this.popupRef.popupElement.setAttribute("id", this.popupUID);
    this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    this.setAriaActiveDescendant();
    this.popupRef.popupAnchorViewportLeave.subscribe(() => this.handleCancel());
    if (this.calendar.type === "infinite") {
      this.subscriptions.add(fromEvent(this.calendar.monthView.list.nativeElement, "keydown").subscribe((event2) => {
        const {
          keyCode,
          shiftKey
        } = event2;
        if (keyCode === Keys.Tab && !shiftKey) {
          event2.preventDefault();
          if (!this.calendarValue && !this.cancelButton) {
            this.dateTabButton.focus();
          } else if (this.calendarValue) {
            this.acceptButton.focus();
          } else if (this.cancelButton) {
            this.cancelButtonElement.focus();
          }
        }
      }));
    }
  }
  setAriaActiveDescendant() {
    const focusedCellChangeEvent = this.calendar.type === "infinite" ? this.calendar.monthView.focusedCellChange : this.calendar.multiViewCalendar.viewList.focusedCellChange;
    this.ariaActiveDescendantSubscription = focusedCellChangeEvent.subscribe((id) => this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant, id));
  }
  closePopup() {
    if (!this.isOpen) {
      return;
    }
    this.ariaActiveDescendantSubscription.unsubscribe();
    if (this.dateInput) {
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaControls);
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant);
    }
    this.popupRef.close();
    this.popupRef = null;
  }
  handleValueChange(value2) {
    if (isEqual(this.value, value2)) {
      return;
    }
    this.value = cloneDate(value2);
    this.onControlChange(cloneDate(value2));
    this.valueChange.emit(cloneDate(value2));
  }
  /**
   * Indicates whether the focus target is part of this component,
   * that is, whether the focus target is inside the component or in the popup.
   */
  focusTargetInComponent(event2) {
    if (!isPresent2(event2)) {
      return false;
    }
    const relatedTarget = event2.relatedTarget || document.activeElement;
    const focusInPopup = isPresent2(this.popupRef) && this.popupRef.popupElement.contains(relatedTarget);
    const focusInWrapper = this.wrapper.nativeElement.contains(relatedTarget);
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(event2.target) || this.actionSheet.element.nativeElement.contains(relatedTarget));
    return focusInPopup || focusInWrapper || isInsideActionSheet;
  }
  setTimeSelectorMinMax(selectedDate) {
    const minDateSelected = isPresent2(selectedDate) && isPresent2(this.min) && isEqual(getDate(selectedDate), getDate(this.min));
    this.timeSelectorMin = cloneDate(minDateSelected ? this.min : MIN_TIME);
    const maxDateSelected = isPresent2(selectedDate) && isPresent2(this.max) && isEqual(getDate(selectedDate), getDate(this.max));
    this.timeSelectorMax = cloneDate(maxDateSelected ? this.max : MAX_TIME);
  }
  setCalendarValue(value2) {
    const isInCalendarRange = isPresent2(value2) && isInRange(value2, this.calendarMin, this.calendarMax);
    this.calendarValue = isInCalendarRange ? getDate(value2) : null;
  }
  /**
   * If the popup is available, runs a popup change detection.
   */
  detectPopupChanges() {
    if (!this.isOpen || this.isAdaptive) {
      return;
    }
    this.popupRef.popup.changeDetectorRef.detectChanges();
  }
  /**
   * Depending on the predicate `runInZone` value that is passed,
   * runs the provided function either in the Angular or in the current zone.
   */
  run(runInZone, fn) {
    if (runInZone) {
      this.ngZone.run(() => fn());
    } else {
      fn();
    }
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.ngZone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function DateTimePickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateTimePickerComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateTimePickerComponent,
    selectors: [["kendo-datetimepicker"]],
    contentQueries: function DateTimePickerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      }
    },
    viewQuery: function DateTimePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c16, 7);
        ɵɵviewQuery(_c14, 7, ViewContainerRef);
        ɵɵviewQuery(_c15, 7, TemplateRef);
        ɵɵviewQuery(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DateTimePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-datetimepicker", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      focusableId: "focusableId",
      weekDaysFormat: "weekDaysFormat",
      showOtherMonthDays: "showOtherMonthDays",
      value: "value",
      format: "format",
      twoDigitYearMax: "twoDigitYearMax",
      tabindex: "tabindex",
      disabledDates: "disabledDates",
      popupSettings: "popupSettings",
      title: "title",
      subtitle: "subtitle",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      cancelButton: "cancelButton",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      steps: "steps",
      focusedDate: "focusedDate",
      calendarType: "calendarType",
      animateCalendarNavigation: "animateCalendarNavigation",
      weekNumber: "weekNumber",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      disabledDatesValidation: "disabledDatesValidation",
      incompleteDateValidation: "incompleteDateValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      clearButton: "clearButton",
      autoFill: "autoFill",
      adaptiveMode: "adaptiveMode",
      inputAttributes: "inputAttributes",
      defaultTab: "defaultTab",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      headerTemplateRef: [0, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [0, "footerTemplate", "footerTemplateRef"],
      footer: "footer"
    },
    outputs: {
      valueChange: "valueChange",
      open: "open",
      close: "close",
      onFocus: "focus",
      onBlur: "blur",
      escape: "escape"
    },
    exportAs: ["kendo-datetimepicker"],
    features: [ɵɵProvidersFeature([PickerService, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.datetimepicker"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DateTimePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DateTimePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DateTimePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _DateTimePickerComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 17,
    vars: 43,
    consts: () => {
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_36 = goog.getMsg("Date");
        i18n_36 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header:Date`;
      }
      let i18n_37;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_37 = goog.getMsg("Date tab");
        i18n_37 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_37;
      } else {
        i18n_37 = $localize`:kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header:Date tab`;
      }
      let i18n_38;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_38 = goog.getMsg("Time");
        i18n_38 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_38;
      } else {
        i18n_38 = $localize`:kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header:Time`;
      }
      let i18n_39;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_39 = goog.getMsg("Time tab");
        i18n_39 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_39;
      } else {
        i18n_39 = $localize`:kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header:Time tab`;
      }
      let i18n_40;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_40 = goog.getMsg("Toggle popup");
        i18n_40 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_40;
      } else {
        i18n_40 = $localize`:kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component:Toggle popup`;
      }
      let i18n_41;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_41 = goog.getMsg("Set");
        i18n_41 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_41;
      } else {
        i18n_41 = $localize`:kendo.datetimepicker.accept|The Accept button text in the datetimepicker component:Set`;
      }
      let i18n_42;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_42 = goog.getMsg("Set");
        i18n_42 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_42;
      } else {
        i18n_42 = $localize`:kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component:Set`;
      }
      let i18n_43;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_43 = goog.getMsg("Cancel");
        i18n_43 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_43;
      } else {
        i18n_43 = $localize`:kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component:Cancel`;
      }
      let i18n_44;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_44 = goog.getMsg("Cancel");
        i18n_44 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_44;
      } else {
        i18n_44 = $localize`:kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component:Cancel`;
      }
      let i18n_45;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_45 = goog.getMsg("NOW");
        i18n_45 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_45;
      } else {
        i18n_45 = $localize`:kendo.datetimepicker.now|The Now button text in the timepicker component:NOW`;
      }
      let i18n_46;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_46 = goog.getMsg("Select now");
        i18n_46 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_46;
      } else {
        i18n_46 = $localize`:kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component:Select now`;
      }
      let i18n_47;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_47 = goog.getMsg("Today");
        i18n_47 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_47;
      } else {
        i18n_47 = $localize`:kendo.datetimepicker.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_48;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_48 = goog.getMsg("Navigate to previous view");
        i18n_48 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_48;
      } else {
        i18n_48 = $localize`:kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_49;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_49 = goog.getMsg("Navigate to next view");
        i18n_49 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_49;
      } else {
        i18n_49 = $localize`:kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_50;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_50 = goog.getMsg("Navigate to parent view");
        i18n_50 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_50;
      } else {
        i18n_50 = $localize`:kendo.datetimepicker.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      let i18n_51;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_51 = goog.getMsg("Hour");
        i18n_51 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_51;
      } else {
        i18n_51 = $localize`:kendo.datetimepicker.hour|The label for the hour part in the timepicker component:Hour`;
      }
      let i18n_52;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_52 = goog.getMsg("Minute");
        i18n_52 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_52;
      } else {
        i18n_52 = $localize`:kendo.datetimepicker.minute|The label for the minute part in the timepicker component:Minute`;
      }
      let i18n_53;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_53 = goog.getMsg("Second");
        i18n_53 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_53;
      } else {
        i18n_53 = $localize`:kendo.datetimepicker.second|The label for the second part in the timepicker component:Second`;
      }
      let i18n_54;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_54 = goog.getMsg("Millisecond");
        i18n_54 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_54;
      } else {
        i18n_54 = $localize`:kendo.datetimepicker.millisecond|The label for the millisecond part in the timepicker component:Millisecond`;
      }
      let i18n_55;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_55 = goog.getMsg("Dayperiod");
        i18n_55 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_55;
      } else {
        i18n_55 = $localize`:kendo.datetimepicker.dayperiod|The label for the dayperiod part in the timepicker component:Dayperiod`;
      }
      let i18n_56;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_56 = goog.getMsg("clear");
        i18n_56 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_56;
      } else {
        i18n_56 = $localize`:kendo.datetimepicker.clearTitle|The title of the clear button:clear`;
      }
      return [["toggleButton", ""], ["container", ""], ["popupTemplate", ""], ["actionSheet", ""], ["dateTimeTemplate", ""], ["dateTimeSelector", ""], ["calendar", ""], ["kendoDateTimePickerLocalizedMessages", "", "dateTab", i18n_36, "dateTabLabel", i18n_37, "timeTab", i18n_38, "timeTabLabel", i18n_39, "toggle", i18n_40, "accept", i18n_41, "acceptLabel", i18n_42, "cancel", i18n_43, "cancelLabel", i18n_44, "now", i18n_45, "nowLabel", i18n_46, "today", i18n_47, "prevButtonTitle", i18n_48, "nextButtonTitle", i18n_49, "parentViewButtonTitle", i18n_50, "hour", i18n_51, "minute", i18n_52, "second", i18n_53, "millisecond", i18n_54, "dayperiod", i18n_55, "clearTitle", i18n_56], ["pickerType", "datetimepicker", "hasPopup", "dialog", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "value", "format", "clearButton", "twoDigitYearMax", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "formatPlaceholder", "placeholder", "disabled", "focusableId", "readonly", "role", "ariaReadOnly", "steps", "tabindex", "isRequired", "title", "inputAttributes", "isPopupOpen", "kendoEventsOutsideAngular", "scope"], [3, "clearTitle"], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "tabindex", "kendoEventsOutsideAngular", "scope"], ["name", "calendar", "innerCssClass", "k-button-icon", 3, "svgIcon", 4, "ngIf"], ["name", "clock", "innerCssClass", "k-button-icon", 3, "svgIcon", 4, "ngIf"], [3, "resize", 4, "ngIf"], [3, "overlayClick", "collapse", "titleId"], ["kendoActionSheetTemplate", ""], ["name", "calendar", "innerCssClass", "k-button-icon", 3, "svgIcon"], ["name", "clock", "innerCssClass", "k-button-icon", 3, "svgIcon"], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group", "k-hbox"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "x", "fillMode", "flat", "aria-hidden", "true", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content", "!k-overflow-hidden"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "class", "k-time-cancel", "type", "button", "size", "large", 3, "click", 4, "ngIf"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 1, "k-time-accept", 3, "click", "disabled"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel", 3, "click"], [3, "ngClass", "kendoEventsOutsideAngular", "scope"], [1, "k-datetime-buttongroup", 3, "kendoEventsOutsideAngular", "scope"], ["role", "group", 1, "k-button-group", "k-button-group-solid", "k-button-group-stretched"], ["type", "button", 1, "k-button", "k-group-start", 3, "ngClass", "kendoEventsOutsideAngular", "scope"], ["type", "button", 1, "k-button", "k-group-end", 3, "ngClass", "kendoEventsOutsideAngular", "scope"], [1, "k-datetime-selector", 3, "kendoEventsOutsideAngular"], [1, "k-datetime-calendar-wrap"], [3, "valueChange", "focusedDate", "size", "value", "type", "min", "max", "weekDaysFormat", "weekNumber", "navigation", "animateNavigation", "showOtherMonthDays", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "disabled", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"], [1, "k-datetime-time-wrap"], [3, "tabOutLastPart", "tabOutFirstPart", "tabOutNow", "ngClass", "value", "format", "min", "max", "setButton", "cancelButton", "steps", "disabled", "isAdaptiveEnabled", "isDateTimePicker"], [3, "acceptLabel", "accept", "cancelLabel", "cancel", "nowLabel", "now", "hour", "minute", "second", "millisecond", "dayperiod"], ["class", "k-datetime-footer k-actions k-actions-stretched k-actions-horizontal", 3, "kendoEventsOutsideAngular", "scope", 4, "ngIf"], [1, "k-datetime-footer", "k-actions", "k-actions-stretched", "k-actions-horizontal", 3, "kendoEventsOutsideAngular", "scope"], ["type", "button", 1, "k-button", "k-time-accept", 3, "ngClass", "disabled", "kendoEventsOutsideAngular", "scope"], ["type", "button", "class", "k-button k-time-cancel", 3, "ngClass", "kendoEventsOutsideAngular", "scope", 4, "ngIf"], ["type", "button", 1, "k-button", "k-time-cancel", 3, "ngClass", "kendoEventsOutsideAngular", "scope"]];
    },
    template: function DateTimePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8);
        ɵɵlistener("valueChange", function DateTimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputValueChange($event));
        })("click", function DateTimePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(2, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(3, "button", 10, 0);
        ɵɵtemplate(5, DateTimePickerComponent_kendo_icon_wrapper_5_Template, 1, 1, "kendo-icon-wrapper", 11)(6, DateTimePickerComponent_kendo_icon_wrapper_6_Template, 1, 1, "kendo-icon-wrapper", 12);
        ɵɵelementEnd();
        ɵɵelementContainer(7, null, 1);
        ɵɵtemplate(9, DateTimePickerComponent_ng_template_9_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor)(11, DateTimePickerComponent_kendo_resize_sensor_11_Template, 1, 0, "kendo-resize-sensor", 13);
        ɵɵelementStart(12, "kendo-actionsheet", 14, 3);
        ɵɵlistener("overlayClick", function DateTimePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleDateTime(false));
        })("collapse", function DateTimePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, DateTimePickerComponent_ng_template_14_Template, 15, 11, "ng-template", 15);
        ɵɵelementEnd();
        ɵɵtemplate(15, DateTimePickerComponent_ng_template_15_Template, 17, 98, "ng-template", null, 4, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("value", ctx.value)("format", ctx.format)("clearButton", ctx.clearButton)("twoDigitYearMax", ctx.twoDigitYearMax)("min", ctx.min)("max", ctx.max)("incompleteDateValidation", ctx.incompleteDateValidation)("autoCorrectParts", ctx.autoCorrectParts)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("autoFill", ctx.autoFill)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("disabled", ctx.disabled)("focusableId", ctx.focusableId)("readonly", ctx.readonly || ctx.readOnlyInput)("role", "combobox")("ariaReadOnly", ctx.readonly)("steps", ctx.steps)("tabindex", ctx.tabindex)("isRequired", ctx.isControlRequired)("title", ctx.title)("inputAttributes", ctx.inputAttributes)("isPopupOpen", ctx.isOpen)("kendoEventsOutsideAngular", ɵɵpureFunction1(38, _c19, ctx.handleKeyDown))("scope", ctx);
        ɵɵadvance();
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("kendoEventsOutsideAngular", ɵɵpureFunction2(40, _c27, ctx.preventMouseDown, ctx.handleIconClick))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"));
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.activeTab === "date");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.activeTab === "time");
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("titleId", ctx.calendar == null ? null : ctx.calendar.headerId);
      }
    },
    dependencies: [LocalizedMessagesDirective, DateInputComponent, EventsOutsideAngularDirective, DateInputCustomMessagesComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgClass, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-datetimepicker",
      exportAs: "kendo-datetimepicker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [PickerService, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.datetimepicker"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DateTimePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DateTimePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DateTimePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => DateTimePickerComponent)
      }],
      template: `
        <ng-container
            kendoDateTimePickerLocalizedMessages

            i18n-dateTab="kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header"
            dateTab="Date"

            i18n-dateTabLabel="kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header"
            dateTabLabel="Date tab"

            i18n-timeTab="kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header"
            timeTab="Time"

            i18n-timeTabLabel="kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header"
            timeTabLabel="Time tab"

            i18n-toggle="kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component"
            toggle="Toggle popup"

            i18n-accept="kendo.datetimepicker.accept|The Accept button text in the datetimepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component"
            acceptLabel="Set"

            i18n-cancel="kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component"
            cancelLabel="Cancel"

            i18n-now="kendo.datetimepicker.now|The Now button text in the timepicker component"
            now="NOW"

            i18n-nowLabel="kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component"
            nowLabel="Select now"

            i18n-today="kendo.datetimepicker.today|The label for the today button in the calendar header"
            today="Today"

            i18n-prevButtonTitle="kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar"
            prevButtonTitle="Navigate to previous view"

            i18n-nextButtonTitle="kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar"
            nextButtonTitle="Navigate to next view"

            i18n-parentViewButtonTitle="kendo.datetimepicker.parentViewButtonTitle|The title of the parent view button in the calendar header"
            parentViewButtonTitle="Navigate to parent view"

            i18n-hour="kendo.datetimepicker.hour|The label for the hour part in the timepicker component"
            hour="Hour"

            i18n-minute="kendo.datetimepicker.minute|The label for the minute part in the timepicker component"
            minute="Minute"

            i18n-second="kendo.datetimepicker.second|The label for the second part in the timepicker component"
            second="Second"

            i18n-millisecond="kendo.datetimepicker.millisecond|The label for the millisecond part in the timepicker component"
            millisecond="Millisecond"

            i18n-dayperiod="kendo.datetimepicker.dayperiod|The label for the dayperiod part in the timepicker component"
            dayperiod="Dayperiod"

            i18n-clearTitle="kendo.datetimepicker.clearTitle|The title of the clear button"
            clearTitle="clear"
        >
        </ng-container>

        <kendo-dateinput
            [value]="value"
            [format]="format"
            [clearButton]="clearButton"
            [twoDigitYearMax]="twoDigitYearMax"
            [min]="min"
            [max]="max"
            [incompleteDateValidation]="incompleteDateValidation"
            [autoCorrectParts]="autoCorrectParts"
            [autoSwitchParts]="autoSwitchParts"
            [autoSwitchKeys]="autoSwitchKeys"
            [enableMouseWheel]="enableMouseWheel"
            [allowCaretMode]="allowCaretMode"
            [autoFill]="autoFill"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [disabled]="disabled"
            [focusableId]="focusableId"
            [readonly]="readonly || readOnlyInput"
            [role]="'combobox'"
            [ariaReadOnly]="readonly"
            [steps]="steps"
            [tabindex]="tabindex"
            [isRequired]="isControlRequired"
            [title]="title"
            pickerType="datetimepicker"
            hasPopup="dialog"
            [inputAttributes]="inputAttributes"
            [isPopupOpen]="isOpen"
            (valueChange)="handleInputValueChange($event)"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown
            }"
            [scope]="this"
            fillMode="none"
            rounded="none"
            size="none"
            (click)="handleDateInputClick()"
        >
            <kendo-dateinput-messages
                [clearTitle]="localization.get('clearTitle')"
            >
            </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
            #toggleButton
            type="button"
            class="k-input-button k-button k-icon-button"
            [tabindex]="-1"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [kendoEventsOutsideAngular]="{
                mousedown: preventMouseDown,
                click: handleIconClick
            }"
            [scope]="this"
        >
            <kendo-icon-wrapper
                *ngIf="activeTab === 'date'"
                name="calendar"
                [svgIcon]="calendarIcon"
                innerCssClass="k-button-icon"
            >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="activeTab === 'time'"
                name="clock"
                [svgIcon]="clockIcon"
                innerCssClass="k-button-icon"
            >
            </kendo-icon-wrapper>
        </button>

        <ng-container #container></ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="dateTimeTemplate"></ng-container>
        </ng-template>

        <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>

        <kendo-actionsheet
            #actionSheet
            (overlayClick)="toggleDateTime(false)"
            (collapse)="handleActionSheetCollapse()"
            [titleId]="calendar?.headerId"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group k-hbox">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ title }}</div>
                            <div class="k-actionsheet-subtitle k-text-center">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="x"
                                [attr.title]="localization.get('clearTitle')"
                                [svgIcon]="xIcon"
                                fillMode="flat"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                size="large"
                                innerCssClass="k-button-icon"
                                (click)="toggleDateTime(false)">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content !k-overflow-hidden">
                    <ng-container *ngTemplateOutlet="dateTimeTemplate"></ng-container>
                </div>
                <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button kendoButton
                        *ngIf="cancelButton"
                        class="k-time-cancel"
                        type="button"
                        (click)="handleCancel()"
                        size="large"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                    >
                        {{localization.get('cancel')}}
                    </button>

                    <button kendoButton
                        type="button"
                        class="k-time-accept"
                        (click)="handleAccept()"
                        [disabled]="!calendarValue"
                        size="large"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>

        <ng-template #dateTimeTemplate>
            <div
                class="k-datetime-wrap k-{{activeTab}}-tab"
                [ngClass]="{
                    'k-datetime-wrap-md': !isAdaptive,
                    'k-datetime-wrap-lg': isAdaptive
                }"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventMouseDown,
                    keydown: handleKeyDown
                }"
                [scope]="this"
            >
                <div class="k-datetime-buttongroup"
                    [kendoEventsOutsideAngular]="{
                        focusin: handleFocus,
                        focusout: handleBlur
                    }"
                    [scope]="this"
                >
                    <div class="k-button-group k-button-group-solid k-button-group-stretched" role="group">
                        <button
                            type="button"
                            class="k-button k-group-start"
                            [ngClass]="popupButtonsClasses()"
                            [class.k-selected]="activeTab === 'date'"
                            [attr.aria-pressed]="activeTab === 'date' ? 'true' : 'false'"
                            [attr.title]="localization.get('dateTabLabel')"
                            [attr.aria-label]="localization.get('dateTabLabel')"
                            [kendoEventsOutsideAngular]="{
                                click: changeActiveTab.bind(this, 'date'),
                                'keydown.shift.tab': handleTab
                            }"
                            [scope]="this"
                        >
                            {{localization.get('dateTab')}}
                        </button>
                        <button
                            type="button"
                            class="k-button k-group-end"
                            [ngClass]="popupButtonsClasses()"
                            [class.k-selected]="activeTab === 'time'"
                            [attr.aria-pressed]="activeTab === 'time' ? 'true' : 'false'"
                            [attr.title]="localization.get('timeTabLabel')"
                            [attr.aria-label]="localization.get('timeTabLabel')"
                            [kendoEventsOutsideAngular]="{
                                click: changeActiveTab.bind(this, 'time'),
                                'keydown.tab': handleTab
                            }"
                            [scope]="this"
                            
                        >
                            {{localization.get('timeTab')}}
                        </button>
                    </div>
                </div>
                <div
                    #dateTimeSelector
                    class="k-datetime-selector"
                    [style.transition]="tabSwitchTransition"
                    [kendoEventsOutsideAngular]="{
                        transitionend: handleTabChangeTransitionEnd.bind(this, dateTimeSelector)
                    }"
                >
                    <div class="k-datetime-calendar-wrap">
                        <kendo-calendar
                            #calendar
                            [focusedDate]="focusedDate"
                            [size]="isAdaptive ? 'large' : size"
                            [(value)]="calendarValue"
                            [type]="calendarType"
                            [min]="calendarMin"
                            [max]="calendarMax"
                            [weekDaysFormat]="weekDaysFormat"
                            [weekNumber]="weekNumber"
                            [navigation]="false"
                            [animateNavigation]="animateCalendarNavigation"
                            [showOtherMonthDays]="showOtherMonthDays"
                            [cellTemplate]="cellTemplate"
                            [monthCellTemplate]="monthCellTemplate"
                            [yearCellTemplate]="yearCellTemplate"
                            [decadeCellTemplate]="decadeCellTemplate"
                            [centuryCellTemplate]="centuryCellTemplate"
                            [weekNumberTemplate]="weekNumberTemplate"
                            [headerTitleTemplate]="headerTitleTemplate"
                            [headerTemplate]="headerTemplate"
                            [footerTemplate]="footerTemplate"
                            [footer]="footer"
                            [disabled]="disableCalendar"
                            [disabledDates]="disabledDates"
                            (valueChange)="handleCalendarValueChange()"
                        >
                            <kendo-calendar-messages
                                [today]="localization.get('today')"
                                [prevButtonTitle]="localization.get('prevButtonTitle')"
                                [nextButtonTitle]="localization.get('nextButtonTitle')"
                                [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
                            >
                            </kendo-calendar-messages>
                        </kendo-calendar>
                    </div>
                    <div class="k-datetime-time-wrap">
                        <kendo-timeselector
                            [ngClass]="{'k-timeselector-lg': isAdaptive}"
                            [value]="value"
                            [format]="timeSelectorFormat"
                            [min]="timeSelectorMin"
                            [max]="timeSelectorMax"
                            [setButton]="false"
                            [cancelButton]="false"
                            [steps]="steps"
                            [disabled]="disableTimeSelector"
                            [isAdaptiveEnabled]="isAdaptiveModeEnabled"
                            [isDateTimePicker]="true"
                            (tabOutLastPart)="onTabOutLastPart()"
                            (tabOutFirstPart)="onTabOutFirstPart()"
                            (tabOutNow)="onTabOutNow()"
                        >
                            <kendo-timeselector-messages
                                [acceptLabel]="localization.get('acceptLabel')"
                                [accept]="localization.get('accept')"
                                [cancelLabel]="localization.get('cancelLabel')"
                                [cancel]="localization.get('cancel')"
                                [nowLabel]="localization.get('nowLabel')"
                                [now]="localization.get('now')"
                                [hour]="localization.get('hour')"
                                [minute]="localization.get('minute')"
                                [second]="localization.get('second')"
                                [millisecond]="localization.get('millisecond')"
                                [dayperiod]="localization.get('dayperiod')"
                            >
                            </kendo-timeselector-messages>
                        </kendo-timeselector>
                    </div>
                </div>
                <div
                    *ngIf="!isAdaptive"
                    class="k-datetime-footer k-actions k-actions-stretched k-actions-horizontal"
                    [kendoEventsOutsideAngular]="{
                        focusin: handleFocus,
                        focusout: handleBlur
                    }"
                    [scope]="this"
                >
                    <button
                        type="button"
                        class="k-button k-time-accept"
                        [ngClass]="popupButtonsClasses('primary')"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                        [disabled]="!calendarValue"
                        [kendoEventsOutsideAngular]="{
                            click: handleAccept,
                            'keydown.tab': handleTab,
                            'keydown.shift.tab': handleTab
                        }"
                        [scope]="this"
                    >
                        {{localization.get('accept')}}
                    </button>

                    <button
                        *ngIf="cancelButton"
                        type="button"
                        class="k-button k-time-cancel"
                        [ngClass]="popupButtonsClasses()"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                        [kendoEventsOutsideAngular]="{
                            click: handleCancel,
                            'keydown.tab': handleTab,
                            'keydown.shift.tab': handleTab
                        }"
                        [scope]="this"
                    >
                        {{localization.get('cancel')}}
                    </button>
                </div>
            </div>
        </ng-template>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective, DateInputComponent, EventsOutsideAngularDirective, DateInputCustomMessagesComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgClass, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: PopupService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PickerService
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: DisabledDatesService
    }, {
      type: Renderer2
    }, {
      type: Injector
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-datetimepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    focusableId: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    animateCalendarNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesValidation: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    escape: [{
      type: Output
    }],
    defaultTab: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    footer: [{
      type: Input
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        read: TemplateRef,
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }]
  });
})();
var WeekNamesService = class _WeekNamesService {
  intl;
  constructor(intl) {
    this.intl = intl;
  }
  getWeekNames(includeWeekNumber = false, nameType) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType,
      type: "days"
    }), this.intl.firstDay());
    return includeWeekNumber ? [""].concat(weekNames) : weekNames;
  }
  static ɵfac = function WeekNamesService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WeekNamesService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _WeekNamesService,
    factory: _WeekNamesService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WeekNamesService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var DateRangePopupTemplateDirective = class _DateRangePopupTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DateRangePopupTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangePopupTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupTemplateDirective,
    selectors: [["", "kendoDateRangePopupTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangePopupTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var isActive = (cmp) => cmp && cmp.isActive || false;
var hasActiveContent = (popup) => popup && popup.hasActiveContent();
var DateRangeService = class _DateRangeService {
  renderer;
  /**
   * An Observable instance that notifies when the `activeRangeEnd` state is changed.
   */
  activeRangeEnd$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the `focusedDate` is changed.
   */
  focusedDate$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the end `DateInput` component is changed.
   * For example, when a new end `DateInput` is attached or when the old one is detached.
   */
  endInput$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the start `DateInput` component is changed.
   * For example, when a new start `DateInput` is attached or the old one is detached.
   */
  startInput$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the `DateRangePopup` component is changed.
   */
  dateRangePopup$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the state of the selection range is changed.
   */
  range$ = new BehaviorSubject(EMPTY_SELECTIONRANGE);
  /**
   * Gets the current `activeRangeEnd` value.
   */
  get activeRangeEnd() {
    return this.activeRangeEnd$.value;
  }
  /**
   * Gets the current `focusedDate` value.
   */
  get focusedDate() {
    return this.focusedDate$.value;
  }
  /**
   * Gets the `min` range value.
   * The `min` value is extracted from the `start` DateInput value or the `min` value of the Calendar.
   */
  get min() {
    return (this.startInput$.value || {}).min || null;
  }
  /**
   * Gets the `max` range value.
   * The `max` value is extracted from the `end` DateInput value or the `max` value of the Calendar.
   */
  get max() {
    return (this.endInput$.value || {}).max || null;
  }
  /**
   * Gets the current `selectionRange` value.
   */
  get selectionRange() {
    return this.range$.value;
  }
  /**
   * @hidden
   * Gets the start input element.
   */
  get inputStartElement() {
    return this.startInput$.value.inputElement;
  }
  /**
   * @hidden
   * Gets the end input element.
   */
  get inputEndElement() {
    return this.endInput$.value.inputElement;
  }
  /** @hidden */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Activates the registered `DateRangePopup` component.
   * The method opens the popup and focuses the calendar.
   */
  activatePopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (!dateRangePopup) {
      return;
    }
    if (this.startInput$.value) {
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaControls, dateRangePopup.popupUID);
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaExpanded, "true");
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaControls, dateRangePopup.popupUID);
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaExpanded, "true");
    }
    dateRangePopup.activate();
  }
  /**
   * Deactivates the registered `DateRangePopup` component.
   * The method closes the popup.
   */
  deactivatePopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (this.startInput$.value) {
      this.renderer.removeAttribute(this.inputStartElement, attributeNames.ariaControls);
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaExpanded, "false");
      this.renderer.removeAttribute(this.inputStartElement, attributeNames.ariaActiveDescendant);
      this.renderer.removeAttribute(this.inputEndElement, attributeNames.ariaControls);
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaExpanded, "false");
      this.renderer.removeAttribute(this.inputEndElement, attributeNames.ariaActiveDescendant);
    }
    if (!(dateRangePopup && dateRangePopup.show)) {
      return;
    }
    dateRangePopup.show = false;
  }
  /**
   * @hidden
   */
  setActiveDescendent(id) {
    this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaActiveDescendant, id);
    this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaActiveDescendant, id);
  }
  /**
   * @hidden
   *
   * Deactivates the registered `DateRangePopup` component and fires the `cancel` event.
   * The method closes the popup.
   */
  cancelPopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (!(dateRangePopup && dateRangePopup.show)) {
      return;
    }
    dateRangePopup.cancelPopup();
  }
  /**
   * Completes all observables to mitigate possible memory leaks.
   * Calls the method when a component that uses it is destroyed.
   */
  destroy() {
    this.activeRangeEnd$.complete();
    this.dateRangePopup$.complete();
    this.focusedDate$.complete();
    this.endInput$.complete();
    this.startInput$.complete();
    this.range$.complete();
  }
  /**
   * Returns `true` when an active component that is placed inside the `DateRangeComponent` is detected.
   * For example, the opened popup or the focused DateInput.
   *
   * @returns `true` if an active component is present.
   */
  hasActiveComponent() {
    const popup = this.dateRangePopup$.value;
    const isPopup = isActive(popup);
    const isStart = isActive(this.startInput$.value);
    const isEnd = isActive(this.endInput$.value);
    return isPopup || isStart || isEnd || hasActiveContent(popup) || false;
  }
  /**
   * Registers a new start `DateInput` component. Notifies all `startInput$` listeners.
   */
  registerStartInput(startInput) {
    this.startInput$.next(startInput);
  }
  /**
   * Registers a new end `DateInput` component. Notifies all `endInput$` listeners.
   */
  registerEndInput(endInput) {
    this.endInput$.next(endInput);
  }
  /**
   * Registers a new `DateRangePopup` component. Notifies all `dateRangePopup$` listeners.
   */
  registerPopup(dateRangePopup) {
    this.dateRangePopup$.next(dateRangePopup);
  }
  /**
   * Updates the `activeRangeEnd` value. Notifies all `activeRangeEnd$` listeners.
   */
  setActiveRangeEnd(activeRange) {
    if (!activeRange || this.activeRangeEnd === activeRange) {
      return;
    }
    this.activeRangeEnd$.next(activeRange);
  }
  /**
   * Updates the focused date. Notifies all `focusedDate$` listeners.
   */
  setFocusedDate(value2) {
    if (isEqual(this.focusedDate$.value, value2)) {
      return;
    }
    this.focusedDate$.next(value2);
  }
  /**
   * Updates the selection range. Notifies all `range$` listeners.
   */
  setRange(range3 = EMPTY_SELECTIONRANGE) {
    this.range$.next(range3);
  }
  static ɵfac = function DateRangeService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeService)(ɵɵinject(Renderer2, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DateRangeService,
    factory: _DateRangeService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DateRangeSelectionDirective = class _DateRangeSelectionDirective {
  calendar;
  cdr;
  element;
  dateRangeService;
  /**
   * Specifies the auto-correction behavior. If the start date is greater than the end date,
   * the directive fixes the date range to a single date either on input change or on blur
   * ([see example](slug:autocorrect_daterange#toc-calendar-selection-directive)).
   *
   * By default, the auto-correction is triggered on change.
   * To disable this behavior, set the `autoCorrectOn` property to `none`.
   */
  autoCorrectOn = "change";
  /**
   * Gets or sets the selection range of the calendar. When a new range is set,
   * the connected DateRangeService notifies all related parties.
   */
  get selectionRange() {
    return this.calendar ? this.calendar.selectionRange : null;
  }
  set selectionRange(range3) {
    if (!this.isEqualCalendarRange(range3)) {
      this.setSelectionRange(range3);
    }
    if (!isEqualRange(this.dateRangeService.selectionRange, range3)) {
      this.dateRangeService.setRange(range3);
    }
    this.updateFocusedDate(range3);
  }
  /**
   * Gets or sets the active end of the selection range. This option determines which range end will be updated on
   * user interaction. When a new active end is set, the connected DateRangeService notifies all related parties.
   */
  /**
   * Specifies which end of the selection range will be marked as active. The active end gets modified upon user
   * interaction. When a new active end is set, the wired DateRangeService notifies all related components. For
   * example, the start and end DateInput components.
   *
   * > If the selection range is undefined, the value is ignored.
   */
  get activeRangeEnd() {
    return this.calendar.activeRangeEnd;
  }
  set activeRangeEnd(activeRange) {
    if (this.dateRangeService.activeRangeEnd === activeRange) {
      return;
    }
    this.calendar.activeRangeEnd = activeRange;
    this.dateRangeService.setActiveRangeEnd(activeRange);
  }
  /**
   * @hidden
   * When in adaptive mode range should not be set automatically on calendar value change but only on accept
   */
  shouldSetRange = true;
  /**
   * Fires when the active range end is changed. For more information, refer to
   * the section on [events](slug:events_multiviewcalendar).
   */
  activeRangeEndChange = new EventEmitter();
  /**
   * Fires when the selection range is changed. For more information, refer to
   * the section on [events](slug:events_multiviewcalendar).
   */
  selectionRangeChange = new EventEmitter();
  get calendarRange() {
    return this.selectionRange || EMPTY_SELECTIONRANGE;
  }
  calendarSubscriptions = new Subscription();
  range;
  constructor(calendar, cdr, element, renderer, dateRangeService) {
    this.calendar = calendar;
    this.cdr = cdr;
    this.element = element;
    this.dateRangeService = dateRangeService;
    this.dateRangeService = this.dateRangeService || new DateRangeService(renderer);
    renderer.setAttribute(element.nativeElement, "aria-multiselectable", "true");
  }
  ngOnInit() {
    const calendar = this.calendar;
    const dateRangeService = this.dateRangeService;
    calendar.min = either(dateRangeService.min, calendar.min);
    calendar.max = either(dateRangeService.max, calendar.max);
    this.addSubscriptions(calendar.cellEnter.subscribe((value2) => this.handleHover(value2)), calendar.valueChange.subscribe((value2) => this.handleChange(value2)), dateRangeService.focusedDate$.subscribe((focusedDate) => {
      if (!isEqual(calendar.focusedDate, focusedDate)) {
        calendar.focusedDate = focusedDate;
      }
    }), dateRangeService.activeRangeEnd$.subscribe((rangeEnd) => {
      if (calendar.activeRangeEnd === rangeEnd) {
        return;
      }
      calendar.activeRangeEnd = rangeEnd;
      this.activeRangeEndChange.emit(rangeEnd);
      this.cdr.markForCheck();
    }), dateRangeService.range$.subscribe((range3) => {
      if (!this.isEqualCalendarRange(range3)) {
        this.acceptAndEmit(range3);
      }
      this.updateFocusedDate(range3);
    }), fromEvent(this.element.nativeElement, "blur").subscribe(() => this.handleBlur()));
  }
  ngOnDestroy() {
    this.calendarSubscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  handleChange(value2) {
    const service = this.dateRangeService;
    const autoCorrect = this.autoCorrectOn === "change" && this.shouldAutoCorrect(value2);
    const activeEnd = this.calendar.activeRangeEnd !== "end" ? "end" : autoCorrect ? "end" : "start";
    this.range = autoCorrect ? clampRange(value2) : this.updateRange(value2);
    if (!isEqualRange(service.selectionRange, this.range)) {
      this.acceptAndEmit(this.range);
      service.setActiveRangeEnd(activeEnd);
      if (this.shouldSetRange) {
        this.setRange();
      }
    }
  }
  setRange(range3) {
    this.dateRangeService.setRange(this.range ? this.range : range3);
  }
  addSubscriptions(...subscriptions) {
    subscriptions.map((s) => this.calendarSubscriptions.add(s));
  }
  isEqualCalendarRange(range3) {
    return isEqualRange(this.calendar.selectionRange, range3);
  }
  handleBlur() {
    const {
      start,
      end
    } = this.calendarRange;
    const autoCorrect = this.autoCorrectOn === "blur" && start !== null && end !== null && end < start;
    if (autoCorrect) {
      this.dateRangeService.setRange(clampRange(start));
    }
  }
  handleHover(value2) {
    if (this.hasCompleteRange()) {
      return;
    }
    const {
      start,
      end
    } = this.calendarRange;
    const activeRangeEnd = this.calendar.activeRangeEnd;
    const updateRange = start && activeRangeEnd === "end" || end && activeRangeEnd === "start";
    if (updateRange) {
      this.setSelectionRange(this.updateRange(value2));
    }
  }
  hasCompleteRange() {
    const {
      start,
      end
    } = this.dateRangeService.selectionRange || EMPTY_SELECTIONRANGE;
    return Boolean(start) && Boolean(end);
  }
  shouldAutoCorrect(value2) {
    const {
      end,
      start
    } = this.calendarRange;
    if (this.calendar.activeRangeEnd !== "end") {
      return end !== null && value2 > end;
    } else {
      return start !== null && value2 < start;
    }
  }
  updateFocusedDate(range3) {
    if (!range3 || this.dateRangeService.focusedDate) {
      return;
    }
    this.dateRangeService.setFocusedDate(range3.start || range3.end);
  }
  updateRange(value2) {
    const {
      end,
      start
    } = this.calendarRange;
    return this.calendar.activeRangeEnd !== "end" ? {
      start: value2,
      end
    } : {
      start,
      end: value2
    };
  }
  setSelectionRange(range3) {
    this.calendar.selectionRange = range3;
    this.calendar.writeValue(null);
  }
  acceptAndEmit(range3) {
    this.setSelectionRange(range3);
    this.selectionRangeChange.emit(range3);
  }
  static ɵfac = function DateRangeSelectionDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeSelectionDirective)(ɵɵdirectiveInject(MultiViewCalendarComponent), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DateRangeService, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeSelectionDirective,
    selectors: [["", "kendoDateRangeSelection", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      selectionRange: "selectionRange",
      activeRangeEnd: "activeRangeEnd",
      shouldSetRange: "shouldSetRange"
    },
    outputs: {
      activeRangeEndChange: "activeRangeEndChange",
      selectionRangeChange: "selectionRangeChange"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeSelectionDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeSelection]",
      standalone: true
    }]
  }], function() {
    return [{
      type: MultiViewCalendarComponent
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DateRangeService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    autoCorrectOn: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    shouldSetRange: [{
      type: Input
    }],
    activeRangeEndChange: [{
      type: Output
    }],
    selectionRangeChange: [{
      type: Output
    }]
  });
})();
var DateRangePopupMessages = class _DateRangePopupMessages extends ComponentMessages {
  /**
   * The text of the **Accept** button in the popup footer of the DateRange Popup.
   */
  accept;
  /**
   * The label of the **Accept** button in the popup footer of the DateRange Popup.
   */
  acceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the DateRange Popup.
   */
  cancel;
  /**
   * The label of the **Cancel** button in the popup footer of the DateRange Popup.
   */
  cancelLabel;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateRangePopupMessages_BaseFactory;
    return function DateRangePopupMessages_Factory(__ngFactoryType__) {
      return (ɵDateRangePopupMessages_BaseFactory || (ɵDateRangePopupMessages_BaseFactory = ɵɵgetInheritedFactory(_DateRangePopupMessages)))(__ngFactoryType__ || _DateRangePopupMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupMessages,
    selectors: [["kendo-daterangepopup-messages-base"]],
    inputs: {
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-daterangepopup-messages-base"
    }]
  }], null, {
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }]
  });
})();
var DateRangePopupLocalizedMessagesDirective = class _DateRangePopupLocalizedMessagesDirective extends DateRangePopupMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DateRangePopupLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangePopupLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupLocalizedMessagesDirective,
    selectors: [["", "kendoDateRangePopupLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: DateRangePopupMessages,
      useExisting: forwardRef(() => _DateRangePopupLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateRangePopupMessages,
        useExisting: forwardRef(() => DateRangePopupLocalizedMessagesDirective)
      }],
      selector: "[kendoDateRangePopupLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DateRangePopupComponent = class _DateRangePopupComponent {
  popupService;
  dateRangeService;
  zone;
  renderer;
  localization;
  cdr;
  rtl;
  container;
  actionSheet;
  defaultTemplate;
  contentTemplate;
  dateRangeSelectionDirective;
  viewCalendar;
  contentCalendar;
  /**
   * @hidden
   *
   * Determines whether to display the MultiViewCalendar header.
   */
  showCalendarHeader = true;
  /**
   * Sets or gets the `focusedDate` property of the MultiViewCalendar and
   * defines the focused date of the component
   * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
   *
   * > If the MultiViewCalendar is out of the min or max range, it normalizes the defined `focusedDate`.
   */
  focusedDate;
  /**
   * Sets the dates of the MultiViewCalendar that will be disabled
   * ([see example]({% slug disabled_dates_multiviewcalendar %})).
   */
  disabledDates;
  /**
   * Defines the active view that the MultiViewCalendar initially renders
   * ([see example]({% slug viewoptions_multiviewcalendar %})).
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost view, to which the user can navigate
   * ([see example](slug:viewdepth_multiviewcalendar)).
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost view, to which the user can navigate.
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Sets or gets the `min` property of the MultiViewCalendar and
   * defines the minimum allowed date value.
   * By default, the `min` value is `1900-1-1`.
   */
  min;
  /**
   * Sets or gets the `max` property of the MultiViewCalendar and
   * defines the maximum allowed date value.
   * By default, the `max` value is `2099-12-31`.
   */
  max;
  /**
   * Allows reverse selection.
   * If `allowReverse` is set to `true`, the component skips the validation of whether the start date is after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Determines whether to enable animation when navigating to previous/next view.
   * @default false
   */
  animateNavigation = false;
  /**
   * Sets or gets the `disabled` property of the MultiViewCalendar and
   * determines whether the component is active
   * ([see example]({% slug disabled_multiviewcalendar %})).
   */
  disabled = false;
  /**
   * Sets or gets the `views` property of the MultiViewCalendar and
   * defines the number of rendered months.
   *
   * @default 2
   */
  views = 2;
  /**
   * Determines whether to display a week number column in the `month` view
   * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).
   */
  weekNumber = false;
  /**
   * Controls the popup animation.
   * By default, the opening and closing animations are enabled.
   * For more information about controlling the popup animations,
   * refer to the article on [animations]({% slug animations_popup %}).
   */
  animate = true;
  /**
   * Specifies the element that will be used as an anchor. The popup opens next to that element.
   * For more information, refer to the section on
   * [aligning to specific components]({% slug alignmentpositioning_popup %}#toc-aligning-to-components).
   */
  anchor;
  /**
   * Specifies the anchor pivot point.
   * For more information, refer to the section on
   * [positioning]({% slug alignmentpositioning_popup %}#toc-positioning).
   */
  anchorAlign;
  /**
   * Determines whether to display a header for every view (for example the month name).
   *
   * @default false
   */
  showViewHeader = false;
  /**
   * Displays the days that fall out of the current month ([see example]({% slug viewoptions_multiviewcalendar %}#toc-displaying-other-month-days)).
   * @default false
   */
  showOtherMonthDays = false;
  /**
   * Controls the popup container. By default, the popup is appended to the root component.
   */
  appendTo;
  /**
   * Configures the collision behavior of the popup.
   * For more information, refer to the article on
   * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).
   */
  collision = {
    horizontal: "fit",
    vertical: "flip"
  };
  /**
   * Specifies the pivot point of the popup.
   * For more information, refer to the section on
   * [positioning]({% slug alignmentpositioning_popup %}#toc-positioning).
   */
  popupAlign;
  /**
   * Specifies the margin value that will be added to the popup dimensions in pixels
   * and leaves a blank space between the popup and the anchor.
   */
  margin;
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the input element of the DateRangePopup and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  title = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  set subtitle(subtitle) {
    this._subtitle = subtitle;
  }
  get subtitle() {
    return this._subtitle;
  }
  _subtitle;
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  size;
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:popup_daterange#toc-events)).
   * This event is preventable. If you cancel the event, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:popup_daterange#toc-events)).
   * This event is preventable. If you cancel the event, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires each time the calendar element is blurred
   * ([see example](slug:popup_daterange#toc-events)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the calendar element is focused
   * ([see example](slug:popup_daterange#toc-events)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the popup is closed either on `ESC` keypress or on leaving the viewport
   * ([see example](slug:popup_daterange#toc-events)).
   */
  cancel = new EventEmitter();
  /**
   * The active calendar that is visible in the popup
   *
   * > When the popup is closed, the property returns `null`.
   */
  get calendar() {
    return this._calendar;
  }
  set calendar(calendar) {
    this._calendar = calendar;
    this.subscribeFocusBlur(calendar);
  }
  /**
   * Gets the active state of the component.
   * When the opened calendar is active, returns `true`.
   */
  get isActive() {
    return this.calendar && this.calendar.isActive || this.actionSheet && this.actionSheet.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  popupRef;
  /**
   * @hidden
   */
  popupUID = guid();
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * Gets or sets the visibility state of the component.
   */
  set show(show) {
    if (this._show === show) {
      return;
    }
    const event2 = new PreventableEvent2();
    if (show) {
      this.open.emit(event2);
    } else {
      this.close.emit(event2);
    }
    if (event2.isDefaultPrevented()) {
      return;
    }
    this.toggleDateRange(show);
  }
  get show() {
    return this._show;
  }
  activateSubscription;
  blurSubscription;
  focusSubscription;
  calendarSubscriptions = new Subscription();
  popupSubscriptions = new Subscription();
  windowBlurSubscription;
  localizationSubscriptions = new Subscription();
  resolvedPromise = Promise.resolve();
  _calendar;
  _show;
  _rangeSelection;
  windowSize;
  constructor(popupService, dateRangeService, zone, renderer, localization, cdr, rtl) {
    this.popupService = popupService;
    this.dateRangeService = dateRangeService;
    this.zone = zone;
    this.renderer = renderer;
    this.localization = localization;
    this.cdr = cdr;
    this.rtl = rtl;
  }
  ngOnInit() {
    this.dateRangeService.registerPopup(this);
    if (this.localization) {
      this.localizationSubscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    }
  }
  ngAfterViewInit() {
    this.calendarSubscriptions.add(this.contentCalendar.changes.subscribe((changes) => {
      this.calendar = changes.first;
      this.actionSheet.titleId = changes.first?.headerId;
      this.cdr.detectChanges();
    }));
    this.calendarSubscriptions.add(this.viewCalendar.changes.subscribe((changes) => {
      this.calendar = changes.first;
      this.actionSheet.titleId = changes.first?.headerId;
      this.cdr.detectChanges();
    }));
    this.calendarSubscriptions.add(this.dateRangeService.startInput$?.value?.valueChange.subscribe((res) => {
      if (this.calendar) {
        if (!res && this.dateRangeService.selectionRange.end) {
          this.calendar.shouldHoverWhenNoStart = true;
        } else {
          this.calendar.shouldHoverWhenNoStart = false;
        }
      }
    }));
    if (isWindowAvailable()) {
      this.zone.runOutsideAngular(() => this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this)));
    }
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  ngOnDestroy() {
    this.destroyPopup();
    this.calendarSubscriptions.unsubscribe();
    if (this.activateSubscription) {
      this.activateSubscription.unsubscribe();
    }
    if (this.blurSubscription) {
      this.blurSubscription.unsubscribe();
      this.focusSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   *
   */
  onRangeSelectionChange(rangeSelection) {
    this.dateRangeService.setActiveRangeEnd(rangeSelection.activeRangeEnd);
    if (!this.isAdaptive) {
      this.dateRangeService.setRange(rangeSelection.selectionRange);
    } else {
      this._rangeSelection = rangeSelection.selectionRange;
    }
  }
  /**
   *  Opens the popup component and focuses the calendar.
   */
  activate() {
    if (this.show === true) {
      return;
    }
    if (this.activateSubscription) {
      this.activateSubscription.unsubscribe();
    }
    this.show = true;
    this.cdr.markForCheck();
    this.zone.runOutsideAngular(() => {
      this.activateSubscription = merge(this.contentCalendar.changes, this.viewCalendar.changes).pipe(filter((changes) => changes && changes.first), map((changes) => changes.first)).subscribe((calendar) => setTimeout(() => {
        calendar.focus();
        this.calendarSubscriptions.add(calendar.viewList.focusedCellChange.subscribe((id) => {
          this.dateRangeService.setActiveDescendent(id);
        }));
      }));
    });
  }
  /**
   *  Focuses the calendar (if available).
   */
  focus() {
    if (this.calendar) {
      this.calendar.focus();
    }
  }
  /**
   * Checks if a focused element ids placed inside the popup.
   *
   * @return boolean;
   */
  hasActiveContent() {
    if (!isDocumentAvailable() || !this.popupRef) {
      return false;
    }
    return this.popupRef.popupElement.contains(document.activeElement);
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show The state of the popup.
   */
  toggle(show) {
    this.resolvedPromise.then(() => {
      this.toggleDateRange(show === void 0 ? !this.show : show);
    });
  }
  /**
   * @hidden
   *
   * Closes the popup and triggers the `cancel` event.
   */
  cancelPopup() {
    this.show = false;
    this.cancel.emit();
  }
  /**
   * @hidden
   */
  handleAccept() {
    this.dateRangeService.setRange(this._rangeSelection);
    this.show = false;
  }
  /**
   * @hidden
   */
  onResize() {
    if (!this.show || this.windowSize === windowSize()) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = windowSize();
  }
  /**
   * @hidden
   */
  closePopup(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    this.toggle(false);
    if (this.dateRangeService.activeRangeEnd === "start" || !this.dateRangeService.activeRangeEnd) {
      this.dateRangeService.startInput$.value.focus();
    } else {
      this.dateRangeService.endInput$.value.focus();
    }
  }
  /**
   * @hidden
   */
  handleTab(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (this.dateRangeService.activeRangeEnd === "start" || !this.dateRangeService.activeRangeEnd) {
      this.dateRangeService.setActiveRangeEnd("end");
    } else {
      this.dateRangeService.endInput$.value.focus();
    }
  }
  /**
   * @hidden
   */
  handleShiftTab(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (this.dateRangeService.activeRangeEnd === "end") {
      this.dateRangeService.setActiveRangeEnd("start");
    } else {
      this.dateRangeService.startInput$.value.focus();
    }
  }
  handleWindowBlur() {
    if (!this.show || this.actionSheet.expanded) {
      return;
    }
    if (hasObservers(this.close)) {
      this.zone.run(() => this.show = false);
    } else {
      this.show = false;
    }
  }
  handleMouseLeave() {
    this.dateRangeService.setRange(this.dateRangeService.selectionRange);
  }
  handleKeydown(event2) {
    const {
      altKey,
      keyCode
    } = event2;
    if (keyCode === Keys.Escape || altKey && keyCode === Keys.ArrowUp) {
      this.zone.run(() => this.cancelPopup());
    }
  }
  subscribeFocusBlur(calendar) {
    if (this.blurSubscription) {
      this.blurSubscription.unsubscribe();
      this.focusSubscription.unsubscribe();
    }
    if (!calendar) {
      return;
    }
    const calendarElement = calendar.element.nativeElement.querySelector(".k-calendar-view");
    this.blurSubscription = fromEvent(calendarElement, "blur").subscribe(() => this.onBlur.emit());
    this.focusSubscription = fromEvent(calendarElement, "focus").subscribe(() => this.onFocus.emit());
  }
  addPopupSubscriptions(...subscriptions) {
    if (!isPresent2(this.popupSubscriptions)) {
      this.popupSubscriptions = new Subscription();
    }
    subscriptions.map((s) => this.popupSubscriptions.add(s));
  }
  get _appendTo() {
    const appendTo = this.appendTo;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  togglePopup(show) {
    this._show = show;
    if (this.popupRef) {
      this.destroyPopup();
    }
    if (this._show) {
      const direction = this.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchor: this.anchor,
        anchorAlign: this.anchorAlign || {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.animate,
        appendTo: this._appendTo,
        collision: this.collision,
        content: (this.contentTemplate || {}).templateRef || this.defaultTemplate,
        margin: this.margin,
        popupClass: "k-calendar-container k-daterangepicker-popup",
        popupAlign: this.popupAlign || {
          vertical: "top",
          horizontal: direction
        },
        positionMode: "absolute"
      });
      const {
        popupElement,
        popupAnchorViewportLeave
      } = this.popupRef;
      this.renderer.setAttribute(popupElement.querySelector(".k-popup"), "id", this.popupUID);
      this.addPopupSubscriptions(this.zone.runOutsideAngular(() => fromEvent(popupElement, "keydown").subscribe(this.handleKeydown.bind(this))), fromEvent(popupElement, "mouseleave").subscribe(this.handleMouseLeave.bind(this)), popupAnchorViewportLeave.subscribe(() => this.cancelPopup()));
    }
  }
  destroyPopup() {
    if (isPresent2(this.popupRef)) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (isPresent2(this.popupSubscriptions)) {
      this.popupSubscriptions.unsubscribe();
    }
  }
  toggleDateRange(show) {
    this.windowSize = windowSize();
    if (this.isAdaptive) {
      this.toggleActionSheet(show);
    } else {
      this.togglePopup(show);
    }
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.actionSheet.expanded) {
      this.actionSheet.toggle();
      this.updateActionSheetAdaptiveAppearance();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
    } else if (!show && this.actionSheet.expanded) {
      this.actionSheet.toggle();
    }
    this._show = show;
  }
  updateActionSheetAdaptiveAppearance() {
    let element;
    let animationContainer;
    if (this.actionSheet) {
      element = this.actionSheet["element"].nativeElement.querySelector(".k-actionsheet");
      animationContainer = this.actionSheet["element"].nativeElement.querySelector(".k-child-animation-container");
      if (this.windowSize === "medium") {
        this.renderer.removeClass(element, "k-actionsheet-fullscreen");
        this.renderer.removeStyle(animationContainer, "height");
      } else if (this.windowSize === "small") {
        this.renderer.addClass(element, "k-actionsheet-fullscreen");
        this.renderer.setStyle(animationContainer, "height", "100%");
      }
      this.renderer.addClass(element, "k-adaptive-actionsheet");
      this.renderer.addClass(element, "k-actionsheet-bottom");
      this.renderer.setStyle(animationContainer, "bottom", "0px");
    }
  }
  static ɵfac = function DateRangePopupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangePopupComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(RTL, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangePopupComponent,
    selectors: [["kendo-daterange-popup"]],
    contentQueries: function DateRangePopupComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DateRangePopupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MultiViewCalendarComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentCalendar = _t);
      }
    },
    viewQuery: function DateRangePopupComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 5, ViewContainerRef);
        ɵɵviewQuery(_c17, 5);
        ɵɵviewQuery(_c36, 5);
        ɵɵviewQuery(DateRangeSelectionDirective, 5);
        ɵɵviewQuery(MultiViewCalendarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateRangeSelectionDirective = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewCalendar = _t);
      }
    },
    inputs: {
      showCalendarHeader: "showCalendarHeader",
      focusedDate: "focusedDate",
      disabledDates: "disabledDates",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      min: "min",
      max: "max",
      allowReverse: "allowReverse",
      animateNavigation: "animateNavigation",
      disabled: "disabled",
      views: "views",
      weekNumber: "weekNumber",
      animate: "animate",
      anchor: "anchor",
      anchorAlign: "anchorAlign",
      showViewHeader: "showViewHeader",
      showOtherMonthDays: "showOtherMonthDays",
      appendTo: "appendTo",
      collision: "collision",
      popupAlign: "popupAlign",
      margin: "margin",
      adaptiveMode: "adaptiveMode",
      title: "title",
      subtitle: "subtitle",
      size: "size"
    },
    outputs: {
      open: "open",
      close: "close",
      onBlur: "blur",
      onFocus: "focus",
      cancel: "cancel"
    },
    exportAs: ["kendo-daterange-popup"],
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.daterangepopup"
    }])],
    decls: 8,
    vars: 0,
    consts: () => {
      let i18n_57;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_57 = goog.getMsg("Set");
        i18n_57 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_57;
      } else {
        i18n_57 = $localize`:kendo.daterangepopup.accept|The Accept button text in the timepicker component:Set`;
      }
      let i18n_58;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_58 = goog.getMsg("Set time");
        i18n_58 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_58;
      } else {
        i18n_58 = $localize`:kendo.daterangepopup.acceptLabel|The label for the Accept button in the timepicker component:Set time`;
      }
      let i18n_59;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_59 = goog.getMsg("Cancel");
        i18n_59 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_59;
      } else {
        i18n_59 = $localize`:kendo.daterangepopup.cancel|The Cancel button text in the timepicker component:Cancel`;
      }
      let i18n_60;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_60 = goog.getMsg("Cancel changes");
        i18n_60 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_60;
      } else {
        i18n_60 = $localize`:kendo.daterangepopup.cancelLabel|The label for the Cancel button in the timepicker component:Cancel changes`;
      }
      return [["container", ""], ["defaultTemplate", ""], ["actionSheet", ""], ["kendoDateRangePopupLocalizedMessages", "", "accept", i18n_57, "acceptLabel", i18n_58, "cancel", i18n_59, "cancelLabel", i18n_60], [3, "overlayClick", "collapse"], ["kendoActionSheetTemplate", ""], ["orientation", "horizontal", "selection", "range", 3, "onClosePopup", "onTabPress", "onShiftTabPress", "rangeSelectionChange", "activeView", "bottomView", "animateNavigation", "disabled", "views", "weekNumber", "topView", "disabledDates", "min", "max", "showCalendarHeader", "focusedDate", "allowReverse", "showViewHeader", "showOtherMonthDays", "size", "value"], [3, "resize", 4, "ngIf"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group", "k-hbox"], [1, "k-actionsheet-title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "x", "fillMode", "flat", "aria-hidden", "true", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content", "!k-overflow-hidden"], [1, "k-scrollable-wrap"], ["size", "large", "orientation", "vertical", "selection", "range", 3, "rangeSelectionChange", "animateNavigation", "disabled", "views", "weekNumber", "disabledDates", "activeView", "bottomView", "topView", "min", "max", "showCalendarHeader", "focusedDate", "allowReverse", "showViewHeader", "showOtherMonthDays", "value"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "type", "button", "size", "large", 3, "click"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 3, "click"], [3, "resize"]];
    },
    template: function DateRangePopupComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 3)(1, null, 0);
        ɵɵtemplate(3, DateRangePopupComponent_ng_template_3_Template, 1, 17, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵelementStart(5, "kendo-actionsheet", 4, 2);
        ɵɵlistener("overlayClick", function DateRangePopupComponent_Template_kendo_actionsheet_overlayClick_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function DateRangePopupComponent_Template_kendo_actionsheet_collapse_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur.emit());
        });
        ɵɵtemplate(7, DateRangePopupComponent_ng_template_7_Template, 18, 29, "ng-template", 5);
        ɵɵelementEnd();
      }
    },
    dependencies: [DateRangePopupLocalizedMessagesDirective, MultiViewCalendarComponent, ActionSheetComponent, ActionSheetTemplateDirective, NgIf, ResizeSensorComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupComponent, [{
    type: Component,
    args: [{
      exportAs: "kendo-daterange-popup",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.daterangepopup"
      }],
      selector: "kendo-daterange-popup",
      template: `
        <ng-container kendoDateRangePopupLocalizedMessages
            i18n-accept="kendo.daterangepopup.accept|The Accept button text in the timepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.daterangepopup.acceptLabel|The label for the Accept button in the timepicker component"
            acceptLabel="Set time"

            i18n-cancel="kendo.daterangepopup.cancel|The Cancel button text in the timepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.daterangepopup.cancelLabel|The label for the Cancel button in the timepicker component"
            cancelLabel="Cancel changes"
        >
        </ng-container> 
        <ng-container #container></ng-container>
        <ng-template #defaultTemplate>
            <kendo-multiviewcalendar
                [activeView]="activeView"
                [bottomView]="bottomView"
                [animateNavigation]="animateNavigation"
                [disabled]="disabled"
                orientation="horizontal"
                [views]="views"
                [weekNumber]="weekNumber"
                [topView]="topView"
                [disabledDates]="disabledDates"
                [min]="min"
                [max]="max"
                [showCalendarHeader]="showCalendarHeader"
                [focusedDate]="focusedDate"
                [allowReverse]="allowReverse"
                [showViewHeader]="showViewHeader"
                [showOtherMonthDays]="showOtherMonthDays"
                selection="range"
                [size]="size"
                [value]="dateRangeService.selectionRange"
                (onClosePopup)="closePopup($event)"
                (onTabPress)="handleTab($event)"
                (onShiftTabPress)="handleShiftTab($event)"
                (rangeSelectionChange)="onRangeSelectionChange($event)"
            ></kendo-multiviewcalendar>
        </ng-template>

        <kendo-actionsheet
            #actionSheet
            (overlayClick)="show=false"
            (collapse)="onBlur.emit()"
        >
            <ng-template kendoActionSheetTemplate>
                <!-- Resize sensor needs to be inside the template because the date-range-popup
                element itself always has 0x0 size and does not trigger the sensor. 
                Note: The popup in non-adaptive mode closes on window blur -->
                <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group k-hbox">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ title }}</div>
                            <div class="k-actionsheet-subtitle k-text-center">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="x"
                                [attr.title]="localization.get('clearTitle')"
                                [svgIcon]="xIcon"
                                fillMode="flat"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                size="large"
                                innerCssClass="k-button-icon"
                                (click)="show = false">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content !k-overflow-hidden">
                    <div class="k-scrollable-wrap">
                        <kendo-multiviewcalendar
                            size="large"
                            [animateNavigation]="animateNavigation"
                            [disabled]="disabled"
                            orientation="vertical"
                            [views]="views"
                            [weekNumber]="weekNumber"
                            [disabledDates]="disabledDates"
                            [activeView]="activeView"
                            [bottomView]="bottomView"
                            [topView]="topView"
                            [min]="min"
                            [max]="max"
                            [showCalendarHeader]="showCalendarHeader"
                            [focusedDate]="focusedDate"
                            [allowReverse]="allowReverse"
                            [showViewHeader]="showViewHeader"
                            [showOtherMonthDays]="showOtherMonthDays"
                            [focusedDate]="dateRangeService.focusedDate"
                            [value]="dateRangeService.selectionRange"
                            selection="range"
                            (rangeSelectionChange)="onRangeSelectionChange($event)"
                            >
                        </kendo-multiviewcalendar>
                    </div>
                </div>
                <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button kendoButton 
                        type="button"
                        size="large"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                        (click)="show=false"
                    >
                        {{localization.get('cancel')}}
                    </button>

                    <button kendoButton
                        type="button"
                        size="large"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                        (click)="handleAccept()"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>
    `,
      standalone: true,
      imports: [DateRangePopupLocalizedMessagesDirective, MultiViewCalendarComponent, ActionSheetComponent, ActionSheetTemplateDirective, NgIf, ResizeSensorComponent, ButtonComponent]
    }]
  }], function() {
    return [{
      type: PopupService
    }, {
      type: DateRangeService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }];
  }, {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: false
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: false
      }]
    }],
    contentTemplate: [{
      type: ContentChild,
      args: [DateRangePopupTemplateDirective, {
        static: false
      }]
    }],
    dateRangeSelectionDirective: [{
      type: ViewChild,
      args: [DateRangeSelectionDirective, {
        static: false
      }]
    }],
    viewCalendar: [{
      type: ViewChildren,
      args: [MultiViewCalendarComponent]
    }],
    contentCalendar: [{
      type: ContentChildren,
      args: [MultiViewCalendarComponent]
    }],
    showCalendarHeader: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    anchor: [{
      type: Input
    }],
    anchorAlign: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    appendTo: [{
      type: Input
    }],
    collision: [{
      type: Input
    }],
    popupAlign: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    cancel: [{
      type: Output
    }]
  });
})();
var DateRangeComponent = class _DateRangeComponent {
  dateRangeService;
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  size;
  /**
  * @hidden
  */
  keydown(event2) {
    const shouldOpenPopup = event2.keyCode === Keys.ArrowDown && event2.altKey;
    if (shouldOpenPopup) {
      this.dateRangeService.activatePopup();
    }
    const shouldClosePopup = event2.keyCode === Keys.ArrowUp && event2.altKey || event2.keyCode === Keys.Escape;
    if (shouldClosePopup) {
      this.dateRangeService.deactivatePopup();
    }
  }
  wrapperClass = true;
  /**
   * @hidden
   */
  showDefault = false;
  contentPopup;
  get hasContentPopup() {
    return this.contentPopup.length > 0;
  }
  subscription;
  constructor(dateRangeService) {
    this.dateRangeService = dateRangeService;
    validatePackage(packageMetadata);
  }
  ngAfterContentInit() {
    this.showDefault = !this.hasContentPopup;
    this.subscription = this.contentPopup.changes.subscribe(() => {
      this.showDefault = !this.hasContentPopup;
    });
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  static ɵfac = function DateRangeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeComponent)(ɵɵdirectiveInject(DateRangeService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangeComponent,
    selectors: [["kendo-daterange"]],
    contentQueries: function DateRangeComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DateRangePopupComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentPopup = _t);
      }
    },
    hostVars: 2,
    hostBindings: function DateRangeComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function DateRangeComponent_keydown_HostBindingHandler($event) {
          return ctx.keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-daterangepicker", ctx.wrapperClass);
      }
    },
    inputs: {
      size: "size"
    },
    features: [ɵɵProvidersFeature([DateRangeService])],
    ngContentSelectors: _c8,
    decls: 2,
    vars: 1,
    consts: [[3, "size", 4, "ngIf"], [3, "size"]],
    template: function DateRangeComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵtemplate(1, DateRangeComponent_kendo_daterange_popup_1_Template, 1, 1, "kendo-daterange-popup", 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showDefault);
      }
    },
    dependencies: [NgIf, DateRangePopupComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeComponent, [{
    type: Component,
    args: [{
      providers: [DateRangeService],
      selector: "kendo-daterange",
      template: `
        <ng-content></ng-content>
        <kendo-daterange-popup *ngIf="showDefault" [size]="size"></kendo-daterange-popup>
    `,
      standalone: true,
      imports: [NgIf, DateRangePopupComponent]
    }]
  }], function() {
    return [{
      type: DateRangeService
    }];
  }, {
    size: [{
      type: Input
    }],
    keydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-daterangepicker"]
    }],
    contentPopup: [{
      type: ContentChildren,
      args: [DateRangePopupComponent]
    }]
  });
})();
var DateRangeInput = class _DateRangeInput {
  activeRangeEnd;
  dateRangeService;
  input;
  element;
  renderer;
  zone;
  navigateCalendarOnFocus = false;
  get isActiveEnd() {
    return this.dateRangeService.activeRangeEnd === this.activeRangeEnd;
  }
  popupSubscriptions = new Subscription();
  subscriptions = new Subscription();
  get popupCalendarActivated() {
    const popup = this.dateRangeService.dateRangePopup$.value;
    return isPresent2(popup) && isPresent2(popup.calendar);
  }
  constructor(activeRangeEnd, dateRangeService, input, element, renderer, zone) {
    this.activeRangeEnd = activeRangeEnd;
    this.dateRangeService = dateRangeService;
    this.input = input;
    this.element = element;
    this.renderer = renderer;
    this.zone = zone;
  }
  init() {
    this.input.role = "combobox";
    this.input.hasPopup = "grid";
    if (this.input.value) {
      this.dateRangeService.setRange(this.getRange(this.input.value));
    }
    [this.input.onBlur.subscribe(() => this.deactivate()), this.input.valueUpdate.subscribe((value2) => this.updateRange(value2, "change")), this.dateRangeService.activeRangeEnd$.subscribe(() => {
      if (this.navigateCalendarOnFocus) {
        this.focusActiveDate();
      }
      this.toggleActiveClass(this.isActiveEnd);
    }), this.dateRangeService.dateRangePopup$.subscribe((popup) => this.initPopup(popup)), this.dateRangeService.range$.subscribe((range3) => this.updateInputValue(range3)), fromEvent(this.element.nativeElement, "click").subscribe(() => this.activate()), fromEvent(this.element.nativeElement, "keydown").subscribe((event2) => this.togglePopup(event2 || {}))].map((s) => this.subscriptions.add(s));
  }
  destroy() {
    this.subscriptions.unsubscribe();
    this.unsubscribePopup();
  }
  initPopup(popup) {
    if (!popup) {
      this.unsubscribePopup();
      return;
    }
    if (!popup.anchor) {
      popup.anchor = this.element.nativeElement;
    }
    [popup.cancel.subscribe(() => this.isActiveEnd && this.input.focus()), popup.onFocus.subscribe(() => this.toggleActiveClass(this.isActiveEnd)), popup.onBlur.subscribe(() => this.deactivate())].map((s) => this.popupSubscriptions.add(s));
  }
  unsubscribePopup() {
    this.popupSubscriptions.unsubscribe();
    this.popupSubscriptions = new Subscription();
  }
  activate() {
    this.dateRangeService.setActiveRangeEnd(this.activeRangeEnd);
    this.dateRangeService.activatePopup();
  }
  deactivate() {
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        this.updateRange(this.input.value, "blur");
        if (this.dateRangeService.hasActiveComponent()) {
          return;
        }
        this.toggleActiveClass(false);
        this.zone.run(() => this.dateRangeService.deactivatePopup());
      });
    });
  }
  updateRange(value2, correctOn) {
    const range3 = this.getRange(value2, correctOn);
    if (range3) {
      this.focusActiveDate();
      this.dateRangeService.setRange(range3);
    }
  }
  togglePopup({
    altKey,
    keyCode
  }) {
    if (keyCode === Keys.Escape) {
      this.dateRangeService.cancelPopup();
    } else if (altKey && keyCode === Keys.ArrowDown) {
      this.dateRangeService.activatePopup();
    }
  }
  focusActiveDate() {
    if (this.input.value && this.isActiveEnd) {
      this.dateRangeService.setFocusedDate(cloneDate(this.input.value));
    }
  }
  toggleActiveClass(show) {
    const action = show ? "addClass" : "removeClass";
    const nativeElement = this.element.nativeElement;
    if (nativeElement && nativeElement.querySelector) {
      this.renderer[action](nativeElement, "k-focus");
    }
  }
  static ɵfac = function DateRangeInput_Factory(__ngFactoryType__) {
    ɵɵinvalidFactory();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeInput,
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeInput, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: void 0
    }, {
      type: DateRangeService
    }, {
      type: DateInputComponent
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, null);
})();
var DateRangeEndInputDirective = class _DateRangeEndInputDirective extends DateRangeInput {
  rangeService;
  dateInput;
  /**
   * Specifies the auto-correction behavior. If the start date is greater than the end date, the
   * directive fixes the date range to a single date either on input change or on blur
   * ([see example](slug:autocorrect_daterange#toc-input-directives)).
   *
   * By default, the component does not perform any auto-correction.
   */
  autoCorrectOn;
  /**
   * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,
   * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.
   *
   * By default, the automatic navigation behavior on input focus is disabled.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>
   *  <kendo-daterange>
   *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]="true" [(value)]="start"></kendo-dateinput>
   *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]="true" [(value)]="end"></kendo-dateinput>
   *  </kendo-daterange>
   * `
   * })
   * export class AppComponent {
   *   public start: Date = new Date(2018, 3, 10);
   *   public end: Date = new Date(2018, 10, 20);
   * }
   * ```
   */
  navigateCalendarOnFocus = false;
  constructor(rangeService, dateInput, element, renderer, zone) {
    super("end", rangeService, dateInput, element, renderer, zone);
    this.rangeService = rangeService;
    this.dateInput = dateInput;
  }
  ngOnInit() {
    this.rangeService.registerEndInput(this.dateInput);
    super.init();
    this.dateInput.pickerType = "daterangeend";
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.dateInput.inputElement, attributeNames.ariaExpanded, "false");
  }
  ngOnDestroy() {
    super.destroy();
  }
  getRange(value2, correctOn) {
    const {
      min,
      max
    } = this.dateInput;
    if (!isInRange(value2, min, max)) {
      return null;
    }
    const {
      start
    } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;
    const shouldClamp = this.autoCorrectOn === correctOn && isPresent2(value2) && value2 < start;
    return shouldClamp ? clampRange(value2) : {
      start,
      end: cloneDate(value2)
    };
  }
  updateInputValue(range3) {
    const {
      end
    } = range3 || EMPTY_SELECTIONRANGE;
    const {
      min,
      max
    } = this.dateInput;
    if (isEqual(this.dateInput.value, end) || !isInRange(end, min, max)) {
      return;
    }
    this.dateInput.writeValue(cloneDate(end));
    this.dateInput.notify();
  }
  static ɵfac = function DateRangeEndInputDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeEndInputDirective)(ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(DateInputComponent), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeEndInputDirective,
    selectors: [["", "kendoDateRangeEndInput", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      navigateCalendarOnFocus: "navigateCalendarOnFocus"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeEndInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeEndInput]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DateRangeService
    }, {
      type: DateInputComponent
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    autoCorrectOn: [{
      type: Input
    }],
    navigateCalendarOnFocus: [{
      type: Input
    }]
  });
})();
var DateRangeStartInputDirective = class _DateRangeStartInputDirective extends DateRangeInput {
  rangeService;
  dateInput;
  renderer;
  /**
   * Specifies the auto-correction behavior. If the start date is greater than the end date,
   * the directive fixes the date range to a single date either on input change or on blur
   * ([see example](slug:autocorrect_daterange#toc-input-directives)).
   *
   * By default, the component does not perform any auto-correction.
   */
  autoCorrectOn;
  /**
   * Specifies the navigation behavior of the calendar when the active end is changed on input focus.
   * When enabled, the calendar navigates to the value of the focused input. Otherwise, the calendar
   * displays the last picked date.
   *
   * By default, the automatic navigation behavior on input focus is disabled.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>
   *  <kendo-daterange>
   *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]="true" [(value)]="start"></kendo-dateinput>
   *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]="true" [(value)]="end"></kendo-dateinput>
   *  </kendo-daterange>
   * `
   * })
   * export class AppComponent {
   *   public start: Date = new Date(2018, 3, 10);
   *   public end: Date = new Date(2018, 10, 20);
   * }
   * ```
   */
  navigateCalendarOnFocus = false;
  constructor(rangeService, dateInput, element, renderer, zone) {
    super("start", rangeService, dateInput, element, renderer, zone);
    this.rangeService = rangeService;
    this.dateInput = dateInput;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.rangeService.registerStartInput(this.dateInput);
    super.init();
    this.dateInput.pickerType = "daterangestart";
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.dateInput.inputElement, attributeNames.ariaExpanded, "false");
  }
  ngOnDestroy() {
    super.destroy();
  }
  getRange(value2, correctOn) {
    const {
      min,
      max
    } = this.dateInput;
    if (!isInRange(value2, min, max)) {
      return null;
    }
    const {
      end
    } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;
    const shouldClamp = this.autoCorrectOn === correctOn && end && value2 > end;
    return shouldClamp ? clampRange(value2) : {
      start: cloneDate(value2),
      end
    };
  }
  updateInputValue(range3) {
    const {
      start
    } = range3 || EMPTY_SELECTIONRANGE;
    const {
      min,
      max
    } = this.dateInput;
    if (isEqual(this.dateInput.value, start) || !isInRange(start, min, max)) {
      return;
    }
    this.dateInput.writeValue(cloneDate(start));
    this.dateInput.notify();
  }
  static ɵfac = function DateRangeStartInputDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeStartInputDirective)(ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(DateInputComponent), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeStartInputDirective,
    selectors: [["", "kendoDateRangeStartInput", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      navigateCalendarOnFocus: "navigateCalendarOnFocus"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeStartInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeStartInput]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DateRangeService
    }, {
      type: DateInputComponent
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    autoCorrectOn: [{
      type: Input
    }],
    navigateCalendarOnFocus: [{
      type: Input
    }]
  });
})();
var DatePickerCustomMessagesComponent = class _DatePickerCustomMessagesComponent extends DatePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DatePickerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DatePickerCustomMessagesComponent,
    selectors: [["kendo-datepicker-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: DatePickerMessages,
      useExisting: forwardRef(() => _DatePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DatePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DatePickerMessages,
        useExisting: forwardRef(() => DatePickerCustomMessagesComponent)
      }],
      selector: "kendo-datepicker-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DateRangePopupCustomMessagesComponent = class _DateRangePopupCustomMessagesComponent extends DateRangePopupMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateRangePopupCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangePopupCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangePopupCustomMessagesComponent,
    selectors: [["kendo-daterange-popup-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: DateRangePopupMessages,
      useExisting: forwardRef(() => _DateRangePopupCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DateRangePopupCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateRangePopupMessages,
        useExisting: forwardRef(() => DateRangePopupCustomMessagesComponent)
      }],
      selector: "kendo-daterange-popup-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DateTimePickerCustomMessagesComponent = class _DateTimePickerCustomMessagesComponent extends DateTimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateTimePickerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateTimePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateTimePickerCustomMessagesComponent,
    selectors: [["kendo-datetimepicker-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: DateTimePickerMessages,
      useExisting: forwardRef(() => _DateTimePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DateTimePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateTimePickerMessages,
        useExisting: forwardRef(() => DateTimePickerCustomMessagesComponent)
      }],
      selector: "kendo-datetimepicker-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var TimePickerCustomMessagesComponent = class _TimePickerCustomMessagesComponent extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TimePickerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimePickerCustomMessagesComponent,
    selectors: [["kendo-timepicker-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function TimePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimePickerCustomMessagesComponent)
      }],
      selector: "kendo-timepicker-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var KENDO_CALENDAR = [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective];
var KENDO_MULTIVIEWCALENDAR = [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective];
var KENDO_DATEINPUT = [DateInputCustomMessagesComponent, DateInputComponent];
var KENDO_DATEPICKER = [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective];
var KENDO_DATERANGE = [DateRangePopupCustomMessagesComponent, ...KENDO_DATEINPUT, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective];
var KENDO_DATETIMEPICKER = [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective];
var KENDO_TIMEPICKER = [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective];
var KENDO_DATEINPUTS = [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR, ...KENDO_DATEINPUT, ...KENDO_DATEPICKER, ...KENDO_DATERANGE, ...KENDO_DATETIMEPICKER, ...KENDO_TIMEPICKER];
var CalendarModule = class _CalendarModule {
  static ɵfac = function CalendarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CalendarModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService],
    imports: [CalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CALENDAR],
      imports: [...KENDO_CALENDAR],
      providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService]
    }]
  }], null, null);
})();
var CalendarsModule = class _CalendarsModule {
  static ɵfac = function CalendarsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CalendarsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CalendarsModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService],
    imports: [CalendarComponent, MultiViewCalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR],
      imports: [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR],
      providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService]
    }]
  }], null, null);
})();
var DateInputModule = class _DateInputModule {
  static ɵfac = function DateInputModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateInputModule,
    imports: [DateInputCustomMessagesComponent, DateInputComponent],
    exports: [DateInputCustomMessagesComponent, DateInputComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [DateInputComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEINPUT],
      imports: [...KENDO_DATEINPUT],
      providers: [IconsService]
    }]
  }], null, null);
})();
var DatePickerModule = class _DatePickerModule {
  static ɵfac = function DatePickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DatePickerModule,
    imports: [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // DateInputModule providers
      IconsService,
      // CalendarModule providers
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService
    ],
    imports: [DatePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // DateInputModule providers
        IconsService,
        // CalendarModule providers
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService
      ]
    }]
  }], null, null);
})();
var DateInputsModule = class _DateInputsModule {
  static ɵfac = function DateInputsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateInputsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateInputsModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, DateInputCustomMessagesComponent, DateInputComponent, DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective, DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, DateInputCustomMessagesComponent, DateInputComponent, DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective, DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // CalendarModule providers
      IconsService,
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService,
      // TimePickerModule providers
      TimePickerDOMService,
      HoursService,
      MinutesService,
      SecondsService,
      MillisecondsService,
      DayPeriodService
    ],
    imports: [CalendarComponent, MultiViewCalendarComponent, DateInputComponent, DatePickerComponent, DateInputComponent, DateRangeComponent, DateRangePopupComponent, DateTimePickerComponent, TimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEINPUTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATEINPUTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // CalendarModule providers
        IconsService,
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService,
        // TimePickerModule providers
        TimePickerDOMService,
        HoursService,
        MinutesService,
        SecondsService,
        MillisecondsService,
        DayPeriodService
      ]
    }]
  }], null, null);
})();
var TimePickerModule = class _TimePickerModule {
  static ɵfac = function TimePickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TimePickerModule,
    imports: [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService],
    imports: [TimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_TIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_TIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [IconsService, PopupService, ResizeBatchService, TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService]
    }]
  }], null, null);
})();
var DateTimePickerModule = class _DateTimePickerModule {
  static ɵfac = function DateTimePickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateTimePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateTimePickerModule,
    imports: [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // CalendarModule providers
      IconsService,
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService,
      // TimePickerModule providers
      TimePickerDOMService,
      HoursService,
      MinutesService,
      SecondsService,
      MillisecondsService,
      DayPeriodService
    ],
    imports: [DateTimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATETIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATETIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // CalendarModule providers
        IconsService,
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService,
        // TimePickerModule providers
        TimePickerDOMService,
        HoursService,
        MinutesService,
        SecondsService,
        MillisecondsService,
        DayPeriodService
      ]
    }]
  }], null, null);
})();
var MultiViewCalendarModule = class _MultiViewCalendarModule {
  static ɵfac = function MultiViewCalendarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiViewCalendarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MultiViewCalendarModule,
    imports: [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective],
    exports: [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, NavigationService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService],
    imports: [MultiViewCalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_MULTIVIEWCALENDAR],
      imports: [...KENDO_MULTIVIEWCALENDAR],
      providers: [PopupService, NavigationService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService]
    }]
  }], null, null);
})();
var DateRangeModule = class _DateRangeModule {
  static ɵfac = function DateRangeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateRangeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateRangeModule,
    imports: [DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective],
    exports: [DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // MultiViewCalendarModule providers
      PopupService,
      NavigationService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      // DateInputModule providers
      IconsService,
      // AdaptiveModule providers
      ResizeBatchService
    ],
    imports: [DateInputComponent, DateRangeComponent, DateRangePopupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATERANGE],
      imports: [...KENDO_DATERANGE],
      providers: [
        // MultiViewCalendarModule providers
        PopupService,
        NavigationService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        // DateInputModule providers
        IconsService,
        // AdaptiveModule providers
        ResizeBatchService
      ]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-recurrence/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends2(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// node_modules/@progress/kendo-recurrence/dist/es/limitations.js
var limitations_exports = {};
__export(limitations_exports, {
  byHour: () => byHour,
  byMinute: () => byMinute,
  byMonth: () => byMonth,
  byMonthDay: () => byMonthDay,
  bySecond: () => bySecond,
  byWeekDay: () => byWeekDay,
  byWeekNumber: () => byWeekNumber,
  byYearDay: () => byYearDay
});

// node_modules/@progress/kendo-recurrence/dist/es/utils/has-modifiers.js
var some = function(arr) {
  return arr instanceof Array && arr.length > 0;
};
var hasModifiers = function(rule) {
  return some(rule.bySecond) || some(rule.byMinute) || some(rule.byHour) || some(rule.byYearDay) || some(rule.byMonthDay) || some(rule.byWeekDay) || some(rule.byMonth) || some(rule.byWeekNumber);
};

// node_modules/@progress/kendo-recurrence/dist/es/utils/parse-date-time.js
var parseDateTimeList = function(rule) {
  var pairs = rule.split(";");
  var values = [];
  var timezone = null;
  for (var idx2 = 0; idx2 < pairs.length; idx2++) {
    var _a2 = pairs[idx2].split(":"), property = _a2[0], _b = _a2[1], val = _b === void 0 ? "" : _b;
    var tzIndex = property.indexOf("TZID");
    if (tzIndex !== -1) {
      timezone = property.substring(tzIndex).split("=")[1];
    }
    values = val.split(",").map(function(v) {
      return parseISODate(v, timezone);
    });
  }
  if (!values.length || values[0] === null) {
    return null;
  }
  return values;
};
var parseDateTime = function(rule) {
  var list2 = parseDateTimeList(rule);
  if (list2 === null) {
    return null;
  }
  return list2[0];
};

// node_modules/@telerik/kendo-intl/dist/es/cldr/default-data.js
var defaultData = {
  en: {
    name: "en",
    identity: {
      version: {
        _number: "$Revision: 12418 $",
        _cldrVersion: "29"
      },
      language: "en"
    },
    territory: "US",
    numbers: {
      symbols: {
        decimal: ".",
        group: ",",
        list: ";",
        percentSign: "%",
        plusSign: "+",
        minusSign: "-",
        exponential: "E",
        superscriptingExponent: "×",
        perMille: "‰",
        infinity: "∞",
        nan: "NaN",
        timeSeparator: ":"
      },
      decimal: {
        patterns: ["n"],
        groupSize: [3]
      },
      scientific: {
        patterns: ["nEn"],
        groupSize: []
      },
      percent: {
        patterns: ["n%"],
        groupSize: [3]
      },
      currency: {
        patterns: ["$n"],
        groupSize: [3],
        "unitPattern-count-one": "n $",
        "unitPattern-count-other": "n $"
      },
      currencies: {
        BGN: {
          displayName: "Bulgarian Lev",
          "displayName-count-one": "Bulgarian lev",
          "displayName-count-other": "Bulgarian leva",
          symbol: "BGN"
        },
        EUR: {
          displayName: "Euro",
          "displayName-count-one": "euro",
          "displayName-count-other": "euros",
          symbol: "€",
          "symbol-alt-narrow": "€"
        },
        USD: {
          displayName: "US Dollar",
          "displayName-count-one": "US dollar",
          "displayName-count-other": "US dollars",
          symbol: "$",
          "symbol-alt-narrow": "$"
        }
      },
      localeCurrency: "USD",
      accounting: {
        patterns: ["$n", "($n)"],
        groupSize: [3]
      }
    },
    calendar: {
      gmtFormat: "GMT{0}",
      gmtZeroFormat: "GMT",
      patterns: {
        d: "M/d/y",
        D: "EEEE, MMMM d, y",
        m: "MMM d",
        M: "MMMM d",
        y: "MMM y",
        Y: "MMMM y",
        F: "EEEE, MMMM d, y h:mm:ss a",
        g: "M/d/y h:mm a",
        G: "M/d/y h:mm:ss a",
        t: "h:mm a",
        T: "h:mm:ss a",
        s: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
        u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"
      },
      dateTimeFormats: {
        full: "{1} 'at' {0}",
        long: "{1} 'at' {0}",
        medium: "{1}, {0}",
        short: "{1}, {0}",
        availableFormats: {
          Bh: "h B",
          Bhm: "h:mm B",
          Bhms: "h:mm:ss B",
          d: "d",
          E: "ccc",
          EBhm: "E h:mm B",
          EBhms: "E h:mm:ss B",
          Ed: "d E",
          Ehm: "E h:mm a",
          EHm: "E HH:mm",
          Ehms: "E h:mm:ss a",
          EHms: "E HH:mm:ss",
          Gy: "y G",
          GyMMM: "MMM y G",
          GyMMMd: "MMM d, y G",
          GyMMMEd: "E, MMM d, y G",
          h: "h a",
          H: "HH",
          hm: "h:mm a",
          Hm: "HH:mm",
          hms: "h:mm:ss a",
          Hms: "HH:mm:ss",
          hmsv: "h:mm:ss a v",
          Hmsv: "HH:mm:ss v",
          hmv: "h:mm a v",
          Hmv: "HH:mm v",
          M: "L",
          Md: "M/d",
          MEd: "E, M/d",
          MMM: "LLL",
          MMMd: "MMM d",
          MMMEd: "E, MMM d",
          MMMMd: "MMMM d",
          "MMMMW-count-one": "'week' W 'of' MMMM",
          "MMMMW-count-other": "'week' W 'of' MMMM",
          ms: "mm:ss",
          y: "y",
          yM: "M/y",
          yMd: "M/d/y",
          yMEd: "E, M/d/y",
          yMMM: "MMM y",
          yMMMd: "MMM d, y",
          yMMMEd: "E, MMM d, y",
          yMMMM: "MMMM y",
          yQQQ: "QQQ y",
          yQQQQ: "QQQQ y",
          "yw-count-one": "'week' w 'of' Y",
          "yw-count-other": "'week' w 'of' Y"
        }
      },
      timeFormats: {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      },
      dateFormats: {
        full: "EEEE, MMMM d, y",
        long: "MMMM d, y",
        medium: "MMM d, y",
        short: "M/d/yy"
      },
      days: {
        format: {
          abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          narrow: ["S", "M", "T", "W", "T", "F", "S"],
          short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
          wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        },
        "stand-alone": {
          abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          narrow: ["S", "M", "T", "W", "T", "F", "S"],
          short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
          wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        }
      },
      months: {
        format: {
          abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
          wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        "stand-alone": {
          abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
          wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        }
      },
      quarters: {
        format: {
          abbreviated: ["Q1", "Q2", "Q3", "Q4"],
          narrow: ["1", "2", "3", "4"],
          wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
        },
        "stand-alone": {
          abbreviated: ["Q1", "Q2", "Q3", "Q4"],
          narrow: ["1", "2", "3", "4"],
          wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
        }
      },
      dayPeriods: {
        format: {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          narrow: {
            midnight: "mi",
            am: "a",
            "am-alt-variant": "am",
            noon: "n",
            pm: "p",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          }
        },
        "stand-alone": {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          narrow: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          }
        }
      },
      eras: {
        format: {
          wide: {
            "0": "Before Christ",
            "1": "Anno Domini",
            "0-alt-variant": "Before Common Era",
            "1-alt-variant": "Common Era"
          },
          abbreviated: {
            "0": "BC",
            "1": "AD",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          },
          narrow: {
            "0": "B",
            "1": "A",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          }
        }
      },
      dateFields: {
        era: {
          wide: "era"
        },
        year: {
          wide: "year",
          short: "yr.",
          narrow: "yr."
        },
        quarter: {
          wide: "quarter",
          short: "qtr.",
          narrow: "qtr."
        },
        month: {
          wide: "month",
          short: "mo.",
          narrow: "mo."
        },
        week: {
          wide: "week",
          short: "wk.",
          narrow: "wk."
        },
        day: {
          wide: "day",
          short: "day",
          narrow: "day"
        },
        weekday: {
          wide: "day of the week"
        },
        dayperiod: {
          wide: "AM/PM"
        },
        hour: {
          wide: "hour",
          short: "hr.",
          narrow: "hr."
        },
        minute: {
          wide: "minute",
          short: "min.",
          narrow: "min."
        },
        second: {
          wide: "second",
          short: "sec.",
          narrow: "sec."
        },
        millisecond: {
          wide: "millisecond",
          short: "ms",
          narrow: "ms"
        },
        zone: {
          wide: "time zone"
        }
      }
    }
  },
  supplemental: {
    likelySubtags: {
      en: "en-Latn-US"
    },
    currencyData: {
      region: {
        US: [{
          USD: {
            _from: "1792-01-01"
          }
        }]
      }
    },
    weekData: {
      firstDay: {
        US: "sun"
      },
      weekendStart: {
        "001": "sat"
      },
      weekendEnd: {
        "001": "sun"
      }
    }
  }
};
var default_data_default = defaultData;

// node_modules/@telerik/kendo-intl/dist/es/common/is-string.js
function isString(value2) {
  return typeof value2 === "string";
}

// node_modules/@telerik/kendo-intl/dist/es/error-details.js
var error_details_default = {
  "NoLocale": "Missing locale info for '{0}'",
  "NoCurrency": "Cannot determine currency information. Please load the locale currencies data.",
  "NoSupplementalCurrency": "Cannot determine currency. Please load the supplemental currencyData.",
  "NoCurrencyRegion": "No currency data for region '{0}'",
  "NoCurrencyDisplay": "Cannot determine currency display information. Please load the locale currencies data. The default culture does not include the all currencies data.",
  "NoGMTInfo": "Cannot determine locale GMT format. Please load the locale timeZoneNames data.",
  "NoWeekData": "Cannot determine locale first day of week. Please load the supplemental weekData.",
  "NoFirstDay": "Cannot determine locale first day of week. Please load the supplemental weekData. The default culture includes only the 'en-US' first day info.",
  "NoValidCurrency": "Cannot determine a default currency for the {0} locale. Please specify explicitly the currency with the format options.",
  "NoDateFieldNames": "Cannot determine the locale date field names. Please load the locale dateFields data."
};

// node_modules/@telerik/kendo-intl/dist/es/errors.js
var formatRegExp3 = /\{(\d+)}?\}/g;
var IntlError = function IntlError2(ref) {
  var name = ref.name;
  var message = ref.message;
  if (!name || !message) {
    throw new Error("{ name: string, message: string } object is required!");
  }
  this.name = name;
  this.message = message;
};
IntlError.prototype.formatMessage = function formatMessage2() {
  var values = [], len = arguments.length;
  while (len--) values[len] = arguments[len];
  var flattenValues = flatten2(values);
  var formattedMessage = this.message.replace(formatRegExp3, function(match, index) {
    return flattenValues[parseInt(index, 10)];
  });
  return this.name + ": " + formattedMessage;
};
IntlError.prototype.error = function error() {
  var values = [], len = arguments.length;
  while (len--) values[len] = arguments[len];
  return new Error(this.formatMessage(values));
};
var flatten2 = function(arr) {
  return arr.reduce(function(a, b) {
    return a.concat(b);
  }, []);
};
var toIntlErrors = function(errors2) {
  var predicate = function(prev, name) {
    prev[name] = new IntlError({
      name,
      message: errors2[name]
    });
    return prev;
  };
  return Object.keys(errors2).reduce(predicate, {});
};
var errors = toIntlErrors(error_details_default);

// node_modules/@telerik/kendo-intl/dist/es/cldr/info.js
function availableLocaleInfo(fullName, suffixes) {
  var parts = fullName.split("-");
  var language = parts[0];
  var script = parts[1];
  var territory = parts[2];
  return cldr[fullName] || suffixes.indexOf(territory) !== -1 && cldr[language + "-" + territory] || suffixes.indexOf(script) !== -1 && cldr[language + "-" + script] || cldr[language];
}
function localeFullName(language, suffixes) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  for (var idx2 = 0; idx2 < suffixes.length; idx2++) {
    var name = likelySubtags[language + "-" + suffixes[idx2]];
    if (name) {
      return name;
    }
  }
  if (likelySubtags[language]) {
    return likelySubtags[language];
  }
}
var cldr = default_data_default;
function getLocaleInfo(locale) {
  var info;
  if (isString(locale)) {
    info = localeInfo(locale);
  } else {
    info = locale;
  }
  return info;
}
function localeInfo(locale) {
  if (cldr[locale]) {
    return cldr[locale];
  }
  var likelySubtags = cldr.supplemental.likelySubtags;
  if (likelySubtags) {
    var parts = locale.split("-");
    var language = parts[0];
    var suffixes = parts.slice(1);
    var fullName = localeFullName(language, suffixes);
    var info = fullName ? availableLocaleInfo(fullName, suffixes) : null;
    if (info) {
      return info;
    }
  }
  throw errors.NoLocale.error(locale);
}

// node_modules/@telerik/kendo-intl/dist/es/common/constants.js
var DECIMAL = "decimal";
var CURRENCY = "currency";
var ACCOUNTING = "accounting";
var PERCENT = "percent";
var SCIENTIFIC = "scientific";
var CURRENCY_PLACEHOLDER = "$";
var PERCENT_PLACEHOLDER = "%";
var NUMBER_PLACEHOLDER = "n";
var LIST_SEPARATOR = ";";
var GROUP_SEPARATOR = ",";
var POINT = ".";
var EMPTY2 = "";
var DEFAULT_LOCALE = "en";

// node_modules/@telerik/kendo-intl/dist/es/cldr/territory.js
function territoryFromName(name, identity4) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  var parts = name.split("-");
  if (likelySubtags) {
    var likelyName = likelySubtags[name] || likelySubtags[parts[0]];
    if (likelyName) {
      parts = likelyName.split("-");
    }
  }
  if (identity4) {
    for (var idx2 = parts.length - 1; idx2 >= 1; idx2--) {
      var part = parts[idx2];
      if (part === identity4.variant || part === identity4.script) {
        parts.splice(idx2, 1);
      }
    }
  }
  var length2 = parts.length;
  if (length2 > 1) {
    var territory = parts[length2 - 1];
    return territory.toUpperCase();
  }
}
function localeTerritory(info) {
  if (info.territory) {
    return info.territory;
  }
  var name = info.name;
  var identity4 = info.identity;
  var territory;
  if (identity4 && identity4.territory) {
    territory = identity4.territory;
  } else {
    territory = territoryFromName(name, identity4);
  }
  info.territory = territory;
  return territory;
}

// node_modules/@telerik/kendo-intl/dist/es/cldr/date-format-names.js
function lowerArray(arr) {
  var result = [];
  for (var idx2 = 0; idx2 < arr.length; idx2++) {
    result.push(arr[idx2].toLowerCase());
  }
  return result;
}
function lowerObject(obj) {
  var result = {};
  for (var field in obj) {
    result[field] = obj[field].toLowerCase();
  }
  return result;
}
function cloneLower(obj) {
  var result = Array.isArray(obj) ? lowerArray(obj) : lowerObject(obj);
  return result;
}
function dateFormatNames(locale, options) {
  var type = options.type;
  var nameType = options.nameType;
  var standAlone = options.standAlone;
  var lower = options.lower;
  var info = getLocaleInfo(locale);
  var formatType = standAlone ? "stand-alone" : "format";
  var lowerNameType = (lower ? "lower-" : EMPTY2) + nameType;
  var formatNames2 = info.calendar[type][formatType];
  var result = formatNames2[lowerNameType];
  if (!result && lower) {
    result = formatNames2[lowerNameType] = cloneLower(formatNames2[nameType]);
  }
  return result;
}

// node_modules/@telerik/kendo-intl/dist/es/cldr/parse-range-date.js
function parseRangeDate(value2) {
  var parts = value2.split("-");
  var year = parseInt(parts[0], 10);
  var month = parseInt(parts[1], 10) - 1;
  var day = parseInt(parts[2], 10);
  return new Date(year, month, day);
}

// node_modules/@telerik/kendo-intl/dist/es/cldr/currency.js
var NoCurrency = errors.NoCurrency;
var NoCurrencyDisplay = errors.NoCurrencyDisplay;
var NoSupplementalCurrency = errors.NoSupplementalCurrency;
var NoCurrencyRegion = errors.NoCurrencyRegion;
var NoValidCurrency = errors.NoValidCurrency;
var DEFAULT_CURRENCY_FRACTIONS = 2;
var SYMBOL = "symbol";
var INVALID_CURRENCY_CODE = "XXX";
var GLOBAL_CURRENCIES = {
  "001": "USD",
  // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error
  "150": "EUR"
  // 150 territory for Europe
};
function getCurrencyInfo(locale, currency, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var currencies = info.numbers.currencies;
  if (!currencies) {
    if (throwIfNoValid) {
      throw NoCurrency.error();
    }
    return;
  }
  var currencyDisplayInfo = currencies[currency];
  if (!currencyDisplayInfo) {
    if (throwIfNoValid) {
      throw NoCurrencyDisplay.error();
    }
    return;
  }
  return currencyDisplayInfo;
}
function regionCurrency(regionCurrencies) {
  var latestValidUntil, latestValidUntilRange;
  var latestStillValid, latestStillValidDate;
  for (var idx2 = 0; idx2 < regionCurrencies.length; idx2++) {
    var currency = regionCurrencies[idx2];
    var code = Object.keys(currency)[0];
    var info = currency[code];
    if (code !== INVALID_CURRENCY_CODE && info._tender !== "false" && info._from) {
      if (!info._to) {
        var stillValidDate = parseRangeDate(info._from);
        if (!latestStillValidDate || latestStillValidDate < stillValidDate) {
          latestStillValid = code;
          latestStillValidDate = stillValidDate;
        }
      } else if (!latestStillValid) {
        var validFrom = parseRangeDate(info._from);
        var validTo = parseRangeDate(info._to);
        if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {
          latestValidUntil = code;
          latestValidUntilRange = {
            from: validFrom,
            to: validTo
          };
        }
      }
    }
  }
  return latestStillValid || latestValidUntil;
}
function currencyDisplay(locale, options) {
  var value2 = options.value;
  var currency = options.currency;
  var currencyDisplay2 = options.currencyDisplay;
  if (currencyDisplay2 === void 0) currencyDisplay2 = SYMBOL;
  if (currencyDisplay2 === "code") {
    return currency;
  }
  var currencyInfo = getCurrencyInfo(locale, currency, true);
  var result;
  if (currencyDisplay2 === SYMBOL) {
    result = currencyInfo["symbol-alt-narrow"] || currencyInfo[SYMBOL];
  } else {
    if (typeof value2 === void 0 || value2 !== 1) {
      result = currencyInfo["displayName-count-other"];
    } else {
      result = currencyInfo["displayName-count-one"];
    }
  }
  return result;
}
function currencyFractionOptions(code) {
  var minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];
  if (fractions && fractions._digits) {
    maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function territoryCurrencyCode(territory, throwIfNoValid) {
  if (throwIfNoValid === void 0) throwIfNoValid = true;
  if (GLOBAL_CURRENCIES[territory]) {
    return GLOBAL_CURRENCIES[territory];
  }
  var currencyData = cldr.supplemental.currencyData;
  if (!currencyData) {
    if (throwIfNoValid) {
      throw NoSupplementalCurrency.error();
    }
    return;
  }
  var regionCurrencies = currencyData.region[territory];
  if (!regionCurrencies) {
    if (throwIfNoValid) {
      throw NoCurrencyRegion.error(territory);
    }
    return;
  }
  var currencyCode = regionCurrency(regionCurrencies);
  return currencyCode;
}
function localeCurrency(locale, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var numbers = info.numbers;
  if (!numbers.localeCurrency) {
    var currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);
    if (!currency && throwIfNoValid) {
      throw NoValidCurrency.error(info.name);
    }
    numbers.localeCurrency = currency;
  }
  return numbers.localeCurrency;
}

// node_modules/@telerik/kendo-intl/dist/es/cldr/constants.js
var DAYS_OF_WEEK = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var DEFAULT_TERRITORY = "001";

// node_modules/@telerik/kendo-intl/dist/es/cldr/first-day.js
var NoWeekData = errors.NoWeekData;
var NoFirstDay = errors.NoFirstDay;
function firstDay(locale) {
  var info = getLocaleInfo(locale);
  if (!isNaN(info.firstDay)) {
    return info.firstDay;
  }
  var weekData = cldr.supplemental.weekData;
  if (!weekData) {
    throw NoWeekData.error();
  }
  var firstDay2 = weekData.firstDay[localeTerritory(info)] || weekData.firstDay[DEFAULT_TERRITORY];
  if (!firstDay2) {
    throw NoFirstDay.error();
  }
  info.firstDay = DAYS_OF_WEEK.indexOf(firstDay2);
  return info.firstDay;
}

// node_modules/@telerik/kendo-intl/dist/es/cldr/weekend-range.js
var NoWeekData2 = errors.NoWeekData;

// node_modules/@telerik/kendo-intl/dist/es/common/is-negative-zero.js
function isNegativeZero(value2) {
  return 1 / value2 === -Infinity;
}

// node_modules/@telerik/kendo-intl/dist/es/numbers/format-currency-symbol.js
function formatCurrencySymbol(info, options) {
  if (options === void 0) options = {};
  if (!options.currency) {
    options.currency = localeCurrency(info, true);
  }
  var display = currencyDisplay(info, options);
  return display;
}

// node_modules/@telerik/kendo-intl/dist/es/numbers/group-integer.js
function groupInteger(number, start, end, options, info) {
  var symbols = info.numbers.symbols;
  var decimalIndex = number.indexOf(symbols.decimal);
  var groupSizes = options.groupSize.slice();
  var groupSize = groupSizes.shift();
  var integerEnd = decimalIndex !== -1 ? decimalIndex : end + 1;
  var integer = number.substring(start, integerEnd);
  var result = number;
  var integerLength = integer.length;
  if (integerLength >= groupSize) {
    var idx2 = integerLength;
    var parts = [];
    while (idx2 > -1) {
      var value2 = integer.substring(idx2 - groupSize, idx2);
      if (value2) {
        parts.push(value2);
      }
      idx2 -= groupSize;
      var newGroupSize = groupSizes.shift();
      groupSize = newGroupSize !== void 0 ? newGroupSize : groupSize;
      if (groupSize === 0) {
        value2 = integer.substring(0, idx2);
        if (value2) {
          parts.push(value2);
        }
        break;
      }
    }
    integer = parts.reverse().join(symbols.group);
    result = number.substring(0, start) + integer + number.substring(integerEnd);
  }
  return result;
}

// node_modules/@telerik/kendo-intl/dist/es/numbers/is-currency-style.js
function isCurrencyStyle(style) {
  return style === CURRENCY || style === ACCOUNTING;
}

// node_modules/@telerik/kendo-intl/dist/es/common/pad.js
function pad(number, digits, right2) {
  if (digits === void 0) digits = 2;
  if (right2 === void 0) right2 = false;
  var count = digits - String(number).length;
  var result = number;
  if (count > 0) {
    var padString = new Array(count + 1).join("0");
    result = right2 ? number + padString : padString + number;
  }
  return result;
}

// node_modules/@telerik/kendo-intl/dist/es/common/round.js
var MAX_PRECISION = 20;
function round(value2, precision) {
  var result = value2;
  var decimals = precision || 0;
  result = result.toString().split("e");
  result = Math.round(Number(result[0] + "e" + (result[1] ? Number(result[1]) + decimals : decimals)));
  result = result.toString().split("e");
  result = Number(result[0] + "e" + (result[1] ? Number(result[1]) - decimals : -decimals));
  return result.toFixed(Math.min(decimals, MAX_PRECISION));
}

// node_modules/@telerik/kendo-intl/dist/es/numbers/standard-number-format.js
var DEFAULT_DECIMAL_ROUNDING = 3;
var DEFAULT_PERCENT_ROUNDING = 0;
var trailingZeroRegex = /0+$/;
function fractionOptions(options) {
  var minimumFractionDigits = options.minimumFractionDigits;
  var maximumFractionDigits = options.maximumFractionDigits;
  var style = options.style;
  var isCurrency = isCurrencyStyle(style);
  var currencyFractions;
  if (isCurrency) {
    currencyFractions = currencyFractionOptions(options.currency);
  }
  if (minimumFractionDigits === void 0) {
    minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;
  }
  if (maximumFractionDigits === void 0) {
    if (style === PERCENT) {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);
    } else if (isCurrency) {
      maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);
    } else {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);
    }
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function applyPattern(value2, pattern, symbol) {
  var result = EMPTY2;
  for (var idx2 = 0, length2 = pattern.length; idx2 < length2; idx2++) {
    var ch = pattern.charAt(idx2);
    if (ch === NUMBER_PLACEHOLDER) {
      result += value2;
    } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {
      result += symbol;
    } else {
      result += ch;
    }
  }
  return result;
}
function currencyUnitPattern(info, value2) {
  var currencyInfo = info.numbers.currency;
  var pattern = value2 !== 1 ? currencyInfo["unitPattern-count-other"] : currencyInfo["unitPattern-count-one"];
  if (value2 < 0) {
    pattern = pattern.replace(NUMBER_PLACEHOLDER, "-" + NUMBER_PLACEHOLDER);
  }
  return pattern;
}
function standardNumberFormat(number, options, info) {
  var symbols = info.numbers.symbols;
  var style = options.style;
  var isCurrency = isCurrencyStyle(style);
  if (style === SCIENTIFIC) {
    var exponential = options.minimumFractionDigits !== void 0 ? number.toExponential(options.minimumFractionDigits) : number.toExponential();
    return exponential.replace(POINT, symbols.decimal);
  }
  var value2 = number;
  var symbol;
  if (isCurrency) {
    options.value = value2;
    symbol = formatCurrencySymbol(info, options);
  }
  if (style === PERCENT) {
    value2 *= 100;
    symbol = symbols.percentSign;
  }
  var ref = fractionOptions(options);
  var minimumFractionDigits = ref.minimumFractionDigits;
  var maximumFractionDigits = ref.maximumFractionDigits;
  value2 = round(value2, maximumFractionDigits);
  var negative = value2 < 0;
  var negativeZero = isNegativeZero(number);
  var parts = value2.split(POINT);
  var integer = parts[0];
  var fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY2) : EMPTY2, minimumFractionDigits, true);
  if (negative) {
    integer = integer.substring(1);
  }
  if (options.minimumIntegerDigits) {
    integer = pad(integer, options.minimumIntegerDigits);
  }
  var formattedValue = options.useGrouping !== false ? groupInteger(integer, 0, integer.length, options, info) : integer;
  if (fraction) {
    formattedValue += symbols.decimal + fraction;
  }
  var pattern;
  if (isCurrency && options.currencyDisplay === "name") {
    pattern = currencyUnitPattern(info, number);
  } else {
    var patterns = options.patterns;
    pattern = negative || negativeZero ? patterns[1] || "-" + patterns[0] : patterns[0];
  }
  if (pattern === NUMBER_PLACEHOLDER && !negative) {
    return formattedValue;
  }
  var result = applyPattern(formattedValue, pattern, symbol);
  return result;
}

// node_modules/@telerik/kendo-intl/dist/es/numbers/utils.js
var literalRegExp = /(\\.)|(['][^']*[']?)|(["][^"]*["]?)/g;
var PLACEHOLDER = "__??__";
function setStyleOptions(formatOptions2, info) {
  var format = formatOptions2.format;
  if (format.indexOf(PERCENT_PLACEHOLDER) !== -1) {
    formatOptions2.style = PERCENT;
    formatOptions2.symbol = info.numbers.symbols.percentSign;
    formatOptions2.number *= 100;
  }
  if (format.indexOf(CURRENCY_PLACEHOLDER) !== -1) {
    formatOptions2.style = CURRENCY;
    formatOptions2.symbol = formatCurrencySymbol(info);
  }
}
function setFormatLiterals(formatOptions2) {
  var format = formatOptions2.format;
  if (format.indexOf("'") > -1 || format.indexOf('"') > -1 || format.indexOf("\\") > -1) {
    var literals = formatOptions2.literals = [];
    formatOptions2.format = format.replace(literalRegExp, function(match) {
      var quoteChar = match.charAt(0).replace("\\", EMPTY2);
      var literal = match.slice(1).replace(quoteChar, EMPTY2);
      literals.push(literal);
      return PLACEHOLDER;
    });
  }
}
function replaceLiterals(number, literals) {
  var result = number;
  if (literals) {
    var length2 = literals.length;
    for (var idx2 = 0; idx2 < length2; idx2++) {
      result = result.replace(PLACEHOLDER, literals[idx2]);
    }
  }
  return result;
}

// node_modules/@telerik/kendo-intl/dist/es/numbers/custom-number-format.js
var SHARP = "#";
var ZERO = "0";
var trailingZerosRegExp = /(\.(?:[0-9]*[1-9])?)0+$/g;
var trailingPointRegExp = /\.$/;
var commaRegExp = /\,/g;
function trimTrailingZeros(value2, lastZero) {
  var trimRegex;
  if (lastZero === 0) {
    trimRegex = trailingZerosRegExp;
  } else {
    trimRegex = new RegExp("(\\.[0-9]{" + lastZero + "}[1-9]*)0+$", "g");
  }
  return value2.replace(trimRegex, "$1").replace(trailingPointRegExp, EMPTY2);
}
function roundNumber(formatOptions2) {
  var number = formatOptions2.number;
  var format = formatOptions2.format;
  var decimalIndex = format.indexOf(POINT);
  if (decimalIndex !== -1) {
    var zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;
    var sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;
    var hasZero = zeroIndex > -1;
    var hasSharp = sharpIndex > -1;
    var fraction = number.toString().split("e");
    if (fraction[1]) {
      fraction = round(number, Math.abs(fraction[1]));
    } else {
      fraction = fraction[0];
    }
    fraction = fraction.split(POINT)[1] || EMPTY2;
    var precision = fraction.length;
    var trailingZeros = -1;
    if (!hasZero && !hasSharp) {
      formatOptions2.format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);
      decimalIndex = -1;
      precision = 0;
    } else if (hasZero && zeroIndex > sharpIndex) {
      precision = zeroIndex;
    } else if (sharpIndex > zeroIndex) {
      if (hasSharp && precision > sharpIndex) {
        precision = sharpIndex;
      } else if (hasZero && precision < zeroIndex) {
        precision = zeroIndex;
      }
      trailingZeros = hasZero ? zeroIndex : 0;
    }
    if (precision > -1) {
      number = round(number, precision);
      if (trailingZeros > -1) {
        number = trimTrailingZeros(number, trailingZeros);
      }
    }
  } else {
    number = round(number);
  }
  if (formatOptions2.negative && number * -1 >= 0 && !formatOptions2.negativeZero) {
    formatOptions2.negative = false;
  }
  formatOptions2.number = number;
  formatOptions2.decimalIndex = decimalIndex;
}
function isConstantFormat(format) {
  return format.indexOf(SHARP) === -1 && format.indexOf(ZERO) === -1;
}
function setValueSpecificFormat(formatOptions2) {
  var number = formatOptions2.number;
  var format = formatOptions2.format;
  format = format.split(LIST_SEPARATOR);
  if ((formatOptions2.negative || formatOptions2.negativeZero) && format[1]) {
    format = format[1];
    formatOptions2.hasNegativeFormat = true;
  } else if (number === 0) {
    var zeroFormat = format[2];
    format = zeroFormat || format[0];
    if (zeroFormat && isConstantFormat(zeroFormat)) {
      formatOptions2.constant = zeroFormat;
    }
  } else {
    format = format[0];
  }
  formatOptions2.format = format;
}
function setGroupOptions(formatOptions2) {
  formatOptions2.hasGroup = formatOptions2.format.indexOf(GROUP_SEPARATOR) > -1;
  if (formatOptions2.hasGroup) {
    formatOptions2.format = formatOptions2.format.replace(commaRegExp, EMPTY2);
  }
}
function placeholderIndex(index1, index2, start) {
  var index;
  if (index1 === -1 && index2 !== -1) {
    index = index2;
  } else if (index1 !== -1 && index2 === -1) {
    index = index1;
  } else {
    index = start ? Math.min(index1, index2) : Math.max(index1, index2);
  }
  return index;
}
function setPlaceholderIndices(formatOptions2) {
  var format = formatOptions2.format;
  var sharpIndex = format.indexOf(SHARP);
  var zeroIndex = format.indexOf(ZERO);
  var start = placeholderIndex(sharpIndex, zeroIndex, true);
  sharpIndex = format.lastIndexOf(SHARP);
  zeroIndex = format.lastIndexOf(ZERO);
  var end = placeholderIndex(sharpIndex, zeroIndex);
  if (start === format.length) {
    end = start;
  }
  formatOptions2.start = start;
  formatOptions2.end = end;
  formatOptions2.lastZeroIndex = zeroIndex;
}
function replaceStyleSymbols(number, style, symbol) {
  var result = number;
  if (style === CURRENCY || style === PERCENT) {
    result = EMPTY2;
    for (var idx2 = 0, length2 = number.length; idx2 < length2; idx2++) {
      var ch = number.charAt(idx2);
      result += ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER ? symbol : ch;
    }
  }
  return result;
}
function replacePlaceHolders(formatOptions2, info) {
  var start = formatOptions2.start;
  var end = formatOptions2.end;
  var negative = formatOptions2.negative;
  var negativeZero = formatOptions2.negativeZero;
  var format = formatOptions2.format;
  var decimalIndex = formatOptions2.decimalIndex;
  var lastZeroIndex = formatOptions2.lastZeroIndex;
  var hasNegativeFormat = formatOptions2.hasNegativeFormat;
  var hasGroup = formatOptions2.hasGroup;
  var number = formatOptions2.number;
  var value2 = number.toString().split(POINT);
  var length2 = format.length;
  var integer = value2[0];
  var fraction = value2[1] || EMPTY2;
  var integerLength = integer.length;
  var replacement = EMPTY2;
  number = format.substring(0, start);
  if ((negative || negativeZero) && !hasNegativeFormat) {
    number += "-";
  }
  for (var idx2 = start; idx2 < length2; idx2++) {
    var ch = format.charAt(idx2);
    if (decimalIndex === -1) {
      if (end - idx2 < integerLength) {
        number += integer;
        break;
      }
    } else {
      if (lastZeroIndex !== -1 && lastZeroIndex < idx2) {
        replacement = EMPTY2;
      }
      if (decimalIndex - idx2 <= integerLength && decimalIndex - idx2 > -1) {
        number += integer;
        idx2 = decimalIndex;
      }
      if (decimalIndex === idx2) {
        number += (fraction ? info.numbers.symbols.decimal : EMPTY2) + fraction;
        idx2 += end - decimalIndex + 1;
        continue;
      }
    }
    if (ch === ZERO) {
      number += ch;
      replacement = ch;
    } else if (ch === SHARP) {
      number += replacement;
    }
  }
  if (hasGroup) {
    number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, integerLength + start), info.numbers.decimal, info);
  }
  if (end >= start) {
    number += format.substring(end + 1);
  }
  return number;
}
function applyCustomFormat(formatOptions2, info) {
  var number = formatOptions2.number;
  if (formatOptions2.start !== -1) {
    number = replacePlaceHolders(formatOptions2, info);
    number = replaceStyleSymbols(number, formatOptions2.style, formatOptions2.symbol);
    number = replaceLiterals(number, formatOptions2.literals);
  }
  return number;
}
function customNumberFormat(number, format, info) {
  var formatOptions2 = {
    negative: number < 0,
    number: Math.abs(number),
    negativeZero: isNegativeZero(number),
    format
  };
  setValueSpecificFormat(formatOptions2);
  if (formatOptions2.constant) {
    return formatOptions2.constant;
  }
  setFormatLiterals(formatOptions2);
  setStyleOptions(formatOptions2, info);
  setGroupOptions(formatOptions2);
  roundNumber(formatOptions2);
  setPlaceholderIndices(formatOptions2);
  return applyCustomFormat(formatOptions2, info);
}

// node_modules/@telerik/kendo-intl/dist/es/numbers/format-options.js
var standardFormatRegExp = /^(n|c|p|e|a)(\d*)$/i;
function standardFormatOptions(format) {
  var formatAndPrecision = standardFormatRegExp.exec(format);
  if (formatAndPrecision) {
    var options = {
      style: DECIMAL
    };
    var style = formatAndPrecision[1].toLowerCase();
    if (style === "c") {
      options.style = CURRENCY;
    } else if (style === "a") {
      options.style = ACCOUNTING;
    } else if (style === "p") {
      options.style = PERCENT;
    } else if (style === "e") {
      options.style = SCIENTIFIC;
    }
    if (formatAndPrecision[2]) {
      options.minimumFractionDigits = options.maximumFractionDigits = parseInt(formatAndPrecision[2], 10);
    }
    return options;
  }
}
function formatOptions(format) {
  var options;
  if (isString(format)) {
    options = standardFormatOptions(format);
  } else {
    options = format;
  }
  return options;
}

// node_modules/@telerik/kendo-intl/dist/es/numbers/format-number.js
function formatNumber(number, format, locale) {
  if (format === void 0) format = NUMBER_PLACEHOLDER;
  if (locale === void 0) locale = DEFAULT_LOCALE;
  if (number === void 0 || number === null) {
    return EMPTY2;
  }
  if (!isFinite(number)) {
    return String(number);
  }
  var info = localeInfo(locale);
  var options = formatOptions(format);
  var result;
  if (options) {
    var style = options.style || DECIMAL;
    result = standardNumberFormat(number, Object.assign({}, info.numbers[style], options), info);
  } else {
    result = customNumberFormat(number, format, info);
  }
  return result;
}

// node_modules/@telerik/kendo-intl/dist/es/common/is-number.js
function isNumber2(value2) {
  return typeof value2 === "number";
}

// node_modules/@telerik/kendo-intl/dist/es/common/format-string.js
var formatRegExp4 = /\{(\d+)}/g;
function formatString(format) {
  var values = arguments;
  return format.replace(formatRegExp4, function(match, index) {
    var value2 = values[parseInt(index, 10) + 1];
    return value2;
  });
}

// node_modules/@telerik/kendo-intl/dist/es/dates/date-pattern.js
var REMOVAL_PENALTY = 120;
var ADDITION_PENALTY = 20;
var LENGHT_DELTA = [2, 1, 5, 3, 4];
var LONG_LESS_PENALTY_DELTA = -2;
var SHORT_LESS_PENALTY_DELTA = -1;
var SHORT_MORE_PENALTY_DELTA = 1;
var LONG_MORE_PENALTY_DELTA = 2;
var PENALTIES = {};
PENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;
PENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;
PENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;
PENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;
var VALUE_FORMAT_LENGTH = {
  numeric: 1,
  "2-digit": 2,
  short: 3,
  long: 4,
  narrow: 5
};
var TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;
function getHourSpecifier(options) {
  return options.hour12 ? "h" : "H";
}
var DATE_OPTIONS_MAP = [{
  key: "era",
  specifier: "G"
}, {
  key: "year",
  specifier: "y"
}, {
  key: "month",
  specifier: "M"
}, {
  key: "day",
  specifier: "d"
}, {
  key: "weekday",
  specifier: "E"
}, {
  key: "hour",
  getSpecifier: getHourSpecifier
}, {
  key: "minute",
  specifier: "m"
}, {
  key: "second",
  specifier: "s"
}, {
  key: "timeZoneName",
  specifier: "z"
}];
var STAND_ALONE_SPECIFIERS = {
  e: "c",
  E: "c",
  M: "L",
  Q: "q"
};
var specifiersRegex = {};
var resolvedFormats = {};
function getSpecifierRegex(specifier) {
  if (!specifiersRegex[specifier]) {
    specifiersRegex[specifier] = new RegExp(specifier + "+");
  }
  return specifiersRegex[specifier];
}
function skeletonSpecifiers(skeleton) {
  var result = [];
  var current = skeleton.charAt(0);
  var specifier = current;
  for (var idx2 = 1; idx2 < skeleton.length; idx2++) {
    var character = skeleton.charAt(idx2);
    if (character === specifier) {
      current += character;
    } else {
      result.push(current);
      current = specifier = character;
    }
  }
  result.push(current);
  return result;
}
function findBestMatch(specifiers, availableFormats) {
  var specifiersLength = specifiers.length;
  var maxScore = -Number.MAX_VALUE;
  var bestMatches, result;
  for (var format in availableFormats) {
    var matches = [];
    var currentFormat = format.replace("v", "z");
    var score = 0;
    for (var idx2 = 0; idx2 < specifiersLength; idx2++) {
      var specifier = specifiers[idx2];
      var specifierRegex = getSpecifierRegex(specifier[0]);
      var match = (specifierRegex.exec(currentFormat) || [])[0];
      if (!match) {
        score -= REMOVAL_PENALTY;
      } else {
        currentFormat = currentFormat.replace(match, EMPTY2);
        if (match.length !== specifier.length) {
          var delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);
          score -= PENALTIES[delta];
        }
      }
      matches.push(match);
      if (score < maxScore) {
        break;
      }
    }
    if (currentFormat.length) {
      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;
    }
    if (score > maxScore) {
      maxScore = score;
      bestMatches = matches;
      result = availableFormats[format];
    }
  }
  result = result.replace("v", "z");
  for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {
    var bestMatch = bestMatches[idx$1];
    if (bestMatch && bestMatch !== specifiers[idx$1]) {
      var matchSpecifier = bestMatches[idx$1][0];
      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);
      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {
        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);
      }
    }
  }
  return result;
}
function cacheFormat(skeleton, format, locale) {
  if (!resolvedFormats[locale]) {
    resolvedFormats[locale] = {};
  }
  resolvedFormats[locale][skeleton] = format;
}
function skeletonFormat(skeleton, info) {
  var availableFormats = info.calendar.dateTimeFormats.availableFormats;
  if (availableFormats[skeleton]) {
    return availableFormats[skeleton];
  }
  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {
    return resolvedFormats[info.name][skeleton];
  }
  var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);
  var result;
  if (timeStartIndex > 0) {
    var dateSkeleton = skeleton.substr(0, timeStartIndex);
    var timeSkeleton = skeleton.substr(timeStartIndex);
    result = formatString(
      info.calendar.dateTimeFormats.short,
      //should be deterimed based on specifiers
      availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),
      availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats)
    );
  } else {
    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);
  }
  cacheFormat(skeleton, result, info.name);
  return result;
}
function skeletonFromOptions(options) {
  var result = [];
  for (var idx2 = 0; idx2 < DATE_OPTIONS_MAP.length; idx2++) {
    var option = DATE_OPTIONS_MAP[idx2];
    var field = option.key;
    var value2 = options[field];
    if (value2) {
      var spcifier = option.specifier || option.getSpecifier(options);
      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value2]));
    }
  }
  return result.join(EMPTY2);
}
function datePattern(format, info) {
  var calendar = info.calendar;
  var result;
  if (isString(format)) {
    if (calendar.patterns[format]) {
      result = calendar.patterns[format];
    } else {
      result = format;
    }
  } else if (format) {
    if (format.pattern) {
      return format.pattern;
    }
    var skeleton = format.skeleton;
    if (!skeleton) {
      if (format.datetime) {
        result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);
      } else if (format.date) {
        result = calendar.dateFormats[format.date];
      } else if (format.time) {
        result = calendar.timeFormats[format.time];
      } else {
        skeleton = skeletonFromOptions(format);
      }
    }
    if (skeleton) {
      result = skeletonFormat(skeleton, info);
    }
  }
  if (!result) {
    result = calendar.patterns.d;
  }
  return result;
}

// node_modules/@telerik/kendo-intl/dist/es/dates/date-name-type.js
function dateNameType(formatLength) {
  var nameType;
  if (formatLength <= 3) {
    nameType = "abbreviated";
  } else if (formatLength === 4) {
    nameType = "wide";
  } else if (formatLength === 5) {
    nameType = "narrow";
  } else if (formatLength === 6) {
    nameType = "short";
  }
  return nameType;
}

// node_modules/@telerik/kendo-intl/dist/es/dates/format-names.js
function formatNames(locale, type, formatLength, standAlone, lower) {
  return dateFormatNames(locale, {
    type,
    nameType: dateNameType(formatLength),
    standAlone,
    lower
  });
}

// node_modules/@telerik/kendo-intl/dist/es/common/is-date.js
function isFunction2(fun) {
  return typeof fun === "function";
}
function isDate(value2) {
  return Boolean(value2) && isFunction2(value2.getTime) && isFunction2(value2.getMonth);
}

// node_modules/@telerik/kendo-intl/dist/es/dates/constants.js
var dateFormatRegExp = /d{1,2}|E{1,6}|e{1,6}|c{3,6}|c{1}|M{1,5}|L{1,5}|y{1,4}|H{1,2}|h{1,2}|k{1,2}|K{1,2}|m{1,2}|a{1,5}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|x{1,5}|X{1,5}|G{1,5}|q{1,5}|Q{1,5}|"[^"]*"|'[^']*'/g;

// node_modules/@telerik/kendo-intl/dist/es/dates/format-date.js
function formatDayOfWeekIndex(day, formatLength, localeInfo2) {
  var firstDayIndex = firstDay(localeInfo2);
  var dayIndex;
  if (day < firstDayIndex) {
    dayIndex = 7 - firstDayIndex + day;
  } else {
    dayIndex = day - firstDayIndex;
  }
  return dayIndex + 1;
}
function formatMonth(month, formatLength, info, standAlone) {
  if (formatLength <= 2) {
    return pad(month + 1, formatLength);
  }
  return formatNames(info, "months", formatLength, standAlone)[month];
}
function formatQuarter(date, formatLength, info, standAlone) {
  var quarter = Math.floor(date.getMonth() / 3);
  if (formatLength < 3) {
    return quarter + 1;
  }
  return formatNames(info, "quarters", formatLength, standAlone)[quarter];
}
function formatTimeZone(date, info, options) {
  var shortHours = options.shortHours;
  var optionalMinutes = options.optionalMinutes;
  var separator = options.separator;
  var localizedName = options.localizedName;
  var zZeroOffset = options.zZeroOffset;
  var offset2 = date.getTimezoneOffset() / 60;
  if (offset2 === 0 && zZeroOffset) {
    return "Z";
  }
  var sign = offset2 <= 0 ? "+" : "-";
  var hoursMinutes = Math.abs(offset2).toString().split(".");
  var minutes = hoursMinutes[1] || 0;
  var result = sign + (shortHours ? hoursMinutes[0] : pad(hoursMinutes[0], 2));
  if (minutes || !optionalMinutes) {
    result += (separator ? ":" : EMPTY2) + pad(minutes, 2);
  }
  if (localizedName) {
    var localizedFormat = offset2 === 0 ? info.calendar.gmtZeroFormat : info.calendar.gmtFormat;
    result = formatString(localizedFormat, result);
  }
  return result;
}
function formatDayOfWeek(date, formatLength, info, standAlone) {
  var result;
  if (formatLength < 3) {
    result = formatDayOfWeekIndex(date.getDay(), formatLength, info);
  } else {
    result = formatNames(info, "days", formatLength, standAlone)[date.getDay()];
  }
  return result;
}
var formatters = {};
formatters.d = function(date, formatLength) {
  return pad(date.getDate(), formatLength);
};
formatters.E = function(date, formatLength, info) {
  return formatNames(info, "days", formatLength)[date.getDay()];
};
formatters.M = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, false);
};
formatters.L = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, true);
};
formatters.y = function(date, formatLength) {
  var year = date.getFullYear();
  if (formatLength === 2) {
    year = year % 100;
  }
  return pad(year, formatLength);
};
formatters.h = function(date, formatLength) {
  var hours = date.getHours() % 12 || 12;
  return pad(hours, formatLength);
};
formatters.H = function(date, formatLength) {
  return pad(date.getHours(), formatLength);
};
formatters.k = function(date, formatLength) {
  return pad(date.getHours() || 24, formatLength);
};
formatters.K = function(date, formatLength) {
  return pad(date.getHours() % 12, formatLength);
};
formatters.m = function(date, formatLength) {
  return pad(date.getMinutes(), formatLength);
};
formatters.s = function(date, formatLength) {
  return pad(date.getSeconds(), formatLength);
};
formatters.S = function(date, formatLength) {
  var milliseconds = date.getMilliseconds();
  var result;
  if (milliseconds !== 0) {
    result = pad(String(milliseconds / 1e3).split(".")[1].substr(0, formatLength), formatLength, true);
  } else {
    result = pad(EMPTY2, formatLength);
  }
  return result;
};
formatters.a = function(date, formatLength, info) {
  return formatNames(info, "dayPeriods", formatLength)[date.getHours() < 12 ? "am" : "pm"];
};
formatters.z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    shortHours: formatLength < 4,
    optionalMinutes: formatLength < 4,
    separator: true,
    localizedName: true
  });
};
formatters.Z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    separator: formatLength > 3,
    localizedName: formatLength === 4,
    zZeroOffset: formatLength === 5
  });
};
formatters.x = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5
  });
};
formatters.X = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5,
    zZeroOffset: true
  });
};
formatters.G = function(date, formatLength, info) {
  var era = date.getFullYear() >= 0 ? 1 : 0;
  return formatNames(info, "eras", formatLength)[era];
};
formatters.e = formatDayOfWeek;
formatters.c = function(date, formatLength, info) {
  return formatDayOfWeek(date, formatLength, info, true);
};
formatters.q = function(date, formatLength, info) {
  return formatQuarter(date, formatLength, info, true);
};
formatters.Q = formatQuarter;
function formatDate2(date, format, locale) {
  if (locale === void 0) locale = DEFAULT_LOCALE;
  if (!isDate(date)) {
    if (date === void 0 || date === null) {
      return EMPTY2;
    }
    return date;
  }
  var info = localeInfo(locale);
  var pattern = datePattern(format, info);
  return pattern.replace(dateFormatRegExp, function(match) {
    var formatLength = match.length;
    var result;
    if (match.includes("'") || match.includes('"')) {
      result = match.slice(1, formatLength - 1);
    } else {
      result = formatters[match[0]](date, formatLength, info);
    }
    return result;
  });
}

// node_modules/@telerik/kendo-intl/dist/es/dates/time-utils.js
function convertTimeZone(date, fromOffset, toOffset) {
  var fromLocalOffset = date.getTimezoneOffset();
  var offsetDate = new Date(date.getTime() + (fromOffset - toOffset) * 6e4);
  var toLocalOffset = offsetDate.getTimezoneOffset();
  return new Date(offsetDate.getTime() + (toLocalOffset - fromLocalOffset) * 6e4);
}
function adjustDST2(date, hours) {
  if (!hours && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
  }
}

// node_modules/@telerik/kendo-intl/dist/es/dates/parse-date.js
var timeZoneOffsetRegExp = /([+|\-]\d{1,2})(:?)(\d{2})?/;
var dateRegExp = /^\/Date\((.*?)\)\/$/;
var offsetRegExp = /[+-]\d*/;
var numberRegExp = {
  2: /^\d{1,2}/,
  3: /^\d{1,3}/,
  4: /^\d{4}/
};
var numberRegex = /\d+/;
var PLACEHOLDER2 = "{0}";
var leadingSpacesRegex = /^ */;
var trailingSpacesRegex = / *$/;
var standardDateFormats = ["yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", "yyyy/MM/dd", "E MMM dd yyyy HH:mm:ss", "yyyy-MM-ddTHH:mm:ss.SSSSSSSXXX", "yyyy-MM-ddTHH:mm:ss.SSSXXX", "yyyy-MM-ddTHH:mm:ss.SSXXX", "yyyy-MM-ddTHH:mm:ssXXX", "yyyy-MM-ddTHH:mm:ss.SSSSSSS", "yyyy-MM-ddTHH:mm:ss.SSS", "yyyy-MM-ddTHH:mmXXX", "yyyy-MM-ddTHH:mmX", "yyyy-MM-ddTHH:mm:ss", "yyyy-MM-ddTHH:mm", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM-dd", "HH:mm:ss", "HH:mm"];
var FORMATS_SEQUENCE = ["G", "g", "F", "Y", "y", "M", "m", "D", "d", "y", "T", "t"];
var TWO_DIGIT_YEAR_MAX2 = 2029;
function outOfRange(value2, start, end) {
  return !(value2 >= start && value2 <= end);
}
function lookAhead(match, state) {
  var format = state.format;
  var idx2 = state.idx;
  var i = 0;
  while (format[idx2] === match) {
    i++;
    idx2++;
  }
  if (i > 0) {
    idx2 -= 1;
  }
  state.idx = idx2;
  return i;
}
function getNumber(size, state) {
  var regex = size ? numberRegExp[size] || new RegExp("^\\d{1," + size + "}") : numberRegex, match = state.value.substr(state.valueIdx, size).match(regex);
  if (match) {
    match = match[0];
    state.valueIdx += match.length;
    return parseInt(match, 10);
  }
  return null;
}
function getIndexByName(names, state, lower) {
  var i = 0, length2 = names.length, name, nameLength, matchLength = 0, matchIdx = 0, subValue;
  for (; i < length2; i++) {
    name = names[i];
    nameLength = name.length;
    subValue = state.value.substr(state.valueIdx, nameLength);
    if (lower) {
      subValue = subValue.toLowerCase();
    }
    if (subValue === name && nameLength > matchLength) {
      matchLength = nameLength;
      matchIdx = i;
    }
  }
  if (matchLength) {
    state.valueIdx += matchLength;
    return matchIdx + 1;
  }
  return null;
}
function checkLiteral(state) {
  var result = false;
  if (state.value.charAt(state.valueIdx) === state.format[state.idx]) {
    state.valueIdx++;
    result = true;
  }
  return result;
}
function calendarGmtFormats(calendar) {
  var gmtFormat = calendar.gmtFormat;
  var gmtZeroFormat = calendar.gmtZeroFormat;
  if (!gmtFormat) {
    throw errors.NoGMTInfo.error();
  }
  return [gmtFormat.replace(PLACEHOLDER2, EMPTY2).toLowerCase(), gmtZeroFormat.replace(PLACEHOLDER2, EMPTY2).toLowerCase()];
}
function parseTimeZoneOffset(state, info, options) {
  var shortHours = options.shortHours;
  var noSeparator = options.noSeparator;
  var optionalMinutes = options.optionalMinutes;
  var localizedName = options.localizedName;
  var zLiteral = options.zLiteral;
  state.UTC = true;
  if (zLiteral && state.value.charAt(state.valueIdx) === "Z") {
    state.valueIdx++;
    return false;
  }
  if (localizedName && !getIndexByName(calendarGmtFormats(info.calendar), state, true)) {
    return true;
  }
  var matches = timeZoneOffsetRegExp.exec(state.value.substr(state.valueIdx, 6));
  if (!matches) {
    return !localizedName;
  }
  var hoursMatch = matches[1];
  var minutesMatch = matches[3];
  var hoursOffset = parseInt(hoursMatch, 10);
  var separator = matches[2];
  var minutesOffset = parseInt(minutesMatch, 10);
  if (isNaN(hoursOffset) || !shortHours && hoursMatch.length !== 3 || !optionalMinutes && isNaN(minutesOffset) || noSeparator && separator) {
    return true;
  }
  if (isNaN(minutesOffset)) {
    minutesOffset = null;
  }
  if (outOfRange(hoursOffset, -12, 13) || minutesOffset && outOfRange(minutesOffset, 0, 59)) {
    return true;
  }
  state.valueIdx += matches[0].length;
  state.hoursOffset = hoursOffset;
  state.minutesOffset = minutesOffset;
}
function parseMonth(ch, state, info) {
  var count = lookAhead(ch, state);
  var names = formatNames(info, "months", count, ch === "L", true);
  var month = count < 3 ? getNumber(2, state) : getIndexByName(names, state, true);
  if (month === null || outOfRange(month, 1, 12)) {
    return true;
  }
  state.month = month - 1;
}
function parseDayOfWeek(ch, state, info) {
  var count = lookAhead(ch, state);
  var names = formatNames(info, "days", count, ch === "c", true);
  var dayOfWeek2 = count < 3 ? getNumber(1, state) : getIndexByName(names, state, true);
  if (!dayOfWeek2 && dayOfWeek2 !== 0 || outOfRange(dayOfWeek2, 1, 7)) {
    return true;
  }
}
var parsers = {};
parsers.d = function(state) {
  lookAhead("d", state);
  var day = getNumber(2, state);
  if (day === null || outOfRange(day, 1, 31)) {
    return true;
  }
  if (state.day === null) {
    state.day = day;
  }
};
parsers.E = function(state, info) {
  var count = lookAhead("E", state);
  var dayOfWeek2 = getIndexByName(formatNames(info, "days", count, false, true), state, true);
  if (dayOfWeek2 === null) {
    return true;
  }
};
parsers.M = function(state, info) {
  return parseMonth("M", state, info);
};
parsers.L = function(state, info) {
  return parseMonth("L", state, info);
};
parsers.y = function(state) {
  var count = lookAhead("y", state);
  var year = getNumber(count === 1 ? void 0 : count, state);
  if (year === null) {
    return true;
  }
  if (count === 2) {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    year = currentYear - currentYear % 100 + year;
    if (year > TWO_DIGIT_YEAR_MAX2) {
      year -= 100;
    }
  }
  state.year = year;
};
parsers.h = function(state) {
  lookAhead("h", state);
  var hours = getNumber(2, state);
  if (hours === 12) {
    hours = 0;
  }
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state.hours = hours;
};
parsers.K = function(state) {
  lookAhead("K", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state.hours = hours;
};
parsers.a = function(state, info) {
  var count = lookAhead("a", state);
  var periodFormats = formatNames(info, "dayPeriods", count, false, true);
  var pmHour = getIndexByName([periodFormats.pm], state, true);
  if (!pmHour && !getIndexByName([periodFormats.am], state, true)) {
    return true;
  }
  state.pmHour = pmHour;
};
parsers.H = function(state) {
  lookAhead("H", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 0, 23)) {
    return true;
  }
  state.hours = hours;
};
parsers.k = function(state) {
  lookAhead("k", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 1, 24)) {
    return true;
  }
  state.hours = hours === 24 ? 0 : hours;
};
parsers.m = function(state) {
  lookAhead("m", state);
  var minutes = getNumber(2, state);
  if (minutes === null || outOfRange(minutes, 0, 59)) {
    return true;
  }
  state.minutes = minutes;
};
parsers.s = function(state) {
  lookAhead("s", state);
  var seconds = getNumber(2, state);
  if (seconds === null || outOfRange(seconds, 0, 59)) {
    return true;
  }
  state.seconds = seconds;
};
parsers.S = function(state) {
  var count = lookAhead("S", state);
  var match = state.value.substr(state.valueIdx, count);
  var milliseconds = null;
  if (!isNaN(parseInt(match, 10))) {
    milliseconds = parseFloat("0." + match, 10);
    milliseconds = round(milliseconds, 3);
    milliseconds *= 1e3;
    state.valueIdx += count;
  }
  if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {
    return true;
  }
  state.milliseconds = milliseconds;
};
parsers.z = function(state, info) {
  var count = lookAhead("z", state);
  var shortFormat = count < 4;
  var invalid = parseTimeZoneOffset(state, info, {
    shortHours: shortFormat,
    optionalMinutes: shortFormat,
    localizedName: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.Z = function(state, info) {
  var count = lookAhead("Z", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count < 4,
    zLiteral: count === 5,
    localizedName: count === 4
  });
  if (invalid) {
    return invalid;
  }
};
parsers.x = function(state, info) {
  var count = lookAhead("x", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1
  });
  if (invalid) {
    return invalid;
  }
};
parsers.X = function(state, info) {
  var count = lookAhead("X", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1,
    zLiteral: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.G = function(state, info) {
  var count = lookAhead("G", state);
  var eras = formatNames(info, "eras", count, false, true);
  var era = getIndexByName([eras[0], eras[1]], state, true);
  if (era === null) {
    return true;
  }
};
parsers.e = function(state, info) {
  return parseDayOfWeek("e", state, info);
};
parsers.c = function(state, info) {
  return parseDayOfWeek("c", state, info);
};
function createDate2(state) {
  var year = state.year;
  var month = state.month;
  var day = state.day;
  var hours = state.hours;
  var minutes = state.minutes;
  var seconds = state.seconds;
  var milliseconds = state.milliseconds;
  var pmHour = state.pmHour;
  var UTC = state.UTC;
  var hoursOffset = state.hoursOffset;
  var minutesOffset = state.minutesOffset;
  var hasTime = hours !== null || minutes !== null || seconds || null;
  var date = /* @__PURE__ */ new Date();
  var result;
  if (year === null && month === null && day === null && hasTime) {
    year = date.getFullYear();
    month = date.getMonth();
    day = date.getDate();
  } else {
    if (year === null) {
      year = date.getFullYear();
    }
    if (day === null) {
      day = 1;
    }
  }
  if (pmHour && hours < 12) {
    hours += 12;
  }
  if (UTC) {
    if (hoursOffset) {
      hours += -hoursOffset;
    }
    if (minutesOffset) {
      minutes += -minutesOffset * (hoursOffset < 0 ? -1 : 1);
    }
    result = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
  } else {
    result = new Date(year, month, day, hours, minutes, seconds, milliseconds);
    adjustDST2(result, hours);
  }
  if (year < 100) {
    result.setFullYear(year);
  }
  if (result.getDate() !== day && UTC === void 0) {
    return null;
  }
  return result;
}
function addFormatSpaces(value2, format) {
  var leadingSpaces = leadingSpacesRegex.exec(format)[0];
  var trailingSpaces = trailingSpacesRegex.exec(format)[0];
  return "" + leadingSpaces + value2 + trailingSpaces;
}
function parseExact(value2, format, info) {
  var pattern = datePattern(format, info).split(EMPTY2);
  var state = {
    format: pattern,
    idx: 0,
    value: addFormatSpaces(value2, format),
    valueIdx: 0,
    year: null,
    month: null,
    day: null,
    hours: null,
    minutes: null,
    seconds: null,
    milliseconds: null
  };
  var length2 = pattern.length;
  var literal = false;
  for (; state.idx < length2; state.idx++) {
    var ch = pattern[state.idx];
    if (literal) {
      if (ch === "'") {
        literal = false;
      }
      checkLiteral(state);
    } else {
      if (parsers[ch]) {
        var invalid = parsers[ch](state, info);
        if (invalid) {
          return null;
        }
      } else if (ch === "'") {
        literal = true;
        checkLiteral(state);
      } else if (!checkLiteral(state)) {
        return null;
      }
    }
  }
  if (state.valueIdx < value2.length) {
    return null;
  }
  return createDate2(state) || null;
}
function parseMicrosoftDateOffset(offset2) {
  var sign = offset2.substr(0, 1) === "-" ? -1 : 1;
  var result = offset2.substring(1);
  result = parseInt(result.substr(0, 2), 10) * 60 + parseInt(result.substring(2), 10);
  return sign * result;
}
function parseMicrosoftDateFormat(value2) {
  if (value2 && value2.indexOf("/D") === 0) {
    var date = dateRegExp.exec(value2);
    if (date) {
      date = date[1];
      var tzoffset = offsetRegExp.exec(date.substring(1));
      date = new Date(parseInt(date, 10));
      if (tzoffset) {
        tzoffset = parseMicrosoftDateOffset(tzoffset[0]);
        date = convertTimeZone(date, date.getTimezoneOffset(), 0);
        date = convertTimeZone(date, 0, -1 * tzoffset);
      }
      return date;
    }
  }
}
function defaultFormats(calendar) {
  var formats = [];
  var patterns = calendar.patterns;
  var length2 = FORMATS_SEQUENCE.length;
  for (var idx2 = 0; idx2 < length2; idx2++) {
    formats.push(patterns[FORMATS_SEQUENCE[idx2]]);
  }
  return formats.concat(standardDateFormats);
}
function parseDate2(value2, formats, locale) {
  if (locale === void 0) locale = DEFAULT_LOCALE;
  if (!value2) {
    return null;
  }
  if (isDate(value2)) {
    return value2;
  }
  var parseValue = String(value2).trim();
  var date = parseMicrosoftDateFormat(parseValue);
  if (date) {
    return date;
  }
  var info = localeInfo(locale);
  var parseFormats = formats || defaultFormats(info.calendar);
  parseFormats = Array.isArray(parseFormats) ? parseFormats : [parseFormats];
  var length2 = parseFormats.length;
  for (var idx2 = 0; idx2 < length2; idx2++) {
    date = parseExact(parseValue, parseFormats[idx2], info);
    if (date) {
      return date;
    }
  }
  return date;
}

// node_modules/@telerik/kendo-intl/dist/es/format.js
function toString(value2, format, locale) {
  if (format) {
    if (isDate(value2)) {
      return formatDate2(value2, format, locale);
    } else if (isNumber2(value2)) {
      return formatNumber(value2, format, locale);
    }
  }
  return value2 !== void 0 && value2 !== null ? value2 : EMPTY2;
}

// node_modules/@progress/kendo-recurrence/dist/es/utils/serialize-date-time.js
var serializeDates = function(values) {
  if (!values || values.length === 0) {
    return "";
  }
  var timezone = values[0].timezone;
  var isUTC = timezone === "Etc/UTC";
  var suffix = isUTC ? "Z" : "";
  var parts = values.map(function(val) {
    return formatDate2(val, "yyyyMMddTHHmmss") + suffix;
  });
  var header = timezone && !isUTC ? ";TZID=" + timezone : "";
  return header + ":" + parts.join(",") + " ";
};

// node_modules/@progress/kendo-recurrence/dist/es/utils/duration.js
var duration = function(start, end) {
  return end.getTime() - start.getTime();
};

// node_modules/@progress/kendo-recurrence/dist/es/utils.js
var isOutOfRange = function(value2, range3) {
  if (!range3) {
    return false;
  }
  var start = range3.start, end = range3.end;
  return value2 < start || value2 > end || value2 === 0 && start < 0;
};
var acsendingComparer = function(a, b) {
  return a - b;
};
var parseArray = function(list2, range3) {
  var result = [];
  for (var idx2 = 0; idx2 < list2.length; idx2++) {
    var value2 = parseInt(list2[idx2], 10);
    if (isNaN(value2) || isOutOfRange(value2, range3)) {
      return [];
    }
    result.push(value2);
  }
  return result.sort(acsendingComparer);
};
var DATE_FORMATS = ["yyyyMMddTHHmmssSSSXXX", "yyyyMMddTHHmmssXXX", "yyyyMMddTHHmmss", "yyyyMMddTHHmm", "yyyyMMddTHH", "yyyyMMdd"];
function toUTCDateTime(localDate) {
  return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
var parseISODate = function(value2, timezone) {
  var parsed = parseDate2(value2) || parseDate2(value2, DATE_FORMATS);
  if (!parsed) {
    return null;
  }
  var utcDate = timezone ? toUTCDateTime(parsed) : parsed;
  return ZonedDate.fromUTCDate(utcDate, timezone || "Etc/UTC");
};
var WEEK_DAYS_IDX = {
  "SU": Day.Sunday,
  "MO": Day.Monday,
  "TU": Day.Tuesday,
  "WE": Day.Wednesday,
  "TH": Day.Thursday,
  "FR": Day.Friday,
  "SA": Day.Saturday
};
var parseWeekDay = function(weekDay) {
  return WEEK_DAYS_IDX[weekDay];
};
var parseWeekDayList = function(weekDays) {
  var result = [];
  for (var idx2 = 0; idx2 < weekDays.length; idx2++) {
    var value2 = weekDays[idx2];
    var day = parseWeekDay(value2.substring(value2.length - 2).toUpperCase());
    if (day === void 0) {
      return [];
    }
    result.push({
      offset: parseInt(value2.substring(0, value2.length - 2), 10) || 0,
      day
    });
  }
  return result;
};
var setDayOfWeek = function(date, day, dir) {
  if (dir === void 0) {
    dir = 1;
  }
  day = (day - date.getUTCDay() + 7 * dir) % 7;
  date.setUTCDate(date.getUTCDate() + day);
};
var normalizeDayIndex = function(weekDay, weekStart) {
  return weekDay + (weekDay < weekStart ? 7 : 0);
};

// node_modules/@progress/kendo-recurrence/dist/es/limitations.js
var numberSortPredicate = function(a, b) {
  return a - b;
};
var weekInMonth = function(date, weekStart) {
  var firstWeekDay = toUTCDateTime(firstDayOfMonth(date)).getUTCDay();
  var firstWeekLength = 7 - (firstWeekDay + 7 - (weekStart || 7)) || 7;
  if (firstWeekLength < 0) {
    firstWeekLength += 7;
  }
  return Math.ceil((date.getUTCDate() - firstWeekLength) / 7) + 1;
};
var weekInYear2 = function(date, weekStart) {
  date = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
  var year = date.getUTCFullYear();
  if (weekStart !== void 0) {
    setDayOfWeek(date, weekStart, -1);
    date.setUTCDate(date.getUTCDate() + 4);
  } else {
    date.setUTCDate(date.getUTCDate() + (4 - (date.getUTCDay() || 7)));
  }
  var days = Math.floor((date.getTime() - Date.UTC(year, 0, 1, -6)) / 864e5);
  return 1 + Math.floor(days / 7);
};
var normalizeOffset = function(date, rule, weekStart) {
  var offset2 = rule.offset;
  if (!offset2) {
    return weekInMonth(date, weekStart);
  }
  var lastDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0));
  var weeksInMonth = weekInMonth(lastDate, weekStart);
  var day = normalizeDayIndex(rule.day, weekStart);
  var skipFirst = day < normalizeDayIndex(new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1)).getUTCDay(), weekStart);
  var skipLast = day > normalizeDayIndex(lastDate.getUTCDay(), weekStart);
  if (offset2 < 0) {
    offset2 = weeksInMonth + (offset2 + 1 - (skipLast ? 1 : 0));
  } else if (skipFirst) {
    offset2 += 1;
  }
  weeksInMonth -= skipLast ? 1 : 0;
  if (offset2 < (skipFirst ? 1 : 0) || offset2 > weeksInMonth) {
    return null;
  }
  return offset2;
};
var isInWeek = function(date, rule, weekStart) {
  return weekInMonth(date, weekStart) === normalizeOffset(date, rule, weekStart);
};
var numberOfWeeks = function(date, weekStart) {
  return weekInMonth(new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0)), weekStart);
};
var DAYS_IN_LEAPYEAR = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var DAYS_IN_YEAR = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var leapYear = function(year) {
  year = year.getUTCFullYear();
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var dayInYear = function(date) {
  var month = date.getUTCMonth();
  var days = leapYear(date) ? DAYS_IN_LEAPYEAR[month] : DAYS_IN_YEAR[month];
  return days + date.getUTCDate();
};
var MONTHS2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var getMonthLength = function(date) {
  var month = date.getUTCMonth();
  if (month === 1) {
    if (new Date(Date.UTC(date.getUTCFullYear(), 1, 29)).getUTCMonth() === 1) {
      return 29;
    }
    return 28;
  }
  return MONTHS2[month];
};
var ruleValues = function(rules, value2, normalize3) {
  var length2 = rules.length;
  var availableRules = [];
  for (var idx2 = 0; idx2 < length2; idx2++) {
    var ruleValue = rules[idx2];
    if (normalize3) {
      ruleValue = normalize3(ruleValue);
    }
    if (value2 === ruleValue) {
      return null;
    } else if (value2 < ruleValue) {
      availableRules.push(ruleValue);
    }
  }
  return availableRules;
};
var ruleWeekValues = function(days, date, weekStart) {
  var currentDay = normalizeDayIndex(date.getUTCDay(), weekStart);
  var length2 = days.length;
  var ruleWeekOffset;
  var weekDay, day;
  var weekNumber;
  var result = [];
  for (var idx2 = 0; idx2 < length2; idx2++) {
    weekDay = days[idx2];
    weekNumber = weekInMonth(date, weekStart);
    ruleWeekOffset = normalizeOffset(date, weekDay, weekStart);
    if (ruleWeekOffset === null) {
      continue;
    }
    if (weekNumber < ruleWeekOffset) {
      result.push(weekDay);
    } else if (weekNumber === ruleWeekOffset) {
      day = normalizeDayIndex(weekDay.day, weekStart);
      if (currentDay < day) {
        result.push(weekDay);
      } else if (currentDay === day) {
        return null;
      }
    }
  }
  return result;
};
var byMonth = function(date, end, rule) {
  var monthRules = rule.byMonth;
  var monthRuleValues = ruleValues(monthRules, date.getUTCMonth() + 1);
  var changed = false;
  if (monthRuleValues !== null) {
    if (monthRuleValues.length) {
      date.setUTCMonth(monthRuleValues[0] - 1, 1);
    } else {
      date.setUTCFullYear(date.getUTCFullYear() + 1, monthRules[0] - 1, 1);
    }
    changed = true;
  }
  return changed;
};
var byMonthDay = function(date, end, rule) {
  var monthLength;
  var changed = false;
  function normalize3(monthDay) {
    if (monthDay < 0) {
      monthDay = monthLength + monthDay + 1;
    }
    return monthDay;
  }
  while (date <= end) {
    var month = date.getUTCMonth();
    monthLength = getMonthLength(date);
    var days = ruleValues(rule.byMonthDay, date.getUTCDate(), normalize3);
    if (days === null) {
      return changed;
    }
    changed = true;
    if (days.length) {
      date.setUTCMonth(month, days.sort(numberSortPredicate)[0]);
      if (month === date.getUTCMonth()) {
        break;
      }
    } else {
      date.setUTCMonth(month + 1, 1);
    }
  }
  return changed;
};
var byYearDay = function(date, end, rule) {
  var year;
  var changed = false;
  function normalize3(yearDay) {
    if (yearDay < 0) {
      yearDay = year + yearDay;
    }
    return yearDay;
  }
  while (date < end) {
    year = leapYear(date) ? 366 : 365;
    var days = ruleValues(rule.byYearDay, dayInYear(date), normalize3);
    if (days === null) {
      return changed;
    }
    changed = true;
    year = date.getUTCFullYear();
    if (days.length) {
      date.setUTCFullYear(year, 0, days.sort(numberSortPredicate)[0]);
      break;
    } else {
      date.setUTCFullYear(year + 1, 0, 1);
    }
  }
  return changed;
};
var byWeekNumber = function(date, end, rule) {
  var weekStart = rule.weekStart || Day.Monday;
  var changed = false;
  function normalize3(week) {
    if (week < 0) {
      week = 53 + week;
    }
    return week;
  }
  while (date < end) {
    var weekRuleValues = ruleValues(rule.byWeekNumber, weekInYear2(date, weekStart), normalize3);
    if (weekRuleValues === null) {
      return changed;
    }
    changed = true;
    var year = date.getUTCFullYear();
    if (weekRuleValues.length) {
      var day = weekRuleValues.sort(numberSortPredicate)[0] * 7 - 1;
      date.setUTCFullYear(year, 0, day);
      setDayOfWeek(date, weekStart, -1);
      break;
    } else {
      date.setUTCFullYear(year + 1, 0, 1);
    }
  }
  return changed;
};
var byWeekDay = function(startDate, end, rule) {
  var ruleValue = rule.byWeekDay;
  var weekStart = rule.weekStart || Day.Monday;
  var weekDayRules = ruleWeekValues(ruleValue, startDate, weekStart);
  if (weekDayRules === null) {
    return false;
  }
  if (!weekDayRules[0]) {
    weekDayRules = ruleValue;
    setDayOfWeek(startDate, weekStart);
  }
  var results = weekDayRules.map(function(weekDayRule) {
    var date = cloneDate(startDate);
    var day = weekDayRule.day;
    if (weekDayRule.offset) {
      while (date <= end && !isInWeek(date, weekDayRule, weekStart)) {
        if (weekInMonth(date, weekStart) === numberOfWeeks(date, weekStart)) {
          date.setUTCMonth(date.getUTCMonth() + 1, 1);
        } else {
          date.setUTCDate(date.getUTCDate() + 7);
          setDayOfWeek(date, weekStart, -1);
        }
      }
    }
    if (date.getUTCDay() !== day) {
      setDayOfWeek(date, day);
    }
    return date;
  }).sort(function(a, b) {
    return a.getTime() - b.getTime();
  });
  var firstDate = results[0];
  if (firstDate) {
    startDate.setTime(firstDate);
  }
  return true;
};
var byHour = function(date, end, rule) {
  var hourRules = rule.byHour;
  var changed = false;
  var startTime = rule._startTime;
  var startHours = startTime.getUTCHours();
  var hourValues = ruleValues(hourRules, startHours);
  if (hourValues !== null) {
    changed = true;
    date.setUTCHours(startHours);
    if (hourValues.length) {
      hourValues = hourValues[0];
      date.setUTCHours(hourValues);
    } else {
      hourValues = date.getUTCHours();
      date.setUTCDate(date.getUTCDate() + 1);
      hourValues = hourRules[0];
      date.setUTCHours(hourValues);
    }
    if (rule.byMinute) {
      date.setUTCMinutes(0);
    }
    startTime.setUTCHours(hourValues, date.getUTCMinutes());
  }
  return changed;
};
var byMinute = function(date, end, rule) {
  var minuteRules = rule.byMinute;
  var currentMinutes = date.getUTCMinutes();
  var minuteValues = ruleValues(minuteRules, currentMinutes);
  var startHours = rule._startTime.getUTCHours();
  var changed = false;
  if (minuteValues !== null) {
    changed = true;
    if (minuteValues.length) {
      minuteValues = minuteValues[0];
    } else {
      startHours += 1;
      minuteValues = minuteRules[0];
    }
    if (rule.bySecond) {
      date.setUTCSeconds(0);
    }
    date.setUTCHours(startHours, minuteValues);
    startHours = startHours % 24;
    rule._startTime.setUTCHours(startHours, minuteValues, date.getUTCSeconds());
  }
  return changed;
};
var bySecond = function(date, _end, rule) {
  var secondRules = rule.bySecond;
  var secondsValues = ruleValues(secondRules, date.getUTCSeconds());
  var startHours = rule._startTime.getUTCHours();
  var dateMinutes = date.getUTCMinutes();
  var changed = false;
  if (secondsValues !== null) {
    changed = true;
    if (secondsValues.length) {
      date.setUTCSeconds(secondsValues[0]);
    } else {
      dateMinutes += 1;
      date.setUTCMinutes(dateMinutes, secondRules[0]);
      if (dateMinutes > 59) {
        dateMinutes = dateMinutes % 60;
        startHours = (startHours + 1) % 24;
      }
    }
    rule._startTime.setUTCHours(startHours, dateMinutes, date.getUTCSeconds());
  }
  return changed;
};

// node_modules/@progress/kendo-recurrence/dist/es/frequencies.js
var RULE_NAMES = ["byMonth", "byWeekNumber", "byYearDay", "byMonthDay", "byWeekDay", "byHour", "byMinute", "bySecond"];
var RULE_NAMES_LENGTH = RULE_NAMES.length;
var intervalExcess = function(diff2, interval2) {
  var excess;
  if (diff2 !== 0 && diff2 < interval2) {
    excess = interval2 - diff2;
  } else {
    excess = diff2 % interval2;
    if (excess) {
      excess = interval2 - excess;
    }
  }
  return excess;
};
var addTime = function(date, time) {
  date.setTime(date.getTime() + time);
};
var BaseFrequency = (
  /** @class */
  function() {
    function BaseFrequency2() {
    }
    BaseFrequency2.prototype.next = function(date, rule) {
      var startTime = rule._startTime;
      var minutes, seconds;
      if (rule.bySecond) {
        seconds = date.getUTCSeconds() + 1;
        date.setUTCSeconds(seconds);
        startTime.setUTCSeconds(seconds);
      } else if (rule.byMinute) {
        minutes = date.getUTCMinutes() + 1;
        date.setUTCMinutes(minutes);
        startTime.setUTCMinutes(minutes);
      } else {
        return false;
      }
      return true;
    };
    BaseFrequency2.prototype.normalize = function(options) {
      var rule = options.rule;
      if (options.idx === 4 && rule.byHour) {
        rule._startTime.setUTCHours(0);
        this._hour(options.date, rule);
      }
    };
    BaseFrequency2.prototype.limit = function(date, end, rule) {
      var interval2 = rule.interval || 1;
      var idx2;
      while (date <= end) {
        var modified = void 0;
        var firstRule = void 0;
        var day = date.getUTCDate();
        for (idx2 = 0; idx2 < RULE_NAMES_LENGTH; idx2++) {
          var ruleName = RULE_NAMES[idx2];
          if (rule[ruleName]) {
            modified = limitations_exports[ruleName](date, end, rule);
            if (firstRule !== void 0 && modified) {
              break;
            } else {
              firstRule = modified;
            }
          }
          if (modified) {
            this.normalize({
              date,
              rule,
              day,
              idx: idx2
            });
          }
        }
        if ((interval2 === 1 || !this.interval(rule, date)) && idx2 === RULE_NAMES_LENGTH) {
          break;
        }
      }
    };
    BaseFrequency2.prototype.interval = function(rule, current) {
      var start = rule._startPeriod.toUTCDate();
      var hours = current.getUTCHours();
      var weekStart = rule.weekStart;
      var interval2 = rule.interval;
      var frequency = rule.freq;
      var date = new Date(current);
      var modified = false;
      var excess = 0;
      var month = 0;
      var day = 1;
      var diff2;
      var startTimeHours;
      if (frequency === "hourly") {
        startTimeHours = rule._startTime.getUTCHours();
        date = date.getTime();
        if (hours !== startTimeHours) {
          date += (startTimeHours - hours) * MS_PER_HOUR;
        }
        date -= start.getTime();
        diff2 = Math.floor(date / MS_PER_HOUR);
        excess = intervalExcess(diff2, interval2);
        if (excess !== 0) {
          this._hour(current, rule, excess);
          modified = true;
        }
      } else if (frequency === "daily") {
        addTime(date, -start);
        diff2 = Math.round(date / MS_PER_DAY);
        excess = intervalExcess(diff2, interval2);
        if (excess !== 0) {
          this._date(current, rule, excess);
          modified = true;
        }
      } else if (frequency === "weekly") {
        excess = this.getNumberOfWeeksBetweenDates(start, current);
        var normalizedCurrentIndex = normalizeDayIndex(current.getUTCDay(), weekStart);
        var normalizedStartIndex = normalizeDayIndex(start.getUTCDay(), weekStart);
        if (normalizedCurrentIndex < normalizedStartIndex) {
          excess += 1;
        }
        excess = intervalExcess(excess, interval2);
        if (excess !== 0) {
          setDayOfWeek(current, rule.weekStart, -1);
          current.setUTCDate(current.getUTCDate() + excess * 7);
          modified = true;
        }
      } else if (frequency === "monthly") {
        diff2 = current.getUTCFullYear() - start.getUTCFullYear();
        diff2 = current.getUTCMonth() - start.getUTCMonth() + diff2 * 12;
        excess = intervalExcess(diff2, interval2);
        if (excess !== 0) {
          day = hasModifiers(rule) ? 1 : current.getDate();
          current.setUTCFullYear(current.getUTCFullYear(), current.getUTCMonth() + excess, day);
          modified = true;
        }
      } else if (frequency === "yearly") {
        diff2 = current.getUTCFullYear() - start.getUTCFullYear();
        excess = intervalExcess(diff2, interval2);
        if (!rule.byMonth) {
          month = current.getUTCMonth();
        }
        if (!rule.byYearDay && !rule.byMonthDay && !rule.byWeekDay) {
          day = current.getUTCDate();
        }
        if (excess !== 0) {
          current.setUTCFullYear(current.getUTCFullYear() + excess, month, day);
          modified = true;
        }
      }
      return modified;
    };
    BaseFrequency2.prototype._hour = function(date, rule, interval2) {
      var startTime = rule._startTime;
      var hours = startTime.getUTCHours();
      if (interval2) {
        hours += interval2;
      }
      date.setUTCHours(hours);
      hours = hours % 24;
      startTime.setUTCHours(hours);
    };
    BaseFrequency2.prototype._date = function(date, rule, interval2) {
      date.setUTCDate(date.getUTCDate() + interval2);
    };
    BaseFrequency2.prototype.getNumberOfWeeksBetweenDates = function(first, second) {
      var weeks = (second.getTime() - first.getTime()) / 6048e5;
      var exactWeeks = Math.floor(weeks);
      if (weeks - exactWeeks > 0.99) {
        exactWeeks = Math.round(weeks);
      }
      return exactWeeks;
    };
    return BaseFrequency2;
  }()
);
var HourlyFrequency = (
  /** @class */
  function(_super) {
    __extends2(HourlyFrequency2, _super);
    function HourlyFrequency2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HourlyFrequency2.prototype.next = function(date, rule) {
      if (!BaseFrequency.prototype.next.call(this, date, rule)) {
        this._hour(date, rule, 1);
      }
      return false;
    };
    HourlyFrequency2.prototype.normalize = function(options) {
      var rule = options.rule;
      if (options.idx === 4) {
        rule._startTime.setUTCHours(0);
        this._hour(options.date, rule);
      }
    };
    return HourlyFrequency2;
  }(BaseFrequency)
);
var DailyFrequency = (
  /** @class */
  function(_super) {
    __extends2(DailyFrequency2, _super);
    function DailyFrequency2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DailyFrequency2.prototype.next = function(date, rule) {
      if (!BaseFrequency.prototype.next.call(this, date, rule)) {
        this[rule.byHour ? "_hour" : "_date"](date, rule, 1);
      }
      return false;
    };
    return DailyFrequency2;
  }(BaseFrequency)
);
var WeeklyFrequency = (
  /** @class */
  function(_super) {
    __extends2(WeeklyFrequency2, _super);
    function WeeklyFrequency2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    WeeklyFrequency2.prototype.setup = function(rule, eventStartDate) {
      if (!rule.byWeekDay) {
        rule.byWeekDay = [{
          day: eventStartDate.getUTCDay(),
          offset: 0
        }];
      }
    };
    return WeeklyFrequency2;
  }(DailyFrequency)
);
var MonthlyFrequency = (
  /** @class */
  function(_super) {
    __extends2(MonthlyFrequency2, _super);
    function MonthlyFrequency2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MonthlyFrequency2.prototype.next = function(date, rule) {
      var day;
      if (!BaseFrequency.prototype.next.call(this, date, rule)) {
        if (rule.byHour) {
          this._hour(date, rule, 1);
        } else if (rule.byMonthDay || rule.byWeekDay || rule.byYearDay || rule.byWeekNumber) {
          this._date(date, rule, 1);
        } else {
          day = date.getUTCDate();
          date.setUTCMonth(date.getUTCMonth() + 1);
          while (date.getUTCDate() !== day) {
            date.setUTCDate(day);
          }
          this._hour(date, rule);
        }
      }
      return false;
    };
    MonthlyFrequency2.prototype.normalize = function(options) {
      var rule = options.rule, date = options.date;
      if (options.idx === 0 && !rule.byMonthDay && !rule.byWeekDay) {
        date.setUTCDate(options.day);
      } else {
        _super.prototype.normalize.call(this, options);
      }
    };
    MonthlyFrequency2.prototype.setup = function(rule, eventStartDate, date) {
      if (!rule.byMonthDay && !rule.byWeekDay) {
        date.setUTCDate(eventStartDate.getUTCDate());
      }
    };
    return MonthlyFrequency2;
  }(BaseFrequency)
);
var YearlyFrequency = (
  /** @class */
  function(_super) {
    __extends2(YearlyFrequency2, _super);
    function YearlyFrequency2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    YearlyFrequency2.prototype.next = function(date, rule) {
      var day;
      if (!BaseFrequency.prototype.next.call(this, date, rule)) {
        if (rule.byHour) {
          this._hour(date, rule, 1);
        } else if (rule.byMonthDay || rule.byWeekDay || rule.byYearDay || rule.byWeekNumber) {
          this._date(date, rule, 1);
        } else if (rule.byMonth) {
          day = date.getUTCDate();
          date.setUTCMonth(date.getUTCMonth() + 1);
          while (date.getUTCDate() !== day) {
            date.setUTCDate(day);
          }
          this._hour(date, rule);
        } else {
          date.setUTCFullYear(date.getUTCFullYear() + 1);
          this._hour(date, rule);
        }
      }
      return false;
    };
    YearlyFrequency2.prototype.setup = function() {
    };
    return YearlyFrequency2;
  }(MonthlyFrequency)
);

// node_modules/@progress/kendo-recurrence/dist/es/expand.js
var frequencies = {
  "hourly": new HourlyFrequency(),
  "daily": new DailyFrequency(),
  "weekly": new WeeklyFrequency(),
  "monthly": new MonthlyFrequency(),
  "yearly": new YearlyFrequency()
};
var normalizeDST = function(date) {
  return ZonedDate.fromLocalDate(date.toLocalDate(), date.timezone);
};
var getTimeAfterMidnight = function(date) {
  return date.getHours() * MS_PER_HOUR + date.getMinutes() * MS_PER_MINUTE + date.getSeconds() * 1e3 + date.getMilliseconds();
};
var isException = function(exceptions, date) {
  if (!exceptions) {
    return false;
  }
  var dateTime = date.getTime() - date.getMilliseconds();
  var length2 = exceptions.length;
  for (var idx2 = 0; idx2 < length2; idx2++) {
    if (exceptions[idx2].getTime() === dateTime) {
      return true;
    }
  }
  return false;
};
var startPeriodByFreq = function(start, rule) {
  var date = start.toUTCDate();
  switch (rule.freq) {
    case "yearly":
      date.setUTCFullYear(date.getFullYear(), 0, 1);
      break;
    case "monthly":
      date.setUTCFullYear(date.getFullYear(), date.getMonth(), 1);
      break;
    case "weekly":
      setDayOfWeek(date, rule.weekStart, -1);
      break;
    default:
      break;
  }
  if (rule.byHour) {
    date.setUTCHours(0);
  }
  if (rule.byMinute) {
    date.setUTCMinutes(0);
  }
  if (rule.bySecond) {
    date.setUTCSeconds(0);
  }
  return ZonedDate.fromUTCDate(date, start.timezone);
};
var endPeriodByFreq = function(start, rule) {
  var date = start.toUTCDate();
  switch (rule.freq) {
    case "yearly":
      date.setUTCFullYear(date.getUTCFullYear(), 11, 31);
      break;
    case "monthly":
      date.setUTCFullYear(date.getUTCFullYear(), date.getUTCMonth() + 1, 0);
      break;
    case "weekly":
      setDayOfWeek(date, rule.weekStart, -1);
      date.setUTCDate(date.getUTCDate() + 6);
      break;
    default:
      break;
  }
  if (rule.byHour) {
    date.setUTCHours(23);
  }
  if (rule.byMinute) {
    date.setUTCMinutes(59);
  }
  if (rule.bySecond) {
    date.setUTCSeconds(59);
  }
  return ZonedDate.fromUTCDate(date, start.timezone);
};
var eventsByPosition = function(periodEvents, start, positions) {
  var periodEventsLength = periodEvents.length;
  var events = [];
  var position;
  for (var idx2 = 0, length_1 = positions.length; idx2 < length_1; idx2++) {
    position = positions[idx2];
    if (position < 0) {
      position = periodEventsLength + position;
    } else {
      position -= 1;
    }
    var event_1 = periodEvents[position];
    if (event_1 && event_1.start >= start) {
      events.push(event_1);
    }
  }
  return events;
};
var removeExceptionDates = function(periodEvents, exceptionDates) {
  var events = [];
  for (var idx2 = 0; idx2 < periodEvents.length; idx2++) {
    var event_2 = periodEvents[idx2];
    if (event_2 && !isException(exceptionDates, event_2.start)) {
      events.push(event_2);
    }
  }
  return events;
};
function expand(rule, options) {
  var rangeStart = options.rangeStart, rangeEnd = options.rangeEnd;
  if (!rule) {
    return {
      success: true,
      errorMessage: "",
      events: []
    };
  }
  var freqName = rule.freq;
  var freq = frequencies[freqName];
  var eventStart = rule.start;
  var eventDuration = duration(rule.start, rule.end);
  var endPeriod;
  if (rule.start.getTime() > rule.end.getTime()) {
    return {
      success: false,
      errorMessage: "Invalid recurrence rule: Start date (" + rule.start + ")" + ("is greater than End date " + rule.start),
      events: []
    };
  }
  if (!freq) {
    return {
      success: false,
      errorMessage: 'Invalid recurrence frequency "' + freqName + '"',
      events: []
    };
  }
  var events = [];
  var positions = rule.bySetPosition;
  var currentIdx = positions ? 0 : 1;
  var exceptionDates = rule.exceptionDates;
  var start = rangeStart.toTimezone(eventStart.timezone);
  var startPeriod = start;
  var end = rangeEnd.toTimezone(eventStart.timezone);
  var count = rule.count;
  if (rule.until && rule.until.getTime() < end.getTime()) {
    end = rule.until.clone();
  }
  var hours = start.getHours();
  var minutes = start.getMinutes();
  var seconds = start.getSeconds();
  var useEventStart = freqName === "yearly" || freqName === "monthly" || freqName === "weekly";
  if (start.getTime() < eventStart.getTime() || count || rule.interval > 1 || useEventStart) {
    start = eventStart.clone();
  } else {
    if (!rule.byHour) {
      hours = eventStart.getHours();
    }
    if (!rule.byMinute) {
      minutes = eventStart.getMinutes();
    }
    if (!rule.bySecond) {
      seconds = eventStart.getSeconds();
    }
    var startAdj = start.toUTCDate();
    startAdj.setUTCHours(hours, minutes, seconds, eventStart.getMilliseconds());
    start = ZonedDate.fromUTCDate(startAdj, start.timezone);
  }
  rule._startPeriod = start.clone();
  if (positions) {
    start = startPeriodByFreq(start, rule);
    end = endPeriodByFreq(end, rule);
    var diff2 = getTimeAfterMidnight(end) - getTimeAfterMidnight(start);
    if (diff2 < 0) {
      var endAdj = end.toUTCDate();
      endAdj.setUTCHours(start.getHours(), start.getMinutes(), start.getSeconds(), start.getMilliseconds());
      end = ZonedDate.fromUTCDate(endAdj, end.timezone);
    }
    rule._startPeriod = start.clone();
    endPeriod = endPeriodByFreq(start, rule);
  }
  var startTime = getTimeAfterMidnight(start);
  rule._startTime = new Date(startTime);
  var next = start.toUTCDate();
  if (freq.setup) {
    freq.setup(rule, eventStart, next);
    start = ZonedDate.fromUTCDate(next, start.timezone);
  }
  next = start.toUTCDate();
  freq.limit(next, end.toUTCDate(), rule);
  start = ZonedDate.fromUTCDate(next, start.timezone);
  while (start <= end) {
    var endDate = start.addTime(eventDuration);
    var inPeriod = start >= startPeriod || endDate > startPeriod;
    if (inPeriod && !isException(exceptionDates, start) || positions) {
      events.push({
        start: normalizeDST(start),
        end: normalizeDST(endDate)
      });
      if (freqName === "hourly" || freqName === "minutely" || freqName === "secondly") {
        startTime = getTimeAfterMidnight(normalizeDST(start));
        rule._startTime = new Date(startTime);
      }
    }
    if (positions) {
      next = start.toUTCDate();
      freq.next(next, rule);
      freq.limit(next, end.toUTCDate(), rule);
      start = ZonedDate.fromUTCDate(next, start.timezone);
      if (start > endPeriod) {
        var periodEvents = eventsByPosition(events.slice(currentIdx), eventStart, positions);
        periodEvents = removeExceptionDates(periodEvents, exceptionDates);
        events = events.slice(0, currentIdx).concat(periodEvents);
        endPeriod = endPeriodByFreq(start, rule);
        currentIdx = events.length;
      }
      if (count && count === currentIdx) {
        break;
      }
    } else {
      if (count && count === currentIdx) {
        break;
      }
      currentIdx += 1;
      next = start.toUTCDate();
      freq.next(next, rule);
      freq.limit(next, end.toUTCDate(), rule);
      start = ZonedDate.fromUTCDate(next, start.timezone);
    }
  }
  return {
    success: true,
    errorMessage: "",
    events
  };
}

// node_modules/@progress/kendo-recurrence/dist/es/parse-rule.js
var normalizeWeekDay = function(day, weekStart) {
  return day + (day < weekStart ? 7 : 0);
};
var daySortPredicate = function(weekStart) {
  return function(a, b) {
    return normalizeWeekDay(a.day, weekStart) - normalizeWeekDay(b.day, weekStart);
  };
};
var sortDays = function(rrule) {
  var byWeekDay2 = rrule.byWeekDay, weekStart = rrule.weekStart;
  if (!byWeekDay2) {
    return;
  }
  byWeekDay2.sort(daySortPredicate(weekStart));
};
var parseRule = function(options) {
  if (!options) {
    return null;
  }
  var recurrenceRule = options.recurrenceRule, _a2 = options.weekStart, weekStart = _a2 === void 0 ? 0 : _a2;
  var rule = {};
  var splits, value2;
  var idx2 = 0, length2;
  var parts;
  var property;
  if (!recurrenceRule) {
    return null;
  }
  var lines = recurrenceRule.split("\n");
  if (!lines[1] && (recurrenceRule.indexOf("DTSTART") !== -1 || recurrenceRule.indexOf("DTEND") !== -1 || recurrenceRule.indexOf("EXDATE") !== -1)) {
    lines = recurrenceRule.split(" ");
  }
  for (idx2 = 0, length2 = lines.length; idx2 < length2; idx2++) {
    var line = (lines[idx2] || "").trim();
    if (line.indexOf("DTSTART") !== -1) {
      rule.start = parseDateTime(line);
    } else if (line.indexOf("DTEND") !== -1) {
      rule.end = parseDateTime(line);
    } else if (line.indexOf("EXDATE") !== -1) {
      rule.exceptionDates = parseDateTimeList(line);
    } else if (line.indexOf("RRULE") !== -1) {
      parts = line.substring(6);
    } else if (line.trim()) {
      parts = line;
    }
  }
  parts = parts.split(";");
  for (idx2 = 0, length2 = parts.length; idx2 < length2; idx2++) {
    property = parts[idx2];
    splits = property.split("=");
    value2 = (splits[1] || "").trim().split(",");
    switch (splits[0].trim().toUpperCase()) {
      case "FREQ":
        rule.freq = value2[0].toLowerCase();
        break;
      case "UNTIL":
        rule.until = parseISODate(value2[0]);
        break;
      case "COUNT":
        rule.count = parseInt(value2[0], 10);
        break;
      case "INTERVAL":
        rule.interval = parseInt(value2[0], 10);
        break;
      case "BYSECOND":
        rule.bySecond = parseArray(value2, {
          start: 0,
          end: 60
        });
        break;
      case "BYMINUTE":
        rule.byMinute = parseArray(value2, {
          start: 0,
          end: 59
        });
        break;
      case "BYHOUR":
        rule.byHour = parseArray(value2, {
          start: 0,
          end: 23
        });
        break;
      case "BYMONTHDAY":
        rule.byMonthDay = parseArray(value2, {
          start: -31,
          end: 31
        });
        break;
      case "BYYEARDAY":
        rule.byYearDay = parseArray(value2, {
          start: -366,
          end: 366
        });
        break;
      case "BYMONTH":
        rule.byMonth = parseArray(value2, {
          start: 1,
          end: 12
        });
        break;
      case "BYDAY":
        rule.byWeekDay = parseWeekDayList(value2);
        break;
      case "BYWEEKNO":
        rule.byWeekNumber = parseArray(value2, {
          start: -53,
          end: 53
        });
        break;
      case "BYSETPOS":
        rule.bySetPosition = parseArray(value2, {
          start: -366,
          end: 366
        });
        break;
      case "WKST":
        rule.weekStart = parseWeekDay(value2[0]);
        break;
      default:
        break;
    }
  }
  if (rule.freq === void 0 || rule.count !== void 0 && rule.until) {
    return null;
  }
  if (rule.weekStart === void 0) {
    rule.weekStart = weekStart;
  }
  if (!rule.interval) {
    rule.interval = 1;
  }
  if (rule.bySetPosition && !hasModifiers(rule)) {
    rule.bySetPosition = [];
  }
  sortDays(rule);
  return rule;
};

// node_modules/@progress/kendo-recurrence/dist/es/serialize-rule.js
var WEEK_DAYS = {
  0: "SU",
  1: "MO",
  2: "TU",
  3: "WE",
  4: "TH",
  5: "FR",
  6: "SA"
};
var serializeWeekDayList = function(list2) {
  var length2 = list2.length;
  var result = [];
  var valueString;
  for (var idx2 = 0; idx2 < length2; idx2++) {
    var value2 = list2[idx2];
    if (typeof value2 === "string") {
      valueString = value2;
    } else {
      valueString = "" + WEEK_DAYS[value2.day];
      if (value2.offset) {
        valueString = value2.offset + valueString;
      }
    }
    result.push(valueString);
  }
  return result.toString();
};
var serializeRule = function(rrule, timezone) {
  if (!rrule || !rrule.freq) {
    return null;
  }
  var weekStart = rrule.weekStart;
  var rruleString = "FREQ=" + rrule.freq.toUpperCase();
  var exdates = "";
  var start = "";
  var end = "";
  var until = rrule.until;
  if (rrule.interval > 1) {
    rruleString += ";INTERVAL=" + rrule.interval;
  }
  if (rrule.count) {
    rruleString += ";COUNT=" + rrule.count;
  }
  if (until) {
    rruleString += ";UNTIL=" + toString(until.toTimezone("Etc/UTC"), "yyyyMMddTHHmmss") + "Z";
  }
  if (rrule.byMonth) {
    rruleString += ";BYMONTH=" + rrule.byMonth;
  }
  if (rrule.byWeekNumber) {
    rruleString += ";BYWEEKNO=" + rrule.byWeekNumber;
  }
  if (rrule.byYearDay) {
    rruleString += ";BYYEARDAY=" + rrule.byYearDay;
  }
  if (rrule.byMonthDay) {
    rruleString += ";BYMONTHDAY=" + rrule.byMonthDay;
  }
  if (rrule.byWeekDay) {
    rruleString += ";BYDAY=" + serializeWeekDayList(rrule.byWeekDay);
  }
  if (rrule.byHour) {
    rruleString += ";BYHOUR=" + rrule.byHour;
  }
  if (rrule.byMinute) {
    rruleString += ";BYMINUTE=" + rrule.byMinute;
  }
  if (rrule.bySecond) {
    rruleString += ";BYSECOND=" + rrule.bySecond;
  }
  if (rrule.bySetPosition) {
    rruleString += ";BYSETPOS=" + rrule.bySetPosition;
  }
  if (weekStart !== void 0) {
    rruleString += ";WKST=" + WEEK_DAYS[weekStart];
  }
  if (rrule.start) {
    start = "DTSTART" + serializeDates([rrule.start]);
  }
  if (rrule.end) {
    end = "DTEND" + serializeDates([rrule.end]);
  }
  if (rrule.exceptionDates) {
    exdates = "EXDATE" + serializeDates(rrule.exceptionDates);
  }
  if (start || end || exdates) {
    rruleString = start + end + exdates + "RRULE:" + rruleString;
  }
  return rruleString;
};

// node_modules/@progress/kendo-file-saver/dist/es/save-as.js
function saveAs(data, fileName, options) {
  if (options === void 0) options = {};
  var save = postToProxy;
  if (options.forceProxy && !options.proxyURL) {
    throw new Error("No proxyURL is set, but forceProxy is true");
  }
  if (!options.forceProxy) {
    if (canDownload()) {
      save = saveAsDataURI;
    }
    if (navigator.msSaveBlob) {
      save = saveAsBlob;
    }
  }
  save(data, fileName, options);
}
var anchor = function() {
  return document.createElement("a");
};
var canDownload = function() {
  return "download" in anchor();
};
function saveAsBlob(data, fileName) {
  var blob = data;
  if (typeof data === "string") {
    var parts = data.split(";base64,");
    var contentType = parts[0];
    var base64 = atob(parts[1]);
    var array = new Uint8Array(base64.length);
    for (var idx2 = 0; idx2 < base64.length; idx2++) {
      array[idx2] = base64.charCodeAt(idx2);
    }
    blob = new Blob([array.buffer], {
      type: contentType
    });
  }
  navigator.msSaveBlob(blob, fileName);
}
function saveAsDataURI(data, fileName) {
  var dataURI = data;
  if (window.Blob && data instanceof Blob) {
    dataURI = URL.createObjectURL(data);
  }
  var fileSaver = anchor();
  fileSaver.download = fileName;
  fileSaver.href = dataURI;
  var e = document.createEvent("MouseEvents");
  e.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
  fileSaver.dispatchEvent(e);
  setTimeout(function() {
    return URL.revokeObjectURL(dataURI);
  });
}
function postToProxy(dataURI, fileName, options) {
  if (!options.proxyURL) {
    return;
  }
  var form = document.createElement("form");
  form.setAttribute("action", options.proxyURL);
  form.setAttribute("method", "POST");
  form.setAttribute("target", options.proxyTarget || "_self");
  var formData = options.proxyData || {};
  formData.fileName = fileName;
  var parts = dataURI.split(";base64,");
  formData.contentType = parts[0].replace("data:", "");
  formData.base64 = parts[1];
  for (var name in formData) {
    if (formData.hasOwnProperty(name)) {
      var input = document.createElement("input");
      input.setAttribute("type", "hidden");
      input.setAttribute("name", name);
      input.setAttribute("value", formData[name]);
      form.appendChild(input);
    }
  }
  document.body.appendChild(form);
  form.submit();
  document.body.removeChild(form);
}

// node_modules/@progress/kendo-file-saver/dist/es/base64.js
var fromCharCode = String.fromCharCode;

// node_modules/@progress/kendo-data-query/dist/es/utils.js
var isPresent3 = function(value2) {
  return value2 !== null && value2 !== void 0;
};
var isBlank = function(value2) {
  return value2 === null || value2 === void 0;
};
var isArray = function(value2) {
  return Array.isArray(value2);
};
var isFunction3 = function(value2) {
  return typeof value2 === "function";
};
var isString2 = function(value2) {
  return typeof value2 === "string";
};
var isNullOrEmptyString = function(value2) {
  return isBlank(value2) || value2.trim().length === 0;
};
var isNotNullOrEmptyString = function(value2) {
  return !isNullOrEmptyString(value2);
};
var isNumeric = function(value2) {
  return !isNaN(value2 - parseFloat(value2));
};
var isDate2 = function(value2) {
  return value2 && value2.getTime;
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-descriptor.interface.js
var isCompositeFilterDescriptor = function(source) {
  return isPresent3(source.filters);
};

// node_modules/@progress/kendo-data-query/dist/es/funcs.js
var ifElse = function(predicate, right2, left2) {
  return function(value2) {
    return predicate(value2) ? right2(value2) : left2(value2);
  };
};
var compose = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(data) {
    return args.reduceRight(function(acc, curr) {
      return curr(acc);
    }, data);
  };
};
var constant = function(x) {
  return function() {
    return x;
  };
};

// node_modules/@progress/kendo-data-query/dist/es/filter-serialization.common.js
var toUTC = function(date) {
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
};
var isDateValue = function(x) {
  return isDate2(x.value);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter.operators.js
var operatorMap = function(key) {
  return {
    "!=": "neq",
    "<": "lt",
    "<=": "lte",
    "==": "eq",
    ">": "gt",
    ">=": "gte",
    equal: "eq",
    equals: "eq",
    equalto: "eq",
    ge: "gte",
    greater: "gt",
    greaterthan: "gt",
    greaterthanequal: "gte",
    isempty: "isempty",
    isequalto: "eq",
    isgreaterthan: "gt",
    isgreaterthanorequalto: "gte",
    islessthan: "lt",
    islessthanorequalto: "lte",
    isnotempty: "isnotempty",
    isnotequalto: "neq",
    isnull: "isnull",
    le: "lte",
    less: "lt",
    lessthan: "lt",
    lessthanequal: "lte",
    ne: "neq",
    notequal: "neq",
    notequals: "neq",
    notequalto: "neq",
    notsubstringof: "doesnotcontain"
  }[key.toLowerCase()] || key;
};
var normalizeOperator = function(descriptor) {
  if (descriptor.filters) {
    descriptor.filters = descriptor.filters.map(function(filter3) {
      var result = Object.assign({}, filter3);
      if (!isCompositeFilterDescriptor(filter3) && isString2(filter3.operator)) {
        result.operator = operatorMap(filter3.operator);
      }
      if (isCompositeFilterDescriptor(filter3)) {
        normalizeOperator(result);
      }
      return result;
    });
  }
};
var normalizeDescriptor = function(descriptor) {
  if (!isCompositeFilterDescriptor(descriptor)) {
    return {
      filters: isArray(descriptor) ? descriptor : [descriptor],
      logic: "and"
    };
  }
  return Object.assign({}, descriptor);
};
var normalizeFilters = function(descriptor) {
  if (isPresent3(descriptor)) {
    descriptor = normalizeDescriptor(descriptor);
    normalizeOperator(descriptor);
  }
  return descriptor;
};

// node_modules/@progress/kendo-data-query/dist/es/odata.operators.js
var emptyString = constant("");

// node_modules/@progress/kendo-data-query/dist/es/accessor.js
var getterCache = {};
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
getterCache["undefined"] = function(obj) {
  return obj;
};
var getter = function(field, safe) {
  var key = field + safe;
  if (getterCache[key]) {
    return getterCache[key];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(_, index, indexAccessor, field2) {
    fields.push(isPresent3(index) ? index : indexAccessor || field2);
    return void 0;
  });
  getterCache[key] = function(obj) {
    var result = obj;
    for (var idx2 = 0; idx2 < fields.length; idx2++) {
      result = result[fields[idx2]];
      if (!isPresent3(result) && safe) {
        return result;
      }
    }
    return result;
  };
  return getterCache[key];
};

// node_modules/@progress/kendo-data-query/dist/es/mvc/operators.js
var pairwise = function(key) {
  return function(value2) {
    return [key, value2];
  };
};
var empty = function() {
  return null;
};
var isNotEmptyArray = function(value2) {
  return isPresent3(value2) && isArray(value2) && value2.length > 0;
};
var has = function(accessor) {
  return function(value2) {
    return isPresent3(accessor(value2));
  };
};
var isNotEmpty = function(accessor) {
  return function(value2) {
    return isNotEmptyArray(accessor(value2));
  };
};
var runOrEmpty = function(predicate, fn) {
  return ifElse(predicate, fn, empty);
};
var calcPage = function(_a2) {
  var skip3 = _a2.skip, take4 = _a2.take;
  return Math.floor((skip3 || 0) / take4) + 1;
};
var formatDescriptors = function(accessor, formatter) {
  return function(state) {
    return accessor(state).map(formatter).join("~");
  };
};
var removeAfter = function(what) {
  return function(str) {
    return str.slice(0, str.indexOf(what));
  };
};
var replace = function(patterns) {
  return compose.apply(void 0, patterns.map(function(_a2) {
    var left2 = _a2[0], right2 = _a2[1];
    return function(s) {
      return s.replace(new RegExp(left2, "g"), right2);
    };
  }));
};
var sanitizeDateLiterals = replace([['"', ""], [":", "-"]]);
var removeAfterDot = removeAfter(".");
var directionFormatter = function(_a2) {
  var field = _a2.field, _b = _a2.dir, dir = _b === void 0 ? "asc" : _b;
  return field + "-" + dir;
};
var aggregateFormatter = function(_a2) {
  var field = _a2.field, aggregate = _a2.aggregate;
  return field + "-" + aggregate;
};
var take2 = getter("take");
var aggregates = getter("aggregates");
var skip = getter("skip");
var group = getter("group");
var sort = getter("sort", true);
var formatSort = formatDescriptors(sort, directionFormatter);
var formatGroup = formatDescriptors(group, directionFormatter);
var formatAggregates = formatDescriptors(aggregates, aggregateFormatter);
var prefixDateValue = function(value2) {
  return "datetime'" + value2 + "'";
};
var formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);
var formatDate3 = function(_a2) {
  var field = _a2.field, value2 = _a2.value, ignoreCase = _a2.ignoreCase, operator = _a2.operator;
  return {
    value: formatDateValue(value2),
    field,
    ignoreCase,
    operator
  };
};
var normalizeSort = function(state) {
  return Object.assign({}, state, {
    sort: (sort(state) || []).filter(function(_a2) {
      var dir = _a2.dir;
      return isNotNullOrEmptyString(dir);
    })
  });
};
var transformSkip = compose(pairwise("page"), calcPage);
var transformTake = compose(pairwise("pageSize"), take2);
var transformGroup = compose(pairwise("group"), formatGroup);
var transformSort = compose(pairwise("sort"), formatSort);
var transformAggregates = compose(pairwise("aggregate"), formatAggregates);
var serializePage = runOrEmpty(has(skip), transformSkip);
var serializePageSize = runOrEmpty(has(take2), transformTake);
var serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);
var serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);
var serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);
var filterFormatter = function(_a2) {
  var field = _a2.field, operator = _a2.operator, value2 = _a2.value;
  return field + "~" + operator + "~" + value2;
};
var dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate3), filterFormatter);

// node_modules/@progress/kendo-data-query/dist/es/mvc/deserialization.js
var set = function(field, target, value2) {
  target[field] = value2;
  return target;
};
var toCamelCase = function(str) {
  return str.replace(/(^[A-Z])/g, function(_, g1) {
    return g1.toLowerCase();
  });
};
var prop = function(fieldName) {
  return function(obj) {
    var value2 = obj[fieldName];
    if (isPresent3(value2)) {
      return value2;
    }
    return obj[toCamelCase(fieldName)];
  };
};
var member = prop("Member");
var aggregateMethodName = prop("AggregateMethodName");
var value = prop("Value");
var convert = function(mapper) {
  return function(values) {
    return Object.keys(values).reduce(mapper.bind(null, values), {});
  };
};
var translateAggregate = convert(function(source, acc, field) {
  return set(field.toLowerCase(), acc, source[field]);
});
var translateAggregates = convert(function(source, acc, field) {
  return set(field, acc, translateAggregate(source[field]));
});
var valueOrDefault = function(value2, defaultValue) {
  return isPresent3(value2) ? value2 : defaultValue;
};
var normalizeGroup = function(group3) {
  return {
    aggregates: group3.Aggregates || group3.aggregates,
    field: group3.Member || group3.member || group3.field,
    hasSubgroups: group3.HasSubgroups || group3.hasSubgroups || false,
    items: group3.Items || group3.items,
    value: valueOrDefault(group3.Key, valueOrDefault(group3.key, group3.value))
  };
};
var translateGroup = compose(function(_a2) {
  var field = _a2.field, hasSubgroups = _a2.hasSubgroups, value2 = _a2.value, aggregates2 = _a2.aggregates, items = _a2.items;
  return {
    aggregates: translateAggregates(aggregates2),
    field,
    items: hasSubgroups ? items.map(translateGroup) : items,
    value: value2
  };
}, normalizeGroup);

// node_modules/@progress/kendo-data-query/dist/es/sorting/sort-array.operator.js
var compare = function(a, b) {
  if (isBlank(a)) {
    return a === b ? 0 : -1;
  }
  if (isBlank(b)) {
    return 1;
  }
  if (a.localeCompare) {
    return a.localeCompare(b);
  }
  return a > b ? 1 : a < b ? -1 : 0;
};
var compareDesc = function(a, b) {
  return compare(b, a);
};
var descriptorAsFunc = function(descriptor) {
  if (typeof descriptor.compare === "function") {
    return descriptor.compare;
  }
  var prop2 = getter(descriptor.field, true);
  return function(a, b) {
    return (descriptor.dir === "asc" ? compare : compareDesc)(prop2(a), prop2(b));
  };
};
var initial = function(_a2, _b) {
  return 0;
};
var composeSortDescriptors = function(descriptors) {
  return descriptors.filter(function(x) {
    return isPresent3(x.dir) || isPresent3(x.compare);
  }).map(function(descriptor) {
    return descriptorAsFunc(descriptor);
  }).reduce(function(acc, curr) {
    return function(a, b) {
      return acc(a, b) || curr(a, b);
    };
  }, initial);
};

// node_modules/@progress/kendo-data-query/dist/es/transducers.js
var valueToString = function(value2) {
  value2 = isPresent3(value2) && value2.getTime ? value2.getTime() : value2;
  return value2 + "";
};
var groupCombinator = function(field) {
  var prop2 = getter(field, true);
  var position = 0;
  return function(agg, value2) {
    agg[field] = agg[field] || {};
    var groupValue = prop2(value2);
    var key = valueToString(groupValue);
    var values = agg[field][key] || {
      __position: position++,
      aggregates: {},
      items: [],
      value: groupValue
    };
    values.items.push(value2);
    agg[field][key] = values;
    return agg;
  };
};
var expandAggregates = function(result) {
  if (result === void 0) {
    result = {};
  }
  Object.keys(result).forEach(function(field) {
    var aggregates2 = result[field];
    Object.keys(aggregates2).forEach(function(aggregate) {
      aggregates2[aggregate] = aggregates2[aggregate].result();
    });
  });
  return result;
};
var aggregatesFuncs = function(name) {
  return {
    average: function() {
      var value2 = 0;
      var count = 0;
      return {
        calc: function(curr) {
          if (isNumeric(curr)) {
            value2 += curr;
            count++;
          } else {
            value2 = curr;
          }
        },
        result: function() {
          return isNumeric(value2) ? value2 / count : value2;
        }
      };
    },
    count: function() {
      var state = 0;
      return {
        calc: function() {
          return state++;
        },
        result: function() {
          return state;
        }
      };
    },
    max: function() {
      var state = Number.NEGATIVE_INFINITY;
      return {
        calc: function(value2) {
          state = isNumeric(state) || isDate2(state) ? state : value2;
          if (state < value2 && (isNumeric(value2) || isDate2(value2))) {
            state = value2;
          }
        },
        result: function() {
          return state;
        }
      };
    },
    min: function() {
      var state = Number.POSITIVE_INFINITY;
      return {
        calc: function(value2) {
          state = isNumeric(state) || isDate2(state) ? state : value2;
          if (state > value2 && (isNumeric(value2) || isDate2(value2))) {
            state = value2;
          }
        },
        result: function() {
          return state;
        }
      };
    },
    sum: function() {
      var state = 0;
      return {
        calc: function(value2) {
          value2 = isPresent3(value2) ? value2 : 0;
          state += value2;
        },
        result: function() {
          return state;
        }
      };
    }
  }[name]();
};
var aggregatesCombinator = function(descriptors) {
  var functions = descriptors.map(function(descriptor) {
    var fieldAccessor = getter(descriptor.field, true);
    var aggregateName = (descriptor.aggregate || "").toLowerCase();
    var aggregateAccessor = getter(aggregateName, true);
    return function(state, value2) {
      var fieldAggregates = state[descriptor.field] || {};
      var aggregateFunction = aggregateAccessor(fieldAggregates) || aggregatesFuncs(aggregateName);
      aggregateFunction.calc(fieldAccessor(value2));
      fieldAggregates[descriptor.aggregate] = aggregateFunction;
      state[descriptor.field] = fieldAggregates;
      return state;
    };
  });
  return function(state, value2) {
    return functions.reduce(function(agg, calc) {
      return calc(agg, value2);
    }, state);
  };
};
var map2 = function(transform) {
  return function(reduce) {
    return function(acc, curr, index) {
      return reduce(acc, transform(curr, index));
    };
  };
};
var isTransformerResult = function(source) {
  return isPresent3(source.__value);
};
var exec = function(transform, initialValue, data) {
  var result = initialValue;
  for (var idx2 = 0, length_1 = data.length; idx2 < length_1; idx2++) {
    result = transform(result, data[idx2], idx2);
    if (isTransformerResult(result)) {
      result = result.__value;
      break;
    }
  }
  return result;
};

// node_modules/@progress/kendo-data-query/dist/es/grouping/aggregate.operators.js
var identity2 = map2(function(x) {
  return x;
});
var aggregateBy = function(data, descriptors, transformers) {
  if (descriptors === void 0) {
    descriptors = [];
  }
  if (transformers === void 0) {
    transformers = identity2;
  }
  var initialValue = {};
  if (!descriptors.length) {
    return initialValue;
  }
  var result = exec(transformers(aggregatesCombinator(descriptors)), initialValue, data);
  return expandAggregates(result);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-no-eval.js
var logic = {
  "or": {
    concat: function(acc, fn) {
      return function(a) {
        return acc(a) || fn(a);
      };
    },
    identity: function() {
      return false;
    }
  },
  "and": {
    concat: function(acc, fn) {
      return function(a) {
        return acc(a) && fn(a);
      };
    },
    identity: function() {
      return true;
    }
  }
};
var operatorsMap = {
  contains: function(a, b) {
    return (a || "").indexOf(b) >= 0;
  },
  doesnotcontain: function(a, b) {
    return (a || "").indexOf(b) === -1;
  },
  doesnotendwith: function(a, b) {
    return (a || "").indexOf(b, (a || "").length - (b || "").length) < 0;
  },
  doesnotstartwith: function(a, b) {
    return (a || "").lastIndexOf(b, 0) === -1;
  },
  endswith: function(a, b) {
    return (a || "").indexOf(b, (a || "").length - (b || "").length) >= 0;
  },
  eq: function(a, b) {
    return a === b;
  },
  gt: function(a, b) {
    return a > b;
  },
  gte: function(a, b) {
    return a >= b;
  },
  isempty: function(a) {
    return a === "";
  },
  isnotempty: function(a) {
    return a !== "";
  },
  isnotnull: function(a) {
    return isPresent3(a);
  },
  isnull: function(a) {
    return isBlank(a);
  },
  lt: function(a, b) {
    return a < b;
  },
  lte: function(a, b) {
    return a <= b;
  },
  neq: function(a, b) {
    return a != b;
  },
  startswith: function(a, b) {
    return (a || "").lastIndexOf(b, 0) === 0;
  }
};
var dateRegExp2 = /^\/Date\((.*?)\)\/$/;
var convertValue = function(value2, ignoreCase) {
  if (value2 != null && isString2(value2)) {
    var date = dateRegExp2.exec(value2);
    if (date) {
      return (/* @__PURE__ */ new Date(+date[1])).getTime();
    } else if (ignoreCase) {
      return value2.toLowerCase();
    }
  } else if (value2 != null && isDate2(value2)) {
    return value2.getTime();
  }
  return value2;
};
var typedGetter = function(prop2, value2, ignoreCase) {
  if (!isPresent3(value2)) {
    return prop2;
  }
  var acc = prop2;
  if (isString2(value2)) {
    var date = dateRegExp2.exec(value2);
    if (date) {
      value2 = /* @__PURE__ */ new Date(+date[1]);
    } else {
      acc = function(a) {
        var x = prop2(a);
        if (typeof x === "string" && ignoreCase) {
          return x.toLowerCase();
        } else {
          return isNumeric(x) ? x + "" : x;
        }
      };
    }
  }
  if (isDate2(value2)) {
    return function(a) {
      var x = acc(a);
      return isDate2(x) ? x.getTime() : x;
    };
  }
  return acc;
};
var transformFilter = function(_a2) {
  var field = _a2.field, ignoreCase = _a2.ignoreCase, value2 = _a2.value, operator = _a2.operator;
  field = !isPresent3(field) ? function(a) {
    return a;
  } : field;
  ignoreCase = isPresent3(ignoreCase) ? ignoreCase : true;
  var itemProp = typedGetter(isFunction3(field) ? field : getter(field, true), value2, ignoreCase);
  value2 = convertValue(value2, ignoreCase);
  var op = isFunction3(operator) ? operator : operatorsMap[operator];
  return function(a) {
    return op(itemProp(a), value2, ignoreCase);
  };
};
var transformCompositeFilter = function(filter3) {
  var combiner = logic[filter3.logic];
  return filter3.filters.filter(isPresent3).map(function(x) {
    return isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x);
  }).reduce(combiner.concat, combiner.identity);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-expression.factory.js
var compileFilter = function(descriptor) {
  if (!descriptor || descriptor.filters.length === 0) {
    return function() {
      return true;
    };
  }
  return transformCompositeFilter(descriptor);
};
var filterBy = function(data, descriptor) {
  if (!isPresent3(descriptor) || isCompositeFilterDescriptor(descriptor) && descriptor.filters.length === 0) {
    return data;
  }
  return data.filter(compileFilter(normalizeFilters(descriptor)));
};

// node_modules/@progress/kendo-data-query/dist/es/grouping/group.operators.js
var normalizeGroups = function(descriptors) {
  descriptors = isArray(descriptors) ? descriptors : [descriptors];
  return descriptors.map(function(x) {
    return Object.assign({
      dir: "asc"
    }, x);
  });
};
var identity3 = map2(function(x) {
  return x;
});
var groupBy = function(data, descriptors, transformers, originalData) {
  if (descriptors === void 0) {
    descriptors = [];
  }
  if (transformers === void 0) {
    transformers = identity3;
  }
  if (originalData === void 0) {
    originalData = data;
  }
  descriptors = normalizeGroups(descriptors);
  if (!descriptors.length) {
    return data;
  }
  var descriptor = descriptors[0];
  var initialValue = {};
  var view2 = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);
  var result = [];
  Object.keys(view2).forEach(function(field) {
    Object.keys(view2[field]).forEach(function(value2) {
      var group3 = view2[field][value2];
      var aggregateResult = {};
      var filteredData = originalData;
      if (isPresent3(descriptor.aggregates)) {
        filteredData = filterBy(originalData, {
          field: descriptor.field,
          ignoreCase: false,
          operator: "eq",
          value: group3.value
        });
        aggregateResult = aggregateBy(filteredData, descriptor.aggregates);
      }
      result[group3.__position] = {
        aggregates: aggregateResult,
        field,
        items: descriptors.length > 1 ? groupBy(group3.items, descriptors.slice(1), identity3, filteredData) : group3.items,
        value: group3.value
      };
    });
  });
  return result;
};

// node_modules/@progress/kendo-data-query/dist/es/array.operators.js
var orderBy = function(data, descriptors) {
  if (descriptors.some(function(x) {
    return isPresent3(x.dir) || isPresent3(x.compare);
  })) {
    data = data.slice(0);
    var comparer = composeSortDescriptors(descriptors);
    data.sort(comparer);
  }
  return data;
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/operators.enum.js
var FilterOperator;
(function(FilterOperator2) {
  FilterOperator2["Contains"] = "contains";
  FilterOperator2["DoesNotContain"] = "doesnotcontain";
  FilterOperator2["DoesNotEndWith"] = "doesnotendwith";
  FilterOperator2["DoesNotStartWith"] = "doesnotstartwith";
  FilterOperator2["EndsWith"] = "endswith";
  FilterOperator2["EqualTo"] = "eq";
  FilterOperator2["GreaterThan"] = "gt";
  FilterOperator2["GreaterThanOrEqual"] = "gte";
  FilterOperator2["IsEmpty"] = "isempty";
  FilterOperator2["IsNotEmpty"] = "isnotempty";
  FilterOperator2["IsNotNull"] = "isnotnull";
  FilterOperator2["IsNull"] = "isnull";
  FilterOperator2["LessThan"] = "lt";
  FilterOperator2["LessThanOrEqual"] = "lte";
  FilterOperator2["NotEqualTo"] = "neq";
  FilterOperator2["StartsWith"] = "startswith";
})(FilterOperator || (FilterOperator = {}));

// node_modules/@progress/kendo-angular-tooltip/fesm2022/progress-kendo-angular-tooltip.mjs
var _c02 = ["popoverWrapper"];
var _c110 = ["titleTemplateWrapper"];
var _c210 = ["bodyTemplateWrapper"];
var _c37 = (a0, a1) => ({
  "width": a0,
  "height": a1
});
var _c42 = (a0, a1) => ({
  $implicit: a0,
  data: a1
});
function PopoverComponent_div_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r0.getCalloutPosition());
  }
}
function PopoverComponent_div_0_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PopoverComponent_div_0_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵtemplate(1, PopoverComponent_div_0_div_3_ng_container_1_Template, 1, 0, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const noCallout_r2 = ɵɵreference(5);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", noCallout_r2);
  }
}
function PopoverComponent_div_0_ng_template_4_div_0_2_ng_template_0_Template(rf, ctx) {
}
function PopoverComponent_div_0_ng_template_4_div_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PopoverComponent_div_0_ng_template_4_div_0_2_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.titleTemplate == null ? null : ctx_r0.titleTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c42, ctx_r0.anchor, ctx_r0.contextData));
  }
}
function PopoverComponent_div_0_ng_template_4_div_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
  }
}
function PopoverComponent_div_0_ng_template_4_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14, 2);
    ɵɵtemplate(2, PopoverComponent_div_0_ng_template_4_div_0_2_Template, 1, 5, null, 15)(3, PopoverComponent_div_0_ng_template_4_div_0_ng_container_3_Template, 2, 1, "ng-container", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.titleTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.title && !ctx_r0.titleTemplate);
  }
}
function PopoverComponent_div_0_ng_template_4_div_1_2_ng_template_0_Template(rf, ctx) {
}
function PopoverComponent_div_0_ng_template_4_div_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PopoverComponent_div_0_ng_template_4_div_1_2_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.bodyTemplate == null ? null : ctx_r0.bodyTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c42, ctx_r0.anchor, ctx_r0.contextData));
  }
}
function PopoverComponent_div_0_ng_template_4_div_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.body, " ");
  }
}
function PopoverComponent_div_0_ng_template_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17, 3);
    ɵɵtemplate(2, PopoverComponent_div_0_ng_template_4_div_1_2_Template, 1, 5, null, 15)(3, PopoverComponent_div_0_ng_template_4_div_1_ng_container_3_Template, 2, 1, "ng-container", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.bodyTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.body && !ctx_r0.bodyTemplate);
  }
}
function PopoverComponent_div_0_ng_template_4_div_2_1_ng_template_0_Template(rf, ctx) {
}
function PopoverComponent_div_0_ng_template_4_div_2_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PopoverComponent_div_0_ng_template_4_div_2_1_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.actionsTemplate == null ? null : ctx_r0.actionsTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c42, ctx_r0.anchor, ctx_r0.contextData));
  }
}
function PopoverComponent_div_0_ng_template_4_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵtemplate(1, PopoverComponent_div_0_ng_template_4_div_2_1_Template, 1, 5, null, 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.actionsTemplate);
  }
}
function PopoverComponent_div_0_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PopoverComponent_div_0_ng_template_4_div_0_Template, 4, 2, "div", 11)(1, PopoverComponent_div_0_ng_template_4_div_1_Template, 4, 2, "div", 12)(2, PopoverComponent_div_0_ng_template_4_div_2_Template, 2, 1, "div", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngIf", ctx_r0.titleTemplate || ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.bodyTemplate || ctx_r0.body);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.actionsTemplate);
  }
}
function PopoverComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5, 0);
    ɵɵtemplate(2, PopoverComponent_div_0_div_2_Template, 1, 1, "div", 6)(3, PopoverComponent_div_0_div_3_Template, 2, 1, "div", 7)(4, PopoverComponent_div_0_ng_template_4_Template, 3, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const noCallout_r2 = ɵɵreference(5);
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ɵɵpureFunction2(4, _c37, ctx_r0.width, ctx_r0.height));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.callout);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.callout)("ngIfElse", noCallout_r2);
  }
}
var _c52 = (a0, a1) => ({
  $implicit: a0,
  anchor: a1
});
function TooltipContentComponent_div_2_ng_template_1_Template(rf, ctx) {
}
function TooltipContentComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, TooltipContentComponent_div_2_ng_template_1_Template, 0, 0, "ng-template", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.titleTemplate)("ngTemplateOutlet", ctx_r0.titleTemplate)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c52, ctx_r0.anchor, ctx_r0.anchor));
  }
}
function TooltipContentComponent_ng_template_3_Template(rf, ctx) {
}
function TooltipContentComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.templateString, " ");
  }
}
function TooltipContentComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 8);
    ɵɵlistener("click", function TooltipContentComponent_div_5_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onCloseClick($event));
    });
    ɵɵelementStart(1, "a", 9);
    ɵɵelement(2, "kendo-icon-wrapper", 10);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-hidden", true);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r0.closeButtonTitle);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.xIcon);
  }
}
function TooltipContentComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.calloutPositionClass());
  }
}
var LocalizedMessagesDirective2 = class _LocalizedMessagesDirective extends ComponentMessages {
  service;
  /**
   * The title of the close button.
   */
  closeTitle;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoTooltipLocalizedMessages", ""]],
    inputs: {
      closeTitle: "closeTitle"
    },
    features: [ɵɵProvidersFeature([{
      provide: ComponentMessages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective2, [{
    type: Directive,
    args: [{
      providers: [{
        provide: ComponentMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective2)
      }],
      selector: `[kendoTooltipLocalizedMessages]`,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    closeTitle: [{
      type: Input
    }]
  });
})();
var ERRORS = {
  popover: `Invalid value provided for the 'popover' property. The accepted data types are 'PopoverComponent' or 'PopoverFn'.`,
  templateData: `templateData must be a function, but received`,
  showOn: `Invalid value provided for the 'showOn' property. The available options are 'click', 'hover', 'focus' or 'none'.`
};
var PopoverShowEvent = class extends PreventableEvent {
  /**
   * The host element related to the popover.
   */
  anchor;
  /**
   * @hidden
   * Constructs the event arguments for the `show` event.
   * @param anchor - The host element related to the popover.
   */
  constructor(anchor2) {
    super();
    this.anchor = anchor2;
  }
};
var PopoverHideEvent = class extends PreventableEvent {
  /**
   * The host element related to the popover.
   */
  anchor;
  /**
   * The popover element.
   */
  popover;
  /**
   * @hidden
   * Constructs the event arguments for the `hide` event.
   * @param anchor - The host element related to the popover.
   * @param popover - The popover element.
   */
  constructor(anchor2, popover) {
    super();
    this.anchor = anchor2;
    this.popover = popover;
  }
};
var PopoverShownEvent = class {
  /**
   * The host element related to the popover.
   */
  anchor;
  /**
   * The popover element.
   */
  popover;
  /**
   * @hidden
   * Constructs the event arguments for the `shown` event.
   * @param anchor - The host element related to the popover.
   * @param popover - The popover element.
   */
  constructor(anchor2, popover) {
    this.anchor = anchor2;
    this.popover = popover;
  }
};
var PopoverHiddenEvent = class {
  /**
   * The host element related to the popover.
   */
  anchor;
  /**
   * @hidden
   * Constructs the event arguments for the `hidden` event.
   * @param anchor - The host element related to the popover.
   */
  constructor(anchor2) {
    this.anchor = anchor2;
  }
};
var idx = 0;
var popoverTitleIdx = 0;
var popoverBodyIdx = 0;
var getId = (prefix, idSource) => {
  switch (idSource) {
    case "popoverTitle":
      return `${prefix}-${++popoverTitleIdx}`;
    case "popoverBody":
      return `${prefix}-${++popoverBodyIdx}`;
    default:
      return `${prefix}-${++idx}`;
  }
};
function align(position, offset2) {
  let anchorAlign = {};
  let popupAlign = {};
  let popupMargin = {};
  switch (position) {
    case "top":
      anchorAlign = {
        horizontal: "center",
        vertical: "top"
      };
      popupAlign = {
        horizontal: "center",
        vertical: "bottom"
      };
      popupMargin = {
        horizontal: 0,
        vertical: offset2
      };
      break;
    case "bottom":
      anchorAlign = {
        horizontal: "center",
        vertical: "bottom"
      };
      popupAlign = {
        horizontal: "center",
        vertical: "top"
      };
      popupMargin = {
        horizontal: 0,
        vertical: offset2
      };
      break;
    case "right":
      anchorAlign = {
        horizontal: "right",
        vertical: "center"
      };
      popupAlign = {
        horizontal: "left",
        vertical: "center"
      };
      popupMargin = {
        horizontal: offset2,
        vertical: 0
      };
      break;
    case "left":
      anchorAlign = {
        horizontal: "left",
        vertical: "center"
      };
      popupAlign = {
        horizontal: "right",
        vertical: "center"
      };
      popupMargin = {
        horizontal: offset2,
        vertical: 0
      };
      break;
    default:
      break;
  }
  return {
    anchorAlign,
    popupAlign,
    popupMargin
  };
}
function collision(inputcollision, position) {
  if (inputcollision) {
    return inputcollision;
  }
  if (position === "top" || position === "bottom") {
    return {
      horizontal: "fit",
      vertical: "flip"
    };
  }
  return {
    horizontal: "flip",
    vertical: "fit"
  };
}
function isDocumentNode(container) {
  return container.nodeType === 9;
}
function closestBySelector(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }
  const matches = Element.prototype.matches ? (el, sel) => el.matches(sel) : (el, sel) => el.msMatchesSelector(sel);
  let node = element;
  while (node && !isDocumentNode(node)) {
    if (matches(node, selector)) {
      return node;
    }
    node = node.parentNode;
  }
}
function contains(container, child) {
  if (!container) {
    return false;
  }
  if (isDocumentNode(container)) {
    return false;
  }
  if (container.contains) {
    return container.contains(child);
  }
  if (container.compareDocumentPosition) {
    return !!(container.compareDocumentPosition(child) & Node.DOCUMENT_POSITION_CONTAINED_BY);
  }
}
var hasParent = (node, parent) => {
  while (node && node !== parent) {
    node = node.parentNode;
  }
  return node;
};
function getCenterOffset(item, dir, size) {
  const rect = item.getBoundingClientRect();
  return rect[dir] + rect[size] / 2;
}
function containsItem(collection, item) {
  return collection.indexOf(item) !== -1;
}
function getAllFocusableChildren(parent) {
  return parent.querySelectorAll(focusableSelector);
}
function getFirstAndLastFocusable(parent) {
  const all = getAllFocusableChildren(parent);
  const firstFocusable = all.length > 0 ? all[0] : parent;
  const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;
  return [firstFocusable, lastFocusable];
}
var packageMetadata2 = {
  name: "@progress/kendo-angular-tooltip",
  productName: "Kendo UI for Angular",
  productCodes: ["KENDOUIANGULAR", "KENDOUICOMPLETE"],
  publishDate: 1733732594,
  version: "17.1.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var PopoverTitleTemplateDirective = class _PopoverTitleTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PopoverTitleTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverTitleTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PopoverTitleTemplateDirective,
    selectors: [["", "kendoPopoverTitleTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverTitleTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPopoverTitleTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var PopoverBodyTemplateDirective = class _PopoverBodyTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PopoverBodyTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverBodyTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PopoverBodyTemplateDirective,
    selectors: [["", "kendoPopoverBodyTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverBodyTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPopoverBodyTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var PopoverActionsTemplateDirective = class _PopoverActionsTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PopoverActionsTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverActionsTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PopoverActionsTemplateDirective,
    selectors: [["", "kendoPopoverActionsTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverActionsTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPopoverActionsTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var PopoverComponent = class _PopoverComponent {
  localization;
  renderer;
  element;
  zone;
  /**
   * @hidden
   */
  anchor;
  /**
   * Specifies the position of the Popover in relation to its anchor element. [See example]({% slug positioning_popover %})
   *
   * The possible options are:
   * `top`
   * `bottom`
   * `right` (Default)
   * `left`
   */
  position = "right";
  /**
   * Specifies the distance from the Popover to its anchor element in pixels.
   *
   * @default `6`
   */
  set offset(value2) {
    this._offset = value2;
  }
  get offset() {
    const calloutBuffer = 14;
    return this.callout ? calloutBuffer + this._offset : this._offset;
  }
  /**
   * Determines the width of the popover. Numeric values are treated as pixels.
   * @default 'auto'
   */
  set width(value2) {
    this._width = typeof value2 === "number" ? `${value2}px` : value2;
  }
  get width() {
    return this._width;
  }
  /**
   * Determines the height of the popover. Numeric values are treated as pixels.
   * @default 'auto'
   */
  set height(value2) {
    this._height = typeof value2 === "number" ? `${value2}px` : value2;
  }
  get height() {
    return this._height;
  }
  /**
   * @hidden
   */
  direction;
  /**
   * Specifies the main header text of the Popover.
   *
   * If a `titleTemplate` is provided it would take precedence over the title.
   */
  title;
  /**
   * @hidden
   * Specifies the secondary header text of the Popover.
   *
   * If a `titleTemplate` is provided it would take precedence over the subtitle.
   */
  subtitle;
  /**
   * Represents the text that will be rendered in the Popover body section.
   *
   * If a `bodyTemplate` is provided it would take precedence over this text.
   */
  body;
  /**
   * Determines whether a callout will be rendered along the Popover. [See example]({% slug callout_popover %})
   *
   * @default true
   */
  callout = true;
  /**
   * Enables and configures the Popover animation. [See example]({% slug animations_popover %})
   *
   * The possible options are:
   *
   * * `boolean`&mdash;Enables the default animation
   * * `PopoverAnimation`&mdash;A configuration object which allows setting the `direction`, `duration` and `type` of the animation.
   *
   * @default false
   */
  animation = false;
  /**
   * Defines a callback function which returns custom data passed to the Popover templates.
   * It exposes the current anchor element as an argument. [See example](slug:templates_popover#toc-passing-data-to-templates)
   */
  set templateData(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`${ERRORS.templateData} ${JSON.stringify(fn)}.`);
    }
    this._templateData = fn;
  }
  get templateData() {
    return this._templateData;
  }
  /**
   * @hidden
   * Determines the visibility of the Popover.
   */
  visible = false;
  /**
   * @hidden
   */
  get isHidden() {
    return !this.visible;
  }
  /**
   * @hidden
   */
  get hasAttributeHidden() {
    return !this.visible;
  }
  /**
   * Fires before the Popover is about to be shown ([see example]({% slug events_popover %})).
   * The event is preventable. If canceled, the Popover will not be displayed. [See example]({% slug events_popover %})
   */
  show = new EventEmitter();
  /**
   * Fires after the Popover has been shown and the animation has ended. [See example]({% slug events_popover %})
   */
  shown = new EventEmitter();
  /**
   * Fires when the Popover is about to be hidden ([see example]({% slug events_popover %})).
   * The event is preventable. If canceled, the Popover will remain visible.
   */
  hide = new EventEmitter();
  /**
   * Fires after the Popover has been hidden and the animation has ended. [See example]({% slug events_popover %})
   */
  hidden = new EventEmitter();
  /**
   * @hidden
   */
  closeOnKeyDown = new EventEmitter();
  /**
   * @hidden
   */
  popoverWrapper;
  /**
   * @hidden
   */
  titleTemplateWrapper;
  /**
   * @hidden
   */
  bodyTemplateWrapper;
  /**
   * @hidden
   */
  titleTemplate;
  /**
   * @hidden
   */
  bodyTemplate;
  /**
   * @hidden
   */
  actionsTemplate;
  /**
   * @hidden
   */
  contextData;
  /**
   * @hidden
   */
  _width = "auto";
  /**
   * @hidden
   */
  _height = "auto";
  /**
   * @hidden
   */
  popoverId = "";
  _offset = 6;
  subs = new Subscription();
  constructor(localization, renderer, element, zone) {
    this.localization = localization;
    this.renderer = renderer;
    this.element = element;
    this.zone = zone;
    validatePackage(packageMetadata2);
  }
  ngOnInit() {
    this.popoverId = getId("k-popover");
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
    this.subs.add(this.renderer.listen(this.element.nativeElement, "keydown", (event2) => this.onKeyDown(event2)));
  }
  ngAfterViewInit() {
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      if (this.visible) {
        const wrapper = this.popoverWrapper.nativeElement;
        const focusablePopoverChildren = getAllFocusableChildren(wrapper);
        if (focusablePopoverChildren.length > 0) {
          focusablePopoverChildren[0].focus();
        }
        this.setAriaAttributes(wrapper, focusablePopoverChildren);
      }
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  getCalloutPosition() {
    switch (this.position) {
      case "top":
        return {
          "k-callout-s": true
        };
      case "bottom":
        return {
          "k-callout-n": true
        };
      case "left":
        return {
          "k-callout-e": true
        };
      case "right":
        return {
          "k-callout-w": true
        };
      default:
        return {
          "k-callout-s": true
        };
    }
  }
  /**
   * @hidden
   */
  onKeyDown(event2) {
    const keyCode = event2.keyCode;
    const target = event2.target;
    if (keyCode === Keys.Tab) {
      this.keepFocusWithinComponent(target, event2);
    }
    if (keyCode === Keys.Escape) {
      this.closeOnKeyDown.emit();
    }
  }
  _templateData = () => null;
  keepFocusWithinComponent(target, event2) {
    const wrapper = this.popoverWrapper.nativeElement;
    const [firstFocusable, lastFocusable] = getFirstAndLastFocusable(wrapper);
    const tabAfterLastFocusable = !event2.shiftKey && target === lastFocusable;
    const shiftTabAfterFirstFocusable = event2.shiftKey && target === firstFocusable;
    if (tabAfterLastFocusable) {
      event2.preventDefault();
      firstFocusable.focus();
    }
    if (shiftTabAfterFirstFocusable) {
      event2.preventDefault();
      lastFocusable.focus();
    }
  }
  setAriaAttributes(wrapper, focusablePopoverChildren) {
    if (this.titleTemplate) {
      const titleRef = this.titleTemplateWrapper.nativeElement;
      const focusableHeaderChildren = getAllFocusableChildren(titleRef).length > 0;
      if (focusableHeaderChildren) {
        const headerId = getId("k-popover-header", "popoverTitle");
        this.renderer.setAttribute(titleRef, "id", headerId);
        this.renderer.setAttribute(wrapper, "aria-labelledby", headerId);
      }
    }
    if (this.bodyTemplate) {
      const bodyRef = this.bodyTemplateWrapper.nativeElement;
      const focusableBodyChildren = getAllFocusableChildren(bodyRef).length > 0;
      if (focusableBodyChildren) {
        const bodyId = getId("k-popover-body", "popoverBody");
        this.renderer.setAttribute(bodyRef, "id", bodyId);
        this.renderer.setAttribute(wrapper, "aria-describedby", bodyId);
      }
    }
    this.renderer.setAttribute(wrapper, "id", this.popoverId);
    this.renderer.setAttribute(wrapper, "role", focusablePopoverChildren.length > 0 ? "dialog" : "tooltip");
  }
  static ɵfac = function PopoverComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PopoverComponent,
    selectors: [["kendo-popover"]],
    contentQueries: function PopoverComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PopoverTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PopoverBodyTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PopoverActionsTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.bodyTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionsTemplate = _t.first);
      }
    },
    viewQuery: function PopoverComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c02, 5);
        ɵɵviewQuery(_c110, 5);
        ɵɵviewQuery(_c210, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popoverWrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleTemplateWrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.bodyTemplateWrapper = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function PopoverComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction)("aria-hidden", ctx.hasAttributeHidden);
        ɵɵstyleProp("width", ctx._width)("height", ctx._height);
        ɵɵclassProp("k-hidden", ctx.isHidden);
      }
    },
    inputs: {
      position: "position",
      offset: "offset",
      width: "width",
      height: "height",
      title: "title",
      subtitle: "subtitle",
      body: "body",
      callout: "callout",
      animation: "animation",
      templateData: "templateData"
    },
    outputs: {
      show: "show",
      shown: "shown",
      hide: "hide",
      hidden: "hidden",
      closeOnKeyDown: "closeOnKeyDown"
    },
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.popover"
    }])],
    decls: 1,
    vars: 1,
    consts: [["popoverWrapper", ""], ["noCallout", ""], ["titleTemplateWrapper", ""], ["bodyTemplateWrapper", ""], ["class", "k-popover k-popup", 3, "ngStyle", 4, "ngIf"], [1, "k-popover", "k-popup", 3, "ngStyle"], ["class", "k-popover-callout", 3, "ngClass", 4, "ngIf"], ["class", "k-popover-inner", 4, "ngIf", "ngIfElse"], [1, "k-popover-callout", 3, "ngClass"], [1, "k-popover-inner"], [4, "ngTemplateOutlet"], ["class", "k-popover-header", 4, "ngIf"], ["class", "k-popover-body", 4, "ngIf"], ["class", "k-popover-actions k-actions k-actions-stretched k-actions-horizontal", 4, "ngIf"], [1, "k-popover-header"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-popover-body"], [1, "k-popover-actions", "k-actions", "k-actions-stretched", "k-actions-horizontal"]],
    template: function PopoverComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PopoverComponent_div_0_Template, 6, 7, "div", 4);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.visible);
      }
    },
    dependencies: [NgIf, NgStyle, NgClass, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverComponent, [{
    type: Component,
    args: [{
      selector: "kendo-popover",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.popover"
      }],
      template: `
    <div #popoverWrapper *ngIf="visible" class="k-popover k-popup" [ngStyle]="{'width': width, 'height': height}">
        <div class="k-popover-callout" [ngClass]="getCalloutPosition()" *ngIf="callout"></div>

        <div class="k-popover-inner" *ngIf="callout; else noCallout">
            <ng-container *ngTemplateOutlet="noCallout"></ng-container>
        </div>

        <ng-template #noCallout>
            <div #titleTemplateWrapper *ngIf="titleTemplate || title" class="k-popover-header">
                <ng-template *ngIf="titleTemplate"
                    [ngTemplateOutlet]="titleTemplate?.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: anchor, data: contextData }">
                </ng-template>
                <ng-container *ngIf="title && !titleTemplate">
                    {{ title }}
                </ng-container>
            </div>

            <div #bodyTemplateWrapper *ngIf="bodyTemplate || body" class="k-popover-body">
                <ng-template *ngIf="bodyTemplate"
                    [ngTemplateOutlet]="bodyTemplate?.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: anchor, data: contextData }">
                </ng-template>
                <ng-container *ngIf="body && !bodyTemplate">
                    {{ body }}
                </ng-container>
            </div>

            <div *ngIf="actionsTemplate" class="k-popover-actions k-actions k-actions-stretched k-actions-horizontal">
                <ng-template *ngIf="actionsTemplate"
                    [ngTemplateOutlet]="actionsTemplate?.templateRef"
                    [ngTemplateOutletContext]="{ $implicit: anchor, data: contextData }">
                </ng-template>
            </div>
        </ng-template>
    </div>
    `,
      standalone: true,
      imports: [NgIf, NgStyle, NgClass, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    position: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    body: [{
      type: Input
    }],
    callout: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    templateData: [{
      type: Input
    }],
    isHidden: [{
      type: HostBinding,
      args: ["class.k-hidden"]
    }],
    hasAttributeHidden: [{
      type: HostBinding,
      args: ["attr.aria-hidden"]
    }],
    show: [{
      type: Output
    }],
    shown: [{
      type: Output
    }],
    hide: [{
      type: Output
    }],
    hidden: [{
      type: Output
    }],
    closeOnKeyDown: [{
      type: Output
    }],
    popoverWrapper: [{
      type: ViewChild,
      args: ["popoverWrapper"]
    }],
    titleTemplateWrapper: [{
      type: ViewChild,
      args: ["titleTemplateWrapper"]
    }],
    bodyTemplateWrapper: [{
      type: ViewChild,
      args: ["bodyTemplateWrapper"]
    }],
    titleTemplate: [{
      type: ContentChild,
      args: [PopoverTitleTemplateDirective, {
        static: false
      }]
    }],
    bodyTemplate: [{
      type: ContentChild,
      args: [PopoverBodyTemplateDirective, {
        static: false
      }]
    }],
    actionsTemplate: [{
      type: ContentChild,
      args: [PopoverActionsTemplateDirective, {
        static: false
      }]
    }],
    _width: [{
      type: HostBinding,
      args: ["style.width"]
    }],
    _height: [{
      type: HostBinding,
      args: ["style.height"]
    }]
  });
})();
var validShowOptions = ["hover", "click", "none", "focus"];
var PopoverDirectivesBase = class _PopoverDirectivesBase {
  ngZone;
  popupService;
  renderer;
  /**
   * Specifies the popover instance that will be rendered.
   * Accepts a [`PopoverComponent`]({% slug api_tooltip_popovercomponent %}) instance or
   * a [`PopoverFn`]({% slug api_tooltip_popoverfn %}) callback which returns a [`PopoverComponent`]({% slug api_tooltip_popovercomponent %}) instance
   * depending on the current anchor element.
   *
   * [See example](slug:templates_popover#toc-passing-data-to-templates)
   */
  set popover(value2) {
    if (value2 instanceof PopoverComponent || typeof value2 === `function`) {
      this._popover = value2;
    } else {
      if (isDevMode) {
        throw new Error(ERRORS.popover);
      }
    }
  }
  get popover() {
    return this._popover;
  }
  /**
   * The event on which the Popover will be shown
   *
   * The supported values are:
   * - `click` (default) &mdash;The Popover will be shown when its `anchor` element is clicked.
   * - `hover`&mdash;The Popover will be shown when its `anchor` element is hovered.
   * - `focus`&mdash;The Popover will be shown when its `anchor` element is focused.
   * - `none`&mdash;The Popover will not be shown on user interaction. It could be rendered via the Popover API methods.
   */
  set showOn(value2) {
    if (isDevMode && !containsItem(validShowOptions, value2)) {
      throw new Error(ERRORS.showOn);
    }
    this._showOn = value2;
  }
  get showOn() {
    return this._showOn;
  }
  /**
   * @hidden
   */
  anchor = null;
  popupRef;
  disposeHoverOverListener;
  disposeHoverOutListener;
  disposeClickListener;
  disposePopupHoverOutListener;
  disposePopupHoverInListener;
  disposePopupFocusOutListener;
  subs = new Subscription();
  _popoverService;
  _hideSub;
  _focusInsideSub;
  _popover;
  _showOn = "click";
  _popupOpenSub;
  _popupCloseSub;
  _popupSubs;
  constructor(ngZone, popupService, renderer) {
    this.ngZone = ngZone;
    this.popupService = popupService;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.manageEvents();
  }
  ngOnDestroy() {
    this.closePopup();
    this.subs.unsubscribe();
    this._popupSubs && this._popupSubs.unsubscribe();
    if (this.disposeHoverOverListener) {
      this.disposeHoverOverListener();
    }
    if (this.disposeHoverOutListener) {
      this.disposeHoverOutListener();
    }
    if (this.disposeClickListener) {
      this.disposeClickListener();
    }
    if (this._focusInsideSub) {
      this._focusInsideSub.unsubscribe();
    }
    if (this._hideSub) {
      this._hideSub.unsubscribe();
    }
    if (this._popupOpenSub) {
      this._popupOpenSub.unsubscribe();
    }
    if (this._popupCloseSub) {
      this._popupCloseSub.unsubscribe();
    }
  }
  /**
   * Hides the Popover ([See example]({% slug programmaticcontrol_popover %})).
   */
  hide() {
    this.closePopup();
  }
  /**
   * @hidden
   */
  closePopup() {
    if (this.popupRef) {
      if (this.anchor) {
        this.renderer.removeAttribute(this.anchor, "aria-describedby");
      }
      this.popupRef.close();
      this.popupRef = null;
      if (this.disposePopupHoverOutListener) {
        this.disposePopupHoverOutListener();
      }
      if (this.disposePopupHoverInListener) {
        this.disposePopupHoverInListener();
      }
      if (this.disposePopupFocusOutListener) {
        this.disposePopupFocusOutListener();
      }
      this._popupSubs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  openPopup(anchor2) {
    this.anchor = anchor2 instanceof ElementRef ? anchor2.nativeElement : anchor2;
    const popoverComp = this.popover instanceof PopoverComponent ? this.popover : this.popover(this.anchor);
    const alignSettings = align(popoverComp.position, popoverComp.offset);
    const anchorAlign = alignSettings.anchorAlign;
    const popupAlign = alignSettings.popupAlign;
    const popupMargin = alignSettings.popupMargin;
    const _animation = popoverComp.animation;
    this.popupRef = this.popupService.open({
      anchor: {
        nativeElement: this.anchor
      },
      animate: _animation,
      content: PopoverComponent,
      popupAlign,
      anchorAlign,
      margin: popupMargin,
      collision: {
        horizontal: "fit",
        vertical: "fit"
      }
    });
    const popupInstance = this.popupRef.content.instance;
    this._popupSubs = new Subscription();
    if (anchor2) {
      this._popupSubs.add(this.renderer.listen(this.anchor, "keydown", (event2) => this.onKeyDown(event2)));
      this.renderer.setAttribute(this.anchor, "aria-describedby", popupInstance.popoverId);
    }
    this._popupSubs.add(popupInstance.closeOnKeyDown.subscribe(() => {
      this.anchor.focus();
      this.hide();
    }));
    this.applySettings(this.popupRef.content, popoverComp);
    this.monitorPopup();
    this.initializeCompletionEvents(popoverComp, this.anchor);
  }
  /**
   * @hidden
   */
  isPrevented(anchorElement, show) {
    const popoverComp = this.popover instanceof PopoverComponent ? this.popover : this.popover(anchorElement);
    let eventArgs;
    eventArgs = this.initializeEvents(popoverComp, eventArgs, show, anchorElement);
    return eventArgs.isDefaultPrevented();
  }
  /**
   * @hidden
   */
  monitorPopup() {
    if (this.showOn === "hover") {
      this.ngZone.runOutsideAngular(() => {
        const popup = this.popupRef.popupElement;
        this.disposePopupHoverInListener = this.renderer.listen(popup, "mouseenter", (_) => {
          this.ngZone.run((_2) => this._popoverService.emitPopoverState(true));
        });
        this.disposePopupHoverOutListener = this.renderer.listen(popup, "mouseleave", (_) => {
          this.ngZone.run((_2) => this._popoverService.emitPopoverState(false));
        });
      });
    }
    if (this.showOn === "focus") {
      this.ngZone.runOutsideAngular(() => {
        const popup = this.popupRef.popupElement;
        this.disposePopupFocusOutListener = this.renderer.listen(popup, "focusout", (e) => {
          const isInsidePopover = closest(e.relatedTarget, (node) => node.classList && node.classList.contains("k-popover"));
          if (!isInsidePopover) {
            this.ngZone.run((_) => this._popoverService.emitFocusInsidePopover(false));
          }
        });
      });
    }
  }
  applySettings(contentComponent, popover) {
    const content2 = contentComponent.instance;
    content2.visible = true;
    content2.anchor = this.anchor;
    content2.position = popover.position;
    content2.offset = popover.offset;
    content2.width = popover.width;
    content2.height = popover.height;
    content2.title = popover.title;
    content2.body = popover.body;
    content2.callout = popover.callout;
    content2.animation = popover.animation;
    content2.contextData = popover.templateData(this.anchor);
    content2.titleTemplate = popover.titleTemplate;
    content2.bodyTemplate = popover.bodyTemplate;
    content2.actionsTemplate = popover.actionsTemplate;
    this.popupRef.content.changeDetectorRef.detectChanges();
  }
  manageEvents() {
    this.ngZone.runOutsideAngular(() => {
      switch (this.showOn) {
        case "hover":
          this.subscribeToShowEvents([{
            name: "mouseenter",
            handler: this.mouseenterHandler
          }, {
            name: "mouseleave",
            handler: this.mouseleaveHandler
          }]);
          break;
        case "focus":
          this.subscribeToShowEvents([{
            name: "focus",
            handler: this.focusHandler
          }, {
            name: "blur",
            handler: this.blurHandler
          }]);
          break;
        case "click":
          this.subscribeClick();
          break;
        default:
          break;
      }
    });
  }
  /**
   * @hidden
   */
  initializeEvents(popoverComp, eventArgs, show, anchorElement) {
    if (show) {
      eventArgs = new PopoverShowEvent(anchorElement);
      if (this.shouldEmitEvent(!!this.popupRef, "show", popoverComp)) {
        this.ngZone.run(() => popoverComp.show.emit(eventArgs));
      }
    } else {
      eventArgs = new PopoverHideEvent(anchorElement, this.popupRef);
      if (this.shouldEmitEvent(!!this.popupRef, "hide", popoverComp)) {
        this.ngZone.run(() => popoverComp.hide.emit(eventArgs));
      }
    }
    return eventArgs;
  }
  onKeyDown(event2) {
    const keyCode = event2.keyCode;
    if (keyCode === Keys.Escape) {
      this.hide();
    }
  }
  initializeCompletionEvents(popoverComp, _anchor) {
    if (this.shouldEmitCompletionEvents("shown", popoverComp)) {
      this.popupRef.popupOpen.subscribe(() => {
        const eventArgs = new PopoverShownEvent(_anchor, this.popupRef);
        popoverComp.shown.emit(eventArgs);
      });
    }
    if (this.shouldEmitCompletionEvents("hidden", popoverComp)) {
      this.popupRef.popupClose.subscribe(() => {
        this.ngZone.run((_) => {
          const eventArgs = new PopoverHiddenEvent(_anchor);
          popoverComp.hidden.emit(eventArgs);
        });
      });
    }
  }
  shouldEmitEvent(hasPopup, event2, popoverComp) {
    if (event2 === "show" && !hasPopup && hasObservers(popoverComp[event2]) || event2 === "hide" && hasPopup && hasObservers(popoverComp[event2])) {
      return true;
    }
    return false;
  }
  shouldEmitCompletionEvents(event2, popoverComp) {
    if (hasObservers(popoverComp[event2]) && !this._popupOpenSub || hasObservers(popoverComp[event2]) && !this._popupCloseSub) {
      return true;
    }
    return false;
  }
  static ɵfac = function PopoverDirectivesBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverDirectivesBase)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PopoverDirectivesBase,
    inputs: {
      popover: "popover",
      showOn: "showOn"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverDirectivesBase, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: PopupService
    }, {
      type: Renderer2
    }];
  }, {
    popover: [{
      type: Input
    }],
    showOn: [{
      type: Input
    }]
  });
})();
var PopoverService = class _PopoverService {
  ngZone;
  _pointerOverPopup = new BehaviorSubject(null);
  _pointerOverAnchor = new BehaviorSubject(null);
  _focusInsidePopover = new BehaviorSubject(null);
  _hidePopover = new Subject();
  _isOrigin;
  originAnchor;
  currentAnchor;
  subs = new Subscription();
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.monitor();
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  get isPopoverHovered() {
    return this._pointerOverPopup.asObservable();
  }
  emitPopoverState(isHovered) {
    this.ngZone.run((_) => this._pointerOverPopup.next(isHovered));
  }
  get isAnchorHovered() {
    return this._pointerOverAnchor.asObservable();
  }
  emitAnchorState(isHovered, anchor2) {
    this._isOrigin = this.originAnchor === anchor2;
    this.currentAnchor = anchor2;
    if (isHovered) {
      this.originAnchor = anchor2;
    }
    this.ngZone.run((_) => this._pointerOverAnchor.next(isHovered));
  }
  get isFocusInsidePopover() {
    return this._focusInsidePopover.asObservable();
  }
  emitFocusInsidePopover(isFocused) {
    this.ngZone.run((_) => this._focusInsidePopover.next(isFocused));
    this._focusInsidePopover.next(null);
  }
  get hidePopover() {
    return this._hidePopover.asObservable();
  }
  monitor() {
    this.subs.add(combineLatest(this.isPopoverHovered, this.isAnchorHovered).pipe(
      // `auditTime` is used because the `mouseleave` event is emitted before `mouseenter`
      // i.e. there is a millisecond in which the pointer leaves the first target (e.g. anchor) and hasn't reached the second one (e.g. popup)
      // resulting in both observables emitting `false`
      auditTime(20)
    ).subscribe((val) => {
      const [isPopoverHovered, isAnchorHovered] = val;
      this._hidePopover.next([isPopoverHovered, isAnchorHovered, this._isOrigin, this.currentAnchor]);
    }));
  }
  static ɵfac = function PopoverService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PopoverService,
    factory: _PopoverService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var PopoverAnchorDirective = class _PopoverAnchorDirective extends PopoverDirectivesBase {
  hostEl;
  ngZone;
  popupService;
  renderer;
  popoverService;
  constructor(hostEl, ngZone, popupService, renderer, popoverService) {
    super(ngZone, popupService, renderer);
    this.hostEl = hostEl;
    this.ngZone = ngZone;
    this.popupService = popupService;
    this.renderer = renderer;
    this.popoverService = popoverService;
    this._popoverService = this.popoverService;
  }
  ngOnChanges(changes) {
    if (changes["showOn"] && !changes["showOn"].isFirstChange()) {
      this.subs.unsubscribe();
      if (this.disposeClickListener) {
        this.disposeClickListener();
      }
      this.subs = new Subscription();
      this.manageEvents();
    }
  }
  /**
   * Shows the Popover. [See example]({% slug programmaticcontrol_popover %})
   */
  show() {
    if (this.popupRef) {
      return;
    }
    this.ngZone.run(() => {
      this.openPopup(this.hostEl);
    });
    this.popupRef.popupAnchorViewportLeave.pipe(take(1)).subscribe(() => this.hide());
  }
  /**
   * Toggles the visibility of the Popover. [See example]({% slug programmaticcontrol_popover %})
   */
  toggle() {
    if (this.popupRef) {
      this.hide();
    } else {
      this.show();
    }
  }
  subscribeToShowEvents(arr) {
    const hostEl = this.hostEl.nativeElement;
    this.subs.add(this.renderer.listen(hostEl, arr[0].name, () => {
      this.popoverService.emitAnchorState(true, hostEl);
      arr[0].handler();
    }));
    this.subs.add(this.renderer.listen(hostEl, arr[1].name, (e) => {
      this.popoverService.emitAnchorState(false, null);
      arr[1].handler({
        domEvent: e
      });
    }));
  }
  subscribeClick() {
    if (this.disposeClickListener) {
      this.disposeClickListener();
    }
    this.disposeClickListener = this.renderer.listen(document, "click", (e) => {
      this.onClick(e);
    });
  }
  mouseenterHandler = () => {
    this.controlVisibility(this.hostEl.nativeElement, true);
  };
  mouseleaveHandler = () => {
    if (this.isPrevented(this.hostEl.nativeElement, false)) {
      return;
    }
    if (!this._hideSub) {
      this._hideSub = this.popoverService.hidePopover.subscribe((val) => {
        const [isPopoverHovered, isAnchorHovered] = val;
        if (!isPopoverHovered && !isAnchorHovered) {
          this.hide();
        }
      });
    }
  };
  focusHandler = () => {
    this.controlVisibility(this.hostEl.nativeElement, true);
  };
  blurHandler = (args) => {
    const event2 = args.domEvent;
    if (this.isPrevented(this.hostEl.nativeElement, false)) {
      return;
    }
    const isFocusInside = !!closest(event2.relatedTarget, (node) => node.classList && node.classList.contains("k-popover"));
    if (!isFocusInside) {
      this.hide();
    }
    if (!this._focusInsideSub) {
      this._focusInsideSub = this.popoverService.isFocusInsidePopover.pipe(filter((v) => v !== null)).subscribe((val) => {
        if (!val) {
          this.hide();
        }
      });
    }
  };
  /**
   * @hidden
   */
  onClick(event2) {
    const isInsidePopup = !!closest(event2.target, (node) => node.classList && node.classList.contains("k-popup"));
    const isAnchor = !!closest(event2.target, (node) => node === this.hostEl.nativeElement);
    if (isInsidePopup || this.popupRef && isAnchor) {
      return;
    }
    if (isAnchor) {
      this.controlVisibility(this.hostEl.nativeElement, true);
    } else {
      this.controlVisibility(this.hostEl.nativeElement, false);
    }
  }
  controlVisibility(anchor2, show) {
    if (this.isPrevented(anchor2, show)) {
      return;
    }
    if (show) {
      this.show();
    } else {
      this.hide();
    }
  }
  static ɵfac = function PopoverAnchorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverAnchorDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PopoverService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PopoverAnchorDirective,
    selectors: [["", "kendoPopoverAnchor", ""]],
    exportAs: ["kendoPopoverAnchor"],
    features: [ɵɵProvidersFeature([PopoverService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverAnchorDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPopoverAnchor]",
      exportAs: "kendoPopoverAnchor",
      providers: [PopoverService],
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: PopupService
    }, {
      type: Renderer2
    }, {
      type: PopoverService
    }];
  }, null);
})();
var PopoverContainerDirective = class _PopoverContainerDirective extends PopoverDirectivesBase {
  wrapperEl;
  ngZone;
  popupService;
  renderer;
  popoverService;
  /**
   * Specifies a selector for the elements that should display a popover.
   *
   * The possible values include any valid query selector.
   * [See example](slug:configuration_popover#toc-popover-container)
   */
  filter;
  constructor(wrapperEl, ngZone, popupService, renderer, popoverService) {
    super(ngZone, popupService, renderer);
    this.wrapperEl = wrapperEl;
    this.ngZone = ngZone;
    this.popupService = popupService;
    this.renderer = renderer;
    this.popoverService = popoverService;
    this._popoverService = this.popoverService;
  }
  /**
   * Shows the Popover.
   *
   * @param anchor&mdash;Specifies the element that will be used as an anchor. The Popover opens relative to that element. [See example]({% slug programmaticcontrol_popover %})
   */
  show(anchor2) {
    if (this.popupRef) {
      return;
    }
    this.ngZone.run(() => {
      this.openPopup(anchor2);
    });
    this.popupRef.popupAnchorViewportLeave.pipe(take(1)).subscribe(() => this.hide());
  }
  /**
   * Toggles the visibility of the Popover. [See example]({% slug programmaticcontrol_popover %})
   *
   * @param anchor&mdash;Specifies the element that will be used as an anchor. The Popover opens relative to that element.
   */
  toggle(anchor2) {
    const previousAnchor = this.popupRef && this.popupRef.content.instance.anchor;
    if (this.popupRef) {
      this.hide();
      if (previousAnchor !== anchor2) {
        this.show(anchor2);
      }
    } else {
      this.show(anchor2);
    }
  }
  subscribeClick() {
    if (this.disposeClickListener) {
      this.disposeClickListener();
    }
    this.disposeClickListener = this.renderer.listen(document, "click", (e) => {
      const filterElement = closestBySelector(e.target, this.filter);
      this.clickHandler(filterElement, e);
    });
  }
  mouseenterHandler = (anchor2) => {
    this.controlVisibility(anchor2, true);
  };
  mouseleaveHandler = (args) => {
    const anchor2 = args.anchor;
    if (this.isPrevented(anchor2, false)) {
      return;
    }
    if (!this._hideSub) {
      this._hideSub = this.popoverService.hidePopover.subscribe((val) => {
        const [isPopoverHovered, , isOriginAnchor, currentAnchor] = val;
        if (!isPopoverHovered && !isOriginAnchor) {
          this.hide();
          if (!isOriginAnchor && currentAnchor) {
            this.show(currentAnchor);
          }
        }
      });
    }
  };
  focusHandler = (anchor2) => {
    this.controlVisibility(anchor2, true);
  };
  blurHandler = (args) => {
    const anchor2 = args.anchor;
    const event2 = args.domEvent;
    if (this.isPrevented(anchor2, false)) {
      return;
    }
    const isFocusInside = !!closest(event2.relatedTarget, (node) => node.classList && node.classList.contains("k-popover"));
    if (!isFocusInside) {
      this.hide();
    }
    if (!this._focusInsideSub) {
      this._focusInsideSub = this.popoverService.isFocusInsidePopover.pipe(filter((v) => v !== null)).subscribe((val) => {
        if (!val && !isFocusInside) {
          this.hide();
        }
      });
    }
  };
  subscribeToShowEvents(arr) {
    const filteredElements = Array.from(document.querySelectorAll(this.filter));
    filteredElements.forEach((el) => {
      this.subs.add(this.renderer.listen(el, arr[0].name, () => {
        this.popoverService.emitAnchorState(true, el);
        arr[0].handler(el);
      }));
      this.subs.add(this.renderer.listen(el, arr[1].name, (e) => {
        this.popoverService.emitAnchorState(false, null);
        arr[1].handler({
          anchor: el,
          domEvent: e
        });
      }));
    });
  }
  clickHandler(anchor2, event2) {
    const isInsidePopup = !!closest(event2.target, (node) => node.classList && node.classList.contains("k-popup"));
    const popupRefAnchor = this.popupRef && this.popupRef.content.instance.anchor;
    const isOriginAnchor = !!closest(event2.target, (node) => node === (popupRefAnchor ? popupRefAnchor : anchor2));
    if (this.showOn !== "click" || isInsidePopup || this.popupRef && isOriginAnchor) {
      return;
    }
    if (!anchor2 && this.popupRef) {
      this.controlVisibility(anchor2, false);
      return;
    }
    if (isOriginAnchor) {
      this.controlVisibility(anchor2, true);
    } else if (this.popupRef) {
      this.controlVisibility(anchor2, false);
      this.controlVisibility(anchor2, true);
    }
  }
  controlVisibility(anchor2, show) {
    if (this.isPrevented(anchor2, show)) {
      return;
    }
    if (show) {
      this.show(anchor2);
    } else {
      this.hide();
    }
  }
  static ɵfac = function PopoverContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverContainerDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PopoverService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PopoverContainerDirective,
    selectors: [["", "kendoPopoverContainer", ""]],
    inputs: {
      filter: "filter"
    },
    exportAs: ["kendoPopoverContainer"],
    features: [ɵɵProvidersFeature([PopoverService]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPopoverContainer]",
      exportAs: "kendoPopoverContainer",
      providers: [PopoverService],
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: PopupService
    }, {
      type: Renderer2
    }, {
      type: PopoverService
    }];
  }, {
    filter: [{
      type: Input
    }]
  });
})();
var TooltipContentComponent = class _TooltipContentComponent {
  content;
  localizationService;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  direction;
  close = new EventEmitter();
  get cssClasses() {
    return "k-tooltip";
  }
  hostRole = "tooltip";
  get hostId() {
    return this.tooltipId;
  }
  get className() {
    return this.closable;
  }
  get cssPosition() {
    return "relative";
  }
  tooltipWidth = null;
  tooltipHeight = null;
  titleTemplate;
  anchor;
  closable;
  templateRef;
  templateString;
  closeTitle;
  callout = true;
  position;
  /**
   * @hidden
   */
  tooltipId;
  dynamicRTLSubscription;
  constructor(content2, localizationService) {
    this.content = content2;
    this.localizationService = localizationService;
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.tooltipId = getId("tooltip");
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => this.direction = rtl ? "rtl" : "ltr");
  }
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
  }
  get closeButtonTitle() {
    return this.closeTitle || this.localizationService.get("closeTitle");
  }
  calloutPositionClass() {
    return {
      "top": "k-callout-s",
      "left": "k-callout-e",
      "bottom": "k-callout-n",
      "right": "k-callout-w"
    }[this.position];
  }
  onCloseClick(event2) {
    event2.preventDefault();
    this.close.emit();
  }
  updateCalloutPosition(position, isFlip) {
    if (!this.callout) {
      return;
    }
    const callout = this.content.nativeElement.querySelector(".k-callout");
    const isVertical = position === "top" || position === "bottom";
    const size = isVertical ? "width" : "height";
    const dir = isVertical ? "left" : "top";
    const offsetProperty = isVertical ? "marginLeft" : "marginTop";
    const calloutSize = callout.getBoundingClientRect()[size];
    const anchorCenter = getCenterOffset(this.anchor.nativeElement, dir, size);
    const contentCenter = getCenterOffset(this.content.nativeElement, dir, size);
    const diff2 = Math.abs(contentCenter - anchorCenter);
    if (diff2 > 1 || diff2 === 0 || Math.round(diff2) === 0) {
      const newMargin = contentCenter - anchorCenter + calloutSize / 2;
      callout.style[offsetProperty] = `${-newMargin}px`;
    }
    const calloutStyles = this.calloutStyles(position, calloutSize, isFlip);
    Object.keys(calloutStyles).forEach((style) => {
      callout.style[style] = calloutStyles[style];
    });
  }
  calloutStyles = (position, calloutSize, isFlip) => {
    const styles = {};
    const isVertical = position === "top" || position === "bottom";
    const flipDeg = "180deg";
    const zeroDeg = "0deg";
    if (!isFlip) {
      styles.transform = isVertical ? `rotateX(${zeroDeg})` : `rotateY(${zeroDeg})`;
      return styles;
    }
    if (position === "top") {
      styles.bottom = "unset";
    } else if (position === "bottom") {
      styles.top = "unset";
    } else if (position === "left") {
      styles.right = "unset";
    } else if (position === "right") {
      styles.left = "unset";
    }
    styles[position] = `${-calloutSize}px`;
    styles.transform = isVertical ? `rotateX(${flipDeg})` : `rotateY(${flipDeg})`;
    return styles;
  };
  static ɵfac = function TooltipContentComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TooltipContentComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TooltipContentComponent,
    selectors: [["kendo-tooltip"]],
    hostVars: 13,
    hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction)("role", ctx.hostRole)("id", ctx.hostId);
        ɵɵclassMap(ctx.cssClasses);
        ɵɵstyleProp("position", ctx.cssPosition)("width", ctx.tooltipWidth, "px")("height", ctx.tooltipHeight, "px");
        ɵɵclassProp("k-tooltip-closable", ctx.className);
      }
    },
    inputs: {
      tooltipWidth: "tooltipWidth",
      tooltipHeight: "tooltipHeight",
      titleTemplate: "titleTemplate",
      anchor: "anchor",
      closable: "closable",
      templateRef: "templateRef",
      templateString: "templateString"
    },
    outputs: {
      close: "close"
    },
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.tooltip"
    }])],
    decls: 7,
    vars: 10,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLTIP_FESM2022_PROGRESS_KENDO_ANGULAR_TOOLTIP_MJS_0 = goog.getMsg("Close");
        i18n_0 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TOOLTIP_FESM2022_PROGRESS_KENDO_ANGULAR_TOOLTIP_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.tooltip.closeTitle|The title of the close button:Close`;
      }
      return [["kendoTooltipLocalizedMessages", "", "closeTitle", i18n_0], [1, "k-tooltip-content"], ["class", "k-tooltip-title", 4, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngIf"], ["class", "k-tooltip-button", 3, "click", 4, "ngIf"], ["class", "k-callout", 3, "ngClass", 4, "ngIf"], [1, "k-tooltip-title"], [1, "k-tooltip-button", 3, "click"], ["href", "#", 1, "k-icon"], ["name", "x", 3, "svgIcon"], [1, "k-callout", 3, "ngClass"]];
    },
    template: function TooltipContentComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵelementStart(1, "div", 1);
        ɵɵtemplate(2, TooltipContentComponent_div_2_Template, 2, 6, "div", 2)(3, TooltipContentComponent_ng_template_3_Template, 0, 0, "ng-template", 3)(4, TooltipContentComponent_ng_template_4_Template, 1, 1, "ng-template", 4);
        ɵɵelementEnd();
        ɵɵtemplate(5, TooltipContentComponent_div_5_Template, 3, 3, "div", 5)(6, TooltipContentComponent_div_6_Template, 1, 1, "div", 6);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.titleTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.templateRef)("ngTemplateOutlet", ctx.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(7, _c52, ctx.anchor, ctx.anchor));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.templateString);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.closable);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.callout);
      }
    },
    dependencies: [LocalizedMessagesDirective2, NgIf, NgTemplateOutlet, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipContentComponent, [{
    type: Component,
    args: [{
      selector: "kendo-tooltip",
      template: `
        <ng-container kendoTooltipLocalizedMessages
            i18n-closeTitle="kendo.tooltip.closeTitle|The title of the close button"
            closeTitle="Close"
        >
        </ng-container>

        <div class="k-tooltip-content">
            <div class="k-tooltip-title" *ngIf="titleTemplate">
                <ng-template
                    [ngIf]="titleTemplate"
                    [ngTemplateOutlet]="titleTemplate"
                    [ngTemplateOutletContext]="{ $implicit: anchor, anchor: anchor }">
                </ng-template>
            </div>

            <ng-template
                [ngIf]="templateRef"
                [ngTemplateOutlet]="templateRef"
                [ngTemplateOutletContext]="{ $implicit: anchor, anchor: anchor }">
            </ng-template>
            <ng-template
                [ngIf]="templateString">
                {{ templateString }}
            </ng-template>
        </div>

        <div *ngIf="closable" [attr.aria-hidden]="true" class="k-tooltip-button" (click)="onCloseClick($event)">
            <a href="#" [attr.title]="closeButtonTitle" class="k-icon">
                <kendo-icon-wrapper
                    name="x"
                    [svgIcon]="xIcon">
                </kendo-icon-wrapper>
            </a>
        </div>

        <div class="k-callout" *ngIf="callout" [ngClass]="calloutPositionClass()"></div>
    `,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.tooltip"
      }],
      standalone: true,
      imports: [LocalizedMessagesDirective2, NgIf, NgTemplateOutlet, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: LocalizationService
    }];
  }, {
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    close: [{
      type: Output
    }],
    cssClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hostId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    className: [{
      type: HostBinding,
      args: ["class.k-tooltip-closable"]
    }],
    cssPosition: [{
      type: HostBinding,
      args: ["style.position"]
    }],
    tooltipWidth: [{
      type: HostBinding,
      args: ["style.width.px"]
    }, {
      type: Input
    }],
    tooltipHeight: [{
      type: HostBinding,
      args: ["style.height.px"]
    }, {
      type: Input
    }],
    titleTemplate: [{
      type: Input
    }],
    anchor: [{
      type: Input
    }],
    closable: [{
      type: Input
    }],
    templateRef: [{
      type: Input
    }],
    templateString: [{
      type: Input
    }]
  });
})();
var TOOLTIP_SETTINGS = new InjectionToken("kendo-ui-tooltip-settings");
var TooltipSettings = class _TooltipSettings {
  /**
   * Specifies if the Тooltip will display a callout arrow.
   *
   * The possible values are:
   * * `true` (default)
   * * `false`
   */
  callout;
  /**
   * Specifies the title of the close button.
   */
  closeTitle;
  /**
   * Specifies the position of the Tooltip that is
   * relative to the anchor element.
   *
   * The possible values are:
   * * `top` (default)
   * * `bottom`
   * * `left`
   * * `right`
   */
  position;
  /**
   * Specifies when the Тooltip will be rendered.
   *
   * The possible values are:
   * * `hover` (default)
   * * `click`
   * * `none`
   */
  showOn;
  /**
   * Specifies the delay in milliseconds before the Tooltip is shown.
   * * `100` (default) milliseconds.
   */
  showAfter;
  /**
   * @hidden
   */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor() {
  }
  static ɵfac = function TooltipSettings_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TooltipSettings)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TooltipSettings,
    factory: _TooltipSettings.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipSettings, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var TooltipDirective = class _TooltipDirective {
  tooltipWrapper;
  ngZone;
  renderer;
  popupService;
  /**
   * Specifies a selector for elements within a container which will display a tooltip
   * ([see example]({% slug anchorelements_tooltip %})). The possible values include any
   * DOM `selector`. The default value is `[title]`.
   */
  filter = "[title]";
  /**
   * Specifies the position of the Tooltip that is relative to the
   * anchor element ([see example]({% slug positioning_tooltip %})).
   *
   * The possible values are:
   * * `top` (default)
   * * `bottom`
   * * `left`
   * * `right`
   */
  position = "top";
  /**
   * Renders the passed template as a header title of the Tooltip
   * ([see example]({% slug anchorelements_tooltip %})).
   */
  titleTemplate;
  /**
   * Specifies when the Тooltip will be rendered
   * ([see example]({% slug programmaticopening_tooltip %})).
   *
   * The possible values are:
   * * `hover` (default)
   * * `click`
   * * `none`
   */
  showOn;
  /**
   * Specifies the delay in milliseconds before the Tooltip is shown.
   * * `100` (default) milliseconds.
   */
  showAfter = 100;
  /**
   * Specifies if the Тooltip will display a callout arrow.
   *
   * The possible values are:
   * * `true` (default)
   * * `false`
   */
  callout = true;
  /**
   * Specifies if the Тooltip will display a **Close** button
   * ([see example]({% slug closable_tooltip %})).
   *
   * The possible values are:
   * * `true`
   * * `false`
   */
  closable = false;
  /**
   * Specifies the offset in pixels between the Tooltip and the anchor. Defaults to `6` pixels.
   * If the `callout` property is set to `true`, the offset is rendered from the callout arrow.
   * If the `callout` property is set to `false`, the offset is rendered from the content of the Tooltip.
   */
  offset = 6;
  /**
   * Specifies the width of the Тooltip ([see example]({% slug anchorelements_tooltip %})).
   */
  tooltipWidth;
  /**
   * Specifies the height of the Тooltip.
   */
  tooltipHeight;
  /**
   * Specifies a CSS class that will be added to the Tooltip.
   */
  tooltipClass;
  /**
   * @hidden
   * Specifies a CSS class that will be added to the kendo-tooltip element.
   */
  tooltipContentClass;
  /**
   * Provides screen boundary detection when the Тooltip is shown.
   */
  collision;
  /**
   * Specifies the title of the close button.
   */
  closeTitle;
  /**
   * Sets the content of the Tooltip as a template reference
   * ([see example]({% slug templates_tooltip %})).
   */
  set tooltipTemplate(value2) {
    this.template = value2;
  }
  get tooltipTemplate() {
    return this.template;
  }
  popupRef;
  template;
  showTimeout;
  anchor = null;
  mouseOverSubscription;
  mouseOutSubscription;
  mouseClickSubscription;
  anchorTitleSubscription;
  popupPositionChangeSubscription;
  popupMouseOutSubscription;
  keyboardNavigationSubscription = new Subscription();
  closeClickSubscription;
  validPositions = ["top", "bottom", "right", "left"];
  validShowOptions = ["hover", "click", "none"];
  constructor(tooltipWrapper, ngZone, renderer, popupService, settings, legacySettings) {
    this.tooltipWrapper = tooltipWrapper;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.popupService = popupService;
    validatePackage(packageMetadata2);
    Object.assign(this, settings, legacySettings);
    this.ngZone.runOutsideAngular(() => {
      const wrapper = this.tooltipWrapper.nativeElement;
      this.anchorTitleSubscription = fromEvent(wrapper, "mouseover").pipe(filter(() => this.filter !== "")).subscribe((e) => {
        const filterElement = closestBySelector(e.target, this.filter);
        if (filterElement) {
          this.hideElementTitle({
            nativeElement: filterElement
          });
        }
      });
      this.mouseOverSubscription = fromEvent(wrapper, "mouseover").pipe(filter(() => this.filter !== "")).subscribe((e) => this.onMouseOver(e));
      this.mouseOutSubscription = fromEvent(wrapper, "mouseout").subscribe((e) => this.onMouseOut(e));
    });
  }
  /**
   * Shows the Tooltip.
   * @param anchor&mdash; ElementRef|Element.
   * Specifies the element that will be used as an anchor. The Tooltip opens relative to that element.
   */
  show(anchor2) {
    if (this.popupRef) {
      return;
    }
    if (anchor2 instanceof Element) {
      anchor2 = {
        nativeElement: anchor2
      };
    }
    this.anchor = anchor2;
    if (this.showOn === "hover") {
      if (this.popupRef) {
        return;
      }
      clearTimeout(this.showTimeout);
      this.showTimeout = setTimeout(() => this.showContent(this.anchor), this.showAfter);
    } else {
      this.hideElementTitle(this.anchor);
      this.showContent(this.anchor);
    }
  }
  /**
   * Hides the Tooltip.
   */
  hide() {
    clearTimeout(this.showTimeout);
    const anchor2 = this.anchor && this.anchor.nativeElement;
    if (anchor2 && anchor2.getAttribute("data-title")) {
      if (!anchor2.getAttribute("title") && anchor2.hasAttribute("title")) {
        anchor2.setAttribute("title", anchor2.getAttribute("data-title"));
      }
      anchor2.setAttribute("data-title", "");
    }
    if (this.popupMouseOutSubscription) {
      this.popupMouseOutSubscription.unsubscribe();
    }
    if (this.closeClickSubscription) {
      this.closeClickSubscription.unsubscribe();
    }
    this.closePopup();
  }
  /**
   * Toggle visibility of the Tooltip.
   *
   * @param anchor&mdash; ElementRef|Element. Specifies the element that will be used as an anchor.
   * @param show&mdash; Optional. Boolean. Specifies if the Tooltip will be rendered.
   */
  toggle(anchor2, show) {
    const previousAnchor = this.anchor && this.anchor.nativeElement;
    if (anchor2 instanceof Element) {
      anchor2 = {
        nativeElement: anchor2
      };
    }
    if (previousAnchor !== anchor2.nativeElement) {
      this.hide();
    }
    if (previousAnchor === anchor2.nativeElement && this.showOn === "click") {
      this.hide();
    }
    if (typeof show === "undefined") {
      show = !this.popupRef;
    }
    if (show) {
      this.show(anchor2);
    } else {
      this.hide();
    }
  }
  ngOnInit() {
    if (this.showOn === void 0) {
      this.showOn = "hover";
    }
    this.keyboardNavigationSubscription.add(this.renderer.listen(this.tooltipWrapper.nativeElement, "keydown", (event2) => this.onKeyDown(event2)));
    this.verifyProperties();
  }
  ngOnChanges(changes) {
    if (changes.showOn && isDocumentAvailable()) {
      this.subscribeClick();
    }
  }
  ngAfterViewChecked() {
    if (!this.popupRef) {
      return;
    }
    if (this.anchor && !hasParent(this.anchor.nativeElement || this.anchor, this.tooltipWrapper.nativeElement)) {
      this.anchor = null;
      this.hide();
    }
  }
  ngOnDestroy() {
    this.hide();
    this.template = null;
    this.anchorTitleSubscription.unsubscribe();
    this.mouseOverSubscription.unsubscribe();
    this.mouseOutSubscription.unsubscribe();
    this.keyboardNavigationSubscription.unsubscribe();
    if (this.mouseClickSubscription) {
      this.mouseClickSubscription.unsubscribe();
    }
    if (this.popupPositionChangeSubscription) {
      this.popupPositionChangeSubscription.unsubscribe();
    }
    if (this.popupMouseOutSubscription) {
      this.popupMouseOutSubscription.unsubscribe();
    }
  }
  showContent(anchorRef) {
    if (!anchorRef.nativeElement.getAttribute("data-title") && !this.template) {
      return;
    }
    this.ngZone.run(() => {
      this.openPopup(anchorRef);
      this.bindContent(this.popupRef.content, anchorRef);
    });
    this.popupRef.popupAnchorViewportLeave.pipe(take(1)).subscribe(() => this.hide());
  }
  bindContent(contentComponent, anchorRef) {
    const content2 = contentComponent.instance;
    this.closeClickSubscription = content2.close.subscribe(() => {
      this.hide();
    });
    if (!this.template) {
      content2.templateString = this.anchor.nativeElement.getAttribute("data-title");
    } else {
      content2.templateRef = this.template;
    }
    if (this.titleTemplate) {
      content2.titleTemplate = this.titleTemplate;
    }
    content2.closeTitle = this.closeTitle;
    content2.anchor = anchorRef;
    content2.callout = this.callout;
    content2.closable = this.closable;
    content2.position = this.position;
    content2.tooltipWidth = this.tooltipWidth;
    content2.tooltipHeight = this.tooltipHeight;
    this.popupRef.content.changeDetectorRef.detectChanges();
  }
  hideElementTitle(elementRef) {
    const element = elementRef.nativeElement;
    if (element.getAttribute("title")) {
      element.setAttribute("data-title", element.getAttribute("title"));
      element.setAttribute("title", "");
    }
  }
  openPopup(anchorRef) {
    const alignSettings = align(this.position, this.offset);
    const anchorAlign = alignSettings.anchorAlign;
    const popupAlign = alignSettings.popupAlign;
    const popupMargin = alignSettings.popupMargin;
    this.popupRef = this.popupService.open({
      anchor: anchorRef,
      anchorAlign,
      animate: false,
      content: TooltipContentComponent,
      collision: collision(this.collision, this.position),
      margin: popupMargin,
      popupAlign,
      popupClass: "k-popup-transparent"
    });
    if (this.tooltipClass) {
      this.renderer.addClass(this.popupRef.popupElement, this.tooltipClass);
    }
    if (this.tooltipContentClass) {
      this.renderer.addClass(this.popupRef.content.instance["content"].nativeElement, this.tooltipContentClass);
    }
    const popupInstance = this.popupRef.content.instance;
    if (anchorRef) {
      this.renderer.setAttribute(anchorRef.nativeElement, "aria-labelledby", popupInstance.tooltipId);
    }
    if (popupInstance.callout) {
      this.popupPositionChangeSubscription = this.popupRef.popupPositionChange.subscribe(({
        flip: flip2
      }) => {
        const isFlip = flip2.horizontal === true || flip2.vertical === true;
        popupInstance.updateCalloutPosition(this.position, isFlip);
      });
    }
    if (this.showOn === "hover") {
      this.ngZone.runOutsideAngular(() => {
        const popup = this.popupRef.popupElement;
        this.popupMouseOutSubscription = fromEvent(popup, "mouseout").subscribe((e) => this.onMouseOut(e));
      });
    }
  }
  closePopup() {
    if (this.popupRef) {
      if (this.anchor) {
        this.renderer.removeAttribute(this.anchor.nativeElement, "aria-labelledby");
      }
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.popupPositionChangeSubscription) {
      this.popupPositionChangeSubscription.unsubscribe();
    }
  }
  subscribeClick() {
    if (this.mouseClickSubscription) {
      this.mouseClickSubscription.unsubscribe();
    }
    if (this.showOn === "click") {
      this.mouseClickSubscription = fromEvent(document, "click").pipe(filter(() => this.filter !== "")).subscribe((e) => this.onMouseClick(e, this.tooltipWrapper.nativeElement));
    }
  }
  onMouseClick(e, wrapper) {
    const target = e.target;
    const filterElement = closestBySelector(target, this.filter);
    const popup = this.popupRef && this.popupRef.popupElement;
    if (popup) {
      if (popup.contains(target)) {
        return;
      }
      if (this.closable) {
        return;
      }
    }
    if (wrapper.contains(target) && filterElement) {
      this.toggle(filterElement, true);
    } else if (popup) {
      this.hide();
    }
  }
  onKeyDown(event2) {
    const keyCode = event2.keyCode;
    const target = event2.target;
    if (this.popupRef) {
      const tooltipId = this.popupRef.content.location.nativeElement.getAttribute("id");
      const anchorLabelledBy = target.getAttribute("aria-labelledby");
      if (keyCode === Keys.Escape && this.canCloseTooltip(target, tooltipId, anchorLabelledBy)) {
        this.closePopup();
      }
    }
  }
  canCloseTooltip(target, tooltipId, anchorLabelledBy) {
    const isIdEqualsLabel = tooltipId === anchorLabelledBy;
    const filterElement = closestBySelector(target, this.filter);
    const isTargetFocused = target === document.activeElement;
    const isTargetInsideWrapper = this.tooltipWrapper.nativeElement.contains(target);
    return isTargetInsideWrapper && filterElement && isTargetFocused && isIdEqualsLabel;
  }
  onMouseOver(e) {
    const filterElement = closestBySelector(e.target, this.filter);
    if (this.showOn !== "hover") {
      return;
    }
    if (filterElement) {
      this.toggle(filterElement, true);
    }
  }
  onMouseOut(e) {
    if (this.showOn !== "hover") {
      return;
    }
    if (this.closable) {
      return;
    }
    const popup = this.popupRef && this.popupRef.popupElement;
    const relatedTarget = e.relatedTarget;
    if (relatedTarget && this.anchor && contains(this.anchor.nativeElement, relatedTarget)) {
      return;
    }
    if (relatedTarget && contains(popup, relatedTarget)) {
      return;
    }
    this.hide();
  }
  verifyProperties() {
    if (!isDevMode()) {
      return;
    }
    if (!containsItem(this.validPositions, this.position)) {
      throw new Error(`Invalid value provided for position property.The available options are 'top', 'bottom', 'left', or 'right'.`);
    }
    if (!containsItem(this.validShowOptions, this.showOn)) {
      throw new Error(`Invalid value provided for showOn property.The available options are 'hover' or 'none'.`);
    }
  }
  static ɵfac = function TooltipDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(TooltipSettings, 8), ɵɵdirectiveInject(TOOLTIP_SETTINGS, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TooltipDirective,
    selectors: [["", "kendoTooltip", ""]],
    inputs: {
      filter: "filter",
      position: "position",
      titleTemplate: "titleTemplate",
      showOn: "showOn",
      showAfter: "showAfter",
      callout: "callout",
      closable: "closable",
      offset: "offset",
      tooltipWidth: "tooltipWidth",
      tooltipHeight: "tooltipHeight",
      tooltipClass: "tooltipClass",
      tooltipContentClass: "tooltipContentClass",
      collision: "collision",
      closeTitle: "closeTitle",
      tooltipTemplate: "tooltipTemplate"
    },
    exportAs: ["kendoTooltip"],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTooltip]",
      exportAs: "kendoTooltip",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: PopupService
    }, {
      type: TooltipSettings,
      decorators: [{
        type: Optional
      }]
    }, {
      type: TooltipSettings,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [TOOLTIP_SETTINGS]
      }]
    }];
  }, {
    filter: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    titleTemplate: [{
      type: Input
    }],
    showOn: [{
      type: Input
    }],
    showAfter: [{
      type: Input
    }],
    callout: [{
      type: Input
    }],
    closable: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    tooltipWidth: [{
      type: Input
    }],
    tooltipHeight: [{
      type: Input
    }],
    tooltipClass: [{
      type: Input
    }],
    tooltipContentClass: [{
      type: Input
    }],
    collision: [{
      type: Input
    }],
    closeTitle: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }]
  });
})();
var KENDO_TOOLTIP = [TooltipDirective, TooltipContentComponent, LocalizedMessagesDirective2];
var KENDO_POPOVER = [PopoverComponent, PopoverActionsTemplateDirective, PopoverBodyTemplateDirective, PopoverTitleTemplateDirective, PopoverAnchorDirective, PopoverContainerDirective];
var KENDO_TOOLTIPS = [...KENDO_TOOLTIP, ...KENDO_POPOVER];
var TooltipModule = class _TooltipModule {
  static ɵfac = function TooltipModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TooltipModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TooltipModule,
    imports: [TooltipDirective, TooltipContentComponent, LocalizedMessagesDirective2],
    exports: [TooltipDirective, TooltipContentComponent, LocalizedMessagesDirective2]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService],
    imports: [TooltipContentComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_TOOLTIP],
      exports: [...KENDO_TOOLTIP],
      providers: [PopupService, ResizeBatchService, IconsService]
    }]
  }], null, null);
})();
var PopoverModule = class _PopoverModule {
  static ɵfac = function PopoverModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PopoverModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PopoverModule,
    imports: [PopoverComponent, PopoverActionsTemplateDirective, PopoverBodyTemplateDirective, PopoverTitleTemplateDirective, PopoverAnchorDirective, PopoverContainerDirective],
    exports: [PopoverComponent, PopoverActionsTemplateDirective, PopoverBodyTemplateDirective, PopoverTitleTemplateDirective, PopoverAnchorDirective, PopoverContainerDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopoverModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_POPOVER],
      imports: [...KENDO_POPOVER],
      providers: [PopupService, ResizeBatchService]
    }]
  }], null, null);
})();
var TooltipsModule = class _TooltipsModule {
  static ɵfac = function TooltipsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TooltipsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TooltipsModule,
    imports: [TooltipDirective, TooltipContentComponent, LocalizedMessagesDirective2, PopoverComponent, PopoverActionsTemplateDirective, PopoverBodyTemplateDirective, PopoverTitleTemplateDirective, PopoverAnchorDirective, PopoverContainerDirective],
    exports: [TooltipDirective, TooltipContentComponent, LocalizedMessagesDirective2, PopoverComponent, PopoverActionsTemplateDirective, PopoverBodyTemplateDirective, PopoverTitleTemplateDirective, PopoverAnchorDirective, PopoverContainerDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService],
    imports: [TooltipContentComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipsModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_TOOLTIPS],
      exports: [...KENDO_TOOLTIPS],
      providers: [PopupService, ResizeBatchService, IconsService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-scheduler/fesm2022/progress-kendo-angular-scheduler.mjs
var _c03 = ["kendoSchedulerLoading", ""];
var _c111 = ["resourceMultiSelect"];
function MultipleResourceEditorComponent_ng_template_2_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 5);
  }
  if (rf & 2) {
    const dataItem_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r2.getResourceStyle(dataItem_r2));
  }
}
function MultipleResourceEditorComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultipleResourceEditorComponent_ng_template_2_span_0_Template, 1, 1, "span", 4);
    ɵɵtext(1);
  }
  if (rf & 2) {
    const dataItem_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r2.resource.colorField);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.getField(dataItem_r2, ctx_r2.resource.textField), " ");
  }
}
function MultipleResourceEditorComponent_ng_template_3_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 5);
  }
  if (rf & 2) {
    const dataItem_r4 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r2.getTagStyle(dataItem_r4));
  }
}
function MultipleResourceEditorComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultipleResourceEditorComponent_ng_template_3_span_0_Template, 1, 1, "span", 4);
    ɵɵtext(1);
  }
  if (rf & 2) {
    const dataItem_r4 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r2.resource.colorField);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.getField(dataItem_r4, ctx_r2.resource.textField), " ");
  }
}
var _c211 = ["resourceDropDown"];
function SingleResourceEditorComponent_ng_template_2_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 4);
  }
  if (rf & 2) {
    const dataItem_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r2.getResourceStyle(dataItem_r2));
  }
}
function SingleResourceEditorComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SingleResourceEditorComponent_ng_template_2_span_0_Template, 1, 1, "span", 3);
    ɵɵtext(1);
  }
  if (rf & 2) {
    const dataItem_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r2.resource.colorField);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.getField(dataItem_r2, ctx_r2.resource.textField), " ");
  }
}
function RecurrenceMonthlyYearlyEditorComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.textFor("monthlyDay"), " ");
  }
}
function RecurrenceMonthlyYearlyEditorComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 11);
    ɵɵlistener("valueChange", function RecurrenceMonthlyYearlyEditorComponent_ng_template_9_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onMonthChange($event, "monthday"));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", 170, "px")("margin", "0 .4ex 0 1ex");
    ɵɵproperty("data", ctx_r0.months)("value", ctx_r0.currentMonthMonthDay)("valuePrimitive", true)("disabled", ctx_r0.isDisabled("monthday"));
  }
}
function RecurrenceMonthlyYearlyEditorComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "kendo-dropdownlist", 11);
    ɵɵlistener("valueChange", function RecurrenceMonthlyYearlyEditorComponent_ng_template_18_Template_kendo_dropdownlist_valueChange_2_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onMonthChange($event, "weekday"));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.textFor("yearlyOf"));
    ɵɵadvance();
    ɵɵstyleProp("margin", "0 .4ex 0 1ex");
    ɵɵproperty("data", ctx_r0.months)("value", ctx_r0.currentMonthWeekDay)("valuePrimitive", true)("disabled", ctx_r0.isDisabled("weekday"));
  }
}
function RecurrenceWeekdayRuleEditorComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("selectedChange", function RecurrenceWeekdayRuleEditorComponent_button_4_Template_button_selectedChange_0_listener($event) {
      const day_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSelectedChange($event, day_r2.value));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("toggleable", true)("selected", ctx_r2.isSelected(day_r2));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.capitalize(day_r2.text));
  }
}
function RecurrenceFrequencyEditorComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("click", function RecurrenceFrequencyEditorComponent_button_4_Template_button_click_0_listener() {
      const freq_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick(freq_r2));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const freq_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("togglable", true)("selected", freq_r2.value === ctx_r2.selected);
    ɵɵadvance();
    ɵɵtextInterpolate(freq_r2.text);
  }
}
function RecurrenceEditorComponent_kendo_recurrence_interval_editor_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-recurrence-interval-editor", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("userNumericOptions", ctx_r0.repeatEveryOptions);
  }
}
function RecurrenceEditorComponent_kendo_recurrence_weekday_rule_editor_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-recurrence-weekday-rule-editor");
  }
}
function RecurrenceEditorComponent_kendo_recurrence_monthly_yearly_editor_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-recurrence-monthly-yearly-editor", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("userNumericOptions", ctx_r0.repeatOnOptions);
  }
}
function RecurrenceEditorComponent_kendo_recurrence_end_rule_editor_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-recurrence-end-rule-editor", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("userNumericOptions", ctx_r0.endAfterOptions)("userDatePickerOptions", ctx_r0.endOnOptions);
  }
}
var _c38 = ["tzcombobox"];
var _c43 = ["tzcomboboxControl"];
function TimeZoneEditorComponent_kendo_combobox_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-combobox", 4, 0);
    ɵɵlistener("filterChange", function TimeZoneEditorComponent_kendo_combobox_0_Template_kendo_combobox_filterChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTimeZoneFilterChange($event));
    })("valueChange", function TimeZoneEditorComponent_kendo_combobox_0_Template_kendo_combobox_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTimeZoneChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.width, "px");
    ɵɵproperty("allowCustom", false)("data", ctx_r1.tzSource)("filterable", true)("suggest", true)("value", ctx_r1.tz);
  }
}
function TimeZoneEditorComponent_kendo_combobox_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-combobox", 5, 1);
    ɵɵlistener("filterChange", function TimeZoneEditorComponent_kendo_combobox_1_Template_kendo_combobox_filterChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTimeZoneFilterChange($event));
    })("valueChange", function TimeZoneEditorComponent_kendo_combobox_1_Template_kendo_combobox_valueChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTimeZoneChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.width, "px");
    ɵɵproperty("allowCustom", false)("data", ctx_r1.tzSource)("filterable", true)("suggest", true)("value", ctx_r1.tz)("formControl", ctx_r1.formControl);
  }
}
var _c53 = ["datepicker"];
var _c62 = ["datetimepicker"];
function SchedulerDateTimePickerComponent_kendo_datepicker_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-datepicker", 3, 0);
    ɵɵtwoWayListener("valueChange", function SchedulerDateTimePickerComponent_kendo_datepicker_0_Template_kendo_datepicker_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.date, $event) || (ctx_r1.date = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("valueChange", function SchedulerDateTimePickerComponent_kendo_datepicker_0_Template_kendo_datepicker_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onValueChange($event));
    });
    ɵɵelement(2, "kendo-datepicker-messages", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtwoWayProperty("value", ctx_r1.date);
    ɵɵproperty("formControl", ctx_r1.formControl)("clearButton", true);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r1.textFor("editorDateInputsToday"))("toggle", ctx_r1.textFor("editorDateInputsToggle"))("parentViewButtonTitle", ctx_r1.textFor("editorDateInputsParentViewButton"));
  }
}
function SchedulerDateTimePickerComponent_kendo_datetimepicker_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-datetimepicker", 3, 1);
    ɵɵtwoWayListener("valueChange", function SchedulerDateTimePickerComponent_kendo_datetimepicker_1_Template_kendo_datetimepicker_valueChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.date, $event) || (ctx_r1.date = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("valueChange", function SchedulerDateTimePickerComponent_kendo_datetimepicker_1_Template_kendo_datetimepicker_valueChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onValueChange($event));
    });
    ɵɵelement(2, "kendo-datetimepicker-messages", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtwoWayProperty("value", ctx_r1.date);
    ɵɵproperty("formControl", ctx_r1.formControl)("clearButton", true);
    ɵɵadvance(2);
    ɵɵproperty("toggle", ctx_r1.textFor("editorDateInputsToggle"))("today", ctx_r1.textFor("editorDateInputsToday"))("accept", ctx_r1.textFor("editorDateInputsAccept"))("acceptLabel", ctx_r1.textFor("editorDateInputsAcceptLabel"))("cancelLabel", ctx_r1.textFor("editorDateInputsCancelLabel"))("cancel", ctx_r1.textFor("editorDateInputsCancel"))("now", ctx_r1.textFor("editorDateInputsNow"))("nowLabel", ctx_r1.textFor("editorDateInputsNowLabel"))("dateTab", ctx_r1.textFor("editorDateInputsDateTab"))("dateTabLabel", ctx_r1.textFor("editorDateInputsDateTabLabel"))("timeTab", ctx_r1.textFor("editorDateInputsTimeTab"))("timeTabLabel", ctx_r1.textFor("editorDateInputsTimeTabLabel"))("parentViewButtonTitle", ctx_r1.textFor("editorDateInputsParentViewButton"));
  }
}
var _c72 = (a0, a1, a2, a3, a4) => ({
  $implicit: a0,
  formGroup: a1,
  dataItem: a2,
  editMode: a3,
  isNew: a4
});
function EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formfield");
    ɵɵelementContainerStart(1);
    ɵɵelementStart(2, "span", 18);
    ɵɵelement(3, "input", 19);
    ɵɵelementEnd();
    ɵɵelementStart(4, "label", 20);
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance(4);
    ɵɵproperty("labelClass", false);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.textFor("editorEventTimeZone"));
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formfield");
    ɵɵelement(1, "kendo-label", 13)(2, "kendo-timezone-editor", 21, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const startTzPicker_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("for", startTzPicker_r3)("text", ctx_r1.textFor("editorEventStartTimeZone"));
    ɵɵadvance();
    ɵɵproperty("width", void 0)("formControl", ctx_r1.getControl(ctx_r1.fields.startTimezone));
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formfield");
    ɵɵelementContainerStart(1);
    ɵɵelementStart(2, "span", 18);
    ɵɵelement(3, "input", 22);
    ɵɵelementEnd();
    ɵɵelementStart(4, "label", 23);
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance(4);
    ɵɵproperty("labelClass", false);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.textFor("editorEventSeparateTimeZones"));
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formfield");
    ɵɵelement(1, "kendo-label", 13)(2, "kendo-timezone-editor", 21, 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const endTzPicker_r4 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("for", endTzPicker_r4)("text", ctx_r1.textFor("editorEventEndTimeZone"));
    ɵɵadvance();
    ɵɵproperty("width", void 0)("formControl", ctx_r1.getControl(ctx_r1.fields.endTimezone));
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formfield");
    ɵɵelementContainerStart(1);
    ɵɵelementStart(2, "span", 18);
    ɵɵelement(3, "input", 24);
    ɵɵelementEnd();
    ɵɵelementStart(4, "label", 25);
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance(3);
    ɵɵproperty("formControl", ctx_r1.getControl(ctx_r1.fields.isAllDay));
    ɵɵadvance();
    ɵɵproperty("labelClass", false);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.textFor("editorEventAllDay"));
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_recurrence_editor_19_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-recurrence-editor", 26);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("formControl", ctx_r1.getControl(ctx_r1.fields.recurrenceRule))("start", ctx_r1.recurrenceStart)("timezone", ctx_r1.eventTimezone)("weekStart", ctx_r1.weekStart);
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formfield");
    ɵɵelement(1, "kendo-label", 13)(2, "textarea", 27, 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const description_r5 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("for", description_r5)("text", ctx_r1.textFor("editorEventDescription"));
    ɵɵadvance();
    ɵɵproperty("formControl", ctx_r1.getControl(ctx_r1.fields.description));
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_kendo_formfield_1_kendo_multiple_resource_editor_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-multiple-resource-editor", 30);
  }
  if (rf & 2) {
    const resource_r7 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("formControl", ctx_r1.getControl(resource_r7.field))("resource", resource_r7);
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_kendo_formfield_1_kendo_single_resource_editor_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-single-resource-editor", 30);
  }
  if (rf & 2) {
    const resource_r7 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("formControl", ctx_r1.getControl(resource_r7.field))("resource", resource_r7);
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_kendo_formfield_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-formfield")(1, "label", 28);
    ɵɵlistener("click", function EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_kendo_formfield_1_Template_label_click_1_listener() {
      ɵɵrestoreView(_r6);
      const resource_r7 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onResourceClick(resource_r7));
    });
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_kendo_formfield_1_kendo_multiple_resource_editor_3_Template, 1, 2, "kendo-multiple-resource-editor", 29)(4, EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_kendo_formfield_1_kendo_single_resource_editor_4_Template, 1, 2, "kendo-single-resource-editor", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resource_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", resource_r7.name ? resource_r7.name : resource_r7.field, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", resource_r7.multiple);
    ɵɵadvance();
    ɵɵproperty("ngIf", !resource_r7.multiple);
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_kendo_formfield_1_Template, 5, 3, "kendo-formfield", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const resource_r7 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.getFormValue(resource_r7.field));
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "form", 12)(2, "kendo-formfield");
    ɵɵelement(3, "kendo-label", 13)(4, "input", 14, 0);
    ɵɵelementEnd();
    ɵɵelementStart(6, "kendo-formfield");
    ɵɵelement(7, "kendo-label", 13)(8, "kendo-scheduler-datetime-picker", 15, 1);
    ɵɵelementEnd();
    ɵɵtemplate(10, EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_10_Template, 6, 2, "kendo-formfield", 8)(11, EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_11_Template, 4, 4, "kendo-formfield", 8);
    ɵɵelementStart(12, "kendo-formfield");
    ɵɵelement(13, "kendo-label", 13)(14, "kendo-scheduler-datetime-picker", 15, 2);
    ɵɵelementEnd();
    ɵɵtemplate(16, EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_16_Template, 6, 2, "kendo-formfield", 8)(17, EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_17_Template, 4, 4, "kendo-formfield", 8)(18, EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_18_Template, 6, 3, "kendo-formfield", 8)(19, EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_recurrence_editor_19_Template, 1, 4, "kendo-recurrence-editor", 16)(20, EditDialogComponent_kendo_dialog_0_ng_container_1_kendo_formfield_20_Template, 4, 3, "kendo-formfield", 8)(21, EditDialogComponent_kendo_dialog_0_ng_container_1_ng_container_21_Template, 2, 1, "ng-container", 17);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    let tmp_12_0;
    let tmp_18_0;
    const title_r8 = ɵɵreference(5);
    const startDateTimePicker_r9 = ɵɵreference(9);
    const endDateTimePicker_r10 = ɵɵreference(15);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("formGroup", ctx_r1.formGroup);
    ɵɵadvance(2);
    ɵɵproperty("for", title_r8)("text", ctx_r1.textFor("editorEventTitle"));
    ɵɵadvance();
    ɵɵproperty("formControl", ctx_r1.getControl(ctx_r1.fields.title));
    ɵɵadvance(3);
    ɵɵproperty("for", startDateTimePicker_r9)("text", ctx_r1.textFor("editorEventStart"));
    ɵɵadvance();
    ɵɵproperty("formControl", ctx_r1.getControl(ctx_r1.fields.start))("isAllDay", (tmp_12_0 = ctx_r1.getFormValue(ctx_r1.fields.isAllDay)) == null ? null : tmp_12_0.value);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.hasStartTimeZone);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isStartTimeZoneVisible);
    ɵɵadvance(2);
    ɵɵproperty("for", endDateTimePicker_r10)("text", ctx_r1.textFor("editorEventEnd"));
    ɵɵadvance();
    ɵɵproperty("formControl", ctx_r1.getControl(ctx_r1.fields.end))("isAllDay", (tmp_18_0 = ctx_r1.getFormValue(ctx_r1.fields.isAllDay)) == null ? null : tmp_18_0.value);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.isStartTimeZoneVisible && ctx_r1.hasEndTimeZone);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isEndTimeZoneVisible);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasAllDay);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isEditingSeries);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.getFormValue(ctx_r1.fields.description));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.resources);
  }
}
function EditDialogComponent_kendo_dialog_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "form", 31);
    ɵɵelementContainer(2, 32);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("formGroup", ctx_r1.formGroup);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.editTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction5(3, _c72, ctx_r1.formGroup, ctx_r1.formGroup, ctx_r1.editedEvent, ctx_r1.editMode, ctx_r1.isNew));
  }
}
function EditDialogComponent_kendo_dialog_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dialog", 7);
    ɵɵlistener("close", function EditDialogComponent_kendo_dialog_0_Template_kendo_dialog_close_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClose());
    });
    ɵɵtemplate(1, EditDialogComponent_kendo_dialog_0_ng_container_1_Template, 22, 20, "ng-container", 8)(2, EditDialogComponent_kendo_dialog_0_ng_container_2_Template, 3, 9, "ng-container", 8);
    ɵɵelementStart(3, "kendo-dialog-actions", 9)(4, "button", 10);
    ɵɵlistener("click", function EditDialogComponent_kendo_dialog_0_Template_button_click_4_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSave($event));
    });
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "button", 11);
    ɵɵlistener("click", function EditDialogComponent_kendo_dialog_0_Template_button_click_6_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onCancel($event));
    });
    ɵɵtext(7);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵpropertyInterpolate("title", ctx_r1.textFor("editorTitle"));
    ɵɵproperty("minWidth", 400)("autoFocusedElement", ctx_r1.autoFocusedElement);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.editTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.editTemplate);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.saveIcon)("disabled", !ctx_r1.formGroup.valid);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.textFor("save"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.cancelIcon);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.textFor("cancel"));
  }
}
var _c82 = ["kendoSchedulerToolbarViewSelector", ""];
function ToolbarViewSelectorComponent_select_0_option_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const view_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("selected", ctx_r1.isSelected(view_r3) === true)("value", view_r3.name);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", view_r3.title, " ");
  }
}
function ToolbarViewSelectorComponent_select_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "select", 2);
    ɵɵlistener("change", function ToolbarViewSelectorComponent_select_0_Template_select_change_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChange($event));
    });
    ɵɵtemplate(1, ToolbarViewSelectorComponent_select_0_option_1_Template, 2, 3, "option", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("kendoSchedulerFocusIndex", 0);
    ɵɵattribute("aria-label", ctx_r1.selectView);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.ctx.views);
  }
}
function ToolbarViewSelectorComponent_span_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function ToolbarViewSelectorComponent_span_1_button_1_Template_button_click_0_listener() {
      const view_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.select(view_r5));
    });
    ɵɵelementStart(1, "span", 8);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const view_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("selected", ctx_r1.isSelected(view_r5))("kendoSchedulerFocusIndex", 0);
    ɵɵattribute("aria-pressed", ctx_r1.isSelected(view_r5));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", view_r5.title, " ");
  }
}
function ToolbarViewSelectorComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtemplate(1, ToolbarViewSelectorComponent_span_1_button_1_Template, 3, 4, "button", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.ctx.views);
  }
}
var _c92 = ["calendar"];
var _c102 = ["kendoSchedulerToolbarNavigation", ""];
function ToolbarNavigationComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar", 8, 2);
    ɵɵpipe(2, "async");
    ɵɵlistener("blur", function ToolbarNavigationComponent_ng_template_9_Template_kendo_calendar_blur_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onBlur());
    })("keydown.escape", function ToolbarNavigationComponent_ng_template_9_Template_kendo_calendar_keydown_escape_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      const anchor_r2 = ɵɵreference(6);
      const template_r3 = ɵɵreference(10);
      ctx_r4.toggleSelectedDate({
        nativeElement: anchor_r2
      }, template_r3);
      return ɵɵresetView(anchor_r2.focus());
    })("valueChange", function ToolbarNavigationComponent_ng_template_9_Template_kendo_calendar_valueChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.selectDate($event));
    });
    ɵɵelement(3, "kendo-calendar-messages", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("activeView", ctx_r4.activeView)("bottomView", ctx_r4.bottomView)("value", ɵɵpipeBind1(2, 6, ctx_r4.ctx.selectedDate))("min", ctx_r4.min)("max", ctx_r4.max);
    ɵɵadvance(3);
    ɵɵproperty("today", ctx_r4.calendarTodayText);
  }
}
function ToolbarComponent_0_ng_template_0_Template(rf, ctx) {
}
function ToolbarComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ToolbarComponent_0_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.template.templateRef)("ngTemplateOutletContext", ctx_r1.templateContext);
  }
}
function ToolbarComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 4)(1, "span", 5)(2, "div", 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("min", ctx_r1.min)("max", ctx_r1.max)("activeView", ctx_r1.activeView)("bottomView", ctx_r1.bottomView);
    ɵɵadvance(2);
    ɵɵproperty("toolbarWidth", ctx_r1.toolbarWidth);
  }
}
var _c112 = ["confirmationDialogContainer"];
function SchedulerComponent_kendo_scheduler_toolbar_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-scheduler-toolbar", 8);
    ɵɵlistener("navigate", function SchedulerComponent_kendo_scheduler_toolbar_1_Template_kendo_scheduler_toolbar_navigate_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onNavigationAction($event));
    })("toolbarWidthChange", function SchedulerComponent_kendo_scheduler_toolbar_1_Template_kendo_scheduler_toolbar_toolbarWidthChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onToolbarWidthChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("dateRange", ctx_r2.dateRangeStream)("selectedDate", ctx_r2.selectedDateStream)("views", ctx_r2.views)("selectedView", ctx_r2.selectedView)("template", ctx_r2.toolbarTemplate)("min", ctx_r2.min)("max", ctx_r2.max);
  }
}
function SchedulerComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function SchedulerComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 9);
  }
}
var _c122 = ["kendoSchedulerPDFCommand", ""];
var _c132 = ["*"];
function PDFCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function PDFCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function PDFCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c142 = ["content"];
var _c152 = ["kendoSchedulerAgendaTaskItem", ""];
var _c162 = (a0, a1, a2) => ({
  $implicit: a0,
  event: a1,
  resources: a2
});
function AgendaTaskItemComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("background-color", ctx_r0.eventColor);
  }
}
function AgendaTaskItemComponent_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.arrowRotateCWIcon);
  }
}
function AgendaTaskItemComponent_kendo_icon_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.arrowsNoRepeatIcon);
  }
}
function AgendaTaskItemComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.item == null ? null : ctx_r0.item.title, " ");
  }
}
function AgendaTaskItemComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.eventTemplate)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c162, ctx_r0.item.event, ctx_r0.item.event, ctx_r0.item.resources));
  }
}
function AgendaTaskItemComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 11);
    ɵɵelement(1, "kendo-icon-wrapper", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r0.deleteMessage);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.xIcon);
  }
}
var _c172 = ["kendoSchedulerAgendaHeaderItem", ""];
var _c182 = (a0) => ({
  date: a0
});
function AgendaHeaderItemComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "strong", 2);
    ɵɵtext(2);
    ɵɵpipe(3, "kendoDate");
    ɵɵelementEnd();
    ɵɵelementStart(4, "em", 3);
    ɵɵtext(5);
    ɵɵpipe(6, "kendoDate");
    ɵɵelementEnd();
    ɵɵelementStart(7, "span", 4);
    ɵɵtext(8);
    ɵɵpipe(9, "kendoDate");
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind2(3, 3, ctx_r0.itemDate, "dd"));
    ɵɵadvance(3);
    ɵɵtextInterpolate(ɵɵpipeBind2(6, 6, ctx_r0.itemDate, "EEEE"));
    ɵɵadvance(3);
    ɵɵtextInterpolate(ɵɵpipeBind2(9, 9, ctx_r0.itemDate, "y"));
  }
}
function AgendaHeaderItemComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.agendaDateTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c182, ctx_r0.itemDate));
  }
}
var _c192 = ["kendoSchedulerAgendaList", ""];
function AgendaListComponent_ng_container_2_tr_1_ng_container_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const resource_r2 = ctx_r0.$implicit;
    const resourceIndex_r3 = ctx_r0.index;
    const group_r4 = ɵɵnextContext(2).$implicit;
    ɵɵattribute("rowspan", group_r4.spans[resourceIndex_r3]);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", resource_r2, " ");
  }
}
function AgendaListComponent_ng_container_2_tr_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, AgendaListComponent_ng_container_2_tr_1_ng_container_1_td_1_Template, 2, 2, "td", 10);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const resourceIndex_r3 = ctx.index;
    const index_r5 = ɵɵnextContext().index;
    const group_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", group_r4.spans[resourceIndex_r3] && index_r5 === 0);
  }
}
function AgendaListComponent_ng_container_2_tr_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 12);
  }
  if (rf & 2) {
    const item_r6 = ɵɵnextContext().$implicit;
    const group_r4 = ɵɵnextContext().$implicit;
    const ctx_r6 = ɵɵnextContext();
    ɵɵproperty("kendoSchedulerAgendaHeaderItem", item_r6)("hasFirstClass", !group_r4.resources || group_r4.resources.length === 0)("agendaDateTemplate", ctx_r6.agendaDateTemplate);
  }
}
function AgendaListComponent_ng_container_2_tr_1_div_4_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 14);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(4);
    ɵɵproperty("name", ctx_r6.arrowIcons[0])("svgIcon", ctx_r6.arrowSVGIcons[0]);
  }
}
function AgendaListComponent_ng_container_2_tr_1_div_4_kendo_icon_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 14);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(4);
    ɵɵproperty("name", ctx_r6.arrowIcons[1])("svgIcon", ctx_r6.arrowSVGIcons[1]);
  }
}
function AgendaListComponent_ng_container_2_tr_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, AgendaListComponent_ng_container_2_tr_1_div_4_kendo_icon_wrapper_1_Template, 1, 2, "kendo-icon-wrapper", 13);
    ɵɵtext(2);
    ɵɵtemplate(3, AgendaListComponent_ng_container_2_tr_1_div_4_kendo_icon_wrapper_3_Template, 1, 2, "kendo-icon-wrapper", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r6 = ɵɵnextContext().$implicit;
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r6.extractDataItem(item_r6).tail || ctx_r6.extractDataItem(item_r6).mid);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r6.formatTime(ctx_r6.extractDataItem(item_r6)), " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r6.extractDataItem(item_r6).head || ctx_r6.extractDataItem(item_r6).mid);
  }
}
function AgendaListComponent_ng_container_2_tr_1_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 15);
  }
  if (rf & 2) {
    const item_r6 = ɵɵnextContext().$implicit;
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r6.agendaTimeTemplate)("ngTemplateOutletContext", ctx_r6.extractDataItemInLocalTime(item_r6));
  }
}
function AgendaListComponent_ng_container_2_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 4);
    ɵɵtemplate(1, AgendaListComponent_ng_container_2_tr_1_ng_container_1_Template, 2, 1, "ng-container", 2)(2, AgendaListComponent_ng_container_2_tr_1_td_2_Template, 1, 3, "td", 5);
    ɵɵelementStart(3, "td", 6);
    ɵɵtemplate(4, AgendaListComponent_ng_container_2_tr_1_div_4_Template, 4, 3, "div", 7)(5, AgendaListComponent_ng_container_2_tr_1_ng_container_5_Template, 1, 2, "ng-container", 8);
    ɵɵelementEnd();
    ɵɵelement(6, "td", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r6 = ctx.$implicit;
    const index_r5 = ctx.index;
    const ctx_r7 = ɵɵnextContext();
    const group_r4 = ctx_r7.$implicit;
    const groupIndex_r9 = ctx_r7.index;
    const ctx_r6 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", group_r4.resources);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r6.type === "group");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r6.agendaTimeTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r6.agendaTimeTemplate);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r6.cellClasses(item_r6))("ngStyle", ctx_r6.getEventStyles(item_r6))("kendoSchedulerFocusIndex", groupIndex_r9)("id", item_r6.elementId)("kendoSchedulerAgendaTaskItem", ctx_r6.extractDataItem(item_r6))("editable", ctx_r6.editable)("eventTemplate", ctx_r6.eventTemplate);
    ɵɵattribute("data-group-index", groupIndex_r9)("data-task-index", index_r5);
  }
}
function AgendaListComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, AgendaListComponent_ng_container_2_tr_1_Template, 7, 13, "tr", 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const group_r4 = ctx.$implicit;
    const ctx_r6 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", group_r4.tasks)("ngForTrackBy", ctx_r6.trackByFn);
  }
}
var _c202 = ["kendoSchedulerAgendaHeader", ""];
function AgendaHeaderComponent_th_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 8);
  }
}
var _c212 = ["headerWrap"];
function AgendaViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "agenda-view-internal", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("numberOfDays", ctx_r0.numberOfDays)("eventTemplate", ctx_r0.eventTemplate == null ? null : ctx_r0.eventTemplate.templateRef)("slotClass", ctx_r0.viewSlotClass)("eventClass", ctx_r0.viewEventClass)("eventStyles", ctx_r0.viewEventStyles)("agendaTimeTemplate", ctx_r0.agendaTimeTemplate == null ? null : ctx_r0.agendaTimeTemplate.templateRef)("agendaDateTemplate", ctx_r0.agendaDateTemplate == null ? null : ctx_r0.agendaDateTemplate.templateRef)("selectedDateFormat", ctx_r0.selectedDateFormat)("selectedShortDateFormat", ctx_r0.selectedShortDateFormat);
  }
}
var _c222 = ["header"];
var _c232 = ["contentTable"];
var _c242 = ["times"];
var _c252 = ["timesHeader"];
var _c262 = ["timesTable"];
var _c272 = ["hintContainer"];
var _c282 = ["monthViewItem", ""];
function MonthViewItemComponent_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.arrowIcons[0])("svgIcon", ctx_r0.arrowSVGIcons[0]);
  }
}
function MonthViewItemComponent_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.arrowRotateCwIcon);
  }
}
function MonthViewItemComponent_kendo_icon_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.arrowsNoRepeatIcon);
  }
}
function MonthViewItemComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.eventTemplate)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c162, ctx_r0.item.event, ctx_r0.item.event, ctx_r0.resources));
  }
}
function MonthViewItemComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 11);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r0.eventTitle);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.item.event.title);
  }
}
function MonthViewItemComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵelement(1, "kendo-icon-wrapper", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r0.deleteMessage);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.xIcon);
  }
}
function MonthViewItemComponent_kendo_icon_wrapper_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.arrowIcons[1])("svgIcon", ctx_r0.arrowSVGIcons[1]);
  }
}
function MonthViewItemComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 14)(2, "span", 15);
    ɵɵelementContainerEnd();
  }
}
var _c292 = ["kendoResizeHint", ""];
function ResizeHintComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 1, ctx_r0.start, ctx_r0.format));
  }
}
function ResizeHintComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 1, ctx_r0.end, ctx_r0.format));
  }
}
var _c302 = ["monthSlot", ""];
var _c312 = (a0, a1) => ({
  date: a0,
  resources: a1
});
function MonthSlotComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r0.day, ctx_r0.isFirstDayOfMonth(ctx_r0.day) ? "MMM dd" : "dd"), " ");
  }
}
function MonthSlotComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.monthDaySlotTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c312, ctx_r0.day, ctx_r0.resourcesByIndex));
  }
}
function MonthSlotComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵelement(1, "kendo-icon-wrapper", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleMap(ctx_r0.style);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.moreHorizontalIcon);
  }
}
var _c322 = (a0) => ({
  resource: a0
});
var _c332 = (a0) => ({
  "k-last-resource": a0
});
var _c342 = (a0, a1, a2) => ({
  start: a0,
  end: a1,
  isAllDay: true,
  resources: a2
});
var _c352 = (a0, a1, a2) => ({
  resourceIndex: a0,
  rangeIndex: a1,
  index: a2
});
function MonthViewRendererComponent_td_3_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19, 5)(2, "table", 13)(3, "tbody")(4, "tr");
    ɵɵelement(5, "th", 20);
    ɵɵelementEnd()()()();
  }
}
function MonthViewRendererComponent_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td");
    ɵɵtemplate(1, MonthViewRendererComponent_td_3_div_1_Template, 6, 0, "div", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.verticalResources.length);
  }
}
function MonthViewRendererComponent_tr_11_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r2 = ɵɵnextContext().$implicit;
    const resource_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.getField(item_r2, resource_r3.textField));
  }
}
function MonthViewRendererComponent_tr_11_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 23);
  }
  if (rf & 2) {
    const item_r2 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.groupHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c322, item_r2));
  }
}
function MonthViewRendererComponent_tr_11_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 20);
    ɵɵtemplate(1, MonthViewRendererComponent_tr_11_th_1_ng_container_1_Template, 2, 1, "ng-container", 10)(2, MonthViewRendererComponent_tr_11_th_1_ng_container_2_Template, 1, 4, "ng-container", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resourceIndex_r4 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("colspan", ctx_r0.horizontalColspan(resourceIndex_r4));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.groupHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.groupHeaderTemplateRef);
  }
}
function MonthViewRendererComponent_tr_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, MonthViewRendererComponent_tr_11_th_1_Template, 3, 3, "th", 21);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resourceIndex_r4 = ctx.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind2(2, 2, ctx_r0.horizontalResources, resourceIndex_r4))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewRendererComponent_ng_container_13_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 20);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r5 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, day_r5, "EEEE"), " ");
  }
}
function MonthViewRendererComponent_ng_container_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MonthViewRendererComponent_ng_container_13_th_1_Template, 3, 4, "th", 21);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.weeks[0])("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewRendererComponent_td_16_ng_container_6_ng_container_2_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    const resource_r7 = ctx_r5.$implicit;
    const resourceIndex_r8 = ctx_r5.index;
    const leafIndex_r9 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.getField(ctx_r0.verticalItem(leafIndex_r9, resourceIndex_r8), resource_r7.textField));
  }
}
function MonthViewRendererComponent_td_16_ng_container_6_ng_container_2_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 23);
  }
  if (rf & 2) {
    const resourceIndex_r8 = ɵɵnextContext(2).index;
    const leafIndex_r9 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.groupHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c322, ctx_r0.verticalItem(leafIndex_r9, resourceIndex_r8)));
  }
}
function MonthViewRendererComponent_td_16_ng_container_6_ng_container_2_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 27);
    ɵɵtemplate(1, MonthViewRendererComponent_td_16_ng_container_6_ng_container_2_th_1_ng_container_1_Template, 2, 1, "ng-container", 10)(2, MonthViewRendererComponent_td_16_ng_container_6_ng_container_2_th_1_ng_container_2_Template, 1, 4, "ng-container", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resourceIndex_r8 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ɵɵpureFunction1(4, _c332, resourceIndex_r8 === ctx_r0.verticalResources.length - 1));
    ɵɵattribute("rowspan", ctx_r0.verticalRowspan(resourceIndex_r8));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.groupHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.groupHeaderTemplateRef);
  }
}
function MonthViewRendererComponent_td_16_ng_container_6_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MonthViewRendererComponent_td_16_ng_container_6_ng_container_2_th_1_Template, 3, 6, "th", 26);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const resourceIndex_r8 = ctx.index;
    const leafIndex_r9 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.verticalItem(leafIndex_r9, resourceIndex_r8));
  }
}
function MonthViewRendererComponent_td_16_ng_container_6_tr_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵelement(1, "th", 25);
    ɵɵelementEnd();
  }
}
function MonthViewRendererComponent_td_16_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "tr");
    ɵɵtemplate(2, MonthViewRendererComponent_td_16_ng_container_6_ng_container_2_Template, 2, 1, "ng-container", 14);
    ɵɵelement(3, "th", 25);
    ɵɵelementEnd();
    ɵɵtemplate(4, MonthViewRendererComponent_td_16_ng_container_6_tr_4_Template, 2, 0, "tr", 14);
    ɵɵpipe(5, "repeat");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.verticalResources)("ngForTrackBy", ctx_r0.itemIndex);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ɵɵpipeBind1(5, 4, ctx_r0.numberOfWeeks - 1))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewRendererComponent_td_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td")(1, "div", 24, 6)(3, "table", 13, 7)(5, "tbody");
    ɵɵtemplate(6, MonthViewRendererComponent_td_16_ng_container_6_Template, 6, 6, "ng-container", 14);
    ɵɵpipe(7, "resourceIterator");
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(6);
    ɵɵproperty("ngForOf", ɵɵpipeBind1(7, 2, ctx_r0.verticalResources))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewRendererComponent_ng_container_24_tr_1_ng_container_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 29);
  }
  if (rf & 2) {
    const day_r10 = ctx.$implicit;
    const index_r11 = ctx.index;
    const horizontalIndex_r12 = ɵɵnextContext().index;
    const rangeIndex_r13 = ɵɵnextContext().index;
    const verticalIndex_r14 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-selected", ctx_r0.isSlotSelected(ɵɵpureFunction3(13, _c342, ctx_r0.toPlainDate(day_r10), ctx_r0.addDay(ctx_r0.toPlainDate(day_r10)), ctx_r0.resourcesByIndex(ctx_r0.verticalResources.length ? verticalIndex_r14 : horizontalIndex_r12))))("k-other-month", ctx_r0.isDayInPreviousMonth(day_r10) || ctx_r0.isDayInNextMonth(day_r10));
    ɵɵproperty("monthSlot", day_r10)("eventHeight", ctx_r0.eventHeight)("eventsPerDay", ctx_r0.eventsPerDay)("adaptiveSlotHeight", ctx_r0.adaptiveSlotHeight)("monthDaySlotTemplateRef", ctx_r0.monthDaySlotTemplateRef)("resourcesByIndex", ctx_r0.resourcesByIndex(ctx_r0.verticalResources.length ? verticalIndex_r14 : horizontalIndex_r12))("ngClass", ctx_r0.daySlotClass(day_r10, ctx_r0.verticalResources.length ? verticalIndex_r14 : horizontalIndex_r12))("id", ɵɵpureFunction3(17, _c352, ctx_r0.verticalResources.length ? verticalIndex_r14 : horizontalIndex_r12, rangeIndex_r13, index_r11))("title", ctx_r0.cellTitle(day_r10));
  }
}
function MonthViewRendererComponent_ng_container_24_tr_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MonthViewRendererComponent_ng_container_24_tr_1_ng_container_1_td_1_Template, 1, 21, "td", 28);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const week_r15 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", week_r15)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewRendererComponent_ng_container_24_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, MonthViewRendererComponent_ng_container_24_tr_1_ng_container_1_Template, 2, 2, "ng-container", 14);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 2, ctx_r0.horizontalResources))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewRendererComponent_ng_container_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MonthViewRendererComponent_ng_container_24_tr_1_Template, 3, 4, "tr", 14);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.weeks)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewRendererComponent_ng_container_26_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 31);
  }
  if (rf & 2) {
    const itemResource_r16 = ctx.$implicit;
    const item_r17 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.getEventClasses(item_r17, itemResource_r16.resources))("ngStyle", ctx_r0.getEventStyles(item_r17, itemResource_r16))("kendoSchedulerFocusIndex", itemResource_r16.leafIdx)("id", item_r17.elementId + "_" + itemResource_r16.leafIdx)("editable", ctx_r0.editable)("item", item_r17)("index", item_r17.index)("rangeIndex", item_r17.rangeIndex)("eventTemplate", ctx_r0.eventTemplateRef)("resources", itemResource_r16.resources)("resourceIndex", itemResource_r16.leafIdx);
  }
}
function MonthViewRendererComponent_ng_container_26_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MonthViewRendererComponent_ng_container_26_div_1_Template, 1, 11, "div", 30);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r17 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", item_r17.resources)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewRendererComponent_ng_template_30_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 34);
  }
  if (rf & 2) {
    const hint_r18 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", hint_r18.style)("ngClass", hint_r18.class)("dragHint", true)("eventTemplate", ctx_r0.eventTemplateRef)("item", hint_r18.item)("resources", hint_r18.resources);
  }
}
function MonthViewRendererComponent_ng_template_30_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 35);
  }
  if (rf & 2) {
    const hint_r19 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("hint", hint_r19)("ngClass", hint_r19.class)("format", ctx_r0.resizeHintFormat);
  }
}
function MonthViewRendererComponent_ng_template_30_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MonthViewRendererComponent_ng_template_30_div_0_Template, 1, 6, "div", 32)(1, MonthViewRendererComponent_ng_template_30_div_1_Template, 1, 3, "div", 33);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r0.dragHints)("ngForTrackBy", ctx_r0.itemIndex);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.resizeHints)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MonthViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "month-view", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("eventHeight", ctx_r0.viewEventHeight)("adaptiveSlotHeight", ctx_r0.adaptiveSlotHeight)("eventsPerDay", ctx_r0.eventsPerDay)("eventTemplate", ctx_r0.eventTemplate == null ? null : ctx_r0.eventTemplate.templateRef)("slotClass", ctx_r0.viewSlotClass)("eventClass", ctx_r0.viewEventClass)("eventStyles", ctx_r0.viewEventStyles)("groupHeaderTemplate", ctx_r0.groupHeaderTemplate == null ? null : ctx_r0.groupHeaderTemplate.templateRef)("monthDaySlotTemplate", ctx_r0.monthDaySlotTemplate == null ? null : ctx_r0.monthDaySlotTemplate.templateRef)("selectedDateFormat", ctx_r0.selectedDateFormat)("selectedShortDateFormat", ctx_r0.selectedShortDateFormat)("highlightOngoingEvents", ctx_r0.viewHighlightOngoingEvents)("weekStart", ctx_r0.viewWeekStart)("dateRangeFn", ctx_r0.dateRange)("newRange", ctx_r0.newRange);
  }
}
function MultiWeekViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "month-view", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("eventHeight", ctx_r0.viewEventHeight)("adaptiveSlotHeight", ctx_r0.adaptiveSlotHeight)("eventsPerDay", ctx_r0.eventsPerDay)("eventTemplate", ctx_r0.eventTemplate == null ? null : ctx_r0.eventTemplate.templateRef)("slotClass", ctx_r0.viewSlotClass)("eventClass", ctx_r0.viewEventClass)("eventStyles", ctx_r0.viewEventStyles)("groupHeaderTemplate", ctx_r0.groupHeaderTemplate == null ? null : ctx_r0.groupHeaderTemplate.templateRef)("monthDaySlotTemplate", ctx_r0.multiWeekDaySlotTemplate == null ? null : ctx_r0.multiWeekDaySlotTemplate.templateRef)("selectedDateFormat", ctx_r0.selectedDateFormat)("selectedShortDateFormat", ctx_r0.selectedShortDateFormat)("highlightOngoingEvents", ctx_r0.viewHighlightOngoingEvents)("weekStart", ctx_r0.viewWeekStart)("numberOfWeeks", ctx_r0.numberOfWeeks)("dateRangeFn", ctx_r0.dateRange)("newRange", ctx_r0.newRange);
  }
}
var _c362 = ["viewFooter", ""];
function ViewFooterComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 2);
    ɵɵlistener("click", function ViewFooterComponent_button_1_Template_button_click_0_listener($event) {
      const item_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onItemClick($event, item_r2));
    });
    ɵɵelementStart(1, "span", 3);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    ɵɵproperty("icon", item_r2.fontIcon)("svgIcon", item_r2.svgIcon)("ngClass", item_r2.cssClass)("kendoSchedulerFocusIndex", 0);
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r2.text);
  }
}
var _c372 = ["dayTimeViewItem", ""];
function DayTimeViewItemComponent_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.arrowIcons[0])("svgIcon", ctx_r0.arrowSVGIcons[0]);
  }
}
function DayTimeViewItemComponent_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.arrowRotateCwIcon);
  }
}
function DayTimeViewItemComponent_kendo_icon_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r0.arrowsNoRepeatIcon);
  }
}
function DayTimeViewItemComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.eventTemplate)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c162, ctx_r0.item.event, ctx_r0.item.event, ctx_r0.resources));
  }
}
function DayTimeViewItemComponent_div_5_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.eventTime);
  }
}
function DayTimeViewItemComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, DayTimeViewItemComponent_div_5_div_1_Template, 2, 1, "div", 13);
    ɵɵelementStart(2, "div", 14);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r0.eventTitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isAllDay);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.item.event.title);
  }
}
function DayTimeViewItemComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 16);
    ɵɵelement(1, "kendo-icon-wrapper", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r0.deleteMessage);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.xIcon);
  }
}
function DayTimeViewItemComponent_kendo_icon_wrapper_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.arrowIcons[1])("svgIcon", ctx_r0.arrowSVGIcons[1]);
  }
}
function DayTimeViewItemComponent_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 18);
    ɵɵelement(1, "kendo-icon-wrapper", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.caretAltUpIcon);
  }
}
function DayTimeViewItemComponent_span_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 20);
    ɵɵelement(1, "kendo-icon-wrapper", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.caretAltDownIcon);
  }
}
function DayTimeViewItemComponent_ng_container_11_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 24);
  }
}
function DayTimeViewItemComponent_ng_container_11_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
}
function DayTimeViewItemComponent_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, DayTimeViewItemComponent_ng_container_11_span_1_Template, 1, 0, "span", 22)(2, DayTimeViewItemComponent_ng_container_11_span_2_Template, 1, 0, "span", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.item.tail);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.item.head);
  }
}
function DayTimeViewItemComponent_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 26)(2, "span", 27);
    ɵɵelementContainerEnd();
  }
}
var _c382 = ["currentTimeMarker"];
var _c39 = ["currentTimeArrow"];
var _c40 = ["headerHintContainer"];
var _c41 = ["allDayCell"];
var _c422 = (a0, a1) => ({
  resourceIndex: a0,
  rangeIndex: 0,
  index: a1
});
var _c432 = (a0) => ({
  "k-slot-cell": a0
});
var _c44 = (a0, a1, a2) => ({
  start: a0,
  end: a1,
  isAllDay: false,
  resources: a2
});
function MultiDayViewRendererComponent_tr_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵelement(1, "th", 18);
    ɵɵelementEnd();
  }
}
function MultiDayViewRendererComponent_tr_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr")(1, "th", 27, 8);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0.allDayMessage);
  }
}
function MultiDayViewRendererComponent_tr_19_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r2 = ɵɵnextContext().$implicit;
    const resource_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.getField(item_r2, resource_r3.textField));
  }
}
function MultiDayViewRendererComponent_tr_19_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 30);
  }
  if (rf & 2) {
    const item_r2 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.groupHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c322, item_r2));
  }
}
function MultiDayViewRendererComponent_tr_19_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 18);
    ɵɵtemplate(1, MultiDayViewRendererComponent_tr_19_th_1_ng_container_1_Template, 2, 1, "ng-container", 19)(2, MultiDayViewRendererComponent_tr_19_th_1_ng_container_2_Template, 1, 4, "ng-container", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resourceIndex_r4 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("colspan", ctx_r0.horizontalColspan(resourceIndex_r4));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.groupHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.groupHeaderTemplateRef);
  }
}
function MultiDayViewRendererComponent_tr_19_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, MultiDayViewRendererComponent_tr_19_th_1_Template, 3, 3, "th", 28);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resourceIndex_r4 = ctx.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind2(2, 2, ctx_r0.horizontalResources, resourceIndex_r4))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_21_th_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 32);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const slot_r6 = ctx_r4.$implicit;
    const index_r7 = ctx_r4.index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵattribute("data-dayslot-index", index_r7);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 2, slot_r6.start, ctx_r0.dateFormat));
  }
}
function MultiDayViewRendererComponent_ng_container_21_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 30);
  }
  if (rf & 2) {
    const slot_r6 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.dateHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c182, slot_r6.start));
  }
}
function MultiDayViewRendererComponent_ng_container_21_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 18);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_21_th_1_span_1_Template, 3, 5, "span", 31)(2, MultiDayViewRendererComponent_ng_container_21_th_1_ng_container_2_Template, 1, 4, "ng-container", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.dateHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.dateHeaderTemplateRef);
  }
}
function MultiDayViewRendererComponent_ng_container_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_21_th_1_Template, 3, 2, "th", 28);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.daySlots)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_div_23_ng_container_4_td_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 30);
  }
  if (rf & 2) {
    const slot_r8 = ɵɵnextContext().$implicit;
    const resourceIndex_r9 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.allDaySlotTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c312, slot_r8.start, ctx_r0.resourcesByIndex(resourceIndex_r9)));
  }
}
function MultiDayViewRendererComponent_div_23_ng_container_4_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 35);
    ɵɵtemplate(1, MultiDayViewRendererComponent_div_23_ng_container_4_td_1_ng_container_1_Template, 1, 5, "ng-container", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const slot_r8 = ctx.$implicit;
    const index_r10 = ctx.index;
    const resourceIndex_r9 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassProp("k-selected", ctx_r0.isSlotSelected(ɵɵpureFunction3(7, _c342, ctx_r0.toPlainDate(slot_r8.start), ctx_r0.toPlainDate(slot_r8.end), ctx_r0.resourcesByIndex(resourceIndex_r9))));
    ɵɵproperty("start", slot_r8.start)("end", slot_r8.end)("id", ɵɵpureFunction2(11, _c422, resourceIndex_r9, index_r10))("ngClass", ctx_r0.allDaySlotClass(slot_r8, resourceIndex_r9));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.allDaySlotTemplateRef);
  }
}
function MultiDayViewRendererComponent_div_23_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_div_23_ng_container_4_td_1_Template, 2, 14, "td", 34);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.daySlots)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_div_23_ng_container_6_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 37);
  }
  if (rf & 2) {
    const itemResource_r11 = ctx.$implicit;
    const item_r12 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r0.getEventClasses(item_r12, itemResource_r11.resources, true))("ngStyle", ctx_r0.getEventStyles(item_r12, itemResource_r11, true))("kendoSchedulerFocusIndex", itemResource_r11.leafIdx)("id", item_r12.elementId + "_" + itemResource_r11.leafIdx)("isAllDay", true)("editable", ctx_r0.editable)("eventTemplate", ctx_r0.allDayEventTemplateRef)("item", item_r12)("index", item_r12.index)("rangeIndex", item_r12.rangeIndex)("resources", itemResource_r11.resources)("resourceIndex", itemResource_r11.leafIdx);
  }
}
function MultiDayViewRendererComponent_div_23_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_div_23_ng_container_6_div_1_Template, 1, 12, "div", 36);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r12 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", item_r12.resources)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_div_23_ng_template_10_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 40);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("isAllDay", true)("ngStyle", ctx_r0.dragHints[0].style)("ngClass", ctx_r0.dragHints[0].class)("dragHint", true)("eventTemplate", ctx_r0.eventTemplateRef)("item", ctx_r0.dragHints[0].item)("resources", ctx_r0.dragHints[0].resources);
  }
}
function MultiDayViewRendererComponent_div_23_ng_template_10_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 41);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("hint", ctx_r0.resizeHints[0])("ngClass", ctx_r0.resizeHints[0].class)("format", ctx_r0.allDayResizeHintFormat);
  }
}
function MultiDayViewRendererComponent_div_23_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiDayViewRendererComponent_div_23_ng_template_10_div_0_Template, 1, 7, "div", 38)(1, MultiDayViewRendererComponent_div_23_ng_template_10_div_1_Template, 1, 3, "div", 39);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngIf", ctx_r0.dragHints.length && ctx_r0.allDayDragHint);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.resizeHints.length && ctx_r0.allDayResizeHint);
  }
}
function MultiDayViewRendererComponent_div_23_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "table", 33)(2, "tbody")(3, "tr");
    ɵɵtemplate(4, MultiDayViewRendererComponent_div_23_ng_container_4_Template, 2, 2, "ng-container", 17);
    ɵɵpipe(5, "resourceIterator");
    ɵɵelementEnd()()();
    ɵɵtemplate(6, MultiDayViewRendererComponent_div_23_ng_container_6_Template, 2, 2, "ng-container", 17);
    ɵɵpipe(7, "async");
    ɵɵelementStart(8, "kendo-hint-container", null, 9);
    ɵɵtemplate(10, MultiDayViewRendererComponent_div_23_ng_template_10_Template, 2, 2, "ng-template");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("position", "relative");
    ɵɵadvance(4);
    ɵɵproperty("ngForOf", ɵɵpipeBind1(5, 6, ctx_r0.horizontalResources))("ngForTrackBy", ctx_r0.itemIndex);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ɵɵpipeBind1(7, 8, ctx_r0.allDayItems))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_28_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 43, 10);
  }
}
function MultiDayViewRendererComponent_ng_container_28_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_28_div_1_Template, 2, 0, "div", 42);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 2, ctx_r0.verticalResources))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_1_ng_container_1_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r12 = ɵɵnextContext(2);
    const resource_r14 = ctx_r12.$implicit;
    const resourceIndex_r15 = ctx_r12.index;
    const leafIndex_r16 = ɵɵnextContext(2).index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.getField(ctx_r0.verticalItem(leafIndex_r16, resourceIndex_r15), resource_r14.textField));
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_1_ng_container_1_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 30);
  }
  if (rf & 2) {
    const resourceIndex_r15 = ɵɵnextContext(2).index;
    const leafIndex_r16 = ɵɵnextContext(2).index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.groupHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c322, ctx_r0.verticalItem(leafIndex_r16, resourceIndex_r15)));
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_1_ng_container_1_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 46);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_32_tr_1_ng_container_1_th_1_ng_container_1_Template, 2, 1, "ng-container", 19)(2, MultiDayViewRendererComponent_ng_container_32_tr_1_ng_container_1_th_1_ng_container_2_Template, 1, 4, "ng-container", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resourceIndex_r15 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵattribute("rowspan", ctx_r0.verticalRowspan(resourceIndex_r15));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.groupHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.groupHeaderTemplateRef);
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_32_tr_1_ng_container_1_th_1_Template, 3, 3, "th", 45);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const resourceIndex_r15 = ctx.index;
    const leafIndex_r16 = ɵɵnextContext(2).index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.verticalItem(leafIndex_r16, resourceIndex_r15));
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 27, 8);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.allDayMessage);
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_32_tr_1_ng_container_1_Template, 2, 1, "ng-container", 17)(2, MultiDayViewRendererComponent_ng_container_32_tr_1_th_2_Template, 3, 1, "th", 44);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.verticalResources)("ngForTrackBy", ctx_r0.itemIndex);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.allDaySlot);
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_2_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const slot_r17 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 1, slot_r17.start, "t"));
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_2_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 30);
  }
  if (rf & 2) {
    const slot_r17 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.majorTimeHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c182, slot_r17.start));
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_2_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 48);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_32_tr_2_th_1_ng_container_1_Template, 3, 4, "ng-container", 19)(2, MultiDayViewRendererComponent_ng_container_32_tr_2_th_1_ng_container_2_Template, 1, 4, "ng-container", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c432, ctx_r0.slotDivisions === 1));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.majorTimeHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.majorTimeHeaderTemplateRef);
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_2_th_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 30);
  }
  if (rf & 2) {
    const slot_r17 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.minorTimeHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c182, slot_r17.start));
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_2_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 48);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_32_tr_2_th_2_ng_container_1_Template, 1, 4, "ng-container", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const timeSlotIndex_r18 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(2, _c432, timeSlotIndex_r18 % ctx_r0.slotDivisions === ctx_r0.slotDivisions - 1));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.minorTimeHeaderTemplateRef);
  }
}
function MultiDayViewRendererComponent_ng_container_32_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_32_tr_2_th_1_Template, 3, 5, "th", 47)(2, MultiDayViewRendererComponent_ng_container_32_tr_2_th_2_Template, 2, 4, "th", 47);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const slot_r17 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", slot_r17.isMajor);
    ɵɵadvance();
    ɵɵproperty("ngIf", !slot_r17.isMajor);
  }
}
function MultiDayViewRendererComponent_ng_container_32_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_32_tr_1_Template, 3, 3, "tr", 19)(2, MultiDayViewRendererComponent_ng_container_32_tr_2_Template, 3, 2, "tr", 17);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.verticalResources.length);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.timeSlots)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_38_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 50, 11);
  }
}
function MultiDayViewRendererComponent_ng_container_38_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_38_div_1_Template, 2, 0, "div", 49);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 2, ctx_r0.verticalResources))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_42_tr_1_td_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 30);
  }
  if (rf & 2) {
    const slot_r19 = ɵɵnextContext().$implicit;
    const verticalIndex_r20 = ɵɵnextContext(2).index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.allDaySlotTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c312, slot_r19.start, ctx_r0.resourcesByIndex(verticalIndex_r20)));
  }
}
function MultiDayViewRendererComponent_ng_container_42_tr_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 55);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_42_tr_1_td_1_ng_container_1_Template, 1, 5, "ng-container", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const slot_r19 = ctx.$implicit;
    const index_r21 = ctx.index;
    const verticalIndex_r20 = ɵɵnextContext(2).index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-selected", ctx_r0.isSlotSelected(ɵɵpureFunction3(6, _c342, ctx_r0.toPlainDate(slot_r19.start), ctx_r0.toPlainDate(slot_r19.end), ctx_r0.resourcesByIndex(verticalIndex_r20))));
    ɵɵproperty("start", slot_r19.start)("end", slot_r19.end)("id", ɵɵpureFunction2(10, _c422, verticalIndex_r20, index_r21));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.allDaySlotTemplateRef);
  }
}
function MultiDayViewRendererComponent_ng_container_42_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 53);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_42_tr_1_td_1_Template, 2, 13, "td", 54);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.daySlots)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_42_tr_2_ng_container_1_td_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 30);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const timeSlot_r22 = ɵɵreference(1);
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.timeSlotTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c312, timeSlot_r22.startLocalTime, ctx_r0.resourcesByIndex(timeSlot_r22.id.resourceIndex)));
  }
}
function MultiDayViewRendererComponent_ng_container_42_tr_2_ng_container_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 57, 12);
    ɵɵtemplate(2, MultiDayViewRendererComponent_ng_container_42_tr_2_ng_container_1_td_1_ng_container_2_Template, 1, 5, "ng-container", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const daySlot_r23 = ctx.$implicit;
    const rangeIndex_r24 = ctx.index;
    const horizontalIndex_r25 = ɵɵnextContext().index;
    const ctx_r25 = ɵɵnextContext();
    const slot_r27 = ctx_r25.$implicit;
    const index_r28 = ctx_r25.index;
    const verticalIndex_r20 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-selected", ctx_r0.isSlotSelected(ɵɵpureFunction3(12, _c44, ctx_r0.toPlainDateTime(daySlot_r23.start, slot_r27.start), ctx_r0.toPlainDateTime(daySlot_r23.start, slot_r27.end), ctx_r0.resourcesByIndex(ctx_r0.verticalResources.length ? verticalIndex_r20 : horizontalIndex_r25))));
    ɵɵproperty("ngClass", ctx_r0.timeSlotClass(slot_r27, daySlot_r23.start, ctx_r0.verticalResources.length ? verticalIndex_r20 : horizontalIndex_r25))("date", daySlot_r23.start)("invariantStart", slot_r27.start)("invariantEnd", slot_r27.end)("workDayStart", ctx_r0.workDayStartTime)("workDayEnd", ctx_r0.workDayEndTime)("workWeekStart", ctx_r0.workWeekStart)("workWeekEnd", ctx_r0.workWeekEnd)("id", ɵɵpureFunction3(16, _c352, ctx_r0.verticalResources.length ? verticalIndex_r20 : horizontalIndex_r25, rangeIndex_r24, index_r28));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.timeSlotTemplateRef);
  }
}
function MultiDayViewRendererComponent_ng_container_42_tr_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_42_tr_2_ng_container_1_td_1_Template, 3, 20, "td", 56);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.daySlots)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_42_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_42_tr_2_ng_container_1_Template, 2, 2, "ng-container", 17);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const index_r28 = ctx.index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassProp("k-middle-row", ctx_r0.isMiddleSlot(index_r28));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 4, ctx_r0.horizontalResources))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_42_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_42_tr_1_Template, 2, 2, "tr", 51)(2, MultiDayViewRendererComponent_ng_container_42_tr_2_Template, 3, 6, "tr", 52);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.allDaySlot && ctx_r0.verticalResources.length);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.timeSlots)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_44_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 59);
  }
  if (rf & 2) {
    const itemResource_r29 = ctx.$implicit;
    const item_r30 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.getEventClasses(item_r30, itemResource_r29.resources))("ngStyle", ctx_r0.getEventStyles(item_r30, itemResource_r29))("kendoSchedulerFocusIndex", itemResource_r29.leafIdx)("id", item_r30.elementId + "_" + itemResource_r29.leafIdx)("editable", ctx_r0.editable)("vertical", true)("eventTemplate", ctx_r0.eventTemplateRef)("item", item_r30)("index", item_r30.index)("rangeIndex", item_r30.rangeIndex)("resources", itemResource_r29.resources)("resourceIndex", itemResource_r29.leafIdx);
  }
}
function MultiDayViewRendererComponent_ng_container_44_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_44_div_1_Template, 1, 12, "div", 58);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r30 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", item_r30.resources)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_46_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 37);
  }
  if (rf & 2) {
    const itemResource_r31 = ctx.$implicit;
    const item_r32 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r0.getEventClasses(item_r32, itemResource_r31.resources, true))("ngStyle", ctx_r0.getEventStyles(item_r32, itemResource_r31, true))("kendoSchedulerFocusIndex", itemResource_r31.leafIdx)("id", item_r32.elementId + "_" + itemResource_r31.leafIdx)("isAllDay", true)("editable", ctx_r0.editable)("eventTemplate", ctx_r0.allDayEventTemplateRef)("item", item_r32)("index", item_r32.index)("rangeIndex", item_r32.rangeIndex)("resources", itemResource_r31.resources)("resourceIndex", itemResource_r31.leafIdx);
  }
}
function MultiDayViewRendererComponent_ng_container_46_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_46_ng_container_1_div_1_Template, 1, 12, "div", 36);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r32 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", item_r32.resources)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_container_46_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_container_46_ng_container_1_Template, 2, 2, "ng-container", 17);
    ɵɵpipe(2, "async");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 2, ctx_r0.allDayItems))("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_template_49_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 61);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("isAllDay", ctx_r0.allDayDragHint)("ngStyle", ctx_r0.dragHints[0].style)("ngClass", ctx_r0.dragHints[0].class)("dragHint", true)("eventTemplate", ctx_r0.eventTemplateRef)("resources", ctx_r0.dragHints[0].resources)("item", ctx_r0.dragHints[0].item);
  }
}
function MultiDayViewRendererComponent_ng_template_49_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 41);
  }
  if (rf & 2) {
    const hint_r33 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("hint", hint_r33)("ngClass", hint_r33.class)("format", ctx_r0.allDayResizeHint ? ctx_r0.allDayResizeHintFormat : ctx_r0.resizeHintFormat);
  }
}
function MultiDayViewRendererComponent_ng_template_49_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiDayViewRendererComponent_ng_template_49_ng_container_1_div_1_Template, 1, 3, "div", 62);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.resizeHints)("ngForTrackBy", ctx_r0.itemIndex);
  }
}
function MultiDayViewRendererComponent_ng_template_49_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiDayViewRendererComponent_ng_template_49_div_0_Template, 1, 7, "div", 60)(1, MultiDayViewRendererComponent_ng_template_49_ng_container_1_Template, 2, 2, "ng-container", 19);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r0.dragHints.length && (!ctx_r0.allDayDragHint || ctx_r0.verticalResources.length));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.resizeHints.length && (!ctx_r0.allDayResizeHint || ctx_r0.verticalResources.length));
  }
}
function DayViewComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("itemClick", function DayViewComponent_ng_template_0_div_1_Template_div_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.showWorkHours = !ctx_r1.shouldShowWorkHours);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("showWorkHours", ctx_r1.shouldShowWorkHours);
  }
}
function DayViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "multi-day-view", 1);
    ɵɵtemplate(1, DayViewComponent_ng_template_0_div_1_Template, 1, 1, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.name)("allDaySlot", ctx_r1.viewAllDaySlot)("eventHeight", ctx_r1.viewEventHeight)("currentTimeMarker", ctx_r1.viewCurrentTimeMarker)("highlightOngoingEvents", ctx_r1.viewHighlightOngoingEvents)("showWorkHours", ctx_r1.shouldShowWorkHours)("scrollTime", ctx_r1.viewScrollTime)("startTime", ctx_r1.viewStartTime)("endTime", ctx_r1.viewEndTime)("workDayStart", ctx_r1.viewWorkDayStart)("workDayEnd", ctx_r1.viewWorkDayEnd)("workWeekStart", ctx_r1.viewWorkWeekStart)("workWeekEnd", ctx_r1.viewWorkWeekEnd)("slotDuration", ctx_r1.viewSlotDuration)("slotDivisions", ctx_r1.viewSlotDivisions)("slotFill", ctx_r1.viewSlotFill)("slotClass", ctx_r1.viewSlotClass)("eventClass", ctx_r1.viewEventClass)("eventStyles", ctx_r1.viewEventStyles)("allDaySlotTemplate", ctx_r1.allDaySlotTemplate == null ? null : ctx_r1.allDaySlotTemplate.templateRef)("allDayEventTemplate", ctx_r1.allDayEventTemplate == null ? null : ctx_r1.allDayEventTemplate.templateRef)("eventTemplate", ctx_r1.eventTemplate == null ? null : ctx_r1.eventTemplate.templateRef)("groupHeaderTemplate", ctx_r1.groupHeaderTemplate == null ? null : ctx_r1.groupHeaderTemplate.templateRef)("timeSlotTemplate", ctx_r1.timeSlotTemplate == null ? null : ctx_r1.timeSlotTemplate.templateRef)("minorTimeHeaderTemplate", ctx_r1.minorTimeHeaderTemplate == null ? null : ctx_r1.minorTimeHeaderTemplate.templateRef)("majorTimeHeaderTemplate", ctx_r1.majorTimeHeaderTemplate == null ? null : ctx_r1.majorTimeHeaderTemplate.templateRef)("dateHeaderTemplate", ctx_r1.dateHeaderTemplate == null ? null : ctx_r1.dateHeaderTemplate.templateRef)("selectedDateFormat", ctx_r1.selectedDateFormat)("selectedShortDateFormat", ctx_r1.selectedShortDateFormat);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.viewShowFooter);
  }
}
function MultiDayViewComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("itemClick", function MultiDayViewComponent_ng_template_0_div_1_Template_div_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.showWorkHours = !ctx_r1.shouldShowWorkHours);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("showWorkHours", ctx_r1.shouldShowWorkHours);
  }
}
function MultiDayViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "multi-day-view", 1);
    ɵɵtemplate(1, MultiDayViewComponent_ng_template_0_div_1_Template, 1, 1, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("allDaySlot", ctx_r1.allDaySlot)("name", ctx_r1.name)("numberOfDays", ctx_r1.numberOfDays)("eventHeight", ctx_r1.viewEventHeight)("currentTimeMarker", ctx_r1.viewCurrentTimeMarker)("highlightOngoingEvents", ctx_r1.viewHighlightOngoingEvents)("showWorkHours", ctx_r1.shouldShowWorkHours)("scrollTime", ctx_r1.viewScrollTime)("startTime", ctx_r1.viewStartTime)("endTime", ctx_r1.viewEndTime)("workDayStart", ctx_r1.viewWorkDayStart)("workDayEnd", ctx_r1.viewWorkDayEnd)("workWeekStart", ctx_r1.viewWorkWeekStart)("workWeekEnd", ctx_r1.viewWorkWeekEnd)("slotDuration", ctx_r1.viewSlotDuration)("slotDivisions", ctx_r1.viewSlotDivisions)("slotFill", ctx_r1.viewSlotFill)("slotClass", ctx_r1.viewSlotClass)("eventClass", ctx_r1.viewEventClass)("eventStyles", ctx_r1.viewEventStyles)("allDaySlotTemplate", ctx_r1.allDaySlotTemplate == null ? null : ctx_r1.allDaySlotTemplate.templateRef)("allDayEventTemplate", ctx_r1.allDayEventTemplate == null ? null : ctx_r1.allDayEventTemplate.templateRef)("eventTemplate", ctx_r1.eventTemplate == null ? null : ctx_r1.eventTemplate.templateRef)("groupHeaderTemplate", ctx_r1.groupHeaderTemplate == null ? null : ctx_r1.groupHeaderTemplate.templateRef)("timeSlotTemplate", ctx_r1.timeSlotTemplate == null ? null : ctx_r1.timeSlotTemplate.templateRef)("minorTimeHeaderTemplate", ctx_r1.minorTimeHeaderTemplate == null ? null : ctx_r1.minorTimeHeaderTemplate.templateRef)("majorTimeHeaderTemplate", ctx_r1.majorTimeHeaderTemplate == null ? null : ctx_r1.majorTimeHeaderTemplate.templateRef)("dateHeaderTemplate", ctx_r1.dateHeaderTemplate == null ? null : ctx_r1.dateHeaderTemplate.templateRef)("selectedDateFormat", ctx_r1.selectedDateFormat)("selectedShortDateFormat", ctx_r1.selectedShortDateFormat);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.viewShowFooter);
  }
}
function WeekViewComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("itemClick", function WeekViewComponent_ng_template_0_div_1_Template_div_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.showWorkHours = !ctx_r1.shouldShowWorkHours);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("showWorkHours", ctx_r1.shouldShowWorkHours);
  }
}
function WeekViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "multi-day-view", 1);
    ɵɵtemplate(1, WeekViewComponent_ng_template_0_div_1_Template, 1, 1, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.name)("allDaySlot", ctx_r1.viewAllDaySlot)("numberOfDays", 7)("getStartDate", ctx_r1.getStartDate)("eventHeight", ctx_r1.viewEventHeight)("currentTimeMarker", ctx_r1.viewCurrentTimeMarker)("highlightOngoingEvents", ctx_r1.viewHighlightOngoingEvents)("showWorkHours", ctx_r1.shouldShowWorkHours)("scrollTime", ctx_r1.viewScrollTime)("startTime", ctx_r1.viewStartTime)("endTime", ctx_r1.viewEndTime)("workDayStart", ctx_r1.viewWorkDayStart)("workDayEnd", ctx_r1.viewWorkDayEnd)("workWeekStart", ctx_r1.viewWorkWeekStart)("workWeekEnd", ctx_r1.viewWorkWeekEnd)("weekStart", ctx_r1.viewWeekStart)("slotDuration", ctx_r1.viewSlotDuration)("slotDivisions", ctx_r1.viewSlotDivisions)("slotFill", ctx_r1.viewSlotFill)("slotClass", ctx_r1.viewSlotClass)("eventClass", ctx_r1.viewEventClass)("eventStyles", ctx_r1.viewEventStyles)("allDaySlotTemplate", ctx_r1.allDaySlotTemplate == null ? null : ctx_r1.allDaySlotTemplate.templateRef)("allDayEventTemplate", ctx_r1.allDayEventTemplate == null ? null : ctx_r1.allDayEventTemplate.templateRef)("eventTemplate", ctx_r1.eventTemplate == null ? null : ctx_r1.eventTemplate.templateRef)("groupHeaderTemplate", ctx_r1.groupHeaderTemplate == null ? null : ctx_r1.groupHeaderTemplate.templateRef)("timeSlotTemplate", ctx_r1.timeSlotTemplate == null ? null : ctx_r1.timeSlotTemplate.templateRef)("minorTimeHeaderTemplate", ctx_r1.minorTimeHeaderTemplate == null ? null : ctx_r1.minorTimeHeaderTemplate.templateRef)("majorTimeHeaderTemplate", ctx_r1.majorTimeHeaderTemplate == null ? null : ctx_r1.majorTimeHeaderTemplate.templateRef)("dateHeaderTemplate", ctx_r1.dateHeaderTemplate == null ? null : ctx_r1.dateHeaderTemplate.templateRef)("selectedDateFormat", ctx_r1.selectedDateFormat)("selectedShortDateFormat", ctx_r1.selectedShortDateFormat);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.viewShowFooter);
  }
}
function WorkWeekViewComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("itemClick", function WorkWeekViewComponent_ng_template_0_div_1_Template_div_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.showWorkHours = !ctx_r1.shouldShowWorkHours);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("showWorkHours", ctx_r1.shouldShowWorkHours);
  }
}
function WorkWeekViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "multi-day-view", 1);
    ɵɵtemplate(1, WorkWeekViewComponent_ng_template_0_div_1_Template, 1, 1, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("allDaySlot", ctx_r1.viewAllDaySlot)("name", ctx_r1.name)("numberOfDays", ctx_r1.numberOfDays)("getStartDate", ctx_r1.getStartDate)("getNextDate", ctx_r1.getNextDate)("eventHeight", ctx_r1.viewEventHeight)("currentTimeMarker", ctx_r1.viewCurrentTimeMarker)("highlightOngoingEvents", ctx_r1.viewHighlightOngoingEvents)("showWorkHours", ctx_r1.shouldShowWorkHours)("scrollTime", ctx_r1.viewScrollTime)("startTime", ctx_r1.viewStartTime)("endTime", ctx_r1.viewEndTime)("workDayStart", ctx_r1.viewWorkDayStart)("workDayEnd", ctx_r1.viewWorkDayEnd)("workWeekStart", ctx_r1.viewWorkWeekStart)("workWeekEnd", ctx_r1.viewWorkWeekEnd)("slotDuration", ctx_r1.viewSlotDuration)("slotDivisions", ctx_r1.viewSlotDivisions)("slotFill", ctx_r1.viewSlotFill)("slotClass", ctx_r1.viewSlotClass)("eventClass", ctx_r1.viewEventClass)("eventStyles", ctx_r1.viewEventStyles)("allDaySlotTemplate", ctx_r1.allDaySlotTemplate == null ? null : ctx_r1.allDaySlotTemplate.templateRef)("allDayEventTemplate", ctx_r1.allDayEventTemplate == null ? null : ctx_r1.allDayEventTemplate.templateRef)("eventTemplate", ctx_r1.eventTemplate == null ? null : ctx_r1.eventTemplate.templateRef)("groupHeaderTemplate", ctx_r1.groupHeaderTemplate == null ? null : ctx_r1.groupHeaderTemplate.templateRef)("timeSlotTemplate", ctx_r1.timeSlotTemplate == null ? null : ctx_r1.timeSlotTemplate.templateRef)("minorTimeHeaderTemplate", ctx_r1.minorTimeHeaderTemplate == null ? null : ctx_r1.minorTimeHeaderTemplate.templateRef)("majorTimeHeaderTemplate", ctx_r1.majorTimeHeaderTemplate == null ? null : ctx_r1.majorTimeHeaderTemplate.templateRef)("dateHeaderTemplate", ctx_r1.dateHeaderTemplate == null ? null : ctx_r1.dateHeaderTemplate.templateRef)("selectedDateFormat", ctx_r1.selectedDateFormat)("selectedShortDateFormat", ctx_r1.selectedShortDateFormat);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.viewShowFooter);
  }
}
var _c45 = ["headerTable"];
var _c46 = ["verticalResourceRows"];
var _c47 = () => ({
  "border-left-color": "transparent",
  "border-right-color": "transparent"
});
function TimelineMultiDayViewComponent_tr_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵelement(1, "th", 18);
    ɵɵelementEnd();
  }
}
function TimelineMultiDayViewComponent_ng_container_18_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 29, 9);
  }
}
function TimelineMultiDayViewComponent_ng_container_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_18_div_1_Template, 2, 0, "div", 28);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 2, ctx_r1.horizontalResources))("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_tr_22_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    const resource_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getField(item_r3, resource_r4.textField));
  }
}
function TimelineMultiDayViewComponent_tr_22_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 32);
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.groupHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c322, item_r3));
  }
}
function TimelineMultiDayViewComponent_tr_22_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 19);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_tr_22_th_1_ng_container_1_Template, 2, 1, "ng-container", 23)(2, TimelineMultiDayViewComponent_tr_22_th_1_ng_container_2_Template, 1, 4, "ng-container", 31);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resourceIndex_r5 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("colspan", ctx_r1.horizontalColspan(resourceIndex_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.groupHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.groupHeaderTemplateRef);
  }
}
function TimelineMultiDayViewComponent_tr_22_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, TimelineMultiDayViewComponent_tr_22_th_1_Template, 3, 3, "th", 30);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const resourceIndex_r5 = ctx.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind2(2, 2, ctx_r1.horizontalResources, resourceIndex_r5))("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_ng_container_24_ng_container_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 35);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const daySlot_r7 = ctx_r5.$implicit;
    const index_r8 = ctx_r5.index;
    ɵɵattribute("data-dayslot-index", index_r8);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 2, daySlot_r7.start, "m"));
  }
}
function TimelineMultiDayViewComponent_ng_container_24_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 32);
  }
  if (rf & 2) {
    const daySlot_r7 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.dateHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c182, daySlot_r7.start));
  }
}
function TimelineMultiDayViewComponent_ng_container_24_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "th", 33);
    ɵɵtemplate(2, TimelineMultiDayViewComponent_ng_container_24_ng_container_1_span_2_Template, 3, 5, "span", 34)(3, TimelineMultiDayViewComponent_ng_container_24_ng_container_1_ng_container_3_Template, 1, 4, "ng-container", 31);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵattribute("colspan", ctx_r1.timeSlots.length);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.dateHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.dateHeaderTemplateRef);
  }
}
function TimelineMultiDayViewComponent_ng_container_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_24_ng_container_1_Template, 4, 3, "ng-container", 20);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.daySlots)("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵpipe(2, "kendoDate");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const timeSlot_r9 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 1, timeSlot_r9.start, "t"));
  }
}
function TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 32);
  }
  if (rf & 2) {
    const timeSlot_r9 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.majorTimeHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c182, timeSlot_r9.start));
  }
}
function TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 18);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_th_1_ng_container_1_Template, 3, 4, "ng-container", 23)(2, TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_th_1_ng_container_2_Template, 1, 4, "ng-container", 31);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const index_r10 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵattribute("colspan", ctx_r1.timeColspan(index_r10));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.majorTimeHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.majorTimeHeaderTemplateRef);
  }
}
function TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 38);
    ɵɵelementContainer(1, 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const timeSlot_r9 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("ngStyle", ɵɵpureFunction0(3, _c47));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.minorTimeHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c182, timeSlot_r9.start));
  }
}
function TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_th_1_Template, 3, 3, "th", 36)(2, TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_th_2_Template, 2, 6, "th", 37);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const timeSlot_r9 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", timeSlot_r9.isMajor);
    ɵɵadvance();
    ɵɵproperty("ngIf", !timeSlot_r9.isMajor && ctx_r1.minorTimeHeaderTemplateRef);
  }
}
function TimelineMultiDayViewComponent_ng_container_27_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_27_ng_container_1_ng_container_1_Template, 3, 2, "ng-container", 20);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.timeSlots)("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_ng_container_27_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_27_ng_container_1_Template, 2, 2, "ng-container", 20);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.daySlots)("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_tr_36_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr")(1, "th", 39, 10);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r1.allEventsMessage, " ");
  }
}
function TimelineMultiDayViewComponent_ng_container_37_ng_container_1_ng_container_3_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(2);
    const resource_r12 = ctx_r10.$implicit;
    const resourceIndex_r13 = ctx_r10.index;
    const leafIndex_r14 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getField(ctx_r1.verticalItem(leafIndex_r14, resourceIndex_r13), resource_r12.textField));
  }
}
function TimelineMultiDayViewComponent_ng_container_37_ng_container_1_ng_container_3_th_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 32);
  }
  if (rf & 2) {
    const resourceIndex_r13 = ɵɵnextContext(2).index;
    const leafIndex_r14 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.groupHeaderTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c322, ctx_r1.verticalItem(leafIndex_r14, resourceIndex_r13)));
  }
}
function TimelineMultiDayViewComponent_ng_container_37_ng_container_1_ng_container_3_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 19)(1, "div");
    ɵɵtemplate(2, TimelineMultiDayViewComponent_ng_container_37_ng_container_1_ng_container_3_th_1_ng_container_2_Template, 2, 1, "ng-container", 23)(3, TimelineMultiDayViewComponent_ng_container_37_ng_container_1_ng_container_3_th_1_ng_container_3_Template, 1, 4, "ng-container", 31);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const resourceIndex_r13 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵattribute("rowspan", ctx_r1.verticalRowspan(resourceIndex_r13));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r1.groupHeaderTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.groupHeaderTemplateRef);
  }
}
function TimelineMultiDayViewComponent_ng_container_37_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_37_ng_container_1_ng_container_3_th_1_Template, 4, 3, "th", 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const resourceIndex_r13 = ctx.index;
    const leafIndex_r14 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.verticalItem(leafIndex_r14, resourceIndex_r13));
  }
}
function TimelineMultiDayViewComponent_ng_container_37_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "tr", null, 11);
    ɵɵtemplate(3, TimelineMultiDayViewComponent_ng_container_37_ng_container_1_ng_container_3_Template, 2, 1, "ng-container", 20);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.verticalResources)("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_ng_container_37_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_37_ng_container_1_Template, 4, 2, "ng-container", 20);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 2, ctx_r1.verticalResources))("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_ng_container_43_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 42, 12);
  }
}
function TimelineMultiDayViewComponent_ng_container_43_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_43_div_1_Template, 2, 0, "div", 41);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 2, ctx_r1.horizontalResources))("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_tr_47_ng_container_1_ng_container_1_td_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 32);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const timeSlot_r15 = ɵɵreference(1);
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.timeSlotTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c312, timeSlot_r15.startLocalTime, ctx_r1.resourcesByIndex(timeSlot_r15.id.resourceIndex)));
  }
}
function TimelineMultiDayViewComponent_tr_47_ng_container_1_ng_container_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 44, 13);
    ɵɵtemplate(2, TimelineMultiDayViewComponent_tr_47_ng_container_1_ng_container_1_td_1_ng_container_2_Template, 1, 5, "ng-container", 31);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const slot_r16 = ctx.$implicit;
    const index_r17 = ctx.index;
    const ctx_r17 = ɵɵnextContext();
    const daySlot_r19 = ctx_r17.$implicit;
    const rangeIndex_r20 = ctx_r17.index;
    const horizontalIndex_r21 = ɵɵnextContext().index;
    const verticalIndex_r22 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("k-selected", ctx_r1.isSlotSelected(ɵɵpureFunction3(12, _c44, ctx_r1.toPlainDateTime(daySlot_r19.start, slot_r16.start), ctx_r1.toPlainDateTime(daySlot_r19.start, slot_r16.end), ctx_r1.resourcesByIndex(ctx_r1.verticalResources.length ? verticalIndex_r22 : horizontalIndex_r21))));
    ɵɵproperty("ngClass", ctx_r1.timeSlotClass(slot_r16, daySlot_r19.start, ctx_r1.verticalResources.length ? verticalIndex_r22 : horizontalIndex_r21))("date", daySlot_r19.start)("invariantStart", slot_r16.start)("invariantEnd", slot_r16.end)("workDayStart", ctx_r1.workDayStartTime)("workDayEnd", ctx_r1.workDayEndTime)("workWeekStart", ctx_r1.workWeekStart)("workWeekEnd", ctx_r1.workWeekEnd)("id", ɵɵpureFunction3(16, _c352, ctx_r1.verticalResources.length ? verticalIndex_r22 : horizontalIndex_r21, rangeIndex_r20, index_r17));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.timeSlotTemplateRef);
  }
}
function TimelineMultiDayViewComponent_tr_47_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_tr_47_ng_container_1_ng_container_1_td_1_Template, 3, 20, "td", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.timeSlots)("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_tr_47_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_tr_47_ng_container_1_ng_container_1_Template, 2, 2, "ng-container", 20);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.daySlots)("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_tr_47_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, TimelineMultiDayViewComponent_tr_47_ng_container_1_Template, 2, 2, "ng-container", 20);
    ɵɵpipe(2, "resourceIterator");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 2, ctx_r1.horizontalResources))("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_ng_container_49_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 46);
  }
  if (rf & 2) {
    const itemResource_r23 = ctx.$implicit;
    const item_r24 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r1.getEventClasses(item_r24, itemResource_r23.resources))("ngStyle", ctx_r1.getEventStyles(item_r24, itemResource_r23))("kendoSchedulerFocusIndex", itemResource_r23.leafIdx)("id", item_r24.elementId + "_" + itemResource_r23.leafIdx)("editable", ctx_r1.editable)("item", item_r24)("index", item_r24.index)("rangeIndex", item_r24.rangeIndex)("eventTemplate", ctx_r1.eventTemplateRef)("resources", itemResource_r23.resources)("resourceIndex", itemResource_r23.leafIdx);
  }
}
function TimelineMultiDayViewComponent_ng_container_49_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TimelineMultiDayViewComponent_ng_container_49_div_1_Template, 1, 11, "div", 45);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r24 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", item_r24.resources)("ngForTrackBy", ctx_r1.itemIndex);
  }
}
function TimelineMultiDayViewComponent_ng_template_54_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 49);
  }
  if (rf & 2) {
    const hint_r25 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", hint_r25.style)("ngClass", hint_r25.class)("dragHint", true)("eventTemplate", ctx_r1.eventTemplateRef)("item", hint_r25.item)("resources", hint_r25.resources);
  }
}
function TimelineMultiDayViewComponent_ng_template_54_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 50);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("hint", ctx_r1.resizeHints[0])("ngClass", ctx_r1.resizeHints[0].class)("format", ctx_r1.resizeHintFormat);
  }
}
function TimelineMultiDayViewComponent_ng_template_54_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimelineMultiDayViewComponent_ng_template_54_div_0_Template, 1, 6, "div", 47)(1, TimelineMultiDayViewComponent_ng_template_54_div_1_Template, 1, 3, "div", 48);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r1.dragHints)("ngForTrackBy", ctx_r1.itemIndex);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.resizeHints && ctx_r1.resizeHints.length);
  }
}
function TimelineMonthViewComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("itemClick", function TimelineMonthViewComponent_ng_template_0_div_1_Template_div_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.showWorkHours = !ctx_r1.shouldShowWorkHours);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("showWorkHours", ctx_r1.shouldShowWorkHours);
  }
}
function TimelineMonthViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "timeline-multi-day-view", 1);
    ɵɵtemplate(1, TimelineMonthViewComponent_ng_template_0_div_1_Template, 1, 1, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.name)("getNextDate", ctx_r1.getNextDate)("getStartDate", ctx_r1.getStartDate)("getEndDate", ctx_r1.getEndDate)("eventHeight", ctx_r1.viewEventHeight)("columnWidth", ctx_r1.viewColumnWidth)("currentTimeMarker", ctx_r1.viewCurrentTimeMarker)("highlightOngoingEvents", ctx_r1.viewHighlightOngoingEvents)("showWorkHours", ctx_r1.shouldShowWorkHours)("scrollTime", ctx_r1.viewScrollTime)("startTime", ctx_r1.viewStartTime)("endTime", ctx_r1.viewEndTime)("workDayStart", ctx_r1.viewWorkDayStart)("workDayEnd", ctx_r1.viewWorkDayEnd)("workWeekStart", ctx_r1.viewWorkWeekStart)("workWeekEnd", ctx_r1.viewWorkWeekEnd)("slotDuration", ctx_r1.viewSlotDuration)("slotDivisions", ctx_r1.viewSlotDivisions)("slotClass", ctx_r1.viewSlotClass)("eventClass", ctx_r1.viewEventClass)("eventStyles", ctx_r1.viewEventStyles)("eventTemplate", ctx_r1.eventTemplate == null ? null : ctx_r1.eventTemplate.templateRef)("groupHeaderTemplate", ctx_r1.groupHeaderTemplate == null ? null : ctx_r1.groupHeaderTemplate.templateRef)("timeSlotTemplate", ctx_r1.timeSlotTemplate == null ? null : ctx_r1.timeSlotTemplate.templateRef)("dateHeaderTemplate", ctx_r1.dateHeaderTemplate == null ? null : ctx_r1.dateHeaderTemplate.templateRef)("majorTimeHeaderTemplate", ctx_r1.majorTimeHeaderTemplate == null ? null : ctx_r1.majorTimeHeaderTemplate.templateRef)("minorTimeHeaderTemplate", ctx_r1.minorTimeHeaderTemplate == null ? null : ctx_r1.minorTimeHeaderTemplate.templateRef)("selectedDateFormat", ctx_r1.selectedDateFormat)("selectedShortDateFormat", ctx_r1.selectedShortDateFormat);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.viewShowFooter);
  }
}
function TimelineViewComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("itemClick", function TimelineViewComponent_ng_template_0_div_1_Template_div_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.showWorkHours = !ctx_r1.shouldShowWorkHours);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("showWorkHours", ctx_r1.shouldShowWorkHours);
  }
}
function TimelineViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "timeline-multi-day-view", 1);
    ɵɵtemplate(1, TimelineViewComponent_ng_template_0_div_1_Template, 1, 1, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.name)("numberOfDays", ctx_r1.numberOfDays)("eventHeight", ctx_r1.viewEventHeight)("columnWidth", ctx_r1.viewColumnWidth)("currentTimeMarker", ctx_r1.viewCurrentTimeMarker)("highlightOngoingEvents", ctx_r1.viewHighlightOngoingEvents)("showWorkHours", ctx_r1.shouldShowWorkHours)("scrollTime", ctx_r1.viewScrollTime)("startTime", ctx_r1.viewStartTime)("endTime", ctx_r1.viewEndTime)("workDayStart", ctx_r1.viewWorkDayStart)("workDayEnd", ctx_r1.viewWorkDayEnd)("workWeekStart", ctx_r1.viewWorkWeekStart)("workWeekEnd", ctx_r1.viewWorkWeekEnd)("slotDuration", ctx_r1.viewSlotDuration)("slotDivisions", ctx_r1.viewSlotDivisions)("slotClass", ctx_r1.viewSlotClass)("eventClass", ctx_r1.viewEventClass)("eventStyles", ctx_r1.viewEventStyles)("eventTemplate", ctx_r1.eventTemplate == null ? null : ctx_r1.eventTemplate.templateRef)("groupHeaderTemplate", ctx_r1.groupHeaderTemplate == null ? null : ctx_r1.groupHeaderTemplate.templateRef)("timeSlotTemplate", ctx_r1.timeSlotTemplate == null ? null : ctx_r1.timeSlotTemplate.templateRef)("majorTimeHeaderTemplate", ctx_r1.majorTimeHeaderTemplate == null ? null : ctx_r1.majorTimeHeaderTemplate.templateRef)("minorTimeHeaderTemplate", ctx_r1.minorTimeHeaderTemplate == null ? null : ctx_r1.minorTimeHeaderTemplate.templateRef)("dateHeaderTemplate", ctx_r1.dateHeaderTemplate == null ? null : ctx_r1.dateHeaderTemplate.templateRef)("selectedDateFormat", ctx_r1.selectedDateFormat)("selectedShortDateFormat", ctx_r1.selectedShortDateFormat);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.viewShowFooter);
  }
}
function TimelineWeekViewComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("itemClick", function TimelineWeekViewComponent_ng_template_0_div_1_Template_div_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.showWorkHours = !ctx_r1.shouldShowWorkHours);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("showWorkHours", ctx_r1.shouldShowWorkHours);
  }
}
function TimelineWeekViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "timeline-multi-day-view", 1);
    ɵɵtemplate(1, TimelineWeekViewComponent_ng_template_0_div_1_Template, 1, 1, "div", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.name)("numberOfDays", 7 * ctx_r1.numberOfWeeks)("getStartDate", ctx_r1.getStartDate)("eventHeight", ctx_r1.viewEventHeight)("columnWidth", ctx_r1.viewColumnWidth)("currentTimeMarker", ctx_r1.viewCurrentTimeMarker)("highlightOngoingEvents", ctx_r1.viewHighlightOngoingEvents)("showWorkHours", ctx_r1.shouldShowWorkHours)("scrollTime", ctx_r1.viewScrollTime)("startTime", ctx_r1.viewStartTime)("endTime", ctx_r1.viewEndTime)("workDayStart", ctx_r1.viewWorkDayStart)("workDayEnd", ctx_r1.viewWorkDayEnd)("workWeekStart", ctx_r1.viewWorkWeekStart)("workWeekEnd", ctx_r1.viewWorkWeekEnd)("weekStart", ctx_r1.viewWeekStart)("slotDuration", ctx_r1.viewSlotDuration)("slotDivisions", ctx_r1.viewSlotDivisions)("slotClass", ctx_r1.viewSlotClass)("eventClass", ctx_r1.viewEventClass)("eventStyles", ctx_r1.viewEventStyles)("eventTemplate", ctx_r1.eventTemplate == null ? null : ctx_r1.eventTemplate.templateRef)("groupHeaderTemplate", ctx_r1.groupHeaderTemplate == null ? null : ctx_r1.groupHeaderTemplate.templateRef)("timeSlotTemplate", ctx_r1.timeSlotTemplate == null ? null : ctx_r1.timeSlotTemplate.templateRef)("dateHeaderTemplate", ctx_r1.dateHeaderTemplate == null ? null : ctx_r1.dateHeaderTemplate.templateRef)("majorTimeHeaderTemplate", ctx_r1.majorTimeHeaderTemplate == null ? null : ctx_r1.majorTimeHeaderTemplate.templateRef)("minorTimeHeaderTemplate", ctx_r1.minorTimeHeaderTemplate == null ? null : ctx_r1.minorTimeHeaderTemplate.templateRef)("selectedDateFormat", ctx_r1.selectedDateFormat)("selectedShortDateFormat", ctx_r1.selectedShortDateFormat);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.viewShowFooter);
  }
}
var _c48 = () => ({
  horizontal: "flip",
  vertical: "flip"
});
function YearViewInternalComponent_ng_template_4_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r2 = ɵɵnextContext().$implicit;
    ɵɵattribute("date", date_r2);
    ɵɵadvance();
    ɵɵtextInterpolate(date_r2.getDate());
  }
}
function YearViewInternalComponent_ng_template_4_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 8);
  }
}
function YearViewInternalComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, YearViewInternalComponent_ng_template_4_span_0_Template, 2, 2, "span", 6)(1, YearViewInternalComponent_ng_template_4_span_1_Template, 1, 0, "span", 7);
  }
  if (rf & 2) {
    const date_r2 = ctx.$implicit;
    const context_r3 = ctx.cellContext;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ngIf", !context_r3.isOtherMonth);
    ɵɵadvance();
    ɵɵproperty("ngIf", !context_r3.isOtherMonth && ctx_r3.hasEvent(date_r2));
  }
}
function YearViewInternalComponent_ng_template_5_div_7_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 21);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("name", ctx_r3.arrowIcons[0])("svgIcon", ctx_r3.arrowSVGIcons[0]);
  }
}
function YearViewInternalComponent_ng_template_5_div_7_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 22);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r7 = ɵɵnextContext().$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.intl.formatDate(event_r7.start, "t"));
  }
}
function YearViewInternalComponent_ng_template_5_div_7_kendo_icon_wrapper_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 21);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("name", ctx_r3.arrowIcons[1])("svgIcon", ctx_r3.arrowSVGIcons[1]);
  }
}
function YearViewInternalComponent_ng_template_5_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16);
    ɵɵtemplate(1, YearViewInternalComponent_ng_template_5_div_7_kendo_icon_wrapper_1_Template, 1, 2, "kendo-icon-wrapper", 17);
    ɵɵelementStart(2, "div", 18);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelement(4, "span", 19);
    ɵɵtemplate(5, YearViewInternalComponent_ng_template_5_div_7_span_5_Template, 2, 1, "span", 20)(6, YearViewInternalComponent_ng_template_5_div_7_kendo_icon_wrapper_6_Template, 1, 2, "kendo-icon-wrapper", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r7 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("title", ctx_r3.eventTitle(event_r7))("ngClass", ctx_r3.getEventClasses(event_r7, event_r7.resources))("ngStyle", ctx_r3.getEventStyles(event_r7, event_r7.resources[0], event_r7.isAllDay));
    ɵɵadvance();
    ɵɵproperty("ngIf", event_r7.tail || event_r7.mid);
    ɵɵadvance(2);
    ɵɵtextInterpolate(event_r7.event.title);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", event_r7.isMultiDay && event_r7.head && !event_r7.isAllDay || !event_r7.isMultiDay);
    ɵɵadvance();
    ɵɵproperty("ngIf", event_r7.head || event_r7.mid);
  }
}
function YearViewInternalComponent_ng_template_5_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 23);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.localization.get("yearViewNoEvents"), " ");
  }
}
function YearViewInternalComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9);
    ɵɵlistener("click", function YearViewInternalComponent_ng_template_5_Template_div_click_0_listener() {
      const anchor_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.navigateToDay(ctx_r3.getDate(anchor_r6)));
    })("mousedown", function YearViewInternalComponent_ng_template_5_Template_div_mousedown_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onMouseDown());
    });
    ɵɵelementStart(1, "div", 10);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 11);
    ɵɵtext(4);
    ɵɵelementEnd()();
    ɵɵelementStart(5, "div", 12);
    ɵɵlistener("mousedown", function YearViewInternalComponent_ng_template_5_Template_div_mousedown_5_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onMouseDown());
    });
    ɵɵelementStart(6, "div", 13);
    ɵɵtemplate(7, YearViewInternalComponent_ng_template_5_div_7_Template, 7, 7, "div", 14);
    ɵɵelementEnd()();
    ɵɵtemplate(8, YearViewInternalComponent_ng_template_5_div_8_Template, 2, 1, "div", 15);
  }
  if (rf & 2) {
    const anchor_r6 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.intl.formatDate(ctx_r3.getDate(anchor_r6), "MMM"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.intl.formatDate(ctx_r3.getDate(anchor_r6), "dd"));
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r3.eventsPerSelectedDay);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.eventsPerSelectedDay.length === 0);
  }
}
function YearViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "year-view-internal", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("selectedDateFormat", ctx_r0.selectedDateFormat)("selectedShortDateFormat", ctx_r0.selectedShortDateFormat)("slotClass", ctx_r0.viewSlotClass)("eventClass", ctx_r0.viewEventClass)("eventStyles", ctx_r0.viewEventStyles)("dateRangeFn", ctx_r0.dateRange)("newRange", ctx_r0.newRange);
  }
}
var packageMetadata3 = {
  name: "@progress/kendo-angular-scheduler",
  productName: "Kendo UI for Angular",
  productCodes: ["KENDOUIANGULAR", "KENDOUICOMPLETE"],
  publishDate: 1733732753,
  version: "17.1.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var DateChangeEvent = class {
  /**
   * The currently selected date of the Scheduler.
   */
  selectedDate;
  /**
   * The date range of the current view.
   */
  dateRange;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, selectedDate, dateRange) {
    this.sender = sender;
    this.selectedDate = selectedDate;
    this.dateRange = dateRange;
  }
};
var NavigateEvent = class extends PreventableEvent2 {
  /**
   * The navigation action that triggered the event.
   */
  action;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, action) {
    super();
    this.sender = sender;
    this.action = action;
  }
};
var SlotClickEvent = class {
  /**
   * The event type.
   */
  type;
  /**
   * The start date of the slot.
   */
  start;
  /**
   * The end date of the slot.
   */
  end;
  /**
   * Indicates if the slot is all-day.
   */
  isAllDay;
  /**
   * The resources of the slot.
   */
  resources;
  /**
   * The original DOM event.
   */
  originalEvent;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    this.sender = sender;
    Object.assign(this, args);
  }
};
var EventClickEvent = class {
  /**
   * The event type.
   */
  type;
  /**
   * The original Scheduler event.
   */
  event;
  /**
   * The original DOM event.
   */
  originalEvent;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    this.sender = sender;
    Object.assign(this, args);
  }
};
var EventKeydownEvent = class {
  /**
   * The original Scheduler event.
   */
  event;
  /**
   * The original DOM event.
   */
  originalEvent;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    this.sender = sender;
    Object.assign(this, args);
  }
};
var CreateEvent = class {
  /**
   * The start date of the slot.
   */
  start;
  /**
   * The end date of the slot.
   */
  end;
  /**
   * Indicates if the slot is all-day.
   */
  isAllDay;
  /**
   * The resources of the slot.
   */
  resources;
  /**
   * The original DOM event.
   */
  originalEvent;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    this.sender = sender;
    Object.assign(this, args);
  }
};
var PreventableEvent3 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses
   * the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented
   * by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var DragEndEvent = class extends PreventableEvent3 {
  /**
   * The original Scheduler event.
   */
  event;
  /**
   * The `isAllDay` value.
   */
  isAllDay;
  /**
   * The data item of the event.
   */
  dataItem;
  /**
   * The new start date of the event.
   */
  start;
  /**
   * The new end date of the event.
   */
  end;
  /**
   * The resources when ending the dragging.
   */
  resources;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var DragEvent = class extends PreventableEvent3 {
  /**
   * The original Scheduler event.
   */
  event;
  /**
   * The current `isAllDay` value.
   */
  isAllDay;
  /**
   * The data item of the event.
   */
  dataItem;
  /**
   * The new start date of the event.
   */
  start;
  /**
   * The new end date of the event.
   */
  end;
  /**
   * The current resources while dragging.
   */
  resources;
  /**
   * Sets the class to the drag hint ([see example]({% slug restrictions_scheduler %})).
   */
  setHintClass;
  /**
   * Sets the class to the slot over which the event is dragged.
   */
  setSlotClass;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var DragStartEvent = class extends PreventableEvent3 {
  /**
   * The original Scheduler event.
   */
  event;
  /**
   * The data item of the event.
   */
  dataItem;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var RemoveEvent = class extends PreventableEvent3 {
  /**
   * The event data item whose **Remove** icon is clicked.
   */
  dataItem;
  /**
   * The event whose **Remove** icon is clicked.
   */
  event;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var ResizeEndEvent = class extends PreventableEvent3 {
  /**
   * The original Scheduler event.
   */
  event;
  /**
   * The data item of the event.
   */
  dataItem;
  /**
   * The new start date of the event.
   */
  start;
  /**
   * The new end date of the event.
   */
  end;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var ResizeEvent = class extends PreventableEvent3 {
  /**
   * The original Scheduler event.
   */
  event;
  /**
   * The data item of the event.
   */
  dataItem;
  /**
   * The new start date of the event.
   */
  start;
  /**
   * The new end date of the event.
   */
  end;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * Sets the class to the resize hint ([see example]({% slug restrictions_scheduler %})).
   */
  setHintClass;
  /**
   * Sets the class to the slot over which the event is resized.
   */
  setSlotClass;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var ResizeStartEvent = class extends PreventableEvent3 {
  /**
   * The original Scheduler event.
   */
  event;
  /**
   * The data item of the event.
   */
  dataItem;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var VIEW_EVENT_MAP = {
  slotClick: SlotClickEvent,
  slotDblClick: SlotClickEvent,
  eventClick: EventClickEvent,
  eventDblClick: EventClickEvent,
  eventKeydown: EventKeydownEvent,
  create: CreateEvent,
  remove: RemoveEvent,
  resizeStart: ResizeStartEvent,
  resize: ResizeEvent,
  resizeEnd: ResizeEndEvent,
  dragStart: DragStartEvent,
  drag: DragEvent,
  dragEnd: DragEndEvent
};
var EditEventBase = class {
  /**
   * Indicates if the event is new or existing.
   */
  isNew;
  /**
   * The edited data item.
   */
  dataItem;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * The type of the action that triggered the event.
   */
  action;
  /**
   * @hidden
   */
  constructor(sender, args) {
    this.sender = sender;
    Object.assign(this, args);
  }
};
var CancelEvent = class extends EditEventBase {
  /**
   * The edited `formGroup` instance.
   */
  formGroup;
};
var SaveEvent = class extends EditEventBase {
  /**
   * The edited `formGroup` instance.
   */
  formGroup;
  /**
   * The selected edit mode.
   */
  mode;
};
var EditEvent = class extends PreventableEvent3 {
  /**
   * The event data item for which the **Edit** dialog will be opened.
   */
  dataItem;
  /**
   * The event for which the **Edit** dialog will be opened.
   */
  event;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var AddEvent = class extends PreventableEvent3 {
  /**
   * The data for binding the **Add** dialog.
   */
  dataItem;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var SlotDragStartEvent = class extends PreventableEvent3 {
  /**
   * The start date of the slot selection.
   */
  start;
  /**
   * The end date of the slot selection.
   */
  end;
  /**
   * Indicates if the slot selection consists of all-day slots, or of time slots.
   */
  isAllDay;
  /**
   * The resources for the slot, if grouping by resource; otherwise all Scheduler resources.
   */
  resources;
  /**
   * The original DOM event.
   */
  originalEvent;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    super();
    this.sender = sender;
    Object.assign(this, args);
  }
};
var SlotDragEvent = class {
  /**
   * The start date of the slot selection.
   */
  start;
  /**
   * The end date of the slot selection.
   */
  end;
  /**
   * Indicates if the slot selection consists of all-day slots, or of time slots.
   */
  isAllDay;
  /**
   * The resources for the slot, if grouping by resource; otherwise all Scheduler resources.
   */
  resources;
  /**
   * The original DOM event.
   */
  originalEvent;
  /**
   * A reference to the Scheduler instance that triggered the event.
   */
  sender;
  /**
   * @hidden
   */
  constructor(sender, args) {
    this.sender = sender;
    Object.assign(this, args);
  }
};
var SlotDragEndEvent = class extends SlotDragEvent {
};
var ToolbarTemplateDirective = class _ToolbarTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ToolbarTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ToolbarTemplateDirective,
    selectors: [["", "kendoSchedulerToolbarTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerToolbarTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ToolbarService = class _ToolbarService {
  /**
   * A stream of navigation actions that is intended for consumption by the toolbar.
   *
   * @hidden
   */
  action;
  /**
   * The context for the built-in navigation components.
   *
   * @hidden
   */
  context;
  actionSource = new Subject();
  /** @hidden */
  constructor() {
    this.action = this.actionSource.asObservable();
  }
  /**
   * Emits the specified navigation action.
   *
   * @param action - The navigation action that will be executed.
   */
  navigate(action) {
    this.actionSource.next(action);
  }
  static ɵfac = function ToolbarService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ToolbarService,
    factory: _ToolbarService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var SchedulerView = class {
};
var EditMode;
(function(EditMode2) {
  EditMode2[EditMode2["Event"] = 0] = "Event";
  EditMode2[EditMode2["Occurrence"] = 1] = "Occurrence";
  EditMode2[EditMode2["Series"] = 2] = "Series";
})(EditMode || (EditMode = {}));
var CrudOperation;
(function(CrudOperation2) {
  CrudOperation2[CrudOperation2["Edit"] = 0] = "Edit";
  CrudOperation2[CrudOperation2["Remove"] = 1] = "Remove";
})(CrudOperation || (CrudOperation = {}));
var IsSlotSelectedArgs = class {
  /**
   * The start date of the slot.
   */
  start;
  /**
   * The end date of the slot.
   */
  end;
  /**
   * Indicates if the slot is an all-day slot, or a time slot.
   */
  isAllDay;
  /**
   * The resources for the slot, if grouping by resource; otherwise all Scheduler resources.
   */
  resources;
};
var slotDragEventName;
(function(slotDragEventName2) {
  slotDragEventName2["initDragSelect"] = "initDragSelect";
  slotDragEventName2["dragSelect"] = "dragSelect";
  slotDragEventName2["refreshSlotSelection"] = "refreshSlotSelection";
  slotDragEventName2["dragSelectRelease"] = "dragSelectRelease";
})(slotDragEventName || (slotDragEventName = {}));
var AgendaDateTemplateDirective = class _AgendaDateTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AgendaDateTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AgendaDateTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AgendaDateTemplateDirective,
    selectors: [["", "kendoSchedulerAgendaDateTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AgendaDateTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerAgendaDateTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var AgendaTimeTemplateDirective = class _AgendaTimeTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AgendaTimeTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AgendaTimeTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AgendaTimeTemplateDirective,
    selectors: [["", "kendoSchedulerAgendaTimeTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AgendaTimeTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerAgendaTimeTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var AllDayEventTemplateDirective = class _AllDayEventTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AllDayEventTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AllDayEventTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AllDayEventTemplateDirective,
    selectors: [["", "kendoSchedulerAllDayEventTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AllDayEventTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerAllDayEventTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var AllDaySlotTemplateDirective = class _AllDaySlotTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function AllDaySlotTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AllDaySlotTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AllDaySlotTemplateDirective,
    selectors: [["", "kendoSchedulerAllDaySlotTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AllDaySlotTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerAllDaySlotTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DateHeaderTemplateDirective = class _DateHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DateHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DateHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateHeaderTemplateDirective,
    selectors: [["", "kendoSchedulerDateHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerDateHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var EventTemplateDirective = class _EventTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function EventTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EventTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EventTemplateDirective,
    selectors: [["", "kendoSchedulerEventTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerEventTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupHeaderTemplateDirective = class _GroupHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupHeaderTemplateDirective,
    selectors: [["", "kendoSchedulerGroupHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerGroupHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var MajorTimeHeaderTemplateDirective = class _MajorTimeHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MajorTimeHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MajorTimeHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MajorTimeHeaderTemplateDirective,
    selectors: [["", "kendoSchedulerMajorTimeHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MajorTimeHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerMajorTimeHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var MinorTimeHeaderTemplateDirective = class _MinorTimeHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MinorTimeHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MinorTimeHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MinorTimeHeaderTemplateDirective,
    selectors: [["", "kendoSchedulerMinorTimeHeaderTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinorTimeHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerMinorTimeHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var MonthDaySlotTemplateDirective = class _MonthDaySlotTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MonthDaySlotTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthDaySlotTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MonthDaySlotTemplateDirective,
    selectors: [["", "kendoSchedulerMonthDaySlotTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthDaySlotTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerMonthDaySlotTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var MultiWeekDaySlotTemplateDirective = class _MultiWeekDaySlotTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MultiWeekDaySlotTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiWeekDaySlotTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiWeekDaySlotTemplateDirective,
    selectors: [["", "kendoSchedulerMultiWeekDaySlotTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiWeekDaySlotTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerMultiWeekDaySlotTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var TimeSlotTemplateDirective = class _TimeSlotTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TimeSlotTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeSlotTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimeSlotTemplateDirective,
    selectors: [["", "kendoSchedulerTimeSlotTemplate", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSlotTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerTimeSlotTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ViewContextService = class _ViewContextService {
  /**
   * A stream of navigation actions that will be handled by the view.
   */
  action;
  /**
   * A stream that executes methods from the view.
   */
  execute;
  /**
   * A stream of items (events) that will be displayed in the view.
   */
  items;
  /**
   * A stream with the selected date that will be displayed by the view.
   */
  selectedDate;
  /**
   * Fires when the Scheduler element is resized.
   */
  resize;
  /**
   * Fires when the Scheduler options are changed.
   */
  optionsChange;
  actionSource = new Subject();
  itemsSource = new BehaviorSubject([]);
  selectedDateSource = new BehaviorSubject(null);
  resizeSource = new Subject();
  optionsChangeSource = new BehaviorSubject({});
  executeSource = new Subject();
  constructor() {
    this.action = this.actionSource.asObservable();
    this.items = this.itemsSource.asObservable();
    this.selectedDate = this.selectedDateSource.asObservable();
    this.resize = this.resizeSource.asObservable();
    this.optionsChange = this.optionsChangeSource.asObservable();
    this.execute = this.executeSource.asObservable();
  }
  /**
   * An internal method which is used by the Scheduler to publish unhandled navigation actions.
   *
   * @hidden
   */
  notifyAction(action) {
    this.actionSource.next(action);
  }
  /**
   * An internal method which is used by the Scheduler to publish the current set of items.
   *
   * @hidden
   */
  notifyItems(items) {
    this.itemsSource.next(items);
  }
  /**
   * An internal method which is used by the Scheduler to publish the currently selected date.
   *
   * @hidden
   */
  notifySelectedDate(date) {
    this.selectedDateSource.next(date);
  }
  /**
   * An internal method which is used by the Scheduler to notify that the size changed.
   *
   * @hidden
   */
  notifyResize() {
    this.resizeSource.next();
  }
  /**
   * An internal method which is used by the Scheduler to notify that the options changed.
   *
   * @hidden
   */
  notifyOptionsChange(changes) {
    this.optionsChangeSource.next(changes);
  }
  /**
   * An internal method which is used by the Scheduler to execute a view method.
   *
   * @hidden
   */
  executeMethod(name, args) {
    let result;
    this.executeSource.next({
      name,
      args,
      result: (r) => {
        result = r;
      }
    });
    return result;
  }
  static ɵfac = function ViewContextService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewContextService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ViewContextService,
    factory: _ViewContextService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewContextService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var emptyDateRange = () => ({
  start: /* @__PURE__ */ new Date(0),
  end: /* @__PURE__ */ new Date(0),
  text: "",
  shortText: ""
});
var ViewStateService = class _ViewStateService {
  /**
   * A stream for publishing the visible date range of the current view to the Scheduler.
   */
  dateRange;
  /**
   * A stream for publishing the changes to the selected date that are initiated from the view.
   */
  nextDate;
  /**
   * A stream fro navigating from the current to another view.
   */
  navigate;
  /**
   * A stream for navigating from the current to another view.
   */
  viewEvent;
  /**
   * A stream for indicating that the view layout finished.
   */
  layoutEnd;
  /**
   * A stream for indicating that the view options has changed.
   */
  optionsChange;
  /**
   * A stream indicating that the user has started making a new slot selection.
   */
  slotSelectionStart;
  /**
   * A stream indicating that the user has dragged over a different slot while making a selection.
   */
  slotSelectionDrag;
  /**
   * A stream indicating that the user has finished making a slot selection.
   */
  slotSelectionEnd;
  /**
   * @hidden
   */
  toggleWorkHours = new Subject();
  /**
   * @hidden
   */
  toolbarVisibilityByView = /* @__PURE__ */ new Map();
  dateRangeSource = new BehaviorSubject(emptyDateRange());
  nextDateSource = new Subject();
  navigateSource = new Subject();
  viewEventSource = new Subject();
  layoutEndSource = new Subject();
  optionsChangeSource = new Subject();
  slotSelectionStartSource = new Subject();
  slotSelectionStartDragSource = new Subject();
  slotSelectionStartEndSource = new Subject();
  constructor() {
    this.dateRange = this.dateRangeSource.asObservable();
    this.nextDate = this.nextDateSource.asObservable();
    this.navigate = this.navigateSource.asObservable();
    this.viewEvent = this.viewEventSource.asObservable();
    this.layoutEnd = this.layoutEndSource.asObservable();
    this.optionsChange = this.optionsChangeSource.asObservable();
    this.slotSelectionStart = this.slotSelectionStartSource.asObservable();
    this.slotSelectionDrag = this.slotSelectionStartDragSource.asObservable();
    this.slotSelectionEnd = this.slotSelectionStartEndSource.asObservable();
  }
  /**
   * Publishes the date that will be displayed by the Scheduler
   * typically as a result from processing a navigation action.
   */
  notifyNextDate(date) {
    this.nextDateSource.next(date);
  }
  /**
   * Publishes the visible date range of the view.
   * The view will calculate and set the new data range when
   * the selected date changes.
   */
  notifyDateRange(range3) {
    this.dateRangeSource.next(range3);
  }
  /**
   * Notifies the Scheduler that the view has completed its layout.
   */
  notifyLayoutEnd() {
    this.layoutEndSource.next();
  }
  /**
   * Navigates to another view.
   */
  navigateTo(args) {
    this.navigateSource.next(args);
  }
  /**
   * Notifies the Scheduler that the view options have been changed.
   */
  notifyOptionsChange(changes) {
    this.optionsChangeSource.next(changes);
  }
  /**
   * Emits a DOM event to the Scheduler.
   */
  emitEvent(name, args) {
    this.viewEventSource.next({
      name,
      args
    });
  }
  /** @hidden */
  notifySlotSelectionStart(selection) {
    this.slotSelectionStartSource.next(selection);
  }
  /** @hidden */
  notifySlotSelectionDrag(selection) {
    this.slotSelectionStartDragSource.next(selection);
  }
  /** @hidden */
  notifySlotSelectionEnd(selection) {
    this.slotSelectionStartEndSource.next(selection);
  }
  static ɵfac = function ViewStateService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewStateService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ViewStateService,
    factory: _ViewStateService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewStateService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var FIELD_REGEX$1 = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache2 = {};
getterCache2["undefined"] = () => void 0;
function getter2(field) {
  if (getterCache2[field]) {
    return getterCache2[field];
  }
  const fields = [];
  field.replace(FIELD_REGEX$1, function(_match, index, indexAccessor, fieldName) {
    fields.push(index !== void 0 ? index : indexAccessor || fieldName);
  });
  getterCache2[field] = function(obj) {
    let result = obj;
    for (let idx2 = 0; idx2 < fields.length && result; idx2++) {
      result = result[fields[idx2]];
    }
    return result;
  };
  return getterCache2[field];
}
var FIELD_REGEX2 = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var setterCache = {};
setterCache["undefined"] = (obj) => obj;
function setter2(field) {
  if (setterCache[field]) {
    return setterCache[field];
  }
  const fields = [];
  field.replace(FIELD_REGEX2, function(_match, index, indexAccessor, fieldName) {
    fields.push(index !== void 0 ? index : indexAccessor || fieldName);
  });
  setterCache[field] = function(obj, value2) {
    let root = obj;
    const depth = fields.length - 1;
    for (let idx2 = 0; idx2 < depth && root; idx2++) {
      root = root[fields[idx2]] = root[fields[idx2]] || {};
    }
    root[fields[depth]] = value2;
  };
  return setterCache[field];
}
var OCCURRENCE_ID = 0;
var capitalize = (value2) => value2.charAt(0).toUpperCase() + value2.slice(1);
var isPresent4 = (value2) => value2 !== null && value2 !== void 0;
var isBlank2 = (value2) => value2 === null || value2 === void 0;
var isArray2 = (value2) => Array.isArray(value2);
var isNullOrEmptyString2 = (value2) => isBlank2(value2) || value2.trim && value2.trim().length === 0;
var isNumber3 = (value2) => typeof value2 === "number" && !isNaN(value2);
var isString3 = (value2) => typeof value2 === "string";
var isObject2 = (value2) => typeof value2 === "object";
var isRecurring = (event2, fields) => {
  const recurrenceId = getter2(fields.recurrenceId)(event2);
  const recurrenceRule = getter2(fields.recurrenceRule)(event2);
  return !!(recurrenceRule || recurrenceId);
};
var isException2 = (event2, fields) => {
  const id = getter2(fields.id)(event2);
  const recurrenceId = getter2(fields.recurrenceId)(event2);
  return isPresent4(id) && id !== OCCURRENCE_ID && isPresent4(recurrenceId);
};
var copyResources = (event2, resources) => {
  if (resources) {
    for (let idx2 = 0; idx2 < resources.length; idx2++) {
      assignField(event2, event2.dataItem, resources[idx2].field);
    }
  }
};
var readEvent = (dataItem, fields, resources) => {
  const result = {
    id: getter2(fields.id)(dataItem),
    start: getter2(fields.start)(dataItem),
    startTimezone: getter2(fields.startTimezone)(dataItem),
    end: getter2(fields.end)(dataItem),
    endTimezone: getter2(fields.endTimezone)(dataItem),
    isAllDay: getter2(fields.isAllDay)(dataItem),
    title: getter2(fields.title)(dataItem),
    description: getter2(fields.description)(dataItem),
    recurrenceRule: getter2(fields.recurrenceRule)(dataItem),
    recurrenceExceptions: getter2(fields.recurrenceExceptions)(dataItem),
    recurrenceId: getter2(fields.recurrenceId)(dataItem),
    dataItem
  };
  copyResources(result, resources);
  return result;
};
var isRecurrenceMaster$1 = (event2) => event2.recurrenceRule && !isPresent4(event2.recurrenceId);
function groupResources(group3, resources) {
  const result = [];
  if (group3 && group3.resources && group3.resources.length) {
    const groups = group3.resources;
    for (let idx2 = 0; idx2 < groups.length; idx2++) {
      const resource = resources.find((r) => r.name === groups[idx2]);
      resource ? result.push(resource) : null;
    }
  }
  return result;
}
var getField = (obj, field) => getter2(field)(obj);
var setField = (obj, field, value2) => setter2(field)(obj, value2);
function assignField(target, source, field) {
  setField(target, field, getField(source, field));
}
function assignValues(target, source) {
  cloneTo(source, target);
  return target;
}
function cloneTo(obj, result) {
  for (const field in obj) {
    if (obj.hasOwnProperty(field)) {
      const value2 = obj[field];
      if (Array.isArray(value2)) {
        result[field] = value2.slice(0);
      } else if (value2 && typeof value2 === "object" && !(value2 instanceof Date)) {
        result[field] = result[field] || {};
        cloneTo(value2, result[field]);
      } else {
        result[field] = value2;
      }
    }
  }
}
function clone(obj) {
  const result = {};
  cloneTo(obj, result);
  return result;
}
var iterator = getIterator();
function getIterator() {
  if (typeof Symbol === "function" && Symbol.iterator) {
    return Symbol.iterator;
  }
  const keys = Object.getOwnPropertyNames(Map.prototype);
  const proto = Map.prototype;
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (key !== "entries" && key !== "size" && proto[key] === proto.entries) {
      return key;
    }
  }
}
function fromClick(element) {
  return fromEvent(element, "click");
}
function fromDoubleClick(element) {
  const DBLCLICK_DELAY = 250;
  const clicks = fromClick(element);
  const endSequence = clicks.pipe(auditTime(DBLCLICK_DELAY));
  return clicks.pipe(buffer(endSequence), filter((sequence) => sequence.length === 2), filter((sequence) => sequence[1].target === sequence[0].target), map((sequence) => sequence[1]));
}
function sortTasksByTime(tasks) {
  tasks.sort((a, b) => a.startTime - b.startTime || b.endTime - a.endTime);
  return tasks;
}
var EditService = class _EditService {
  ngZone;
  changes = new EventEmitter();
  changed;
  editedEvent;
  newEventGroup;
  changedSource = new Subject();
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.changed = this.changedSource.asObservable().pipe(debounceTime(0));
  }
  endEdit() {
    const formGroup = this.hasNewEvent ? this.newEventGroup.group : this.editedEvent.formGroup;
    this.changes.emit({
      action: "cancel",
      formGroup
    });
  }
  removeEvent(dataItem) {
    this.changes.emit({
      action: "remove",
      dataItem
    });
  }
  addEvent(formGroup) {
    this.newEventGroup = {
      formGroup
    };
    this.onChanged();
  }
  editEvent(dataItem, formGroup = void 0, mode) {
    this.editedEvent = {
      dataItem,
      formGroup,
      mode
    };
    this.onChanged();
  }
  close() {
    this.newEventGroup = this.editedEvent = null;
    this.onChanged();
  }
  save() {
    const {
      dataItem,
      formGroup
    } = this.context;
    this.changes.emit({
      action: "save",
      dataItem,
      formGroup,
      isNew: this.hasNewEvent,
      mode: this.occurrenceEditMode
    });
  }
  isEditing() {
    return isPresent4(this.context);
  }
  get occurrenceEditMode() {
    if (this.hasNewEvent) {
      return EditMode.Series;
    } else {
      return this.editedEvent.mode || EditMode.Event;
    }
  }
  get hasNewEvent() {
    return isPresent4(this.newEventGroup);
  }
  get newEvent() {
    if (this.hasNewEvent) {
      return this.newEventGroup.group.value;
    }
    return {};
  }
  get context() {
    if (this.hasNewEvent) {
      return this.newEventGroup;
    }
    return this.editedEvent;
  }
  onChanged() {
    this.ngZone.runOutsideAngular(() => {
      this.changedSource.next();
    });
  }
  static ɵfac = function EditService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _EditService,
    factory: _EditService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var EditDialogTemplateDirective = class _EditDialogTemplateDirective {
  templateRef;
  /**
   * Specifies the query selector used to set the initial focus.
   */
  autoFocusedElement;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function EditDialogTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditDialogTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EditDialogTemplateDirective,
    selectors: [["", "kendoSchedulerEditDialogTemplate", ""]],
    inputs: {
      autoFocusedElement: "autoFocusedElement"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditDialogTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerEditDialogTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    autoFocusedElement: [{
      type: Input
    }]
  });
})();
var LocalDataChangesService = class _LocalDataChangesService {
  changes = new EventEmitter();
  data;
  static ɵfac = function LocalDataChangesService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalDataChangesService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _LocalDataChangesService,
    factory: _LocalDataChangesService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalDataChangesService, [{
    type: Injectable
  }], null, null);
})();
var DomEventsService = class _DomEventsService {
  focus = new EventEmitter();
  focusIn = new EventEmitter();
  focusOut = new EventEmitter();
  click = new EventEmitter();
  keydown = new EventEmitter();
  windowBlur = new EventEmitter();
  static ɵfac = function DomEventsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomEventsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DomEventsService,
    factory: _DomEventsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsService, [{
    type: Injectable
  }], null, null);
})();
var FocusService = class _FocusService {
  renderer;
  wrapper;
  domEvents;
  zone;
  get activeElement() {
    if (this.activeItem) {
      return this.activeItem.element;
    }
  }
  get focusableItems() {
    return this.items;
  }
  activeItem;
  focusedItem;
  items = /* @__PURE__ */ new Set();
  elementMap = /* @__PURE__ */ new WeakMap();
  subs = new Subscription();
  hasContentRendered = false;
  constructor(renderer, wrapper, domEvents, zone) {
    this.renderer = renderer;
    this.wrapper = wrapper;
    this.domEvents = domEvents;
    this.zone = zone;
    this.subs.add(this.domEvents.focus.subscribe((e) => this.onFocusIn(e)));
    this.subs.add(this.domEvents.focusOut.subscribe(() => this.onFocusOut()));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  register(item) {
    if (!this.activeItem) {
      this.activeItem = item;
      item.toggle(true);
    }
    const items = Array.from(this.focusableItems);
    if (item.containerType !== "content") {
      this.items.add(item);
    } else {
      const newContentIndex = items.map((item2) => item2.containerType).lastIndexOf("content") + 1;
      const hasFooter = items.find((item2) => item2.containerType === "footer");
      if (newContentIndex > 0) {
        items.splice(newContentIndex, 0, item);
        this.items = new Set(items);
      } else if (hasFooter) {
        items.splice(items.length - 1, 0, item);
        this.items = new Set(items);
      } else {
        this.items.add(item);
      }
      if (!this.hasContentRendered) {
        this.activeItem.toggle(false);
        this.activeItem = item;
        item.toggle(true);
        this.hasContentRendered = true;
      }
    }
    this.elementMap.set(item.element.nativeElement, item);
    this.toggleWrapper();
  }
  unregister(item) {
    if (item === this.activeItem) {
      this.activateNext();
    }
    this.items.delete(item);
    this.elementMap.delete(item.element.nativeElement);
    this.toggleWrapper();
  }
  focus() {
    if (this.activeItem) {
      this.activeItem.focus();
    } else {
      this.focusContent();
    }
  }
  focusContent() {
    const items = Array.from(this.focusableItems);
    const activeItemContainer = this.activeItem?.containerType;
    const focusableContent = activeItemContainer === "content" ? this.activeItem : items.find((item) => item.containerType === "content");
    const focusableTool = activeItemContainer === "toolbar" ? this.activeItem : items.find((item) => item.containerType === "toolbar");
    const itemToFocus = focusableContent || focusableTool;
    itemToFocus.focus();
    this.activeItem = itemToFocus;
  }
  focusToolbar() {
    const items = Array.from(this.focusableItems);
    const firstFocusableTool = items.find((item) => item.containerType === "toolbar");
    firstFocusableTool && firstFocusableTool.focus();
    this.activeItem = firstFocusableTool;
  }
  focusNext(options) {
    const currentItem = this.activeItem;
    this.activateNext(options);
    if (this.activeItem) {
      this.activeItem.focus();
    }
    return this.activeItem !== currentItem;
  }
  focusByIndex(index) {
    const item = Array.from(this.items.values())[index];
    if (!item) {
      return;
    }
    this.activate(item);
    this.focus();
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      const itemToFocus = Array.from(this.items.values())[index];
      if (!itemToFocus) {
        return;
      }
    });
  }
  activate(next) {
    this.items.forEach((item) => {
      item.toggle(item === next);
    });
    this.activeItem = next;
  }
  activateNext(position) {
    const next = this.findNext(position);
    this.activeItem = next;
    this.activeItem?.focus();
  }
  findNext(position) {
    const {
      offset: offset2,
      nowrap
    } = __spreadValues({
      nowrap: false,
      offset: 1
    }, position);
    const items = Array.from(this.items.values()).filter((item) => item.canFocus()).sort((a, b) => a.focusIndex - b.focusIndex);
    if (items.length === 0) {
      return null;
    }
    if (!this.activeItem) {
      return nowrap ? null : items[0];
    }
    const index = items.indexOf(this.activeItem);
    let nextIndex = index + offset2;
    if (nowrap) {
      nextIndex = Math.max(0, Math.min(items.length - 1, nextIndex));
    } else {
      nextIndex = nextIndex % items.length;
      if (nextIndex < 0) {
        nextIndex = items.length - 1;
      }
    }
    return items[nextIndex];
  }
  toggleWrapper() {
    if (this.wrapper) {
      this.renderer.setAttribute(this.wrapper.nativeElement, "tabindex", this.activeItem ? "-1" : "0");
    }
  }
  onFocusIn(e) {
    const item = this.elementMap.get(e.target);
    if (!item || item === this.focusedItem) {
      return;
    }
    if (this.focusedItem) {
      this.focusedItem.toggleFocus(false);
    }
    this.activate(item);
    item.toggleFocus(true);
    this.focusedItem = item;
  }
  onFocusOut() {
    if (!this.focusedItem) {
      return;
    }
    this.focusedItem.toggleFocus(false);
    this.focusedItem = null;
  }
  static ɵfac = function FocusService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusService)(ɵɵinject(Renderer2, 8), ɵɵinject(ElementRef, 8), ɵɵinject(DomEventsService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusService,
    factory: _FocusService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DomEventsService
    }, {
      type: NgZone
    }];
  }, null);
})();
var DialogsService = class _DialogsService {
  dialogService;
  localization;
  changeDetector;
  focusService;
  viewState;
  container;
  isOpen = false;
  constructor(dialogService, localization, changeDetector, focusService, viewState) {
    this.dialogService = dialogService;
    this.localization = localization;
    this.changeDetector = changeDetector;
    this.focusService = focusService;
    this.viewState = viewState;
  }
  openRemoveConfirmationDialog() {
    const dialog = this.dialogService.open({
      title: this.textFor("deleteDialogTitle"),
      content: this.textFor("deleteConfirmation"),
      actions: [{
        text: this.textFor("cancel"),
        value: false
      }, {
        text: this.textFor("destroy"),
        value: true
      }],
      appendTo: this.container,
      autoFocusedElement: "button:nth-child(2)"
    });
    this.isOpen = true;
    this.changeDetector.markForCheck();
    return dialog.result.pipe(map((result) => {
      this.isOpen = false;
      if (result instanceof DialogCloseResult) {
        this.focusService.focus();
        return false;
      }
      this.viewState.layoutEnd.pipe(take(1)).subscribe(() => this.focusService.focus());
      const res = result;
      return res.value;
    }));
  }
  openRecurringConfirmationDialog(operation) {
    const dialog = this.dialogService.open({
      actions: [{
        text: operation === CrudOperation.Edit ? this.textFor("editOccurrence") : this.textFor("deleteOccurrence"),
        value: EditMode.Occurrence
      }, {
        text: operation === CrudOperation.Edit ? this.textFor("editSeries") : this.textFor("deleteSeries"),
        value: EditMode.Series
      }],
      appendTo: this.container,
      autoFocusedElement: "button:nth-child(1)",
      content: operation === CrudOperation.Edit ? this.textFor("editRecurringConfirmation") : this.textFor("deleteRecurringConfirmation"),
      title: operation === CrudOperation.Edit ? this.textFor("editRecurringDialogTitle") : this.textFor("deleteRecurringDialogTitle")
    });
    this.isOpen = true;
    this.changeDetector.markForCheck();
    return dialog.result.pipe(map((result) => {
      this.isOpen = false;
      this.focusService.focus();
      if (result instanceof DialogCloseResult) {
        return void 0;
      }
      const res = result;
      return res.value;
    }));
  }
  textFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function DialogsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogsService)(ɵɵinject(DialogService), ɵɵinject(LocalizationService), ɵɵinject(ChangeDetectorRef), ɵɵinject(FocusService), ɵɵinject(ViewStateService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DialogsService,
    factory: _DialogsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogsService, [{
    type: Injectable
  }], function() {
    return [{
      type: DialogService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: FocusService
    }, {
      type: ViewStateService
    }];
  }, null);
})();
var SchedulerLocalizationService = class _SchedulerLocalizationService extends LocalizationService {
  constructor(prefix, messageService, _rtl) {
    super(prefix, messageService, _rtl);
  }
  static ɵfac = function SchedulerLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SchedulerLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SchedulerLocalizationService,
    factory: _SchedulerLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchedulerLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }];
  }, null);
})();
var defaultModelFields = {
  id: "id",
  start: "start",
  startTimezone: "startTimezone",
  end: "end",
  endTimezone: "endTimezone",
  isAllDay: "isAllDay",
  title: "title",
  description: "description",
  recurrenceRule: "recurrenceRule",
  recurrenceId: "recurrenceId",
  recurrenceExceptions: "recurrenceExceptions"
};
var PDFService = class _PDFService {
  createElement = new EventEmitter();
  exportClick = new EventEmitter();
  done = new EventEmitter();
  elementReady = new EventEmitter();
  save() {
    if (!hasObservers(this.elementReady)) {
      if (isDevMode()) {
        throw new Error("Creating PDF requires including the PDFModule and adding the <kendo-scheduler-pdf> component.");
      }
      return;
    }
    if (!hasObservers(this.createElement)) {
      if (isDevMode()) {
        throw new Error("No active Scheduler view to export.");
      }
      return;
    }
    this.createElement.emit();
  }
  static ɵfac = function PDFService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PDFService,
    factory: _PDFService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFService, [{
    type: Injectable
  }], null, null);
})();
var PDFExportEvent = class extends PreventableEvent3 {
};
var LoadingComponent = class _LoadingComponent {
  element;
  renderer;
  hostClasses = true;
  loading;
  get display() {
    return this.loading || this.force ? "block" : "none";
  }
  force;
  constructor(element, renderer) {
    this.element = element;
    this.renderer = renderer;
  }
  toggle(value2) {
    this.force = value2;
    this.renderer.setStyle(this.element.nativeElement, "display", this.display);
  }
  static ɵfac = function LoadingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadingComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _LoadingComponent,
    selectors: [["", "kendoSchedulerLoading", ""]],
    hostVars: 4,
    hostBindings: function LoadingComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.display);
        ɵɵclassProp("k-loading-mask", ctx.hostClasses);
      }
    },
    inputs: {
      loading: "loading"
    },
    attrs: _c03,
    decls: 2,
    vars: 0,
    consts: [[1, "k-loading-image"], [1, "k-loading-color"]],
    template: function LoadingComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "div", 0)(1, "div", 1);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoSchedulerLoading]",
      template: `
        <div class="k-loading-image"></div>
        <div class="k-loading-color"></div>
    `,
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-loading-mask"]
    }],
    loading: [{
      type: Input
    }],
    display: [{
      type: HostBinding,
      args: ["style.display"]
    }]
  });
})();
var FocusableDirective = class _FocusableDirective {
  element;
  renderer;
  focusService;
  /**
   * The order of the element with respect to the other focusable elements.
   * If multiple elements share the same value, their relative to each other order follows their position in the component tree.
   */
  focusIndex = 0;
  containerType = "content";
  get visible() {
    return this.element.nativeElement.style.display !== "none";
  }
  get enabled() {
    return !this.element.nativeElement.disabled;
  }
  active;
  constructor(element, renderer, focusService) {
    this.element = element;
    this.renderer = renderer;
    this.focusService = focusService;
    this.toggle(false);
  }
  ngAfterViewChecked() {
    const element = this.element.nativeElement;
    const isViewSelector = element.closest(".k-scheduler-views-wrapper");
    if (!isViewSelector || !isDocumentAvailable()) {
      return;
    }
    isVisible(element) ? this.focusService.register(this) : this.focusService.unregister(this);
  }
  ngOnInit() {
    this.focusService.register(this);
  }
  ngOnDestroy() {
    this.focusService.unregister(this);
  }
  toggle(active) {
    if (active !== this.active) {
      const index = active ? "0" : "-1";
      this.renderer.setAttribute(this.element.nativeElement, "tabIndex", index);
      this.active = active;
    }
  }
  canFocus() {
    return this.visible && this.enabled;
  }
  focus() {
    this.element.nativeElement.focus();
  }
  toggleFocus(value2) {
    const element = this.element.nativeElement;
    const focusedClass = element.matches(".k-button-group .k-button") ? "k-focus" : "k-selected";
    const renderedEvents = this.element.nativeElement.ownerDocument.querySelectorAll(".k-event");
    const method = value2 ? "addClass" : "removeClass";
    this.renderer[method](element, focusedClass);
    if (renderedEvents.length > 0) {
      const ariaLabel = element.getAttribute("aria-label");
      renderedEvents.forEach((event2) => {
        if (event2.getAttribute("aria-label") === ariaLabel) {
          this.renderer[method](event2, "k-selected");
        }
      });
    }
    const selectable = element.matches(".k-scheduler-agendaview .k-scheduler-content .k-selected");
    if (selectable) {
      element.closest(".k-scheduler-agendaview").querySelector('[aria-selected="true"]')?.removeAttribute("aria-selected");
      this.renderer.setAttribute(element, "aria-selected", value2.toString());
    }
  }
  static ɵfac = function FocusableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(FocusService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FocusableDirective,
    selectors: [["", "kendoSchedulerFocusIndex", ""]],
    inputs: {
      focusIndex: [0, "kendoSchedulerFocusIndex", "focusIndex"],
      containerType: "containerType"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerFocusIndex]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: FocusService
    }];
  }, {
    focusIndex: [{
      type: Input,
      args: ["kendoSchedulerFocusIndex"]
    }],
    containerType: [{
      type: Input
    }]
  });
})();
var toClassList = (classNames) => String(classNames).trim().split(" ");
var hasClasses = (element, classNames) => {
  const namesList = toClassList(classNames);
  return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
var closest3 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var firstElementChild = (node) => {
  const children = node.children;
  const length2 = children.length;
  for (let idx2 = 0; idx2 < length2; idx2++) {
    if (children[idx2].nodeType === 1) {
      return children[idx2];
    }
  }
};
var closestInScope2 = (node, predicate, scope) => {
  while (node && node !== scope && !predicate(node)) {
    node = node.parentNode;
  }
  if (node !== scope) {
    return node;
  }
};
var wheelDeltaY = (e) => {
  const deltaY = e.wheelDeltaY;
  if (e.wheelDelta && (deltaY === void 0 || deltaY)) {
    return e.wheelDelta;
  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
    return -e.detail * 10;
  }
  return 0;
};
var preventLockedScroll = (el) => (event2) => {
  const delta = wheelDeltaY(event2);
  const scrollTop = el.scrollTop;
  const allowScroll = scrollTop === 0 && 0 < delta || el.scrollHeight <= el.offsetHeight + scrollTop && delta < 0;
  if (!allowScroll) {
    event2.preventDefault();
  }
};
function hasScrollbar(element, type) {
  const sizeField = type === "vertical" ? "Height" : "Width";
  return element[`scroll${sizeField}`] > element[`client${sizeField}`] && scrollbarWidth() > 0;
}
function rtlScrollPosition(element, position) {
  const initial2 = element.scrollLeft;
  let result = position;
  element.scrollLeft = -1;
  if (element.scrollLeft < 0) {
    result = -position;
  } else if (initial2 > 0) {
    result = element.scrollWidth - element.offsetWidth - position;
  }
  return result;
}
var intersects = (startTime, endTime, periodStart, periodEnd) => startTime < periodStart && endTime > periodEnd || periodStart <= startTime && startTime < periodEnd || periodStart < endTime && endTime <= periodEnd && startTime < endTime;
var dateInRange2 = (date, start, end) => start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
var roundAllDayEnd = ({
  start,
  end
}) => {
  const startDate = start.stripTime();
  const endDate = end.stripTime();
  return endDate.getTime() !== end.getTime() || startDate.getTime() === endDate.getTime() ? endDate.addDays(1) : endDate;
};
function toInvariantTime(date) {
  const staticDate = new Date(1980, 0, 1, 0, 0, 0);
  if (date) {
    staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
  }
  return staticDate;
}
var addUTCDays = (date, offset2) => {
  const newDate = new Date(date.getTime());
  newDate.setUTCDate(newDate.getUTCDate() + offset2);
  return newDate;
};
function toUTCTime(localDate, localTime) {
  return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localTime.getHours(), localTime.getMinutes(), localTime.getSeconds(), localTime.getMilliseconds()));
}
function toUTCDate(localDate) {
  return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate()));
}
function getUTCDate(utcDate) {
  return new Date(Date.UTC(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate()));
}
function toUTCDateTime2(localDate) {
  return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
function dateWithTime(target, time) {
  return new Date(target.getFullYear(), target.getMonth(), target.getDate(), time.getHours(), time.getMinutes());
}
function normaliseRangeStartAndEnd(selectionOrigin, currentSlot) {
  let start;
  let end;
  if (currentSlot.end <= selectionOrigin.end) {
    end = selectionOrigin.end;
    start = currentSlot.start;
  } else {
    start = selectionOrigin.start;
    end = currentSlot.end;
  }
  return {
    start,
    end
  };
}
function getDataIdx(value2, resource) {
  const data = resource.data;
  for (let dataIdx = 0; dataIdx < data.length; dataIdx++) {
    if (getField(data[dataIdx], resource.valueField) === value2) {
      return dataIdx;
    }
  }
  return -1;
}
function resourceItem(value2, resource) {
  const index = getDataIdx(value2, resource);
  return index >= 0 ? resource.data[index] : {};
}
function resourceItems(values, resource) {
  return values.map((value2) => resourceItem(value2, resource));
}
function cloneResources(arr) {
  const result = [];
  for (let idx2 = 0; idx2 < arr.length; idx2++) {
    const clone2 = Object.assign({}, arr[idx2]);
    clone2.resources = clone2.resources.slice(0);
    result.push(clone2);
  }
  return result;
}
function resourceItemByValue(event2, resource) {
  const value2 = getField(event2, resource.field);
  if (Array.isArray(value2)) {
    return resourceItems(value2, resource);
  }
  return resourceItem(value2, resource);
}
function addNotGroupedResources(event2, resources, allResources) {
  for (let resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {
    const current = resources[resourceIdx];
    for (let idx2 = 0; idx2 < allResources.length; idx2++) {
      const item = allResources[idx2];
      if (!current.resources[idx2] && item.data) {
        current.resources[idx2] = resourceItemByValue(event2, item);
      }
    }
  }
}
function eventResources(event2, {
  taskResources,
  hasGroups,
  spans,
  allResources = []
}) {
  let resources = [];
  for (let resourceIdx = 0; resourceIdx < taskResources.length; resourceIdx++) {
    const resource = taskResources[resourceIdx];
    if (!resource.data) {
      resources = [{
        leafIdx: 0,
        resources: []
      }];
      continue;
    }
    const resourceIndex = allResources.indexOf(resource);
    let values = getField(event2, resource.field);
    if (!Array.isArray(values)) {
      values = [values];
    }
    const expandedResources = [];
    for (let valueIdx = 0; valueIdx < values.length; valueIdx++) {
      const dataIdx = getDataIdx(values[valueIdx], resource);
      if (dataIdx < 0) {
        if (hasGroups) {
          continue;
        }
        return [{
          leafIdx: 0,
          resources: []
        }];
      }
      const item = resource.data[dataIdx];
      if (resourceIdx === 0 && (hasGroups || valueIdx === 0)) {
        const resourceItems2 = [];
        resourceItems2[resourceIndex] = resource.multiple && !hasGroups ? [item] : item;
        resources.push({
          leafIdx: hasGroups ? dataIdx * spans[resourceIdx] : 0,
          color: getField(item, resource.colorField),
          resources: resourceItems2
        });
      } else if (hasGroups) {
        let currentResources = resources;
        if (values.length > 1) {
          currentResources = cloneResources(resources);
          expandedResources.push(...currentResources);
        }
        for (let currentIdx = 0; currentIdx < currentResources.length; currentIdx++) {
          currentResources[currentIdx].leafIdx += dataIdx * spans[resourceIdx];
          currentResources[currentIdx].resources[resourceIndex] = item;
        }
      } else if (valueIdx > 0) {
        for (let idx2 = 0; idx2 < resources.length; idx2++) {
          resources[idx2].resources[resourceIndex].push(item);
        }
      }
    }
    if (expandedResources.length) {
      resources = expandedResources;
    }
  }
  addNotGroupedResources(event2, resources, allResources);
  return resources;
}
function assignTasksResources(tasks, options) {
  for (let idx2 = 0; idx2 < tasks.length; idx2++) {
    const task = tasks[idx2];
    task.resources = eventResources(task.event, options);
  }
}
function isEmptyResource(resources) {
  return Array.isArray(resources) && resources.length === 1 && resources[0] === void 0;
}
function resourcesMatch(res1, res2) {
  if (res1.length !== res2.length) {
    return false;
  }
  if (isEmptyResource(res1) && isEmptyResource(res2)) {
    return true;
  }
  return res1.every((r1) => res2.some((r2) => r2.value === r1.value));
}
function isSameRange(range1, range22) {
  return range1.start.getTime() === range22.start.getTime() && range1.end.getTime() === range22.end.getTime() && range1.isAllDay === range22.isAllDay && resourcesMatch(range1.resources, range22.resources);
}
function findRowIndex(events, data) {
  if (data.rowIndex !== void 0) {
    return data.rowIndex;
  }
  for (let idx2 = 0; idx2 < events.length; idx2++) {
    if (!events[idx2]) {
      return idx2;
    }
  }
  return events.length;
}
function isRecurrence(task) {
  return Boolean(task.event && task.event.recurrenceRule);
}
function isRecurrenceException(task) {
  return task.event && isPresent4(task.event.recurrenceId) && !task.event.recurrenceRule;
}
var rectContains = (rect, left2, top, scaleX = 1) => rect.left * scaleX <= left2 && left2 <= rect.left * scaleX + rect.width * scaleX && rect.top * scaleX <= top && top <= rect.top * scaleX + rect.height * scaleX;
var rectContainsX = (rect, left2, scaleX = 1) => rect.left * scaleX <= left2 && left2 <= rect.left * scaleX + rect.width * scaleX;
var toPx = (value2) => `${value2}px`;
var elementOffset = (element) => {
  if (!element) {
    return null;
  }
  const box = element.getBoundingClientRect();
  const documentElement = document.documentElement;
  return {
    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
    width: box.width,
    height: box.height
  };
};
var pointDistance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
var ignoreContentChild = (child) => child.nodeName === "KENDO-RESIZE-SENSOR" || hasClasses(child, "k-loading-mask");
var setCoordinates = (element, coordinates) => {
  for (const field in coordinates) {
    if (coordinates.hasOwnProperty(field)) {
      element.style[field] = toPx(coordinates[field]);
    }
  }
};
var convertNgClassBindings = (bindingValues) => {
  const result = [];
  if (isString3(bindingValues)) {
    result.push(bindingValues);
  } else if (isArray2(bindingValues)) {
    result.push(...bindingValues);
  } else if (isObject2(bindingValues)) {
    for (const field in bindingValues) {
      if (bindingValues.hasOwnProperty(field) && bindingValues[field]) {
        result.push(field);
      }
    }
  }
  return result;
};
function formatEventTime(start, end, isAllDay, localeId) {
  const dateFormat = {
    skeleton: "yMMMMEEEEd"
  };
  const timeFormat = "t";
  const startFormat = formatEventStart(start, dateFormat, timeFormat, isAllDay, localeId);
  const endFormat = formatEventEnd(start, end, dateFormat, timeFormat, localeId);
  return isAllDay ? `${startFormat}` : `${startFormat}-${endFormat}`;
}
function formValueOrDefault(group3, field, defaultValue) {
  const control = group3.get(field);
  if (!control) {
    return defaultValue;
  }
  return control.value || defaultValue;
}
var isWorkWeekDay = (day, start, end) => {
  if (end < start) {
    return day <= end || start <= day;
  }
  return start <= day && day <= end;
};
var alwaysFalse = () => false;
var formatEventStart = (start, dateFormat, timeFormat, isAllDay, localeId) => {
  let startFormat = `${formatDate(start, dateFormat, localeId)}`;
  if (!isAllDay) {
    startFormat += `, ${formatDate(start, timeFormat, localeId)}`;
  }
  return startFormat;
};
var formatEventEnd = (start, end, dateFormat, timeFormat, localeId) => {
  let endFormat = "";
  if (!isEqualDate(start, end)) {
    endFormat = `${formatDate(end, dateFormat, localeId)}, `;
  }
  endFormat += `${formatDate(end, timeFormat, localeId)}`;
  return endFormat;
};
var ResourceEditorBase = class _ResourceEditorBase {
  resource;
  valueChange = new EventEmitter();
  resourceValue;
  getField = getField;
  /**
   * @hidden
   */
  writeValue(newValue) {
    this.resourceValue = newValue;
  }
  getResourceStyle(dataItem) {
    return {
      "background-color": getField(dataItem, this.resource.colorField),
      "margin-right": isPresent4(getField(dataItem, this.resource.valueField)) ? "8px" : "4px"
    };
  }
  onResourceValueChange(newValue) {
    this.resourceValue = newValue;
    this.emitChange(this.resourceValue);
  }
  onTouchedCallback = (_) => {
  };
  onChangeCallback = (_) => {
  };
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  emitChange(value2) {
    this.onChangeCallback(value2);
    this.valueChange.emit(value2);
  }
  static ɵfac = function ResourceEditorBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResourceEditorBase)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ResourceEditorBase,
    inputs: {
      resource: "resource"
    },
    outputs: {
      valueChange: "valueChange"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResourceEditorBase, [{
    type: Directive
  }], null, {
    resource: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var MULTIPLE_RESOURCE_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MultipleResourceEditorComponent)
};
var MultipleResourceEditorComponent = class _MultipleResourceEditorComponent extends ResourceEditorBase {
  resourceMultiSelect;
  getTagStyle(dataItem) {
    return {
      "background-color": dataItem[this.resource.colorField]
    };
  }
  focus() {
    this.resourceMultiSelect.focus();
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMultipleResourceEditorComponent_BaseFactory;
    return function MultipleResourceEditorComponent_Factory(__ngFactoryType__) {
      return (ɵMultipleResourceEditorComponent_BaseFactory || (ɵMultipleResourceEditorComponent_BaseFactory = ɵɵgetInheritedFactory(_MultipleResourceEditorComponent)))(__ngFactoryType__ || _MultipleResourceEditorComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _MultipleResourceEditorComponent,
    selectors: [["kendo-multiple-resource-editor"]],
    viewQuery: function MultipleResourceEditorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c111, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resourceMultiSelect = _t.first);
      }
    },
    features: [ɵɵProvidersFeature([MULTIPLE_RESOURCE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 5,
    consts: [["resourceMultiSelect", ""], [3, "valueChange", "data", "textField", "valueField", "valuePrimitive", "value"], ["kendoDropDownListItemTemplate", ""], ["kendoMultiSelectTagTemplate", ""], ["class", "k-scheduler-mark", 3, "ngStyle", 4, "ngIf"], [1, "k-scheduler-mark", 3, "ngStyle"]],
    template: function MultipleResourceEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-multiselect", 1, 0);
        ɵɵlistener("valueChange", function MultipleResourceEditorComponent_Template_kendo_multiselect_valueChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onResourceValueChange($event));
        });
        ɵɵtemplate(2, MultipleResourceEditorComponent_ng_template_2_Template, 2, 2, "ng-template", 2)(3, MultipleResourceEditorComponent_ng_template_3_Template, 2, 2, "ng-template", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("data", ctx.resource.data)("textField", ctx.resource.textField)("valueField", ctx.resource.valueField)("valuePrimitive", true)("value", ctx.resourceValue);
      }
    },
    dependencies: [MultiSelectComponent, ItemTemplateDirective, NgIf, NgStyle, TagTemplateDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultipleResourceEditorComponent, [{
    type: Component,
    args: [{
      providers: [MULTIPLE_RESOURCE_VALUE_ACCESSOR],
      selector: "kendo-multiple-resource-editor",
      template: `
        <kendo-multiselect
            #resourceMultiSelect
            [data]='resource.data'
            [textField]='resource.textField'
            [valueField]='resource.valueField'
            [valuePrimitive]='true'
            [value]='resourceValue'
            (valueChange)='onResourceValueChange($event)'
        >
            <ng-template kendoDropDownListItemTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getResourceStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
            <ng-template kendoMultiSelectTagTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getTagStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
        </kendo-multiselect>
    `,
      standalone: true,
      imports: [MultiSelectComponent, ItemTemplateDirective, NgIf, NgStyle, TagTemplateDirective]
    }]
  }], null, {
    resourceMultiSelect: [{
      type: ViewChild,
      args: ["resourceMultiSelect", {
        static: true
      }]
    }]
  });
})();
var SINGLE_RESOURCE_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SingleResourceEditorComponent)
};
var SingleResourceEditorComponent = class _SingleResourceEditorComponent extends ResourceEditorBase {
  resourceDropDown;
  focus() {
    this.resourceDropDown.focus();
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSingleResourceEditorComponent_BaseFactory;
    return function SingleResourceEditorComponent_Factory(__ngFactoryType__) {
      return (ɵSingleResourceEditorComponent_BaseFactory || (ɵSingleResourceEditorComponent_BaseFactory = ɵɵgetInheritedFactory(_SingleResourceEditorComponent)))(__ngFactoryType__ || _SingleResourceEditorComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _SingleResourceEditorComponent,
    selectors: [["kendo-single-resource-editor"]],
    viewQuery: function SingleResourceEditorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c211, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resourceDropDown = _t.first);
      }
    },
    features: [ɵɵProvidersFeature([SINGLE_RESOURCE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 5,
    consts: [["resourceDropDown", ""], [3, "valueChange", "data", "textField", "valueField", "valuePrimitive", "value"], ["kendoDropDownListItemTemplate", ""], ["class", "k-scheduler-mark", 3, "ngStyle", 4, "ngIf"], [1, "k-scheduler-mark", 3, "ngStyle"]],
    template: function SingleResourceEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-dropdownlist", 1, 0);
        ɵɵlistener("valueChange", function SingleResourceEditorComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onResourceValueChange($event));
        });
        ɵɵtemplate(2, SingleResourceEditorComponent_ng_template_2_Template, 2, 2, "ng-template", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("data", ctx.resource.data)("textField", ctx.resource.textField)("valueField", ctx.resource.valueField)("valuePrimitive", true)("value", ctx.resourceValue);
      }
    },
    dependencies: [DropDownListComponent, ItemTemplateDirective, NgIf, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SingleResourceEditorComponent, [{
    type: Component,
    args: [{
      providers: [SINGLE_RESOURCE_VALUE_ACCESSOR],
      selector: "kendo-single-resource-editor",
      template: `
        <kendo-dropdownlist
            #resourceDropDown
            [data]='resource.data'
            [textField]='resource.textField'
            [valueField]='resource.valueField'
            [valuePrimitive]='true'
            [value]='resourceValue'
            (valueChange)='onResourceValueChange($event)'
        >
            <ng-template kendoDropDownListItemTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getResourceStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
        </kendo-dropdownlist>
    `,
      standalone: true,
      imports: [DropDownListComponent, ItemTemplateDirective, NgIf, NgStyle]
    }]
  }], null, {
    resourceDropDown: [{
      type: ViewChild,
      args: ["resourceDropDown", {
        static: true
      }]
    }]
  });
})();
var Modifiers;
(function(Modifiers2) {
  Modifiers2[Modifiers2["None"] = 0] = "None";
  Modifiers2[Modifiers2["AltKey"] = 1] = "AltKey";
  Modifiers2[Modifiers2["CtrlKey"] = 2] = "CtrlKey";
  Modifiers2[Modifiers2["ShiftKey"] = 4] = "ShiftKey";
  Modifiers2[Modifiers2["MetaKey"] = 8] = "MetaKey";
})(Modifiers || (Modifiers = {}));
function withModifiers(e, modifiers) {
  return e.altKey === ((modifiers & Modifiers.AltKey) === Modifiers.AltKey) && e.ctrlKey === ((modifiers & Modifiers.CtrlKey) === Modifiers.CtrlKey) && e.shiftKey === ((modifiers & Modifiers.ShiftKey) === Modifiers.ShiftKey) && e.metaKey === ((modifiers & Modifiers.MetaKey) === Modifiers.MetaKey);
}
function noModifiers(e) {
  return withModifiers(e, Modifiers.None);
}
var uniqueIdCounter = 0;
var offsetPositions = ["first", "second", "third", "fourth", "last"];
var frequencies2 = ["never", "daily", "weekly", "monthly", "yearly"];
var dayRule = [{
  day: 0,
  offset: 0
}, {
  day: 1,
  offset: 0
}, {
  day: 2,
  offset: 0
}, {
  day: 3,
  offset: 0
}, {
  day: 4,
  offset: 0
}, {
  day: 5,
  offset: 0
}, {
  day: 6,
  offset: 0
}];
var weekdayRule = [{
  day: 1,
  offset: 0
}, {
  day: 2,
  offset: 0
}, {
  day: 3,
  offset: 0
}, {
  day: 4,
  offset: 0
}, {
  day: 5,
  offset: 0
}];
var weekendRule = [{
  day: 0,
  offset: 0
}, {
  day: 6,
  offset: 0
}];
var RecurrenceService = class _RecurrenceService {
  intl;
  localization;
  rrule;
  timezone;
  weekStart;
  start;
  change = new EventEmitter();
  endRuleChange = new EventEmitter();
  frequencyChange = new EventEmitter();
  repeatOnRuleChange = new EventEmitter();
  constructor(intl, localization) {
    this.intl = intl;
    this.localization = localization;
  }
  init(rrule = "", start, timezone, weekStart) {
    this.start = start;
    this.timezone = timezone;
    this.weekStart = weekStart;
    this.rrule = parseRule({
      recurrenceRule: rrule,
      weekStart
    });
  }
  /**
   * @hidden
   */
  getUniqueId() {
    return uniqueIdCounter++;
  }
  get frequencies() {
    return frequencies2.map((freq) => ({
      value: freq,
      text: this.localization.get("frequencies" + capitalize(freq))
    }));
  }
  get frequency() {
    if (isPresent4(this.rrule) && !isNullOrEmptyString2(this.rrule.freq)) {
      return this.rrule.freq;
    }
    return "never";
  }
  setFrequency(freq) {
    this.rrule = {};
    this.rrule.freq = freq;
    this.rrule.interval = 1;
    if (freq === "weekly") {
      this.rrule.byWeekDay = [{
        day: this.start.getDay(),
        offset: 0
      }];
    }
    if (freq === "monthly" || freq === "yearly") {
      this.rrule.byMonthDay = [this.start.getDate()];
    }
    if (freq === "yearly") {
      this.rrule.byMonth = [this.start.getMonth() + 1];
    }
    this.frequencyChange.emit();
    this.onChange();
  }
  set interval(newInterval) {
    this.rrule.interval = newInterval;
    this.onChange();
  }
  set count(newCount) {
    this.rrule.count = newCount;
    this.onChange();
  }
  set until(newUntil) {
    this.rrule.until = ZonedDate.fromLocalDate(newUntil, this.timezone);
    this.onChange();
  }
  get until() {
    if (isPresent4(this.rrule.until)) {
      return toLocalDate(this.rrule.until);
    }
  }
  setWeekDays(newWeekDays) {
    this.rrule.byWeekDay = newWeekDays;
    this.onChange();
  }
  set monthDays(newMonthDays) {
    this.rrule.byMonthDay = newMonthDays;
    this.onChange();
  }
  set positions(newPositions) {
    this.rrule.bySetPosition = newPositions;
    this.onChange();
  }
  setMonths(newMonths) {
    this.rrule.byMonth = newMonths;
    this.onChange();
  }
  get months() {
    return this.intl.dateFormatNames({
      type: "months",
      nameType: "wide"
    }).map((month, idx2) => ({
      text: month,
      value: idx2 + 1
    }));
  }
  /*
      ToDo Refactor weekDays and extendedWeekDays getters into a single method
  */
  get weekDays() {
    const firstDay2 = this.weekStart;
    const abbrNames = this.intl.dateFormatNames({
      type: "days",
      nameType: "abbreviated"
    }).map((day, idx2) => ({
      text: day,
      value: idx2
    }));
    return abbrNames.slice(firstDay2).concat(abbrNames.slice(0, firstDay2));
  }
  get extendedWeekDays() {
    const firstDay2 = this.weekStart;
    const wideNames = this.intl.dateFormatNames({
      type: "days",
      nameType: "wide"
    }).map((day, idx2) => ({
      text: day,
      value: idx2
    }));
    const sortedWideNames = wideNames.slice(firstDay2).concat(wideNames.slice(0, firstDay2));
    const specialRules = [{
      text: this.localization.get("weekdaysDay"),
      value: "day"
    }, {
      text: this.localization.get("weekdaysWeekday"),
      value: "weekday"
    }, {
      text: this.localization.get("weekdaysWeekendday"),
      value: "weekend"
    }];
    return specialRules.concat(sortedWideNames);
  }
  get offsetPositions() {
    const values = [1, 2, 3, 4, -1];
    return offsetPositions.map((offset2, idx2) => ({
      text: this.localization.get("offsetPositions" + capitalize(offset2)),
      value: values[idx2]
    }));
  }
  get endRule() {
    if (isPresent4(this.rrule.count)) {
      return "count";
    } else if (isPresent4(this.rrule.until)) {
      return "until";
    } else {
      return "never";
    }
  }
  set endRule(endRule) {
    if (endRule === "count") {
      this.rrule.until = null;
    } else if (endRule === "until") {
      this.rrule.count = null;
    } else {
      this.rrule.count = null;
      this.rrule.until = null;
    }
    this.endRuleChange.emit(endRule);
    this.onChange();
  }
  get repeatOnRule() {
    if (isPresent4(this.rrule.byWeekDay)) {
      return "weekday";
    } else if (isPresent4(this.rrule.byMonthDay)) {
      return "monthday";
    }
    return null;
  }
  set repeatOnRule(repeatOnRule) {
    if (repeatOnRule === "monthday") {
      this.rrule.byWeekDay = null;
      this.rrule.bySetPosition = null;
    } else {
      this.rrule.byMonthDay = null;
    }
    this.repeatOnRuleChange.emit(repeatOnRule);
    this.onChange();
  }
  onChange() {
    if (this.frequency === "never") {
      this.change.emit(null);
    } else {
      this.change.emit(serializeRule(this.rrule, this.timezone));
    }
  }
  static ɵfac = function RecurrenceService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceService)(ɵɵinject(IntlService), ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _RecurrenceService,
    factory: _RecurrenceService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceService, [{
    type: Injectable
  }], function() {
    return [{
      type: IntlService
    }, {
      type: LocalizationService
    }];
  }, null);
})();
var RecurrenceLocalizationService = class _RecurrenceLocalizationService extends LocalizationService {
  schedulerLocalization;
  constructor(prefix, messageService, _rtl, schedulerLocalization) {
    super(prefix, messageService, _rtl);
    this.schedulerLocalization = schedulerLocalization;
  }
  get(shortKey) {
    if (this.schedulerLocalization) {
      return this.schedulerLocalization.get("recurrenceEditor" + capitalize(shortKey));
    }
    return super.get(shortKey);
  }
  static ɵfac = function RecurrenceLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8), ɵɵinject(SchedulerLocalizationService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _RecurrenceLocalizationService,
    factory: _RecurrenceLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: SchedulerLocalizationService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [SchedulerLocalizationService]
      }]
    }];
  }, null);
})();
var EndRuleRadioButtonDirective = class _EndRuleRadioButtonDirective {
  el;
  renderer;
  recurrence;
  changeDetector;
  type = "radio";
  radioClass = true;
  radioSizeClass = true;
  endRuleId;
  destroyClick;
  endRule;
  constructor(el, renderer, recurrence, changeDetector) {
    this.el = el;
    this.renderer = renderer;
    this.recurrence = recurrence;
    this.changeDetector = changeDetector;
    this.destroyClick = this.renderer.listen(this.elem, "click", this.onClick.bind(this));
  }
  ngOnInit() {
    this.endRule = this.endRuleId.split("-")[2];
    this.renderer.setAttribute(this.elem, "id", this.endRuleId);
    this.renderer.setAttribute(this.elem, "name", `end-${this.endRuleId.split("-").pop()}`);
  }
  ngAfterContentChecked() {
    this.setCheckedState();
  }
  ngOnDestroy() {
    if (this.destroyClick) {
      this.destroyClick();
    }
  }
  onClick() {
    if (this.elem.checked) {
      this.recurrence.endRule = this.endRule;
      this.changeDetector.markForCheck();
    }
  }
  setCheckedState() {
    const isChecked = this.endRule === this.recurrence.endRule;
    this.renderer.setProperty(this.elem, "checked", isChecked);
  }
  get elem() {
    return this.el.nativeElement;
  }
  static ɵfac = function EndRuleRadioButtonDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EndRuleRadioButtonDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(RecurrenceService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EndRuleRadioButtonDirective,
    selectors: [["", "kendoRecurrenceEndRuleRadioButton", ""]],
    hostVars: 5,
    hostBindings: function EndRuleRadioButtonDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("type", ctx.type);
        ɵɵclassProp("k-radio", ctx.radioClass)("k-radio-md", ctx.radioSizeClass);
      }
    },
    inputs: {
      endRuleId: [0, "kendoRecurrenceEndRuleRadioButton", "endRuleId"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EndRuleRadioButtonDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoRecurrenceEndRuleRadioButton]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: RecurrenceService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    type: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    radioClass: [{
      type: HostBinding,
      args: ["class.k-radio"]
    }],
    radioSizeClass: [{
      type: HostBinding,
      args: ["class.k-radio-md"]
    }],
    endRuleId: [{
      type: Input,
      args: ["kendoRecurrenceEndRuleRadioButton"]
    }]
  });
})();
var RecurrenceEndRuleEditorComponent = class _RecurrenceEndRuleEditorComponent {
  recurrence;
  localization;
  cssClass = true;
  set userNumericOptions(options) {
    this.numericOptions = __spreadValues(__spreadValues({}, this.numericOptions), options);
  }
  set userDatePickerOptions(options) {
    this.datePickerOptions = __spreadValues(__spreadValues({}, this.datePickerOptions), options);
  }
  endRuleRadioButtons;
  countValue;
  untilValue;
  numericOptions = {
    min: 1,
    format: "#",
    autoCorrect: true,
    step: 1,
    spinners: true
  };
  datePickerOptions = {
    activeView: "month",
    bottomView: "month",
    topView: "century",
    disabledDatesValidation: true,
    navigation: true,
    format: "d"
  };
  uniqueId;
  subscriptions;
  constructor(recurrence, localization) {
    this.recurrence = recurrence;
    this.localization = localization;
    this.uniqueId = this.recurrence.getUniqueId();
    this.setInitialValues();
    this.subscribeChanges();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  setEndRule(endRule) {
    if (endRule === "count") {
      this.recurrence.rrule.count = this.countValue;
    } else if (endRule === "until") {
      this.recurrence.until = this.untilValue;
    }
  }
  get rrule() {
    return this.recurrence.rrule;
  }
  get isCountDisabled() {
    return this.recurrence.endRule !== "count";
  }
  get isUntilDisabled() {
    return this.recurrence.endRule !== "until";
  }
  onCountChange(value2) {
    if (isPresent4(value2)) {
      this.recurrence.count = value2;
    }
  }
  onCountBlur() {
    if (!isPresent4(this.countValue)) {
      this.recurrence.count = this.countValue = 1;
    }
  }
  onUntilChange(value2) {
    if (isPresent4(value2)) {
      this.recurrence.until = this.createUntil(value2);
    }
  }
  onUntilBlur() {
    if (!isPresent4(this.untilValue)) {
      this.recurrence.until = this.untilValue = this.createUntil(this.recurrence.start);
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  onEndLabelClick() {
    const selected = this.endRuleRadioButtons.toArray().find((r) => r.elem.checked);
    if (selected) {
      selected.elem.focus();
    }
  }
  setInitialValues() {
    this.countValue = this.rrule.count || 1;
    const currentUntil = this.recurrence.until;
    const currentStart = this.recurrence.start;
    this.untilValue = isPresent4(currentUntil) ? currentUntil : this.createUntil(currentStart);
  }
  subscribeChanges() {
    this.subscriptions = this.recurrence.endRuleChange.subscribe((endRule) => {
      this.setEndRule(endRule);
    });
    this.subscriptions.add(this.recurrence.frequencyChange.subscribe(() => {
      this.setInitialValues();
    }));
  }
  createUntil(until) {
    const untilDate = toUTCDate(until);
    untilDate.setUTCHours(23);
    untilDate.setUTCMinutes(59);
    untilDate.setUTCSeconds(59);
    return ZonedDate.fromUTCDate(untilDate, this.recurrence.timezone).toLocalDate();
  }
  static ɵfac = function RecurrenceEndRuleEditorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceEndRuleEditorComponent)(ɵɵdirectiveInject(RecurrenceService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RecurrenceEndRuleEditorComponent,
    selectors: [["kendo-recurrence-end-rule-editor"]],
    viewQuery: function RecurrenceEndRuleEditorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(EndRuleRadioButtonDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.endRuleRadioButtons = _t);
      }
    },
    hostVars: 2,
    hostBindings: function RecurrenceEndRuleEditorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-scheduler-recurrence-end-rule-editor", ctx.cssClass);
      }
    },
    inputs: {
      userNumericOptions: "userNumericOptions",
      userDatePickerOptions: "userDatePickerOptions"
    },
    decls: 26,
    vars: 61,
    consts: [["afterOccurances", ""], [1, "k-form-field"], ["labelCssClass", "k-form-label", 3, "click", "text"], [1, "k-form-field-wrap"], [1, "k-radio-list"], [1, "k-radio-list-item"], [1, "k-radio-wrap"], [3, "kendoRecurrenceEndRuleRadioButton"], [1, "k-radio-label", 3, "labelClass", "for"], [1, "k-recur-count", 3, "valueChange", "blur", "autoCorrect", "decimals", "disabled", "format", "min", "max", "readonly", "selectOnFocus", "spinners", "step", "title", "value"], [3, "increment", "decrement"], [1, "k-recur-until", 3, "valueChange", "blur", "clearButton", "disabled", "activeView", "bottomView", "disabledDatesValidation", "focusedDate", "format", "formatPlaceholder", "max", "min", "navigation", "placeholder", "readOnlyInput", "readonly", "title", "topView", "weekNumber", "disabledDates", "popupSettings", "value"], [3, "today", "toggle", "parentViewButtonTitle"]],
    template: function RecurrenceEndRuleEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 1)(1, "kendo-label", 2);
        ɵɵlistener("click", function RecurrenceEndRuleEditorComponent_Template_kendo_label_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onEndLabelClick());
        });
        ɵɵelementEnd();
        ɵɵelementStart(2, "div", 3)(3, "ul", 4)(4, "li", 5)(5, "span", 6);
        ɵɵelement(6, "input", 7);
        ɵɵelementEnd();
        ɵɵelementStart(7, "label", 8);
        ɵɵtext(8);
        ɵɵelementEnd()();
        ɵɵelementStart(9, "li", 5)(10, "span", 6);
        ɵɵelement(11, "input", 7);
        ɵɵelementEnd();
        ɵɵelementStart(12, "label", 8);
        ɵɵtext(13);
        ɵɵelementEnd();
        ɵɵelementStart(14, "kendo-numerictextbox", 9, 0);
        ɵɵtwoWayListener("valueChange", function RecurrenceEndRuleEditorComponent_Template_kendo_numerictextbox_valueChange_14_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.countValue, $event) || (ctx.countValue = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("blur", function RecurrenceEndRuleEditorComponent_Template_kendo_numerictextbox_blur_14_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCountBlur());
        })("valueChange", function RecurrenceEndRuleEditorComponent_Template_kendo_numerictextbox_valueChange_14_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCountChange($event));
        });
        ɵɵelement(16, "kendo-numerictextbox-messages", 10);
        ɵɵelementEnd();
        ɵɵelementStart(17, "span");
        ɵɵtext(18);
        ɵɵelementEnd()();
        ɵɵelementStart(19, "li", 5)(20, "span", 6);
        ɵɵelement(21, "input", 7);
        ɵɵelementEnd();
        ɵɵelementStart(22, "label", 8);
        ɵɵtext(23);
        ɵɵelementEnd();
        ɵɵelementStart(24, "kendo-datepicker", 11);
        ɵɵtwoWayListener("valueChange", function RecurrenceEndRuleEditorComponent_Template_kendo_datepicker_valueChange_24_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.untilValue, $event) || (ctx.untilValue = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("blur", function RecurrenceEndRuleEditorComponent_Template_kendo_datepicker_blur_24_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onUntilBlur());
        })("valueChange", function RecurrenceEndRuleEditorComponent_Template_kendo_datepicker_valueChange_24_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onUntilChange($event));
        });
        ɵɵelement(25, "kendo-datepicker-messages", 12);
        ɵɵelementEnd()()()()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("text", ctx.textFor("endLabel"));
        ɵɵadvance(5);
        ɵɵpropertyInterpolate1("kendoRecurrenceEndRuleRadioButton", "k-endrule-never-", ctx.uniqueId, "");
        ɵɵadvance();
        ɵɵpropertyInterpolate1("for", "k-endrule-never-", ctx.uniqueId, "");
        ɵɵproperty("labelClass", false);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.textFor("endNever"));
        ɵɵadvance(3);
        ɵɵpropertyInterpolate1("kendoRecurrenceEndRuleRadioButton", "k-endrule-count-", ctx.uniqueId, "");
        ɵɵadvance();
        ɵɵpropertyInterpolate1("for", "k-endrule-count-", ctx.uniqueId, "");
        ɵɵproperty("labelClass", false);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.textFor("endAfter"));
        ɵɵadvance();
        ɵɵstyleProp("width", 70, "px");
        ɵɵproperty("autoCorrect", ctx.numericOptions.autoCorrect)("decimals", 0)("disabled", ctx.isCountDisabled)("format", ctx.numericOptions.format)("min", ctx.numericOptions.min)("max", ctx.numericOptions.max)("readonly", ctx.numericOptions.readonly)("selectOnFocus", ctx.numericOptions.selectOnFocus)("spinners", ctx.numericOptions.spinners)("step", ctx.numericOptions.step)("title", ctx.numericOptions.title);
        ɵɵtwoWayProperty("value", ctx.countValue);
        ɵɵadvance(2);
        ɵɵproperty("increment", ctx.textFor("numericIncrement"))("decrement", ctx.textFor("numericDecrement"));
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.textFor("endOccurrence"));
        ɵɵadvance(3);
        ɵɵpropertyInterpolate1("kendoRecurrenceEndRuleRadioButton", "k-endrule-until-", ctx.uniqueId, "");
        ɵɵadvance();
        ɵɵpropertyInterpolate1("for", "k-endrule-until-", ctx.uniqueId, "");
        ɵɵproperty("labelClass", false);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.textFor("endOn"));
        ɵɵadvance();
        ɵɵstyleProp("width", 150, "px");
        ɵɵproperty("clearButton", true)("disabled", ctx.isUntilDisabled)("activeView", ctx.datePickerOptions.activeView)("bottomView", ctx.datePickerOptions.bottomView)("disabledDatesValidation", ctx.datePickerOptions.disabledDatesValidation)("focusedDate", ctx.datePickerOptions.focusedDate)("format", ctx.datePickerOptions.format)("formatPlaceholder", ctx.datePickerOptions.formatPlaceHolder)("max", ctx.datePickerOptions.max)("min", ctx.datePickerOptions.min)("navigation", ctx.datePickerOptions.navigation)("placeholder", ctx.datePickerOptions.placeholder)("readOnlyInput", ctx.datePickerOptions.readOnlyInput)("readonly", ctx.datePickerOptions.readonly)("title", ctx.datePickerOptions.title)("topView", ctx.datePickerOptions.topView)("weekNumber", ctx.datePickerOptions.weekNumber)("disabledDates", ctx.datePickerOptions.disabledDates)("popupSettings", ctx.datePickerOptions.popupSettings);
        ɵɵtwoWayProperty("value", ctx.untilValue);
        ɵɵadvance();
        ɵɵproperty("today", ctx.textFor("dateInputsToday"))("toggle", ctx.textFor("dateInputsToggle"))("parentViewButtonTitle", ctx.textFor("dateInputsParentViewButton"));
      }
    },
    dependencies: [LabelComponent, EndRuleRadioButtonDirective, LabelDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, DatePickerComponent, DatePickerCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceEndRuleEditorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-recurrence-end-rule-editor",
      template: `
        <div class="k-form-field">
            <kendo-label
                [text]="textFor('endLabel')"
                (click)="onEndLabelClick()"
                labelCssClass="k-form-label"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <ul class='k-radio-list'>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-never-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-never-{{uniqueId}}'>{{ textFor('endNever') }}</label>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-count-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-count-{{uniqueId}}'>{{ textFor('endAfter') }}</label>
                        <kendo-numerictextbox
                            #afterOccurances
                            class="k-recur-count"
                            [style.width.px]='70'
                            [autoCorrect]='numericOptions.autoCorrect'
                            [decimals]='0'
                            [disabled]='isCountDisabled'
                            [format]="numericOptions.format"
                            [min]='numericOptions.min'
                            [max]="numericOptions.max"
                            [readonly]="numericOptions.readonly"
                            [selectOnFocus]="numericOptions.selectOnFocus"
                            [spinners]="numericOptions.spinners"
                            [step]="numericOptions.step"
                            [title]="numericOptions.title"
                            [(value)]='countValue'
                            (blur)="onCountBlur()"
                            (valueChange)='onCountChange($event)'
                        >
                            <kendo-numerictextbox-messages
                                [increment]="textFor('numericIncrement')"
                                [decrement]="textFor('numericDecrement')"
                            >
                            </kendo-numerictextbox-messages>
                        </kendo-numerictextbox>
                        <span>{{ textFor('endOccurrence') }}</span>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-until-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-until-{{uniqueId}}'>{{ textFor('endOn') }}</label>
                        <kendo-datepicker
                            class="k-recur-until"
                            [style.width.px]='150'
                            [clearButton]="true"
                            [disabled]='isUntilDisabled'
                            [activeView]="datePickerOptions.activeView"
                            [bottomView]="datePickerOptions.bottomView"
                            [disabledDatesValidation]="datePickerOptions.disabledDatesValidation"
                            [focusedDate]="datePickerOptions.focusedDate"
                            [format]="datePickerOptions.format"
                            [formatPlaceholder]="datePickerOptions.formatPlaceHolder"
                            [max]="datePickerOptions.max"
                            [min]="datePickerOptions.min"
                            [navigation]="datePickerOptions.navigation"
                            [placeholder]="datePickerOptions.placeholder"
                            [readOnlyInput]="datePickerOptions.readOnlyInput"
                            [readonly]="datePickerOptions.readonly"
                            [title]="datePickerOptions.title"
                            [topView]="datePickerOptions.topView"
                            [weekNumber]="datePickerOptions.weekNumber"
                            [disabledDates]="datePickerOptions.disabledDates"
                            [popupSettings]="datePickerOptions.popupSettings"
                            [(value)]='untilValue'
                            (blur)="onUntilBlur()"
                            (valueChange)='onUntilChange($event)'
                        >
                            <kendo-datepicker-messages
                                [today]="textFor('dateInputsToday')"
                                [toggle]="textFor('dateInputsToggle')"
                                [parentViewButtonTitle]="textFor('dateInputsParentViewButton')"
                            >
                            </kendo-datepicker-messages>
                        </kendo-datepicker>
                    </li>
                </ul>
            </div>
        </div>
    `,
      standalone: true,
      imports: [LabelComponent, EndRuleRadioButtonDirective, LabelDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, DatePickerComponent, DatePickerCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: RecurrenceService
    }, {
      type: LocalizationService
    }];
  }, {
    cssClass: [{
      type: HostBinding,
      args: ["class.k-scheduler-recurrence-end-rule-editor"]
    }],
    userNumericOptions: [{
      type: Input
    }],
    userDatePickerOptions: [{
      type: Input
    }],
    endRuleRadioButtons: [{
      type: ViewChildren,
      args: [EndRuleRadioButtonDirective]
    }]
  });
})();
var RepeatOnRadioButtonDirective = class _RepeatOnRadioButtonDirective {
  el;
  renderer;
  recurrence;
  changeDetector;
  type = "radio";
  radioClass = true;
  radioSizeClass = true;
  set repeatOnRule(value2) {
    const parts = value2.split("-");
    this._repeatOnRule = parts[0];
    this._uniqueId = parts[1];
  }
  destroyClick;
  _repeatOnRule;
  _uniqueId;
  constructor(el, renderer, recurrence, changeDetector) {
    this.el = el;
    this.renderer = renderer;
    this.recurrence = recurrence;
    this.changeDetector = changeDetector;
    this.destroyClick = this.renderer.listen(this.elem, "click", this.onClick.bind(this));
  }
  ngOnInit() {
    this.renderer.setAttribute(this.elem, "id", `k-repeaton-${this._repeatOnRule}-${this._uniqueId}`);
    this.renderer.setAttribute(this.elem, "name", `day-${this._uniqueId}`);
  }
  ngAfterContentChecked() {
    this.setCheckedState();
  }
  ngOnDestroy() {
    if (this.destroyClick) {
      this.destroyClick();
    }
  }
  onClick() {
    if (this.elem.checked) {
      this.recurrence.repeatOnRule = this._repeatOnRule;
      this.changeDetector.markForCheck();
    }
  }
  setCheckedState() {
    const isChecked = this._repeatOnRule === this.recurrence.repeatOnRule;
    this.renderer.setProperty(this.elem, "checked", isChecked);
  }
  get elem() {
    return this.el.nativeElement;
  }
  static ɵfac = function RepeatOnRadioButtonDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RepeatOnRadioButtonDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(RecurrenceService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RepeatOnRadioButtonDirective,
    selectors: [["", "kendoRecurrenceRepeatOnRadioButton", ""]],
    hostVars: 5,
    hostBindings: function RepeatOnRadioButtonDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("type", ctx.type);
        ɵɵclassProp("k-radio", ctx.radioClass)("k-radio-md", ctx.radioSizeClass);
      }
    },
    inputs: {
      repeatOnRule: [0, "kendoRecurrenceRepeatOnRadioButton", "repeatOnRule"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RepeatOnRadioButtonDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoRecurrenceRepeatOnRadioButton]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: RecurrenceService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    type: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    radioClass: [{
      type: HostBinding,
      args: ["class.k-radio"]
    }],
    radioSizeClass: [{
      type: HostBinding,
      args: ["class.k-radio-md"]
    }],
    repeatOnRule: [{
      type: Input,
      args: ["kendoRecurrenceRepeatOnRadioButton"]
    }]
  });
})();
var RecurrenceMonthlyYearlyEditorComponent = class _RecurrenceMonthlyYearlyEditorComponent {
  recurrence;
  localization;
  set userNumericOptions(options) {
    this.numericOptions = __spreadValues(__spreadValues({}, this.numericOptions), options);
  }
  repeatOnRadioButtons;
  extendedWeekDays;
  offsetPositions;
  months;
  currentMonthDay;
  currentMonthMonthDay;
  currentMonthWeekDay;
  currentOffset;
  currentWeekDay;
  uniqueId;
  numericOptions = {
    min: 1,
    max: 31,
    format: "#",
    autoCorrect: true,
    step: 1,
    spinners: true
  };
  subs;
  constructor(recurrence, localization) {
    this.recurrence = recurrence;
    this.localization = localization;
    this.uniqueId = this.recurrence.getUniqueId();
    this.setInitialValues();
    this.subscribeEventHandlers();
  }
  setInitialValues() {
    this.extendedWeekDays = this.recurrence.extendedWeekDays;
    this.offsetPositions = this.recurrence.offsetPositions;
    this.currentOffset = this.defaultOffset;
    this.currentWeekDay = this.defaultWeekDay;
    if (this.currentFreq === "yearly") {
      this.months = this.recurrence.months;
      this.currentMonthMonthDay = this.currentMonthWeekDay = this.recurrence.rrule.byMonth[0];
    }
  }
  subscribeEventHandlers() {
    this.subs = this.recurrence.repeatOnRuleChange.subscribe(this.onRepeatOnRuleChange.bind(this));
    this.subs.add(this.recurrence.frequencyChange.subscribe(this.onFrequencyChange.bind(this)));
  }
  onRepeatOnRuleChange(newRepeatOnRule) {
    if (newRepeatOnRule === "monthday") {
      this.recurrence.rrule.byMonthDay = [this.monthDay];
      if (this.currentFreq === "yearly") {
        this.recurrence.rrule.byMonth = [this.currentMonthMonthDay];
      }
    } else if (newRepeatOnRule === "weekday") {
      if (typeof this.weekDay === "string") {
        this.recurrence.rrule.bySetPosition = [this.offset];
        this.recurrence.rrule.byWeekDay = this.weekDayRuleFromString(this.weekDay);
      } else {
        this.recurrence.rrule.byWeekDay = [{
          day: this.weekDay,
          offset: this.offset
        }];
      }
      if (this.currentFreq === "yearly") {
        this.recurrence.rrule.byMonth = [this.currentMonthWeekDay];
      }
    }
  }
  onFrequencyChange() {
    this.setInitialValues();
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  get monthDay() {
    const rrule = this.recurrence.rrule;
    if (isPresent4(rrule.byMonthDay) && rrule.byMonthDay.length > 0) {
      return rrule.byMonthDay[0];
    } else if (isPresent4(this.currentMonthDay)) {
      return this.currentMonthDay;
    } else {
      return this.recurrence.start.getDate();
    }
  }
  get weekDay() {
    const rrule = this.recurrence.rrule;
    if (isPresent4(rrule.byWeekDay)) {
      const weekDaysCount = rrule.byWeekDay.length;
      switch (weekDaysCount) {
        case 7:
          return "day";
        case 5:
          return "weekday";
        case 2:
          return "weekend";
        case 1:
          return rrule.byWeekDay[0].day;
        default:
          break;
      }
    } else if (isPresent4(this.currentWeekDay)) {
      return this.currentWeekDay;
    }
    return this.defaultWeekDay;
  }
  get offset() {
    const rrule = this.recurrence.rrule;
    if (isPresent4(rrule.byWeekDay)) {
      const weekDaysCount = rrule.byWeekDay.length;
      switch (weekDaysCount) {
        case 7:
        case 5:
        case 2:
          return rrule.bySetPosition[0];
        case 1:
          return rrule.byWeekDay[0].offset;
        default:
          break;
      }
    } else if (isPresent4(this.currentOffset)) {
      return this.currentOffset;
    }
    return this.defaultOffset;
  }
  onMonthChange(month, repeatOnRule) {
    if (repeatOnRule === "monthday") {
      this.currentMonthMonthDay = month;
    } else {
      this.currentMonthWeekDay = month;
    }
    this.recurrence.setMonths([month]);
  }
  onMonthDayChange(monthDay) {
    this.currentMonthDay = monthDay;
    this.recurrence.monthDays = [monthDay];
  }
  onOffsetPositionChange(offset2) {
    const rrule = this.recurrence.rrule;
    if (isPresent4(rrule.byWeekDay)) {
      const weekDaysCount = rrule.byWeekDay.length;
      switch (weekDaysCount) {
        case 7:
        case 5:
        case 2:
          this.recurrence.positions = [offset2];
          break;
        case 1:
          rrule.byWeekDay[0].offset = offset2;
          this.recurrence.onChange();
          break;
        default:
          break;
      }
    }
    this.currentOffset = offset2;
  }
  onWeekDayChange(weekDay) {
    let weekDays;
    if (typeof weekDay === "string") {
      weekDays = this.weekDayRuleFromString(weekDay);
      this.recurrence.positions = [this.offset];
    } else {
      this.recurrence.rrule.bySetPosition = null;
      this.recurrence.rrule.byWeekDay = null;
      weekDays = [{
        day: weekDay,
        offset: this.offset
      }];
    }
    this.currentWeekDay = weekDay;
    this.recurrence.setWeekDays(weekDays);
  }
  isDisabled(repeatOn) {
    return this.recurrence.repeatOnRule !== repeatOn;
  }
  get currentFreq() {
    return this.recurrence.frequency;
  }
  get defaultOffset() {
    return 1;
  }
  get defaultWeekDay() {
    return this.recurrence.start.getDay();
  }
  weekDayRuleFromString(weekDay) {
    switch (weekDay) {
      case "day":
        return dayRule;
      case "weekday":
        return weekdayRule;
      case "weekend":
        return weekendRule;
      default:
        break;
    }
    return null;
  }
  textForRepeatOn() {
    const freq = this.currentFreq;
    switch (freq) {
      case "monthly":
        return this.textFor("monthlyRepeatOn");
      case "yearly":
        return this.textFor("yearlyRepeatOn");
      default:
        break;
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  onRepeatOnLabelClick() {
    const selected = this.repeatOnRadioButtons.toArray().find((r) => r.elem.checked);
    if (selected) {
      selected.elem.focus();
    }
  }
  static ɵfac = function RecurrenceMonthlyYearlyEditorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceMonthlyYearlyEditorComponent)(ɵɵdirectiveInject(RecurrenceService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RecurrenceMonthlyYearlyEditorComponent,
    selectors: [["kendo-recurrence-monthly-yearly-editor"]],
    viewQuery: function RecurrenceMonthlyYearlyEditorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(RepeatOnRadioButtonDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.repeatOnRadioButtons = _t);
      }
    },
    inputs: {
      userNumericOptions: "userNumericOptions"
    },
    decls: 19,
    vars: 40,
    consts: [[1, "k-form-field"], ["labelCssClass", "k-form-label", 3, "click", "text"], [1, "k-form-field-wrap"], [1, "k-radio-list"], [1, "k-radio-list-item"], [1, "k-radio-wrap"], [3, "kendoRecurrenceRepeatOnRadioButton"], [1, "k-radio-label", 3, "labelClass", "for"], [3, "ngIf"], [1, "k-recur-monthday", 3, "valueChange", "min", "max", "decimals", "format", "autoCorrect", "readonly", "selectOnFocus", "spinners", "step", "title", "value", "disabled"], [3, "increment", "decrement"], ["textField", "text", "valueField", "value", 3, "valueChange", "data", "value", "valuePrimitive", "disabled"]],
    template: function RecurrenceMonthlyYearlyEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "kendo-label", 1);
        ɵɵlistener("click", function RecurrenceMonthlyYearlyEditorComponent_Template_kendo_label_click_1_listener() {
          return ctx.onRepeatOnLabelClick();
        });
        ɵɵelementEnd();
        ɵɵelementStart(2, "div", 2)(3, "ul", 3)(4, "li", 4)(5, "span", 5);
        ɵɵelement(6, "input", 6);
        ɵɵelementEnd();
        ɵɵelementStart(7, "label", 7);
        ɵɵtemplate(8, RecurrenceMonthlyYearlyEditorComponent_ng_template_8_Template, 1, 1, "ng-template", 8);
        ɵɵelementEnd();
        ɵɵtemplate(9, RecurrenceMonthlyYearlyEditorComponent_ng_template_9_Template, 1, 8, "ng-template", 8);
        ɵɵelementStart(10, "kendo-numerictextbox", 9);
        ɵɵlistener("valueChange", function RecurrenceMonthlyYearlyEditorComponent_Template_kendo_numerictextbox_valueChange_10_listener($event) {
          return ctx.onMonthDayChange($event);
        });
        ɵɵelement(11, "kendo-numerictextbox-messages", 10);
        ɵɵelementEnd()();
        ɵɵelementStart(12, "li", 4)(13, "span", 5);
        ɵɵelement(14, "input", 6);
        ɵɵelementEnd();
        ɵɵelement(15, "label", 7);
        ɵɵelementStart(16, "kendo-dropdownlist", 11);
        ɵɵlistener("valueChange", function RecurrenceMonthlyYearlyEditorComponent_Template_kendo_dropdownlist_valueChange_16_listener($event) {
          return ctx.onOffsetPositionChange($event);
        });
        ɵɵelementEnd();
        ɵɵelementStart(17, "kendo-dropdownlist", 11);
        ɵɵlistener("valueChange", function RecurrenceMonthlyYearlyEditorComponent_Template_kendo_dropdownlist_valueChange_17_listener($event) {
          return ctx.onWeekDayChange($event);
        });
        ɵɵelementEnd();
        ɵɵtemplate(18, RecurrenceMonthlyYearlyEditorComponent_ng_template_18_Template, 3, 7, "ng-template", 8);
        ɵɵelementEnd()()()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("text", ctx.textForRepeatOn());
        ɵɵadvance(5);
        ɵɵpropertyInterpolate1("kendoRecurrenceRepeatOnRadioButton", "monthday-", ctx.uniqueId, "");
        ɵɵadvance();
        ɵɵpropertyInterpolate1("for", "k-repeaton-monthday-", ctx.uniqueId, "");
        ɵɵproperty("labelClass", false);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.currentFreq === "monthly");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.currentFreq === "yearly");
        ɵɵadvance();
        ɵɵproperty("min", ctx.numericOptions.min)("max", ctx.numericOptions.max)("decimals", 0)("format", ctx.numericOptions.format)("autoCorrect", ctx.numericOptions.autoCorrect)("readonly", ctx.numericOptions.readonly)("selectOnFocus", ctx.numericOptions.selectOnFocus)("spinners", ctx.numericOptions.spinners)("step", ctx.numericOptions.step)("title", ctx.numericOptions.title)("value", ctx.monthDay)("disabled", ctx.isDisabled("monthday"));
        ɵɵadvance();
        ɵɵproperty("increment", ctx.textFor("numericIncrement"))("decrement", ctx.textFor("numericDecrement"));
        ɵɵadvance(3);
        ɵɵpropertyInterpolate1("kendoRecurrenceRepeatOnRadioButton", "weekday-", ctx.uniqueId, "");
        ɵɵadvance();
        ɵɵpropertyInterpolate1("for", "k-repeaton-weekday-", ctx.uniqueId, "");
        ɵɵproperty("labelClass", false);
        ɵɵadvance();
        ɵɵstyleProp("margin", "0 .4ex 0 1ex");
        ɵɵproperty("data", ctx.offsetPositions)("value", ctx.offset)("valuePrimitive", true)("disabled", ctx.isDisabled("weekday"));
        ɵɵadvance();
        ɵɵstyleProp("margin", "0 .4ex 0 1ex");
        ɵɵproperty("data", ctx.extendedWeekDays)("value", ctx.weekDay)("valuePrimitive", true)("disabled", ctx.isDisabled("weekday"));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.currentFreq === "yearly");
      }
    },
    dependencies: [LabelComponent, RepeatOnRadioButtonDirective, LabelDirective, NgIf, DropDownListComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceMonthlyYearlyEditorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-recurrence-monthly-yearly-editor",
      template: `
        <div class='k-form-field'>
            <kendo-label
                [text]="textForRepeatOn()"
                labelCssClass="k-form-label"
                (click)="onRepeatOnLabelClick()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <ul class='k-radio-list'>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceRepeatOnRadioButton='monthday-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-repeaton-monthday-{{uniqueId}}'>
                            <ng-template [ngIf]="currentFreq === 'monthly'">
                                {{ textFor('monthlyDay') }}
                            </ng-template>
                        </label>

                        <ng-template [ngIf]="currentFreq === 'yearly'">
                            <kendo-dropdownlist
                                [data]='months'
                                textField='text'
                                valueField='value'
                                [value]='currentMonthMonthDay'
                                [valuePrimitive]='true'
                                (valueChange)="onMonthChange($event, 'monthday')"
                                [disabled]="isDisabled('monthday')"
                                [style.width.px]="170"
                                [style.margin]="'0 .4ex 0 1ex'">
                            </kendo-dropdownlist>
                        </ng-template>

                        <kendo-numerictextbox
                            class="k-recur-monthday"
                            [min]="numericOptions.min"
                            [max]="numericOptions.max"
                            [decimals]="0"
                            [format]="numericOptions.format"
                            [autoCorrect]="numericOptions.autoCorrect"
                            [readonly]="numericOptions.readonly"
                            [selectOnFocus]="numericOptions.selectOnFocus"
                            [spinners]="numericOptions.spinners"
                            [step]="numericOptions.step"
                            [title]="numericOptions.title"
                            [value]='monthDay'
                            (valueChange)='onMonthDayChange($event)'
                            [disabled]="isDisabled('monthday')"
                        >
                            <kendo-numerictextbox-messages 
                                [increment]="textFor('numericIncrement')"
                                [decrement]="textFor('numericDecrement')"
                            >
                            </kendo-numerictextbox-messages>
                        </kendo-numerictextbox>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceRepeatOnRadioButton='weekday-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-repeaton-weekday-{{uniqueId}}'></label>

                        <kendo-dropdownlist
                            [data]='offsetPositions'
                            textField='text'
                            valueField='value'
                            [value]='offset'
                            [valuePrimitive]='true'
                            (valueChange)='onOffsetPositionChange($event)'
                            [disabled]="isDisabled('weekday')"
                            [style.margin]="'0 .4ex 0 1ex'">
                        </kendo-dropdownlist>

                        <kendo-dropdownlist
                            [data]="extendedWeekDays"
                            textField='text'
                            valueField='value'
                            [value]='weekDay'
                            [valuePrimitive]='true'
                            (valueChange)='onWeekDayChange($event)'
                            [disabled]="isDisabled('weekday')"
                            [style.margin]="'0 .4ex 0 1ex'">
                        </kendo-dropdownlist>

                        <ng-template [ngIf]="currentFreq === 'yearly'">
                            <span>{{ textFor('yearlyOf') }}</span>

                            <kendo-dropdownlist
                                [data]='months'
                                textField='text'
                                valueField='value'
                                [value]='currentMonthWeekDay'
                                [valuePrimitive]='true'
                                (valueChange)="onMonthChange($event, 'weekday')"
                                [disabled]="isDisabled('weekday')"
                                [style.margin]="'0 .4ex 0 1ex'">
                            </kendo-dropdownlist>
                        </ng-template>
                    </li>
                </ul>
            </div>
        </div>
    `,
      standalone: true,
      imports: [LabelComponent, RepeatOnRadioButtonDirective, LabelDirective, NgIf, DropDownListComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: RecurrenceService
    }, {
      type: LocalizationService
    }];
  }, {
    userNumericOptions: [{
      type: Input
    }],
    repeatOnRadioButtons: [{
      type: ViewChildren,
      args: [RepeatOnRadioButtonDirective]
    }]
  });
})();
var RecurrenceWeekdayRuleEditorComponent = class _RecurrenceWeekdayRuleEditorComponent {
  recurrence;
  localization;
  weekDayButtons;
  weekDays;
  selected = [];
  constructor(recurrence, localization) {
    this.recurrence = recurrence;
    this.localization = localization;
    this.weekDays = this.recurrence.weekDays;
    this.setSelectedDays();
  }
  setSelectedDays() {
    for (let i = 0; i < 7; i++) {
      this.selected[i] = false;
    }
    if (isPresent4(this.rrule.byWeekDay)) {
      this.rrule.byWeekDay.forEach((rule) => {
        this.selected[rule.day] = true;
      });
    }
  }
  onSelectedChange(isSelected, day) {
    this.selected[day] = isSelected;
    this.recurrence.setWeekDays(this.serializeToWeekDayRuleArray(this.selected));
  }
  isSelected(day) {
    return this.selected[day.value];
  }
  serializeToWeekDayRuleArray(arr) {
    const selectedValues = [];
    arr.forEach((isSelected, idx2) => {
      if (isSelected) {
        selectedValues.push({
          day: idx2,
          offset: 0
        });
      }
    });
    return selectedValues.length > 0 ? selectedValues : null;
  }
  get rrule() {
    return this.recurrence.rrule;
  }
  capitalize(day) {
    return capitalize(day);
  }
  textFor(key) {
    return this.localization.get(key);
  }
  onWeeklyRepeatOnClick() {
    const selected = this.weekDayButtons.toArray().find((r) => r.selected);
    if (selected) {
      selected.focus();
    }
  }
  static ɵfac = function RecurrenceWeekdayRuleEditorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceWeekdayRuleEditorComponent)(ɵɵdirectiveInject(RecurrenceService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RecurrenceWeekdayRuleEditorComponent,
    selectors: [["kendo-recurrence-weekday-rule-editor"]],
    viewQuery: function RecurrenceWeekdayRuleEditorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ButtonComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekDayButtons = _t);
      }
    },
    decls: 5,
    vars: 2,
    consts: [[1, "k-form-field"], ["labelCssClass", "k-form-label", 3, "click", "text"], [1, "k-form-field-wrap"], ["width", "100%", "selection", "multiple", 1, "k-button-group-solid"], ["kendoButton", "", 3, "toggleable", "selected", "selectedChange", 4, "ngFor", "ngForOf"], ["kendoButton", "", 3, "selectedChange", "toggleable", "selected"]],
    template: function RecurrenceWeekdayRuleEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "kendo-label", 1);
        ɵɵlistener("click", function RecurrenceWeekdayRuleEditorComponent_Template_kendo_label_click_1_listener() {
          return ctx.onWeeklyRepeatOnClick();
        });
        ɵɵelementEnd();
        ɵɵelementStart(2, "div", 2)(3, "kendo-buttongroup", 3);
        ɵɵtemplate(4, RecurrenceWeekdayRuleEditorComponent_button_4_Template, 2, 3, "button", 4);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("text", ctx.textFor("weeklyRepeatOn"));
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.weekDays);
      }
    },
    dependencies: [LabelComponent, ButtonGroupComponent, NgForOf, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceWeekdayRuleEditorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-recurrence-weekday-rule-editor",
      template: `
        <div class="k-form-field">
            <kendo-label
                [text]="textFor('weeklyRepeatOn')"
                labelCssClass="k-form-label"
                (click)="onWeeklyRepeatOnClick()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-buttongroup
                    class="k-button-group-solid"
                    width="100%"
                    selection="multiple"
                >
                    <button
                        *ngFor='let day of weekDays'
                        kendoButton
                        [toggleable]="true"
                        [selected]="isSelected(day)"
                        (selectedChange)="onSelectedChange($event, day.value)"
                    >{{ capitalize(day.text) }}</button>
                </kendo-buttongroup>
            </div>
        </div>
    `,
      standalone: true,
      imports: [LabelComponent, ButtonGroupComponent, NgForOf, ButtonComponent]
    }]
  }], function() {
    return [{
      type: RecurrenceService
    }, {
      type: LocalizationService
    }];
  }, {
    weekDayButtons: [{
      type: ViewChildren,
      args: [ButtonComponent]
    }]
  });
})();
var RecurrenceIntervalEditorComponent = class _RecurrenceIntervalEditorComponent {
  recurrence;
  localization;
  cssClass = true;
  set userNumericOptions(options) {
    this.numericOptions = __spreadValues(__spreadValues({}, this.numericOptions), options);
  }
  intervalValue;
  numericOptions = {
    min: 1,
    format: "#",
    autoCorrect: true,
    step: 1,
    spinners: true
  };
  constructor(recurrence, localization) {
    this.recurrence = recurrence;
    this.localization = localization;
    this.intervalValue = this.recurrence.rrule.interval || 1;
  }
  get currentFreq() {
    return this.recurrence.frequency;
  }
  onIntervalChange(newInterval) {
    if (isPresent4(newInterval)) {
      this.recurrence.interval = newInterval;
    }
  }
  onIntervalBlur() {
    if (!isPresent4(this.intervalValue)) {
      this.recurrence.interval = this.intervalValue = 1;
    }
  }
  textForRepeatEvery() {
    const freq = this.currentFreq;
    switch (freq) {
      case "daily":
        return this.textFor("dailyRepeatEvery");
      case "weekly":
        return this.textFor("weeklyRepeatEvery");
      case "monthly":
        return this.textFor("monthlyRepeatEvery");
      case "yearly":
        return this.textFor("yearlyRepeatEvery");
      default:
        break;
    }
  }
  textForFrequency() {
    const freq = this.currentFreq;
    switch (freq) {
      case "daily":
        return this.textFor("dailyInterval");
      case "weekly":
        return this.textFor("weeklyInterval");
      case "monthly":
        return this.textFor("monthlyInterval");
      case "yearly":
        return this.textFor("yearlyInterval");
      default:
        break;
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function RecurrenceIntervalEditorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceIntervalEditorComponent)(ɵɵdirectiveInject(RecurrenceService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RecurrenceIntervalEditorComponent,
    selectors: [["kendo-recurrence-interval-editor"]],
    hostVars: 2,
    hostBindings: function RecurrenceIntervalEditorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-scheduler-recurrence-interval-editor", ctx.cssClass);
      }
    },
    inputs: {
      userNumericOptions: "userNumericOptions"
    },
    decls: 8,
    vars: 16,
    consts: [["intervalNumeric", ""], [1, "k-form-field"], ["labelCssClass", "k-form-label", 3, "click", "for", "text"], [1, "k-form-field-wrap"], [1, "k-recur-interval", 3, "valueChange", "blur", "min", "max", "decimals", "format", "autoCorrect", "readonly", "selectOnFocus", "spinners", "step", "title", "value"], [3, "increment", "decrement"]],
    template: function RecurrenceIntervalEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 1)(1, "kendo-label", 2);
        ɵɵlistener("click", function RecurrenceIntervalEditorComponent_Template_kendo_label_click_1_listener() {
          ɵɵrestoreView(_r1);
          const intervalNumeric_r2 = ɵɵreference(4);
          return ɵɵresetView(intervalNumeric_r2.focus());
        });
        ɵɵelementEnd();
        ɵɵelementStart(2, "div", 3)(3, "kendo-numerictextbox", 4, 0);
        ɵɵtwoWayListener("valueChange", function RecurrenceIntervalEditorComponent_Template_kendo_numerictextbox_valueChange_3_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.intervalValue, $event) || (ctx.intervalValue = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("blur", function RecurrenceIntervalEditorComponent_Template_kendo_numerictextbox_blur_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onIntervalBlur());
        })("valueChange", function RecurrenceIntervalEditorComponent_Template_kendo_numerictextbox_valueChange_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onIntervalChange($event));
        });
        ɵɵelement(5, "kendo-numerictextbox-messages", 5);
        ɵɵelementEnd();
        ɵɵelementStart(6, "span");
        ɵɵtext(7);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        const intervalNumeric_r2 = ɵɵreference(4);
        ɵɵadvance();
        ɵɵproperty("for", intervalNumeric_r2)("text", ctx.textForRepeatEvery());
        ɵɵadvance(2);
        ɵɵproperty("min", ctx.numericOptions.min)("max", ctx.numericOptions.max)("decimals", 0)("format", ctx.numericOptions.format)("autoCorrect", ctx.numericOptions.autoCorrect)("readonly", ctx.numericOptions.readonly)("selectOnFocus", ctx.numericOptions.selectOnFocus)("spinners", ctx.numericOptions.spinners)("step", ctx.numericOptions.step)("title", ctx.numericOptions.title);
        ɵɵtwoWayProperty("value", ctx.intervalValue);
        ɵɵadvance(2);
        ɵɵproperty("increment", ctx.textFor("numericIncrement"))("decrement", ctx.textFor("numericDecrement"));
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx.textForFrequency(), "");
      }
    },
    dependencies: [LabelComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceIntervalEditorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-recurrence-interval-editor",
      template: `
        <div class="k-form-field">
            <kendo-label
                [for]="intervalNumeric"
                [text]="textForRepeatEvery()"
                labelCssClass="k-form-label"
                (click)="intervalNumeric.focus()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-numerictextbox
                    #intervalNumeric
                    class="k-recur-interval"
                    [min]="numericOptions.min"
                    [max]="numericOptions.max"
                    [decimals]="0"
                    [format]="numericOptions.format"
                    [autoCorrect]="numericOptions.autoCorrect"
                    [readonly]="numericOptions.readonly"
                    [selectOnFocus]="numericOptions.selectOnFocus"
                    [spinners]="numericOptions.spinners"
                    [step]="numericOptions.step"
                    [title]="numericOptions.title"
                    [(value)]="intervalValue"
                    (blur)="onIntervalBlur()"
                    (valueChange)="onIntervalChange($event)"
                >
                    <kendo-numerictextbox-messages 
                        [increment]="textFor('numericIncrement')"
                        [decrement]="textFor('numericDecrement')"
                    >
                    </kendo-numerictextbox-messages>
                </kendo-numerictextbox>
                <span>&nbsp;{{ textForFrequency() }}</span>
            </div>
        </div>
    `,
      standalone: true,
      imports: [LabelComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: RecurrenceService
    }, {
      type: LocalizationService
    }];
  }, {
    cssClass: [{
      type: HostBinding,
      args: ["class.k-scheduler-recurrence-interval-editor"]
    }],
    userNumericOptions: [{
      type: Input
    }]
  });
})();
var RecurrenceFrequencyEditorComponent = class _RecurrenceFrequencyEditorComponent {
  recurrence;
  localization;
  weekDayButtons;
  frequencies;
  constructor(recurrence, localization) {
    this.recurrence = recurrence;
    this.localization = localization;
  }
  ngOnInit() {
    this.frequencies = this.recurrence.frequencies;
  }
  get selected() {
    return this.recurrence.frequency;
  }
  onClick(newFreq) {
    if (newFreq.value !== this.selected) {
      this.recurrence.setFrequency(newFreq.value);
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  onFrequencyClick() {
    const selected = this.weekDayButtons.toArray().find((r) => r.selected);
    if (selected) {
      selected.focus();
    }
  }
  static ɵfac = function RecurrenceFrequencyEditorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceFrequencyEditorComponent)(ɵɵdirectiveInject(RecurrenceService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RecurrenceFrequencyEditorComponent,
    selectors: [["kendo-recurrence-frequency-editor"]],
    viewQuery: function RecurrenceFrequencyEditorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ButtonComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekDayButtons = _t);
      }
    },
    decls: 5,
    vars: 2,
    consts: [[1, "k-form-field"], ["labelCssClass", "k-form-label", 3, "click", "text"], [1, "k-form-field-wrap"], ["width", "100%", "selection", "single", 1, "k-scheduler-recurrence-repeat", "k-button-group-solid"], ["kendoButton", "", 3, "togglable", "selected", "click", 4, "ngFor", "ngForOf"], ["kendoButton", "", 3, "click", "togglable", "selected"]],
    template: function RecurrenceFrequencyEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "kendo-label", 1);
        ɵɵlistener("click", function RecurrenceFrequencyEditorComponent_Template_kendo_label_click_1_listener() {
          return ctx.onFrequencyClick();
        });
        ɵɵelementEnd();
        ɵɵelementStart(2, "div", 2)(3, "kendo-buttongroup", 3);
        ɵɵtemplate(4, RecurrenceFrequencyEditorComponent_button_4_Template, 2, 3, "button", 4);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("text", ctx.textFor("repeat"));
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.frequencies);
      }
    },
    dependencies: [LabelComponent, ButtonGroupComponent, NgForOf, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceFrequencyEditorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-recurrence-frequency-editor",
      template: `
        <div class='k-form-field'>
            <kendo-label
                [text]="textFor('repeat')"
                (click)="onFrequencyClick()"
                labelCssClass="k-form-label"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-buttongroup
                    class="k-scheduler-recurrence-repeat k-button-group-solid"
                    width="100%"
                    selection="single"
                >
                    <button *ngFor='let freq of frequencies' kendoButton
                            [togglable]="true"
                            [selected]="freq.value === selected"
                            (click)="onClick(freq)"
                    >{{ freq.text }}</button>
                </kendo-buttongroup>
            </div>
        </div>
    `,
      standalone: true,
      imports: [LabelComponent, ButtonGroupComponent, NgForOf, ButtonComponent]
    }]
  }], function() {
    return [{
      type: RecurrenceService
    }, {
      type: LocalizationService
    }];
  }, {
    weekDayButtons: [{
      type: ViewChildren,
      args: [ButtonComponent]
    }]
  });
})();
var Messages$1 = class Messages2 extends ComponentMessages {
  /**
   * The text similar to **Repeat** which is displayed in the recurrence editor.
   */
  repeat;
  /**
   * The text similar to **day(s)** which is displayed in the recurrence editor.
   */
  dailyInterval;
  /**
   * The text similar to **Repeat every** which is displayed in the recurrence editor.
   */
  dailyRepeatEvery;
  /**
   * The text similar to **week(s)** which is displayed in the recurrence editor.
   */
  weeklyInterval;
  /**
   * The text similar to **Repeat every** which is displayed in the recurrence editor.
   */
  weeklyRepeatEvery;
  /**
   * The text similar to **Repeat on** which is displayed in the recurrence editor.
   */
  weeklyRepeatOn;
  /**
   * The text similar to **Day** which is displayed in the recurrence editor.
   */
  monthlyDay;
  /**
   * The text similar to **month(s)** which is displayed in the recurrence editor.
   */
  monthlyInterval;
  /**
   * The text similar to **Repeat every** which is displayed in the recurrence editor.
   */
  monthlyRepeatEvery;
  /**
   * The text similar to **Repeat on** which is displayed in the recurrence editor.
   */
  monthlyRepeatOn;
  /**
   * The text similar to **of** which is displayed in the recurrence editor.
   */
  yearlyOf;
  /**
   * The text similar to **Repeat every** which is displayed in the recurrence editor.
   */
  yearlyRepeatEvery;
  /**
   * The text similar to **Repeat on** which is displayed in the recurrence editor.
   */
  yearlyRepeatOn;
  /**
   * The text similar to **year(s)** which is displayed in the recurrence editor.
   */
  yearlyInterval;
  /**
   * The text similar to **Daily** which is displayed in the recurrence editor.
   */
  frequenciesDaily;
  /**
   * The text similar to **Monthly** which is displayed in the recurrence editor.
   */
  frequenciesMonthly;
  /**
   * The text similar to **Never** which is displayed in the recurrence editor.
   */
  frequenciesNever;
  /**
   * The text similar to **Weekly** which is displayed in the recurrence editor.
   */
  frequenciesWeekly;
  /**
   * The text similar to **Yearly** which is displayed in the recurrence editor.
   */
  frequenciesYearly;
  /**
   * The text similar to **First** which is displayed in the recurrence editor.
   */
  offsetPositionsFirst;
  /**
   * The text similar to **Second** which is displayed in the recurrence editor.
   */
  offsetPositionsSecond;
  /**
   * The text similar to **Third** which is displayed in the recurrence editor.
   */
  offsetPositionsThird;
  /**
   * The text similar to **Fourth** which is displayed in the recurrence editor.
   */
  offsetPositionsFourth;
  /**
   * The text similar to **Last** which is displayed in the recurrence editor.
   */
  offsetPositionsLast;
  /**
   * The text similar to **Day** which is displayed in the repeat-by-section of the monthly recurrence pattern.
   */
  weekdaysDay;
  /**
   * The text similar to **Weekday** which is displayed in the repeat-by-section of the monthly recurrence pattern.
   */
  weekdaysWeekday;
  /**
   * The text similar to **Weekend Day** which is displayed in the repeat-by-section of the monthly recurrence pattern.
   */
  weekdaysWeekendday;
  /**
   * The text similar to **After** which is displayed in the recurrence editor.
   */
  endAfter;
  /**
   * The text similar to **occurrence(s)** which is displayed in the recurrence editor.
   */
  endOccurrence;
  /**
   * The text similar to **End** which is displayed in the recurrence editor.
   */
  endLabel;
  /**
   * The text similar to **Never** which is displayed in the recurrence editor.
   */
  endNever;
  /**
   * The text similar to **On** which is displayed in the recurrence editor.
   */
  endOn;
  /**
   * The title of the **Increment** button of the NumericTextBoxes which are displayed in the recurrence editor.
   */
  numericIncrement;
  /**
   * The title of the **Decrement** button of the NumericTextBoxes which are displayed in the recurrence editor.
   */
  numericDecrement;
  /**
   * The title of the **Today** button in the popup of the DatePickers which are displayed in the recurrence editor.
   */
  dateInputsToday;
  /**
   * The title of the **Toggle** button of the DatePickers which are displayed in the recurrence editor.
   */
  dateInputsToggle;
  /**
   * The title of the **Parent View** button in the popup of the DatePickers which are displayed in the recurrence editor.
   */
  dateInputsParentViewButton;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(Messages2)))(__ngFactoryType__ || Messages2);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: Messages2,
    inputs: {
      repeat: "repeat",
      dailyInterval: "dailyInterval",
      dailyRepeatEvery: "dailyRepeatEvery",
      weeklyInterval: "weeklyInterval",
      weeklyRepeatEvery: "weeklyRepeatEvery",
      weeklyRepeatOn: "weeklyRepeatOn",
      monthlyDay: "monthlyDay",
      monthlyInterval: "monthlyInterval",
      monthlyRepeatEvery: "monthlyRepeatEvery",
      monthlyRepeatOn: "monthlyRepeatOn",
      yearlyOf: "yearlyOf",
      yearlyRepeatEvery: "yearlyRepeatEvery",
      yearlyRepeatOn: "yearlyRepeatOn",
      yearlyInterval: "yearlyInterval",
      frequenciesDaily: "frequenciesDaily",
      frequenciesMonthly: "frequenciesMonthly",
      frequenciesNever: "frequenciesNever",
      frequenciesWeekly: "frequenciesWeekly",
      frequenciesYearly: "frequenciesYearly",
      offsetPositionsFirst: "offsetPositionsFirst",
      offsetPositionsSecond: "offsetPositionsSecond",
      offsetPositionsThird: "offsetPositionsThird",
      offsetPositionsFourth: "offsetPositionsFourth",
      offsetPositionsLast: "offsetPositionsLast",
      weekdaysDay: "weekdaysDay",
      weekdaysWeekday: "weekdaysWeekday",
      weekdaysWeekendday: "weekdaysWeekendday",
      endAfter: "endAfter",
      endOccurrence: "endOccurrence",
      endLabel: "endLabel",
      endNever: "endNever",
      endOn: "endOn",
      numericIncrement: "numericIncrement",
      numericDecrement: "numericDecrement",
      dateInputsToday: "dateInputsToday",
      dateInputsToggle: "dateInputsToggle",
      dateInputsParentViewButton: "dateInputsParentViewButton"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages$1, [{
    type: Directive
  }], null, {
    repeat: [{
      type: Input
    }],
    dailyInterval: [{
      type: Input
    }],
    dailyRepeatEvery: [{
      type: Input
    }],
    weeklyInterval: [{
      type: Input
    }],
    weeklyRepeatEvery: [{
      type: Input
    }],
    weeklyRepeatOn: [{
      type: Input
    }],
    monthlyDay: [{
      type: Input
    }],
    monthlyInterval: [{
      type: Input
    }],
    monthlyRepeatEvery: [{
      type: Input
    }],
    monthlyRepeatOn: [{
      type: Input
    }],
    yearlyOf: [{
      type: Input
    }],
    yearlyRepeatEvery: [{
      type: Input
    }],
    yearlyRepeatOn: [{
      type: Input
    }],
    yearlyInterval: [{
      type: Input
    }],
    frequenciesDaily: [{
      type: Input
    }],
    frequenciesMonthly: [{
      type: Input
    }],
    frequenciesNever: [{
      type: Input
    }],
    frequenciesWeekly: [{
      type: Input
    }],
    frequenciesYearly: [{
      type: Input
    }],
    offsetPositionsFirst: [{
      type: Input
    }],
    offsetPositionsSecond: [{
      type: Input
    }],
    offsetPositionsThird: [{
      type: Input
    }],
    offsetPositionsFourth: [{
      type: Input
    }],
    offsetPositionsLast: [{
      type: Input
    }],
    weekdaysDay: [{
      type: Input
    }],
    weekdaysWeekday: [{
      type: Input
    }],
    weekdaysWeekendday: [{
      type: Input
    }],
    endAfter: [{
      type: Input
    }],
    endOccurrence: [{
      type: Input
    }],
    endLabel: [{
      type: Input
    }],
    endNever: [{
      type: Input
    }],
    endOn: [{
      type: Input
    }],
    numericIncrement: [{
      type: Input
    }],
    numericDecrement: [{
      type: Input
    }],
    dateInputsToday: [{
      type: Input
    }],
    dateInputsToggle: [{
      type: Input
    }],
    dateInputsParentViewButton: [{
      type: Input
    }]
  });
})();
var RecurrenceEditorLocalizedMessagesDirective = class _RecurrenceEditorLocalizedMessagesDirective extends Messages$1 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function RecurrenceEditorLocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceEditorLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RecurrenceEditorLocalizedMessagesDirective,
    selectors: [["", "kendoRecurrenceEditorLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages$1,
      useExisting: forwardRef(() => _RecurrenceEditorLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceEditorLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages$1,
        useExisting: forwardRef(() => RecurrenceEditorLocalizedMessagesDirective)
      }],
      selector: "[kendoRecurrenceEditorLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var RECURRENCE_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RecurrenceEditorComponent)
};
var RecurrenceEditorComponent = class _RecurrenceEditorComponent {
  recurrenceService;
  intl;
  cssClass = true;
  /**
   * Specifies the start date of the event.
   */
  set start(value2) {
    this._start = value2;
  }
  get start() {
    return isPresent4(this._start) ? this._start : getDate(/* @__PURE__ */ new Date());
  }
  /**
   * Specifies the id of the timezone that will be used.
   * @default 'Etc/UTC'
   */
  timezone = "Etc/UTC";
  /**
   * The first day of the week. Defaults to the locale settings.
   */
  weekStart;
  /**
   * Specifies the options of the `Repeat Every` NumericTextBox component within the recurrence `interval` editor.
   */
  repeatEveryOptions;
  /**
   * Specifies the options of the `End After` NumericTextBox component within the recurrence `count` rule editor.
   */
  endAfterOptions;
  /**
   * Specifies the options of the `Repeat On` NumericTextBox component for choosing the day
   * an event will occur on within the monthly and yearly sections of the recurrence editor.
   */
  repeatOnOptions;
  /**
   * Specifies the options of the `End On` DatePicker component within the recurrence `until` rule editor.
   */
  endOnOptions;
  /**
   * Fires when the value of the component has changed.
   */
  valueChange = new EventEmitter();
  _start;
  subscriptions;
  constructor(recurrenceService, intl) {
    this.recurrenceService = recurrenceService;
    this.intl = intl;
    this.weekStart = this.intl.firstDay();
    this.subscriptions = this.recurrenceService.change.subscribe((rrule) => {
      this.emitChange(rrule);
    });
  }
  /**
   * @hidden
   */
  get currentFreq() {
    return this.recurrenceService.frequency;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.recurrenceService.init("", this.start, this.timezone, this.weekStart);
  }
  ngOnChanges(changes) {
    if (isChanged("start", changes)) {
      this.recurrenceService.start = this.start;
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  writeValue(rrule) {
    this.recurrenceService.init(typeof rrule === "string" ? rrule : "", this.start, this.timezone, this.weekStart);
  }
  onTouchedCallback = (_) => {
  };
  onChangeCallback = (_) => {
  };
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  emitChange(rrule) {
    this.onChangeCallback(rrule);
    this.valueChange.emit(rrule);
  }
  static ɵfac = function RecurrenceEditorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceEditorComponent)(ɵɵdirectiveInject(RecurrenceService), ɵɵdirectiveInject(IntlService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RecurrenceEditorComponent,
    selectors: [["kendo-recurrence-editor"]],
    hostVars: 2,
    hostBindings: function RecurrenceEditorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-recurrence-editor", ctx.cssClass);
      }
    },
    inputs: {
      start: "start",
      timezone: "timezone",
      weekStart: "weekStart",
      repeatEveryOptions: "repeatEveryOptions",
      endAfterOptions: "endAfterOptions",
      repeatOnOptions: "repeatOnOptions",
      endOnOptions: "endOnOptions"
    },
    outputs: {
      valueChange: "valueChange"
    },
    exportAs: ["kendoRecurrenceEditor"],
    features: [ɵɵProvidersFeature([RecurrenceLocalizationService, {
      provide: LocalizationService,
      useExisting: RecurrenceLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.recurrenceeditor"
    }, RECURRENCE_VALUE_ACCESSOR, RecurrenceService]), ɵɵNgOnChangesFeature],
    decls: 7,
    vars: 4,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_0 = goog.getMsg("Repeat");
        i18n_0 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.recurrenceeditor.repeat|The text similar to 'Repeat' displayed in the recurrence editor.:Repeat`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_1 = goog.getMsg("day(s)");
        i18n_1 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.recurrenceeditor.dailyInterval|The text similar to 'day(s)' displayed in the recurrence editor.:day(s)`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_2 = goog.getMsg("Repeat every");
        i18n_2 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.recurrenceeditor.dailyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor.:Repeat every`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_3 = goog.getMsg("week(s)");
        i18n_3 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.recurrenceeditor.weeklyInterval|The text similar to 'week(s)' displayed in the recurrence editor.:week(s)`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_4 = goog.getMsg("Repeat every");
        i18n_4 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.recurrenceeditor.weeklyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor.:Repeat every`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_5 = goog.getMsg("Repeat on");
        i18n_5 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.recurrenceeditor.weeklyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor.:Repeat on`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_6 = goog.getMsg("Day");
        i18n_6 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.recurrenceeditor.monthlyDay|The text similar to 'Day' displayed in the recurrence editor.:Day`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_7 = goog.getMsg("month(s)");
        i18n_7 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.recurrenceeditor.monthlyInterval|The text similar to 'month(s)' displayed in the recurrence editor.:month(s)`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_8 = goog.getMsg("Repeat every");
        i18n_8 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.recurrenceeditor.monthlyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor.:Repeat every`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_9 = goog.getMsg("Repeat on");
        i18n_9 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.recurrenceeditor.monthlyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor.:Repeat on`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_10 = goog.getMsg("of");
        i18n_10 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.recurrenceeditor.yearlyOf|The text similar to 'of' displayed in the recurrence editor.:of`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_11 = goog.getMsg("Repeat every");
        i18n_11 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.recurrenceeditor.yearlyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor.:Repeat every`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_12 = goog.getMsg("Repeat on");
        i18n_12 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.recurrenceeditor.yearlyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor.:Repeat on`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_13 = goog.getMsg("year(s)");
        i18n_13 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.recurrenceeditor.yearlyInterval|The text similar to 'year(s)' displayed in the recurrence editor.:year(s)`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_14 = goog.getMsg("Daily");
        i18n_14 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.recurrenceeditor.frequenciesDaily|The text similar to 'Daily' displayed in the recurrence editor.:Daily`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_15 = goog.getMsg("Monthly");
        i18n_15 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.recurrenceeditor.frequenciesMonthly|The text similar to 'Monthly' displayed in the recurrence editor.:Monthly`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_16 = goog.getMsg("Never");
        i18n_16 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.recurrenceeditor.frequenciesNever|The text similar to 'Never' displayed in the recurrence editor.:Never`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_17 = goog.getMsg("Weekly");
        i18n_17 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.recurrenceeditor.frequenciesWeekly|The text similar to 'Weekly' displayed in the recurrence editor.:Weekly`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_18 = goog.getMsg("Yearly");
        i18n_18 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.recurrenceeditor.frequenciesYearly|The text similar to 'Yearly' displayed in the recurrence editor.:Yearly`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_19 = goog.getMsg("First");
        i18n_19 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.recurrenceeditor.offsetPositionsFirst|The text similar to 'First' displayed in the recurrence editor.:First`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_20 = goog.getMsg("Second");
        i18n_20 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.recurrenceeditor.offsetPositionsSecond|The text similar to 'Second' displayed in the recurrence editor.:Second`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_21 = goog.getMsg("Third");
        i18n_21 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.recurrenceeditor.offsetPositionsThird|The text similar to 'Third' displayed in the recurrence editor.:Third`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_22 = goog.getMsg("Fourth");
        i18n_22 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.recurrenceeditor.offsetPositionsFourth|The text similar to 'Fourth' displayed in the recurrence editor.:Fourth`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_23 = goog.getMsg("Last");
        i18n_23 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.recurrenceeditor.offsetPositionsLast|The text similar to 'Last' displayed in the recurrence editor.:Last`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_24 = goog.getMsg("Day");
        i18n_24 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.recurrenceeditor.weekdaysDay|The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern.:Day`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_25 = goog.getMsg("Weekday");
        i18n_25 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.recurrenceeditor.weekdaysWeekday|The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern.:Weekday`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_26 = goog.getMsg("Weekend Day");
        i18n_26 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.recurrenceeditor.weekdaysWeekendday|The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern.:Weekend Day`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_27 = goog.getMsg("After");
        i18n_27 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.recurrenceeditor.endAfter|The text similar to 'After' displayed in the recurrence editor.:After`;
      }
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_28 = goog.getMsg("occurrence(s)");
        i18n_28 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.recurrenceeditor.endOccurrence|The text similar to 'occurrence(s)' displayed in the recurrence editor.:occurrence(s)`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_29 = goog.getMsg("End");
        i18n_29 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.recurrenceeditor.endLabel|The text similar to 'End' displayed in the recurrence editor.:End`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_30 = goog.getMsg("Never");
        i18n_30 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.recurrenceeditor.endNever|The text similar to 'Never' displayed in the recurrence editor.:Never`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_31 = goog.getMsg("On");
        i18n_31 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.recurrenceeditor.endOn|The text similar to 'On' displayed in the recurrence editor.:On`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_32 = goog.getMsg("Increase value");
        i18n_32 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.recurrenceeditor.numericIncrement|The title of the 'Increment' button of the NumericTextBoxes displayed in the recurrence editor.:Increase value`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_33 = goog.getMsg("Decrease value");
        i18n_33 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.recurrenceeditor.numericDecrement|The title of the 'Decrement' button of the NumericTextBoxes displayed in the recurrence editor.:Decrease value`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_34 = goog.getMsg("Today");
        i18n_34 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.recurrenceeditor.dateInputsToday|The title of the 'Today' button in the popup of the DatePickers displayed in the recurrence editor.:Today`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_35 = goog.getMsg("Toggle calendar");
        i18n_35 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.recurrenceeditor.dateInputsToggle|The title of the 'Toggle' button of the DatePickers displayed in the recurrence editor.:Toggle calendar`;
      }
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_36 = goog.getMsg("Navigate to parent view");
        i18n_36 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.recurrenceeditor.dateInputsParentViewButton|The title of the 'Parent View' button in the popup of the DatePickers displayed in the recurrence editor.:Navigate to parent view`;
      }
      return [["kendoRecurrenceEditorLocalizedMessages", "", "repeat", i18n_0, "dailyInterval", i18n_1, "dailyRepeatEvery", i18n_2, "weeklyInterval", i18n_3, "weeklyRepeatEvery", i18n_4, "weeklyRepeatOn", i18n_5, "monthlyDay", i18n_6, "monthlyInterval", i18n_7, "monthlyRepeatEvery", i18n_8, "monthlyRepeatOn", i18n_9, "yearlyOf", i18n_10, "yearlyRepeatEvery", i18n_11, "yearlyRepeatOn", i18n_12, "yearlyInterval", i18n_13, "frequenciesDaily", i18n_14, "frequenciesMonthly", i18n_15, "frequenciesNever", i18n_16, "frequenciesWeekly", i18n_17, "frequenciesYearly", i18n_18, "offsetPositionsFirst", i18n_19, "offsetPositionsSecond", i18n_20, "offsetPositionsThird", i18n_21, "offsetPositionsFourth", i18n_22, "offsetPositionsLast", i18n_23, "weekdaysDay", i18n_24, "weekdaysWeekday", i18n_25, "weekdaysWeekendday", i18n_26, "endAfter", i18n_27, "endOccurrence", i18n_28, "endLabel", i18n_29, "endNever", i18n_30, "endOn", i18n_31, "numericIncrement", i18n_32, "numericDecrement", i18n_33, "dateInputsToday", i18n_34, "dateInputsToggle", i18n_35, "dateInputsParentViewButton", i18n_36], [1, "k-recur-view"], [3, "userNumericOptions", 4, "ngIf"], [4, "ngIf"], [3, "userNumericOptions", "userDatePickerOptions", 4, "ngIf"], [3, "userNumericOptions"], [3, "userNumericOptions", "userDatePickerOptions"]];
    },
    template: function RecurrenceEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵelement(1, "kendo-recurrence-frequency-editor");
        ɵɵelementStart(2, "div", 1);
        ɵɵtemplate(3, RecurrenceEditorComponent_kendo_recurrence_interval_editor_3_Template, 1, 1, "kendo-recurrence-interval-editor", 2)(4, RecurrenceEditorComponent_kendo_recurrence_weekday_rule_editor_4_Template, 1, 0, "kendo-recurrence-weekday-rule-editor", 3)(5, RecurrenceEditorComponent_kendo_recurrence_monthly_yearly_editor_5_Template, 1, 1, "kendo-recurrence-monthly-yearly-editor", 2)(6, RecurrenceEditorComponent_kendo_recurrence_end_rule_editor_6_Template, 1, 2, "kendo-recurrence-end-rule-editor", 4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.currentFreq !== "never");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.currentFreq === "weekly");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.currentFreq === "monthly" || ctx.currentFreq === "yearly");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.currentFreq !== "never");
      }
    },
    dependencies: [RecurrenceEditorLocalizedMessagesDirective, RecurrenceFrequencyEditorComponent, NgIf, RecurrenceIntervalEditorComponent, RecurrenceWeekdayRuleEditorComponent, RecurrenceMonthlyYearlyEditorComponent, RecurrenceEndRuleEditorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceEditorComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoRecurrenceEditor",
      providers: [RecurrenceLocalizationService, {
        provide: LocalizationService,
        useExisting: RecurrenceLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.recurrenceeditor"
      }, RECURRENCE_VALUE_ACCESSOR, RecurrenceService],
      selector: "kendo-recurrence-editor",
      template: `
        <ng-container kendoRecurrenceEditorLocalizedMessages
            i18n-repeat="kendo.recurrenceeditor.repeat|The text similar to 'Repeat' displayed in the recurrence editor."
            repeat='Repeat'

            i18n-dailyInterval="kendo.recurrenceeditor.dailyInterval|The text similar to 'day(s)' displayed in the recurrence editor."
            dailyInterval='day(s)'

            i18n-dailyRepeatEvery="kendo.recurrenceeditor.dailyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            dailyRepeatEvery='Repeat every'

            i18n-weeklyInterval="kendo.recurrenceeditor.weeklyInterval|The text similar to 'week(s)' displayed in the recurrence editor."
            weeklyInterval='week(s)'

            i18n-weeklyRepeatEvery="kendo.recurrenceeditor.weeklyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            weeklyRepeatEvery='Repeat every'

            i18n-weeklyRepeatOn="kendo.recurrenceeditor.weeklyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            weeklyRepeatOn='Repeat on'

            i18n-monthlyDay="kendo.recurrenceeditor.monthlyDay|The text similar to 'Day' displayed in the recurrence editor."
            monthlyDay='Day'

            i18n-monthlyInterval="kendo.recurrenceeditor.monthlyInterval|The text similar to 'month(s)' displayed in the recurrence editor."
            monthlyInterval='month(s)'

            i18n-monthlyRepeatEvery="kendo.recurrenceeditor.monthlyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            monthlyRepeatEvery='Repeat every'

            i18n-monthlyRepeatOn="kendo.recurrenceeditor.monthlyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            monthlyRepeatOn='Repeat on'

            i18n-yearlyOf="kendo.recurrenceeditor.yearlyOf|The text similar to 'of' displayed in the recurrence editor."
            yearlyOf='of'

            i18n-yearlyRepeatEvery="kendo.recurrenceeditor.yearlyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            yearlyRepeatEvery='Repeat every'

            i18n-yearlyRepeatOn="kendo.recurrenceeditor.yearlyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            yearlyRepeatOn='Repeat on'

            i18n-yearlyInterval="kendo.recurrenceeditor.yearlyInterval|The text similar to 'year(s)' displayed in the recurrence editor."
            yearlyInterval='year(s)'

            i18n-frequenciesDaily="kendo.recurrenceeditor.frequenciesDaily|The text similar to 'Daily' displayed in the recurrence editor."
            frequenciesDaily='Daily'

            i18n-frequenciesMonthly="kendo.recurrenceeditor.frequenciesMonthly|The text similar to 'Monthly' displayed in the recurrence editor."
            frequenciesMonthly='Monthly'

            i18n-frequenciesNever="kendo.recurrenceeditor.frequenciesNever|The text similar to 'Never' displayed in the recurrence editor."
            frequenciesNever='Never'

            i18n-frequenciesWeekly="kendo.recurrenceeditor.frequenciesWeekly|The text similar to 'Weekly' displayed in the recurrence editor."
            frequenciesWeekly='Weekly'

            i18n-frequenciesYearly="kendo.recurrenceeditor.frequenciesYearly|The text similar to 'Yearly' displayed in the recurrence editor."
            frequenciesYearly='Yearly'

            i18n-offsetPositionsFirst="kendo.recurrenceeditor.offsetPositionsFirst|The text similar to 'First' displayed in the recurrence editor."
            offsetPositionsFirst='First'

            i18n-offsetPositionsSecond="kendo.recurrenceeditor.offsetPositionsSecond|The text similar to 'Second' displayed in the recurrence editor."
            offsetPositionsSecond='Second'

            i18n-offsetPositionsThird="kendo.recurrenceeditor.offsetPositionsThird|The text similar to 'Third' displayed in the recurrence editor."
            offsetPositionsThird='Third'

            i18n-offsetPositionsFourth="kendo.recurrenceeditor.offsetPositionsFourth|The text similar to 'Fourth' displayed in the recurrence editor."
            offsetPositionsFourth='Fourth'

            i18n-offsetPositionsLast="kendo.recurrenceeditor.offsetPositionsLast|The text similar to 'Last' displayed in the recurrence editor."
            offsetPositionsLast='Last'

            i18n-weekdaysDay="kendo.recurrenceeditor.weekdaysDay|The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysDay='Day'

            i18n-weekdaysWeekday="kendo.recurrenceeditor.weekdaysWeekday|The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysWeekday='Weekday'

            i18n-weekdaysWeekendday="kendo.recurrenceeditor.weekdaysWeekendday|The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysWeekendday='Weekend Day'

            i18n-endAfter="kendo.recurrenceeditor.endAfter|The text similar to 'After' displayed in the recurrence editor."
            endAfter='After'

            i18n-endOccurrence="kendo.recurrenceeditor.endOccurrence|The text similar to 'occurrence(s)' displayed in the recurrence editor."
            endOccurrence='occurrence(s)'

            i18n-endLabel="kendo.recurrenceeditor.endLabel|The text similar to 'End' displayed in the recurrence editor."
            endLabel='End'

            i18n-endNever="kendo.recurrenceeditor.endNever|The text similar to 'Never' displayed in the recurrence editor."
            endNever='Never'

            i18n-endOn="kendo.recurrenceeditor.endOn|The text similar to 'On' displayed in the recurrence editor."
            endOn='On'

            i18n-numericIncrement="kendo.recurrenceeditor.numericIncrement|The title of the 'Increment' button of the NumericTextBoxes displayed in the recurrence editor."
            numericIncrement='Increase value'

            i18n-numericDecrement="kendo.recurrenceeditor.numericDecrement|The title of the 'Decrement' button of the NumericTextBoxes displayed in the recurrence editor."
            numericDecrement='Decrease value'

            i18n-dateInputsToday="kendo.recurrenceeditor.dateInputsToday|The title of the 'Today' button in the popup of the DatePickers displayed in the recurrence editor."
            dateInputsToday='Today'

            i18n-dateInputsToggle="kendo.recurrenceeditor.dateInputsToggle|The title of the 'Toggle' button of the DatePickers displayed in the recurrence editor."
            dateInputsToggle='Toggle calendar'

            i18n-dateInputsParentViewButton="kendo.recurrenceeditor.dateInputsParentViewButton|The title of the 'Parent View' button in the popup of the DatePickers displayed in the recurrence editor."
            dateInputsParentViewButton='Navigate to parent view'
        >
        </ng-container>

        <kendo-recurrence-frequency-editor>
        </kendo-recurrence-frequency-editor>

        <div class="k-recur-view">
            <kendo-recurrence-interval-editor
                *ngIf="currentFreq !== 'never'"
                [userNumericOptions]="repeatEveryOptions">
            </kendo-recurrence-interval-editor>

            <kendo-recurrence-weekday-rule-editor *ngIf="currentFreq === 'weekly'">
            </kendo-recurrence-weekday-rule-editor>

            <kendo-recurrence-monthly-yearly-editor
                *ngIf="currentFreq === 'monthly' || currentFreq === 'yearly'"
                [userNumericOptions]="repeatOnOptions">
            </kendo-recurrence-monthly-yearly-editor>

            <kendo-recurrence-end-rule-editor
                *ngIf="currentFreq !== 'never'"
                [userNumericOptions]="endAfterOptions"
                [userDatePickerOptions]="endOnOptions">
            </kendo-recurrence-end-rule-editor>
        </div>
    `,
      standalone: true,
      imports: [RecurrenceEditorLocalizedMessagesDirective, RecurrenceFrequencyEditorComponent, NgIf, RecurrenceIntervalEditorComponent, RecurrenceWeekdayRuleEditorComponent, RecurrenceMonthlyYearlyEditorComponent, RecurrenceEndRuleEditorComponent]
    }]
  }], function() {
    return [{
      type: RecurrenceService
    }, {
      type: IntlService
    }];
  }, {
    cssClass: [{
      type: HostBinding,
      args: ["class.k-recurrence-editor"]
    }],
    start: [{
      type: Input
    }],
    timezone: [{
      type: Input
    }],
    weekStart: [{
      type: Input
    }],
    repeatEveryOptions: [{
      type: Input
    }],
    endAfterOptions: [{
      type: Input
    }],
    repeatOnOptions: [{
      type: Input
    }],
    endOnOptions: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var TIME_ZONE_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => TimeZoneEditorComponent)
};
var TimeZoneEditorComponent = class _TimeZoneEditorComponent {
  injector;
  tzComboBox;
  tzComboBoxControl;
  /**
   * Specifies the width of the ComboBox which contains the names of the timezones.
   * @default 260
   */
  width = 260;
  /**
   * Fires when the value of the component has changed.
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   */
  get focusableId() {
    return this.tzComboBox?.focusableId || this.tzComboBoxControl?.focusableId;
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  tz;
  tzNames;
  tzSource;
  constructor(injector) {
    this.injector = injector;
    this.tzNames = timezoneNames();
    this.tzSource = this.tzNames.slice();
  }
  /**
   * @hidden
   */
  onTimeZoneChange(tzName) {
    this.tz = tzName;
    this.onChangeCallback(this.tz);
    this.valueChange.emit(tzName);
  }
  /**
   * @hidden
   */
  onTimeZoneFilterChange(value2) {
    this.tzSource = this.tzNames.filter((tz) => tz.toLowerCase().indexOf(value2.toLowerCase()) !== -1);
  }
  /**
   * @hidden
   */
  writeValue(value2) {
    if (typeof value2 === "string" && this.tzNames.indexOf(value2) >= 0) {
      this.tz = value2;
    }
  }
  /**
   * @hidden
   */
  focus() {
    this.tzComboBox ? this.tzComboBox.focus() : this.tzComboBoxControl.focus();
  }
  onTouchedCallback = (_) => {
  };
  onChangeCallback = (_) => {
  };
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  static ɵfac = function TimeZoneEditorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeZoneEditorComponent)(ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeZoneEditorComponent,
    selectors: [["kendo-timezone-editor"]],
    viewQuery: function TimeZoneEditorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c38, 7);
        ɵɵviewQuery(_c43, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tzComboBox = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tzComboBoxControl = _t.first);
      }
    },
    inputs: {
      width: "width"
    },
    outputs: {
      valueChange: "valueChange"
    },
    features: [ɵɵProvidersFeature([TIME_ZONE_VALUE_ACCESSOR])],
    decls: 2,
    vars: 2,
    consts: [["tzcombobox", ""], ["tzcomboboxControl", ""], [3, "width", "allowCustom", "data", "filterable", "suggest", "value", "filterChange", "valueChange", 4, "ngIf"], [3, "width", "allowCustom", "data", "filterable", "suggest", "value", "formControl", "filterChange", "valueChange", 4, "ngIf"], [3, "filterChange", "valueChange", "allowCustom", "data", "filterable", "suggest", "value"], [3, "filterChange", "valueChange", "allowCustom", "data", "filterable", "suggest", "value", "formControl"]],
    template: function TimeZoneEditorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, TimeZoneEditorComponent_kendo_combobox_0_Template, 2, 7, "kendo-combobox", 2)(1, TimeZoneEditorComponent_kendo_combobox_1_Template, 2, 8, "kendo-combobox", 3);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.formControl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.formControl);
      }
    },
    dependencies: [NgIf, ComboBoxComponent, ReactiveFormsModule, NgControlStatus, FormControlDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeZoneEditorComponent, [{
    type: Component,
    args: [{
      providers: [TIME_ZONE_VALUE_ACCESSOR],
      selector: "kendo-timezone-editor",
      template: `
        <kendo-combobox
            *ngIf="!formControl"
            #tzcombobox
            [style.width.px]="width"
            [allowCustom]="false"
            [data]="tzSource"
            [filterable]="true"
            [suggest]="true"
            [value]="tz"
            (filterChange)="onTimeZoneFilterChange($event)"
            (valueChange)="onTimeZoneChange($event)">
        </kendo-combobox>
        <kendo-combobox
            *ngIf="formControl"
            #tzcomboboxControl
            [style.width.px]="width"
            [allowCustom]="false"
            [data]="tzSource"
            [filterable]="true"
            [suggest]="true"
            [value]="tz"
            [formControl]="formControl"
            (filterChange)="onTimeZoneFilterChange($event)"
            (valueChange)="onTimeZoneChange($event)">
        </kendo-combobox>
    `,
      standalone: true,
      imports: [NgIf, ComboBoxComponent, ReactiveFormsModule]
    }]
  }], function() {
    return [{
      type: Injector
    }];
  }, {
    tzComboBox: [{
      type: ViewChild,
      args: ["tzcombobox", {
        static: true
      }]
    }],
    tzComboBoxControl: [{
      type: ViewChild,
      args: ["tzcomboboxControl", {
        static: true
      }]
    }],
    width: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var SCHEDULER_DATETIMEPICKER_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SchedulerDateTimePickerComponent)
};
var SchedulerDateTimePickerComponent = class _SchedulerDateTimePickerComponent {
  injector;
  localization;
  datePicker;
  dateTimePicker;
  isAllDay;
  valueChange = new EventEmitter();
  constructor(injector, localization) {
    this.injector = injector;
    this.localization = localization;
  }
  /**
   * @hidden
   */
  get focusableId() {
    return this.isAllDay ? this.datePicker?.focusableId : this.dateTimePicker?.focusableId;
  }
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  textFor(key) {
    return this.localization.get(key);
  }
  date;
  writeValue(newDate) {
    if (newDate instanceof Date) {
      this.date = newDate;
    }
  }
  onValueChange(newValue) {
    this.onChangeCallback(newValue);
    this.valueChange.emit(newValue);
  }
  /**
   * @hidden
   */
  focus() {
    this.datePicker ? this.datePicker.focus() : this.dateTimePicker.focus();
  }
  onTouchedCallback = (_) => {
  };
  onChangeCallback = (_) => {
  };
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  static ɵfac = function SchedulerDateTimePickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SchedulerDateTimePickerComponent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(SchedulerLocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SchedulerDateTimePickerComponent,
    selectors: [["kendo-scheduler-datetime-picker"]],
    viewQuery: function SchedulerDateTimePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c53, 5);
        ɵɵviewQuery(_c62, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.datePicker = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateTimePicker = _t.first);
      }
    },
    inputs: {
      isAllDay: "isAllDay"
    },
    outputs: {
      valueChange: "valueChange"
    },
    features: [ɵɵProvidersFeature([SCHEDULER_DATETIMEPICKER_VALUE_ACCESSOR])],
    decls: 2,
    vars: 2,
    consts: [["datepicker", ""], ["datetimepicker", ""], [3, "value", "formControl", "clearButton", "valueChange", 4, "ngIf"], [3, "valueChange", "value", "formControl", "clearButton"], [3, "today", "toggle", "parentViewButtonTitle"], [3, "toggle", "today", "accept", "acceptLabel", "cancelLabel", "cancel", "now", "nowLabel", "dateTab", "dateTabLabel", "timeTab", "timeTabLabel", "parentViewButtonTitle"]],
    template: function SchedulerDateTimePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, SchedulerDateTimePickerComponent_kendo_datepicker_0_Template, 3, 6, "kendo-datepicker", 2)(1, SchedulerDateTimePickerComponent_kendo_datetimepicker_1_Template, 3, 16, "kendo-datetimepicker", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.isAllDay);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.isAllDay);
      }
    },
    dependencies: [NgIf, DatePickerComponent, ReactiveFormsModule, NgControlStatus, FormControlDirective, DatePickerCustomMessagesComponent, DateTimePickerComponent, DateTimePickerCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchedulerDateTimePickerComponent, [{
    type: Component,
    args: [{
      providers: [SCHEDULER_DATETIMEPICKER_VALUE_ACCESSOR],
      selector: "kendo-scheduler-datetime-picker",
      template: `
    <kendo-datepicker
        *ngIf='isAllDay'
        #datepicker
        [(value)]='date'
        (valueChange)='onValueChange($event)'
        [formControl]="formControl"
        [clearButton]="true"
    >
        <kendo-datepicker-messages
            [today]="textFor('editorDateInputsToday')"
            [toggle]="textFor('editorDateInputsToggle')"
            [parentViewButtonTitle]="textFor('editorDateInputsParentViewButton')"
        >
        </kendo-datepicker-messages>
    </kendo-datepicker>
    <kendo-datetimepicker
        *ngIf='!isAllDay'
        #datetimepicker
        [(value)]='date'
        (valueChange)='onValueChange($event)'
        [formControl]="formControl"
        [clearButton]="true"
    >
        <kendo-datetimepicker-messages
            [toggle]="textFor('editorDateInputsToggle')"
            [today]="textFor('editorDateInputsToday')"
            [accept]="textFor('editorDateInputsAccept')"
            [acceptLabel]="textFor('editorDateInputsAcceptLabel')"
            [cancelLabel]="textFor('editorDateInputsCancelLabel')"
            [cancel]="textFor('editorDateInputsCancel')"
            [now]="textFor('editorDateInputsNow')"
            [nowLabel]="textFor('editorDateInputsNowLabel')"
            [dateTab]="textFor('editorDateInputsDateTab')"
            [dateTabLabel]="textFor('editorDateInputsDateTabLabel')"
            [timeTab]="textFor('editorDateInputsTimeTab')"
            [timeTabLabel]="textFor('editorDateInputsTimeTabLabel')"
            [parentViewButtonTitle]="textFor('editorDateInputsParentViewButton')"
        >
        </kendo-datetimepicker-messages>
    </kendo-datetimepicker>
    `,
      standalone: true,
      imports: [NgIf, DatePickerComponent, ReactiveFormsModule, DatePickerCustomMessagesComponent, DateTimePickerComponent, DateTimePickerCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: SchedulerLocalizationService
    }];
  }, {
    datePicker: [{
      type: ViewChild,
      args: ["datepicker"]
    }],
    dateTimePicker: [{
      type: ViewChild,
      args: ["datetimepicker"]
    }],
    isAllDay: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var EditDialogComponent = class _EditDialogComponent {
  ngZone;
  editService;
  localization;
  changeDetector;
  element;
  focusService;
  multipleResourceEditors;
  singleResourceEditors;
  resources = [];
  timezone = "Etc/UTC";
  weekStart;
  fields;
  editTemplate;
  get autoFocusedElement() {
    if (this.editTemplate) {
      return this.editTemplate.autoFocusedElement;
    }
    return ".k-form-field input";
  }
  dialogTitle;
  isActive;
  editMode;
  get isEditingSeries() {
    return this.editMode === EditMode.Series && Boolean(this.formGroup.get(this.fields.recurrenceRule));
  }
  get eventTimezone() {
    return formValueOrDefault(this.formGroup, this.fields.startTimezone, this.timezone);
  }
  get endTimezone() {
    return formValueOrDefault(this.formGroup, this.fields.endTimezone, this.eventTimezone);
  }
  recurrenceStart;
  setTimeZone = false;
  setSeparateStartEndTimeZones = false;
  formGroup;
  editedEvent;
  isNew;
  saveIcon = saveIcon;
  cancelIcon = cancelOutlineIcon;
  subs;
  constructor(ngZone, editService, localization, changeDetector, element, focusService) {
    this.ngZone = ngZone;
    this.editService = editService;
    this.localization = localization;
    this.changeDetector = changeDetector;
    this.element = element;
    this.focusService = focusService;
    this.subs = this.editService.changed.subscribe(() => {
      this.ngZone.run(() => {
        this.onChange();
      });
    });
    this.subs.add(fromEvent(this.element.nativeElement, "keydown").pipe(filter(() => this.isActive)).subscribe((e) => {
      if (e.keyCode === Keys.Escape) {
        this.reset();
      }
      if (e.keyCode === Keys.Enter && (withModifiers(e, Modifiers.CtrlKey) || withModifiers(e, Modifiers.MetaKey))) {
        this.onSave(e);
      }
      e.stopPropagation();
    }));
  }
  onChange() {
    this.changeDetector.markForCheck();
    if (this.editService.hasNewEvent) {
      this.editMode = EditMode.Series;
      this.formGroup = this.editService.context.formGroup;
      this.isNew = true;
      this.applyLocalTimezone();
    } else if (this.editService.isEditing()) {
      const {
        dataItem,
        mode
      } = this.editService.context;
      this.formGroup = this.editService.context.formGroup;
      this.isNew = false;
      this.editedEvent = dataItem;
      this.editMode = isPresent4(mode) ? mode : EditMode.Series;
      this.applyLocalTimezone();
    } else {
      this.reset();
      return;
    }
    if (!this.editTemplate) {
      this.addTimeZoneCheckboxesToFormGroup();
      this.subscribeToFormGroupChanges();
    }
    if (isPresent4(this.formGroup)) {
      this.recurrenceStart = this.formGroup.get(this.fields.start).value;
    }
    this.isActive = true;
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  onCancel(e) {
    e.preventDefault();
    this.onClose();
    this.changeDetector.markForCheck();
  }
  onSave(e) {
    e.preventDefault();
    this.applyTimezone();
    this.editService.save();
    this.changeDetector.markForCheck();
  }
  onClose() {
    this.editService.endEdit();
    this.changeDetector.markForCheck();
    this.focusService.focus();
  }
  get hasAllDay() {
    return Boolean(this.formGroup.get(this.fields.isAllDay));
  }
  get hasStartTimeZone() {
    return Boolean(this.formGroup.get(this.fields.startTimezone));
  }
  get isStartTimeZoneVisible() {
    return this.formGroup && this.formGroup.get("startTimezoneCheckbox").value;
  }
  get hasEndTimeZone() {
    return Boolean(this.formGroup.get(this.fields.endTimezone));
  }
  get isEndTimeZoneVisible() {
    return this.formGroup && this.formGroup.get("endTimezoneCheckbox").value;
  }
  getFormValue(field) {
    if (field) {
      return this.formGroup.get(field);
    }
  }
  textFor(key) {
    return this.localization.get(key);
  }
  onResourceClick(resource) {
    const resourceEditors = resource.multiple ? this.multipleResourceEditors : this.singleResourceEditors;
    const currentEditor = resourceEditors.filter((editor) => editor.resource.field === resource.field).pop();
    if (currentEditor) {
      currentEditor.focus();
    }
  }
  getControl(name) {
    return this.formGroup.get(name);
  }
  reset() {
    this.isActive = false;
    this.setTimeZone = false;
    this.setSeparateStartEndTimeZones = false;
    this.removeTimeZoneCheckboxesFromFormGroup();
    this.focusService.focus();
  }
  addTimeZoneCheckboxesToFormGroup() {
    if (isPresent4(this.formGroup)) {
      const startField = this.fields.startTimezone;
      this.formGroup.addControl("startTimezoneCheckbox", new FormControl(this.formGroup.contains(startField) && this.formGroup.get(startField).value));
      const endField = this.fields.endTimezone;
      this.formGroup.addControl("endTimezoneCheckbox", new FormControl(this.formGroup.contains(endField) && this.formGroup.get(endField).value));
    }
  }
  removeTimeZoneCheckboxesFromFormGroup() {
    if (isPresent4(this.formGroup)) {
      this.formGroup.removeControl("startTimezoneCheckbox");
      this.formGroup.removeControl("endTimezoneCheckbox");
    }
  }
  subscribeToFormGroupChanges() {
    if (isPresent4(this.formGroup)) {
      const fields = this.fields;
      this.formGroup.get("startTimezoneCheckbox").valueChanges.subscribe((isTrue) => {
        if (!isTrue) {
          this.formGroup.get(fields.startTimezone).setValue(null, {
            emitEvent: false
          });
          this.formGroup.get(fields.endTimezone).setValue(null, {
            emitEvent: false
          });
          this.formGroup.get("endTimezoneCheckbox").setValue(false, {
            emitEvent: false
          });
        }
      });
      this.formGroup.get("endTimezoneCheckbox").valueChanges.subscribe((isTrue) => {
        if (!isTrue) {
          this.formGroup.get(fields.endTimezone).setValue(null, {
            emitEvent: false
          });
        }
      });
      this.formGroup.get(fields.start).valueChanges.subscribe((newStart) => {
        this.recurrenceStart = newStart;
      });
    }
  }
  /**
   * Converts the event dates to "display dates" that look like the original date in its time zone.
   * The result does not represent the same moment in time and must be converted back to local dates.
   */
  applyLocalTimezone() {
    const fields = this.fields;
    const start = this.readDateAsLocal(fields.start, this.eventTimezone);
    const end = this.readDateAsLocal(fields.end, this.endTimezone);
    this.formGroup.get(fields.start).reset(start);
    this.formGroup.get(fields.end).reset(end);
  }
  /**
   * Converts the "display dates" used by the editors back to local dates that represent the true moment in time.
   */
  applyTimezone() {
    const fields = this.fields;
    const start = this.readDateWithTimezone(fields.start, this.eventTimezone);
    const end = this.readDateWithTimezone(fields.end, this.endTimezone);
    this.formGroup.get(fields.start).reset(start);
    this.formGroup.get(fields.end).reset(end);
  }
  readDateWithTimezone(field, timezone) {
    const value2 = this.formGroup.get(field).value;
    return ZonedDate.fromUTCDate(toUTCDateTime2(value2), timezone).toLocalDate();
  }
  readDateAsLocal(field, timezone) {
    const value2 = this.formGroup.get(field).value;
    return toLocalDate(ZonedDate.fromLocalDate(value2, timezone).toUTCDate());
  }
  static ɵfac = function EditDialogComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditDialogComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _EditDialogComponent,
    selectors: [["kendo-scheduler-edit-dialog"]],
    viewQuery: function EditDialogComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(MultipleResourceEditorComponent, 5);
        ɵɵviewQuery(SingleResourceEditorComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multipleResourceEditors = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.singleResourceEditors = _t);
      }
    },
    inputs: {
      resources: "resources",
      timezone: "timezone",
      weekStart: "weekStart",
      fields: "fields",
      editTemplate: "editTemplate"
    },
    decls: 1,
    vars: 1,
    consts: [["title", ""], ["startDateTimePicker", ""], ["endDateTimePicker", ""], ["startTzPicker", ""], ["endTzPicker", ""], ["description", ""], ["class", "k-scheduler-edit-dialog", 3, "minWidth", "title", "autoFocusedElement", "close", 4, "ngIf"], [1, "k-scheduler-edit-dialog", 3, "close", "minWidth", "title", "autoFocusedElement"], [4, "ngIf"], ["layout", "start"], ["kendoButton", "", "themeColor", "primary", "icon", "save", 3, "click", "svgIcon", "disabled"], ["kendoButton", "", "icon", "cancel-outline", 3, "click", "svgIcon"], ["novalidate", "", 1, "k-scheduler-edit-form", "k-form", "k-form-md", 3, "formGroup"], ["labelCssClass", "k-form-label", 3, "for", "text"], ["kendoTextBox", "", "placeholder", "Title", 3, "formControl"], [3, "formControl", "isAllDay"], [3, "formControl", "start", "timezone", "weekStart", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "k-checkbox-wrap"], ["id", "k-set-timezone", "type", "checkbox", "kendoCheckBox", "", "formControlName", "startTimezoneCheckbox"], ["for", "k-set-timezone", 1, "k-checkbox-label", 3, "labelClass"], [3, "width", "formControl"], ["id", "k-use-separate", "type", "checkbox", "kendoCheckBox", "", "formControlName", "endTimezoneCheckbox"], ["for", "k-use-separate", 1, "k-checkbox-label", 3, "labelClass"], ["id", "k-is-allday-chkbox", "type", "checkbox", "kendoCheckBox", "", 3, "formControl"], ["for", "k-is-allday-chkbox", 1, "k-checkbox-label", 3, "labelClass"], [3, "formControl", "start", "timezone", "weekStart"], ["kendoTextArea", "", 3, "formControl"], [1, "k-label", "k-form-label", 3, "click"], [3, "formControl", "resource", 4, "ngIf"], [3, "formControl", "resource"], ["novalidate", "", 3, "formGroup"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function EditDialogComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, EditDialogComponent_kendo_dialog_0_Template, 8, 10, "kendo-dialog", 6);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.isActive);
      }
    },
    dependencies: [NgIf, DialogComponent, ReactiveFormsModule, ɵNgNoValidate, DefaultValueAccessor, CheckboxControlValueAccessor, NgControlStatus, NgControlStatusGroup, FormControlDirective, FormGroupDirective, FormControlName, FormFieldComponent, LabelComponent, TextBoxDirective, SchedulerDateTimePickerComponent, CheckBoxDirective, LabelDirective, TimeZoneEditorComponent, RecurrenceEditorComponent, TextAreaDirective, NgForOf, MultipleResourceEditorComponent, SingleResourceEditorComponent, NgTemplateOutlet, DialogActionsComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditDialogComponent, [{
    type: Component,
    args: [{
      selector: "kendo-scheduler-edit-dialog",
      template: `
        <kendo-dialog (close)='onClose()' [minWidth]='400' *ngIf='isActive' title='{{ textFor("editorTitle") }}' class='k-scheduler-edit-dialog' [autoFocusedElement]="autoFocusedElement">
            <ng-container *ngIf='!editTemplate'>
                <form
                    class='k-scheduler-edit-form k-form k-form-md'
                    novalidate
                    [formGroup]='formGroup'
                >
                    <!-- Title -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="title"
                            [text]="textFor('editorEventTitle')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <input
                            #title
                            kendoTextBox
                            placeholder='Title'
                            [formControl]='getControl(fields.title)'
                        />
                    </kendo-formfield>

                    <!-- Start -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="startDateTimePicker"
                            [text]="textFor('editorEventStart')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-scheduler-datetime-picker
                            #startDateTimePicker
                            [formControl]='getControl(fields.start)'
                            [isAllDay]='getFormValue(fields.isAllDay)?.value'
                        ></kendo-scheduler-datetime-picker>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="hasStartTimeZone">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-set-timezone'
                                    type='checkbox'
                                    kendoCheckBox
                                    formControlName='startTimezoneCheckbox'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-set-timezone'>{{ textFor('editorEventTimeZone') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isStartTimeZoneVisible">
                        <kendo-label
                            [for]="startTzPicker"
                            [text]="textFor('editorEventStartTimeZone')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-timezone-editor
                            #startTzPicker
                            [width]="undefined"
                            [formControl]='getControl(fields.startTimezone)'
                        ></kendo-timezone-editor>
                    </kendo-formfield>

                    <!-- End -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="endDateTimePicker"
                            [text]="textFor('editorEventEnd')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-scheduler-datetime-picker
                            #endDateTimePicker
                            [formControl]='getControl(fields.end)'
                            [isAllDay]='getFormValue(fields.isAllDay)?.value'
                        ></kendo-scheduler-datetime-picker>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isStartTimeZoneVisible && hasEndTimeZone">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-use-separate'
                                    type='checkbox'
                                    kendoCheckBox
                                    formControlName='endTimezoneCheckbox'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-use-separate'>{{ textFor('editorEventSeparateTimeZones') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isEndTimeZoneVisible">
                        <kendo-label
                            [for]="endTzPicker"
                            [text]="textFor('editorEventEndTimeZone')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-timezone-editor
                            #endTzPicker
                            [width]="undefined"
                            [formControl]='getControl(fields.endTimezone)'
                        ></kendo-timezone-editor>
                    </kendo-formfield>

                    <!-- All day -->
                    <kendo-formfield *ngIf="hasAllDay">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-is-allday-chkbox'
                                    type='checkbox'
                                    kendoCheckBox
                                    [formControl]='getControl(fields.isAllDay)'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-is-allday-chkbox'>{{ textFor('editorEventAllDay') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <!-- Series -->
                    <kendo-recurrence-editor
                        *ngIf="isEditingSeries"
                        [formControl]='getControl(fields.recurrenceRule)'
                        [start]='recurrenceStart'
                        [timezone]='eventTimezone'
                        [weekStart]='weekStart'
                    ></kendo-recurrence-editor>

                    <!-- Description -->
                    <kendo-formfield *ngIf='getFormValue(fields.description)'>
                        <kendo-label
                            [for]="description"
                            [text]="textFor('editorEventDescription')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <textarea #description kendoTextArea [formControl]='getControl(fields.description)'></textarea>
                    </kendo-formfield>

                    <!-- Resources -->
                    <ng-container *ngFor='let resource of resources'>
                        <kendo-formfield *ngIf='getFormValue(resource.field)'>
                            <label class='k-label k-form-label' (click)="onResourceClick(resource)">
                                {{ resource.name ? resource.name : resource.field }}
                            </label>
                            <kendo-multiple-resource-editor
                                *ngIf='resource.multiple'
                                [formControl]='getControl(resource.field)'
                                [resource]='resource'>
                            </kendo-multiple-resource-editor>
                            <kendo-single-resource-editor
                                *ngIf='!resource.multiple'
                                [formControl]='getControl(resource.field)'
                                [resource]='resource'>
                            </kendo-single-resource-editor>
                        </kendo-formfield>
                    </ng-container>
                </form>
            </ng-container>

            <ng-container *ngIf='editTemplate'>
                <form novalidate [formGroup]='formGroup'>
                    <ng-container [ngTemplateOutlet]='editTemplate.templateRef'
                        [ngTemplateOutletContext]="{
                            $implicit: formGroup,
                            formGroup: formGroup,
                            dataItem: editedEvent,
                            editMode: editMode,
                            isNew: isNew
                        }">
                    </ng-container>
                </form>
            </ng-container>

            <kendo-dialog-actions layout="start">
                <button
                    kendoButton
                    themeColor="primary"
                    icon="save"
                    [svgIcon]="saveIcon"
                    [disabled]="!formGroup.valid"
                    (click)="onSave($event)"
                >{{ textFor('save') }}</button>
                <button
                    kendoButton
                    icon="cancel-outline"
                    [svgIcon]="cancelIcon"
                    (click)="onCancel($event)"
                >{{ textFor('cancel') }}</button>
            </kendo-dialog-actions>
        </kendo-dialog>
    `,
      standalone: true,
      imports: [NgIf, DialogComponent, ReactiveFormsModule, FormFieldComponent, LabelComponent, TextBoxDirective, SchedulerDateTimePickerComponent, CheckBoxDirective, LabelDirective, TimeZoneEditorComponent, RecurrenceEditorComponent, TextAreaDirective, NgForOf, MultipleResourceEditorComponent, SingleResourceEditorComponent, NgTemplateOutlet, DialogActionsComponent, ButtonComponent]
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: EditService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: FocusService
    }];
  }, {
    multipleResourceEditors: [{
      type: ViewChildren,
      args: [MultipleResourceEditorComponent]
    }],
    singleResourceEditors: [{
      type: ViewChildren,
      args: [SingleResourceEditorComponent]
    }],
    resources: [{
      type: Input
    }],
    timezone: [{
      type: Input
    }],
    weekStart: [{
      type: Input
    }],
    fields: [{
      type: Input
    }],
    editTemplate: [{
      type: Input
    }]
  });
})();
var ToolbarViewSelectorComponent = class _ToolbarViewSelectorComponent {
  service;
  localization;
  /**
   * Specifies the current width of the Toolbar (in pixels) so the responsive calculations can be made.
   * The ([schedulerResize]({% slug api_scheduler_schedulercomponent %}#toc-schedulerresize)) event can be used in order to obtain the Toolbar width.
   */
  toolbarWidth;
  /**
   * Specifies the Toolbar width (in pixels) at which the responsive behavior should be enabled.
   * The responsive behavior means that the ButtonGroup with the views will be replaced by a `select` element.
   *
   * @default 1024
   */
  responsiveBreakpoint = 1024;
  /**
   * @hidden
   */
  get ctx() {
    return this.service.context;
  }
  /**
   * @hidden
   */
  get selectView() {
    return this.localization.get("selectView");
  }
  detachDomEvents;
  constructor(service, localization) {
    this.service = service;
    this.localization = localization;
  }
  ngOnDestroy() {
    if (this.detachDomEvents) {
      this.detachDomEvents();
    }
  }
  /**
   * @hidden
   */
  select(view2) {
    if (this.ctx.selectedView !== view2) {
      this.service.navigate({
        type: "view-change",
        view: view2
      });
    }
  }
  /**
   * @hidden
   */
  onChange(e) {
    const view2 = this.ctx.views.find((view3) => view3.name === e.target.value);
    if (view2) {
      this.select(view2);
    }
  }
  /**
   * @hidden
   */
  isSelected(view2) {
    return this.ctx.selectedView === view2;
  }
  static ɵfac = function ToolbarViewSelectorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarViewSelectorComponent)(ɵɵdirectiveInject(ToolbarService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ToolbarViewSelectorComponent,
    selectors: [["", "kendoSchedulerToolbarViewSelector", ""]],
    inputs: {
      toolbarWidth: "toolbarWidth",
      responsiveBreakpoint: "responsiveBreakpoint"
    },
    attrs: _c82,
    decls: 2,
    vars: 2,
    consts: [["class", "k-views-dropdown k-picker-md k-rounded-md k-picker-solid k-dropdownlist k-picker", "containerType", "toolbar", 3, "kendoSchedulerFocusIndex", "change", 4, "ngIf"], ["class", "k-toolbar-button-group k-scheduler-views k-button-group k-button-group-solid", "role", "group", 4, "ngIf"], ["containerType", "toolbar", 1, "k-views-dropdown", "k-picker-md", "k-rounded-md", "k-picker-solid", "k-dropdownlist", "k-picker", 3, "change", "kendoSchedulerFocusIndex"], [3, "selected", "value", 4, "ngFor", "ngForOf"], [3, "selected", "value"], ["role", "group", 1, "k-toolbar-button-group", "k-scheduler-views", "k-button-group", "k-button-group-solid"], ["kendoButton", "", "type", "button", "containerType", "toolbar", 3, "selected", "kendoSchedulerFocusIndex", "click", 4, "ngFor", "ngForOf"], ["kendoButton", "", "type", "button", "containerType", "toolbar", 3, "click", "selected", "kendoSchedulerFocusIndex"], [1, "k-button-text"]],
    template: function ToolbarViewSelectorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ToolbarViewSelectorComponent_select_0_Template, 2, 3, "select", 0)(1, ToolbarViewSelectorComponent_span_1_Template, 2, 1, "span", 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", (ctx.ctx.views == null ? null : ctx.ctx.views.length) > 1 && ctx.toolbarWidth <= ctx.responsiveBreakpoint);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.toolbarWidth > ctx.responsiveBreakpoint);
      }
    },
    dependencies: [NgIf, FocusableDirective, NgForOf, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarViewSelectorComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoSchedulerToolbarViewSelector]",
      template: `
        <select
            *ngIf="ctx.views?.length > 1 && toolbarWidth <= responsiveBreakpoint"
            (change)="onChange($event)"
            class="k-views-dropdown k-picker-md k-rounded-md k-picker-solid k-dropdownlist k-picker"
            [attr.aria-label]="selectView"
            [kendoSchedulerFocusIndex]="0"
            containerType="toolbar">
            <option *ngFor="let view of ctx.views"
                [selected]="isSelected(view) === true"
                [value]="view.name"
            >
                {{ view.title }}
            </option>
        </select>
        <span
            *ngIf="toolbarWidth > responsiveBreakpoint"
            class="k-toolbar-button-group k-scheduler-views k-button-group k-button-group-solid"
            role="group"
        >
            <button kendoButton
                type="button"
                *ngFor="let view of ctx.views"
                [selected]="isSelected(view)"
                [attr.aria-pressed]="isSelected(view)"
                (click)="select(view)"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
                <span class="k-button-text">
                    {{ view.title }}
                </span>
            </button>
        </span>
    `,
      standalone: true,
      imports: [NgIf, FocusableDirective, NgForOf, ButtonComponent]
    }]
  }], function() {
    return [{
      type: ToolbarService
    }, {
      type: LocalizationService
    }];
  }, {
    toolbarWidth: [{
      type: Input
    }],
    responsiveBreakpoint: [{
      type: Input
    }]
  });
})();
var iconsMap = {
  caretAltLeftIcon,
  caretAltRightIcon,
  calendarIcon
};
var ToolbarNavigationComponent = class _ToolbarNavigationComponent {
  popupService;
  toolbarService;
  localization;
  cd;
  viewContext;
  set calendar(calendar) {
    if (calendar) {
      calendar.focus();
    }
  }
  hostClass = true;
  /**
   * @hidden
   */
  min;
  /**
   * @hidden
   */
  max;
  /**
   * @hidden
   */
  get todayText() {
    return this.localization.get("today");
  }
  /**
   * Sets the [`activeView`]({% slug api_dateinputs_calendarcomponent %}#toc-activeview) of the Calendar in the navigation component.
   *
   * @default month
   */
  activeView = "month";
  /**
   * Sets the [`bottomView`]({% slug api_dateinputs_calendarcomponent %}#toc-bottomview) of the Calendar in the navigation component.
   *
   * @default month
   */
  bottomView = "month";
  /**
   * @hidden
   */
  get calendarTodayText() {
    return this.localization.get("calendarToday");
  }
  /**
   * @hidden
   */
  get nextText() {
    return this.localization.get("nextTitle");
  }
  /**
   * @hidden
   */
  get previousText() {
    return this.localization.get("previousTitle");
  }
  /**
   * @hidden
   */
  get ctx() {
    return this.toolbarService.context;
  }
  /**
   * @hidden
   */
  dateRangeText = {
    short: "",
    long: "",
    current: ""
  };
  /**
   * @hidden
   */
  svgIcon(name) {
    return iconsMap[name];
  }
  popupRef;
  subs;
  isMouseDown = false;
  constructor(popupService, toolbarService, localization, cd, viewContext) {
    this.popupService = popupService;
    this.toolbarService = toolbarService;
    this.localization = localization;
    this.cd = cd;
    this.viewContext = viewContext;
    this.subs = this.localization.changes.subscribe(() => {
      cd.markForCheck();
    });
  }
  /**
   * @hidden
   */
  onBlur() {
    this.isMouseDown ? null : this.closePopup();
  }
  /**
   * @hidden
   */
  onMouseDown() {
    this.isMouseDown = true;
  }
  ngOnInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.add(this.ctx.dateRange.subscribe((res) => {
      this.dateRangeText.short = res?.shortText;
      this.dateRangeText.long = res?.text;
      this.setDateRangeText();
    }));
    this.subs.add(this.viewContext.resize.subscribe(() => {
      this.setDateRangeText();
    }));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    this.closePopup();
  }
  /**
   * @hidden
   */
  toggleSelectedDate(anchor2, template) {
    if (this.popupRef) {
      this.closePopup();
    } else {
      const popupSettings = {
        anchor: anchor2,
        content: template
      };
      if (this.localization.rtl) {
        popupSettings.popupClass = "k-rtl";
      }
      this.popupRef = this.popupService.open(popupSettings);
    }
    this.isMouseDown = false;
    return false;
  }
  /**
   * @hidden
   */
  selectDate(value2) {
    this.closePopup();
    this.toolbarService.navigate({
      type: "select-date",
      date: value2
    });
  }
  /**
   * @hidden
   */
  prevClick() {
    this.toolbarService.navigate({
      type: "prev"
    });
    return false;
  }
  /**
   * @hidden
   */
  nextClick() {
    this.toolbarService.navigate({
      type: "next"
    });
    return false;
  }
  /**
   * @hidden
   */
  todayClick() {
    this.toolbarService.navigate({
      type: "today"
    });
    return false;
  }
  closePopup() {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  setDateRangeText() {
    const isDesktop = window.matchMedia("(min-width: 1024px)").matches;
    this.dateRangeText.current = isDesktop ? this.dateRangeText.long : this.dateRangeText.short;
    this.cd.detectChanges();
  }
  get arrowIcons() {
    return !this.localization.rtl ? ["caret-alt-left", "caret-alt-right"] : ["caret-alt-right", "caret-alt-left"];
  }
  get arrowSVGIcons() {
    return !this.localization.rtl ? ["caretAltLeftIcon", "caretAltRightIcon"] : ["caretAltRightIcon", "caretAltLeftIcon"];
  }
  static ɵfac = function ToolbarNavigationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarNavigationComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ToolbarService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ToolbarNavigationComponent,
    selectors: [["", "kendoSchedulerToolbarNavigation", ""]],
    viewQuery: function ToolbarNavigationComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c92, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.calendar = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function ToolbarNavigationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-toolbar-group", ctx.hostClass);
      }
    },
    inputs: {
      min: "min",
      max: "max",
      activeView: "activeView",
      bottomView: "bottomView"
    },
    features: [ɵɵProvidersFeature([PopupService])],
    attrs: _c102,
    decls: 11,
    vars: 17,
    consts: [["anchor", ""], ["template", ""], ["calendar", ""], ["role", "group", 1, "k-scheduler-navigation", "k-button-group", "k-button-group-solid"], ["kendoButton", "", "containerType", "toolbar", 1, "k-nav-today", 3, "click", "kendoSchedulerFocusIndex"], ["kendoButton", "", "containerType", "toolbar", 1, "k-nav-prev", 3, "click", "icon", "svgIcon", "kendoSchedulerFocusIndex"], ["kendoButton", "", "type", "button", "containerType", "toolbar", 1, "k-nav-next", 3, "click", "icon", "svgIcon", "kendoSchedulerFocusIndex"], ["kendoButton", "", "type", "button", "icon", "calendar", "fillMode", "flat", "role", "button", "containerType", "toolbar", 1, "k-nav-current", 3, "mousedown", "mouseup", "keydown.enter", "keydown.alt.arrowdown", "svgIcon", "kendoSchedulerFocusIndex"], [3, "blur", "keydown.escape", "valueChange", "activeView", "bottomView", "value", "min", "max"], [3, "today"]],
    template: function ToolbarNavigationComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "span", 3)(1, "button", 4);
        ɵɵlistener("click", function ToolbarNavigationComponent_Template_button_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.todayClick());
        });
        ɵɵtext(2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "button", 5);
        ɵɵlistener("click", function ToolbarNavigationComponent_Template_button_click_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.prevClick());
        });
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 6);
        ɵɵlistener("click", function ToolbarNavigationComponent_Template_button_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.nextClick());
        });
        ɵɵelementEnd()();
        ɵɵelementStart(5, "button", 7, 0);
        ɵɵlistener("mousedown", function ToolbarNavigationComponent_Template_button_mousedown_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onMouseDown());
        })("mouseup", function ToolbarNavigationComponent_Template_button_mouseup_5_listener() {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(6);
          const template_r3 = ɵɵreference(10);
          return ɵɵresetView(ctx.toggleSelectedDate({
            nativeElement: anchor_r2.element
          }, template_r3));
        })("keydown.enter", function ToolbarNavigationComponent_Template_button_keydown_enter_5_listener() {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(6);
          const template_r3 = ɵɵreference(10);
          return ɵɵresetView(ctx.toggleSelectedDate({
            nativeElement: anchor_r2.element
          }, template_r3));
        })("keydown.alt.arrowdown", function ToolbarNavigationComponent_Template_button_keydown_alt_arrowdown_5_listener() {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(6);
          const template_r3 = ɵɵreference(10);
          return ɵɵresetView(ctx.toggleSelectedDate({
            nativeElement: anchor_r2.element
          }, template_r3));
        });
        ɵɵelementStart(7, "span");
        ɵɵtext(8);
        ɵɵelementEnd()();
        ɵɵtemplate(9, ToolbarNavigationComponent_ng_template_9_Template, 4, 8, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("kendoSchedulerFocusIndex", 0);
        ɵɵattribute("title", ctx.todayText);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.todayText, " ");
        ɵɵadvance();
        ɵɵproperty("icon", ctx.arrowIcons[0])("svgIcon", ctx.svgIcon(ctx.arrowSVGIcons[0]))("kendoSchedulerFocusIndex", 0);
        ɵɵattribute("title", ctx.previousText)("aria-label", ctx.previousText);
        ɵɵadvance();
        ɵɵproperty("icon", ctx.arrowIcons[1])("svgIcon", ctx.svgIcon(ctx.arrowSVGIcons[1]))("kendoSchedulerFocusIndex", 0);
        ɵɵattribute("title", ctx.nextText)("aria-label", ctx.nextText);
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.svgIcon("calendarIcon"))("kendoSchedulerFocusIndex", 0);
        ɵɵattribute("aria-live", "polite");
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.dateRangeText == null ? null : ctx.dateRangeText.current);
      }
    },
    dependencies: [ButtonComponent, FocusableDirective, CalendarComponent, CalendarCustomMessagesComponent, AsyncPipe],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarNavigationComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoSchedulerToolbarNavigation]",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [PopupService],
      template: `
        <span class="k-scheduler-navigation k-button-group k-button-group-solid" role="group">
            <button kendoButton
                (click)="todayClick()"
                class="k-nav-today"
                [attr.title]="todayText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
                {{todayText}}
            </button>
            <button kendoButton
                (click)="prevClick()"
                class="k-nav-prev"
                [icon]="arrowIcons[0]"
                [svgIcon]="svgIcon(arrowSVGIcons[0])"
                [attr.title]="previousText"
                [attr.aria-label]="previousText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
            </button>
            <button kendoButton
                (click)="nextClick()"
                type="button"
                class="k-nav-next"
                [icon]="arrowIcons[1]"
                [svgIcon]="svgIcon(arrowSVGIcons[1])"
                [attr.title]="nextText"
                [attr.aria-label]="nextText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
            </button>
        </span>

        <button
            #anchor
            kendoButton
            type="button"
            icon="calendar"
            [svgIcon]="svgIcon('calendarIcon')"
            fillMode="flat"
            (mousedown)="onMouseDown()"
            (mouseup)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            (keydown.enter)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            (keydown.alt.arrowdown)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            role="button"
            class="k-nav-current"
            [attr.aria-live]="'polite'"
            [kendoSchedulerFocusIndex]="0"
            containerType="toolbar">
            <span>{{ dateRangeText?.current }}</span>
        </button>

        <ng-template #template>
            <kendo-calendar
                #calendar
                (blur)="onBlur()"
                [activeView]="activeView"
                [bottomView]="bottomView"
                (keydown.escape)="toggleSelectedDate({ nativeElement: anchor }, template); anchor.focus();"
                (valueChange)="selectDate($event)"
                [value]="ctx.selectedDate | async" [min]="min" [max]="max">
                <kendo-calendar-messages [today]="calendarTodayText">
                </kendo-calendar-messages>
            </kendo-calendar>
        </ng-template>
    `,
      standalone: true,
      imports: [ButtonComponent, FocusableDirective, CalendarComponent, CalendarCustomMessagesComponent, AsyncPipe]
    }]
  }], function() {
    return [{
      type: PopupService
    }, {
      type: ToolbarService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }];
  }, {
    calendar: [{
      type: ViewChild,
      args: ["calendar", {
        static: false
      }]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-toolbar-group"]
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }]
  });
})();
var ToolbarComponent = class _ToolbarComponent {
  service;
  element;
  zone;
  hostClasses = true;
  toolbarRole = "toolbar";
  selectedView;
  views;
  dateRange;
  selectedDate;
  template;
  min;
  max;
  navigate = new EventEmitter();
  toolbarWidthChange = new EventEmitter();
  // The template context is the same as the service context,
  // but with resolved values instead of observables.
  templateContext = {};
  toolbarWidth;
  /**
   * @hidden
   */
  get activeView() {
    return this.service.context.selectedView?.name === "year" ? "decade" : "month";
  }
  /**
   * @hidden
   */
  get bottomView() {
    return this.service.context.selectedView?.name === "year" ? "decade" : "month";
  }
  subs = new Subscription();
  constructor(service, element, zone) {
    this.service = service;
    this.element = element;
    this.zone = zone;
    this.subs.add(service.action.subscribe((action) => this.navigate.next(action)));
  }
  ngOnInit() {
    this.subs.add(this.selectedDate.subscribe((date) => this.templateContext.selectedDate = date));
    this.subs.add(this.dateRange.subscribe((dateRange) => this.templateContext.dateRange = dateRange));
    this.resizeHandler();
  }
  ngOnChanges() {
    this.service.context = {
      dateRange: this.dateRange,
      selectedDate: this.selectedDate,
      views: this.views,
      selectedView: this.selectedView
    };
    Object.assign(this.templateContext, {
      views: this.views,
      selectedView: this.selectedView
      // The dateRange and selectedDate context fields
      // are updated through the subscriptions added in ngOnInit.
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  resizeHandler() {
    const element = this.element.nativeElement;
    this.zone.run(() => this.toolbarWidth = element.offsetWidth);
    this.toolbarWidthChange.emit(this.toolbarWidth);
  }
  static ɵfac = function ToolbarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToolbarComponent)(ɵɵdirectiveInject(ToolbarService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ToolbarComponent,
    selectors: [["kendo-scheduler-toolbar"]],
    hostVars: 9,
    hostBindings: function ToolbarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.toolbarRole);
        ɵɵclassProp("k-scheduler-toolbar", ctx.hostClasses)("k-toolbar", ctx.hostClasses)("k-toolbar-solid", ctx.hostClasses)("k-toolbar-md", ctx.hostClasses);
      }
    },
    inputs: {
      selectedView: "selectedView",
      views: "views",
      dateRange: "dateRange",
      selectedDate: "selectedDate",
      template: "template",
      min: "min",
      max: "max"
    },
    outputs: {
      navigate: "navigate",
      toolbarWidthChange: "toolbarWidthChange"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 4,
    consts: [["defaultTemplate", ""], [4, "ngIf", "ngIfElse"], [3, "resize"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoSchedulerToolbarNavigation", "", 3, "min", "max", "activeView", "bottomView"], [1, "k-spacer"], ["kendoSchedulerToolbarViewSelector", "", 3, "toolbarWidth"]],
    template: function ToolbarComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵtemplate(0, ToolbarComponent_0_Template, 1, 2, null, 1)(1, ToolbarComponent_ng_template_1_Template, 3, 5, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementStart(3, "kendo-resize-sensor", 2);
        ɵɵlistener("resize", function ToolbarComponent_Template_kendo_resize_sensor_resize_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.resizeHandler());
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const defaultTemplate_r3 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.template)("ngIfElse", defaultTemplate_r3);
        ɵɵadvance(3);
        ɵɵstyleMap("display: contents;");
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, ToolbarNavigationComponent, ToolbarViewSelectorComponent, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-scheduler-toolbar",
      template: `
        <ng-template
            *ngIf="template; else defaultTemplate"
            [ngTemplateOutlet]="template.templateRef"
            [ngTemplateOutletContext]="templateContext"
        >
        </ng-template>

        <ng-template #defaultTemplate>
            <div kendoSchedulerToolbarNavigation
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView">
            </div>
            <span class="k-spacer"></span>
            <div kendoSchedulerToolbarViewSelector [toolbarWidth]="toolbarWidth"></div>
        </ng-template>

        <kendo-resize-sensor (resize)="resizeHandler()" [style]="'display: contents;'"></kendo-resize-sensor>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, ToolbarNavigationComponent, ToolbarViewSelectorComponent, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: ToolbarService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-scheduler-toolbar"]
    }, {
      type: HostBinding,
      args: ["class.k-toolbar"]
    }, {
      type: HostBinding,
      args: ["class.k-toolbar-solid"]
    }, {
      type: HostBinding,
      args: ["class.k-toolbar-md"]
    }],
    toolbarRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    selectedView: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    dateRange: [{
      type: Input
    }],
    selectedDate: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    navigate: [{
      type: Output
    }],
    toolbarWidthChange: [{
      type: Output
    }]
  });
})();
var Messages3 = class _Messages extends ComponentMessages {
  /**
   * The **All events** text that is displayed in the **Timeline** views when no vertical grouping is applied.
   */
  allEvents;
  /**
   * The **All day** text that is displayed in the *Day** and **Week** views.
   */
  allDay;
  /**
   * The date-header text that is displayed in the **Agenda** view.
   */
  dateHeader;
  /**
   * The time-header text that is displayed in the **Agenda** view.
   */
  timeHeader;
  /**
   * The event-header text that is displayed in the **Agenda** view.
   */
  eventHeader;
  /**
   * The title of the **Delete** icon.
   */
  deleteTitle;
  /**
   * The title of the **Next** navigation button.
   */
  nextTitle;
  /**
   * The title of the **Previous** navigation button.
   */
  previousTitle;
  /**
   * The text of the **Today** navigation button.
   */
  today;
  /**
   * The text of today's date in the header of the Calendar.
   */
  calendarToday;
  /**
   * The text of the **Show full day** button that is displayed in the footer of the **Day**, **Week**, and **Timeline** views.
   */
  showFullDay;
  /**
   * The text of the **Show work day** button that is displayed in the footer of the **Day**, **Week**, and **Timeline** views.
   */
  showWorkDay;
  /**
   * The title of the **Day** view.
   */
  dayViewTitle;
  /**
   * The title of the **Multi-Day** view.
   */
  multiDayViewTitle;
  /**
   * The title of the **Week** view.
   */
  weekViewTitle;
  /**
   * The title of the **Work Week** view.
   */
  workWeekViewTitle;
  /**
   * The title of the **Month** view.
   */
  monthViewTitle;
  /**
   * The title of the **Multi-Week** view.
   */
  multiWeekViewTitle;
  /**
   * The title of the **Timeline** view.
   */
  timelineViewTitle;
  /**
   * The title of the **Week** timeline view.
   */
  timelineWeekViewTitle;
  /**
   * The title of the **Month** timeline view.
   */
  timelineMonthViewTitle;
  /**
   * The title of the **Agenda** view.
   */
  agendaViewTitle;
  /**
   * The title of the **Year** view.
   */
  yearViewTitle;
  /**
   * The message displayed in **Year** view for any date that has no events.
   */
  yearViewNoEvents;
  /* ********************* */
  /* Editing Section Start */
  /* ********************* */
  /**
   * The text of the **Cancel** button displayed in the Scheduler dialogs.
   */
  cancel;
  /**
   * The text of the **Save** button displayed in the Scheduler dialogs.
   */
  save;
  /**
   * The text similar to 'Title' displayed in the Scheduler event editor.
   */
  editorEventTitle;
  /**
   * The text similar to 'Start' displayed in the Scheduler event editor.
   */
  editorEventStart;
  /**
   * The text similar to 'Start Time Zone' displayed in the Scheduler event editor.
   */
  editorEventStartTimeZone;
  /**
   * The text similar to 'End' displayed in the Scheduler event editor.
   */
  editorEventEnd;
  /**
   * The text similar to 'End Time Zone' displayed in the Scheduler event editor.
   */
  editorEventEndTimeZone;
  /**
   * The text similar to 'All Day Event' displayed in the Scheduler event editor.
   */
  editorEventAllDay;
  /**
   * The text similar to 'Description' displayed in the Scheduler event editor.
   */
  editorEventDescription;
  /**
   * The text similar to 'Use separate Start and End Time Zones' displayed in the Scheduler event editor.
   */
  editorEventSeparateTimeZones;
  /**
   * The text similar to 'Time Zone' displayed in the Scheduler event editor.
   */
  editorEventTimeZone;
  /**
   * The **Today** button text in the popup of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsToday;
  /**
   * The title of the **Toggle** button in the popup of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsToggle;
  /**
   * The title of the **Parent View** button in the popup of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsParentViewButton;
  /**
   * The text of the **Now** button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsNow;
  /**
   * The label of the **Now** button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsNowLabel;
  /**
   * The text of the **Accept** button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsAccept;
  /**
   * The label of the **Accept** button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsAcceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsCancel;
  /**
   * The label of the **Cancel** button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsCancelLabel;
  /**
   * The text of the **Date** tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsDateTab;
  /**
   * The label of the **Date** tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsDateTabLabel;
  /**
   * The text of the **Time** tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsTimeTab;
  /**
   * The label of the **Time** tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor.
   */
  editorDateInputsTimeTabLabel;
  /**
   * The **Today** button text in the popup of the DatePickers in the Scheduler recurrence editor.
   */
  recurrenceEditorDateInputsToday;
  /**
   * The title of the **Toggle** button in the popup of the DatePickers in the Scheduler recurrence editor.
   */
  recurrenceEditorDateInputsToggle;
  /**
   * The title of the **Parent View** button in the popup of the DatePickers in the Scheduler recurrence editor.
   */
  recurrenceEditorDateInputsParentViewButton;
  /**
   * The title of the **Increment** button of the NumericTextBox in the Scheduler recurrence editor.
   */
  recurrenceEditorNumericIncrement;
  /**
   * The title of the **Decrement** button of the NumericTextBox in the Scheduler recurrence editor.
   */
  recurrenceEditorNumericDecrement;
  /**
   * The text similar to 'Repeat' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorRepeat;
  /**
   * The text similar to 'day(s)' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorDailyInterval;
  /**
   * The text similar to 'Repeat every' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorDailyRepeatEvery;
  /**
   * The text similar to 'week(s)' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorWeeklyInterval;
  /**
   * The text similar to 'Repeat every' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorWeeklyRepeatEvery;
  /**
   * The text similar to 'Repeat on' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorWeeklyRepeatOn;
  /**
   * The text similar to 'Day' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorMonthlyDay;
  /**
   * The text similar to 'month(s)' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorMonthlyInterval;
  /**
   * The text similar to 'Repeat every' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorMonthlyRepeatEvery;
  /**
   * The text similar to 'Repeat on' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorMonthlyRepeatOn;
  /**
   * The text similar to 'of' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorYearlyOf;
  /**
   * The text similar to 'Repeat every' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorYearlyRepeatEvery;
  /**
   * The text similar to 'Repeat on' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorYearlyRepeatOn;
  /**
   * The text similar to 'year(s)' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorYearlyInterval;
  /**
   * The text similar to 'Daily' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorFrequenciesDaily;
  /**
   * The text similar to 'Monthly' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorFrequenciesMonthly;
  /**
   * The text similar to 'Never' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorFrequenciesNever;
  /**
   * The text similar to 'Weekly' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorFrequenciesWeekly;
  /**
   * The text similar to 'Yearly' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorFrequenciesYearly;
  /**
   * The text similar to 'First' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorOffsetPositionsFirst;
  /**
   * The text similar to 'Second' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorOffsetPositionsSecond;
  /**
   * The text similar to 'Third' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorOffsetPositionsThird;
  /**
   * The text similar to 'Fourth' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorOffsetPositionsFourth;
  /**
   * The text similar to 'Last' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorOffsetPositionsLast;
  /**
   * The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern.
   */
  recurrenceEditorWeekdaysDay;
  /**
   * The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern.
   */
  recurrenceEditorWeekdaysWeekday;
  /**
   * The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern.
   */
  recurrenceEditorWeekdaysWeekendday;
  /**
   * The text similar to 'After' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorEndAfter;
  /**
   * The text similar to 'occurrence(s)' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorEndOccurrence;
  /**
   * The text similar to 'End' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorEndLabel;
  /**
   * The text similar to 'Never' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorEndNever;
  /**
   * The text similar to 'On' displayed in the Scheduler recurrence editor.
   */
  recurrenceEditorEndOn;
  /* ******************* */
  /* Editing Section End */
  /* ******************* */
  /* ********************* */
  /* Dialogs Section Start */
  /* ********************* */
  /**
   * The text similar to **Event** displayed as title of the Scheduler event editor.
   */
  editorTitle;
  /**
   * The text of the **Delete** button displayed in the Scheduler remove confirmation dialog.
   */
  destroy;
  /**
   * The text similar to **Are you sure you want to delete this event?** displayed in Scheduler remove confirmation dialog.
   */
  deleteConfirmation;
  /**
   * The text similar to **Do you want to edit only this event occurrence or the whole series?** displayed in the Scheduler recurring confirmation dialog.
   */
  editRecurringConfirmation;
  /**
   * The text of the **Edit current occurrence** button displayed in the Scheduler recurring confirmation dialog.
   */
  editOccurrence;
  /**
   * The text of the **Edit the series** button displayed in the Scheduler recurring confirmation dialog.
   */
  editSeries;
  /**
   * The text similar to **Do you want to delete only this event occurrence or the whole series?** displayed in the Scheduler recurring confirmation dialog.
   */
  deleteRecurringConfirmation;
  /**
   * The text of the **Delete current occurrence** button displayed in the Scheduler recurring confirmation dialog.
   */
  deleteOccurrence;
  /**
   * The text similar of the **Delete the series** button displayed in the Scheduler recurring confirmation dialog.
   */
  deleteSeries;
  /**
   * The title of the remove confirmation dialog, similar to **Delete event**.
   */
  deleteDialogTitle;
  /**
   * The title of the recurring remove confirmation dialog, similar to **Delete Recurring Item**.
   */
  deleteRecurringDialogTitle;
  /**
   * The title of the recurring edit confirmation dialog, similar to **Edit Recurring Item**.
   */
  editRecurringDialogTitle;
  /**
   * The value of the aria-label attribute of the `<select>` element used for switching the Scheduler views.
   */
  selectView;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    inputs: {
      allEvents: "allEvents",
      allDay: "allDay",
      dateHeader: "dateHeader",
      timeHeader: "timeHeader",
      eventHeader: "eventHeader",
      deleteTitle: "deleteTitle",
      nextTitle: "nextTitle",
      previousTitle: "previousTitle",
      today: "today",
      calendarToday: "calendarToday",
      showFullDay: "showFullDay",
      showWorkDay: "showWorkDay",
      dayViewTitle: "dayViewTitle",
      multiDayViewTitle: "multiDayViewTitle",
      weekViewTitle: "weekViewTitle",
      workWeekViewTitle: "workWeekViewTitle",
      monthViewTitle: "monthViewTitle",
      multiWeekViewTitle: "multiWeekViewTitle",
      timelineViewTitle: "timelineViewTitle",
      timelineWeekViewTitle: "timelineWeekViewTitle",
      timelineMonthViewTitle: "timelineMonthViewTitle",
      agendaViewTitle: "agendaViewTitle",
      yearViewTitle: "yearViewTitle",
      yearViewNoEvents: "yearViewNoEvents",
      cancel: "cancel",
      save: "save",
      editorEventTitle: "editorEventTitle",
      editorEventStart: "editorEventStart",
      editorEventStartTimeZone: "editorEventStartTimeZone",
      editorEventEnd: "editorEventEnd",
      editorEventEndTimeZone: "editorEventEndTimeZone",
      editorEventAllDay: "editorEventAllDay",
      editorEventDescription: "editorEventDescription",
      editorEventSeparateTimeZones: "editorEventSeparateTimeZones",
      editorEventTimeZone: "editorEventTimeZone",
      editorDateInputsToday: "editorDateInputsToday",
      editorDateInputsToggle: "editorDateInputsToggle",
      editorDateInputsParentViewButton: "editorDateInputsParentViewButton",
      editorDateInputsNow: "editorDateInputsNow",
      editorDateInputsNowLabel: "editorDateInputsNowLabel",
      editorDateInputsAccept: "editorDateInputsAccept",
      editorDateInputsAcceptLabel: "editorDateInputsAcceptLabel",
      editorDateInputsCancel: "editorDateInputsCancel",
      editorDateInputsCancelLabel: "editorDateInputsCancelLabel",
      editorDateInputsDateTab: "editorDateInputsDateTab",
      editorDateInputsDateTabLabel: "editorDateInputsDateTabLabel",
      editorDateInputsTimeTab: "editorDateInputsTimeTab",
      editorDateInputsTimeTabLabel: "editorDateInputsTimeTabLabel",
      recurrenceEditorDateInputsToday: "recurrenceEditorDateInputsToday",
      recurrenceEditorDateInputsToggle: "recurrenceEditorDateInputsToggle",
      recurrenceEditorDateInputsParentViewButton: "recurrenceEditorDateInputsParentViewButton",
      recurrenceEditorNumericIncrement: "recurrenceEditorNumericIncrement",
      recurrenceEditorNumericDecrement: "recurrenceEditorNumericDecrement",
      recurrenceEditorRepeat: "recurrenceEditorRepeat",
      recurrenceEditorDailyInterval: "recurrenceEditorDailyInterval",
      recurrenceEditorDailyRepeatEvery: "recurrenceEditorDailyRepeatEvery",
      recurrenceEditorWeeklyInterval: "recurrenceEditorWeeklyInterval",
      recurrenceEditorWeeklyRepeatEvery: "recurrenceEditorWeeklyRepeatEvery",
      recurrenceEditorWeeklyRepeatOn: "recurrenceEditorWeeklyRepeatOn",
      recurrenceEditorMonthlyDay: "recurrenceEditorMonthlyDay",
      recurrenceEditorMonthlyInterval: "recurrenceEditorMonthlyInterval",
      recurrenceEditorMonthlyRepeatEvery: "recurrenceEditorMonthlyRepeatEvery",
      recurrenceEditorMonthlyRepeatOn: "recurrenceEditorMonthlyRepeatOn",
      recurrenceEditorYearlyOf: "recurrenceEditorYearlyOf",
      recurrenceEditorYearlyRepeatEvery: "recurrenceEditorYearlyRepeatEvery",
      recurrenceEditorYearlyRepeatOn: "recurrenceEditorYearlyRepeatOn",
      recurrenceEditorYearlyInterval: "recurrenceEditorYearlyInterval",
      recurrenceEditorFrequenciesDaily: "recurrenceEditorFrequenciesDaily",
      recurrenceEditorFrequenciesMonthly: "recurrenceEditorFrequenciesMonthly",
      recurrenceEditorFrequenciesNever: "recurrenceEditorFrequenciesNever",
      recurrenceEditorFrequenciesWeekly: "recurrenceEditorFrequenciesWeekly",
      recurrenceEditorFrequenciesYearly: "recurrenceEditorFrequenciesYearly",
      recurrenceEditorOffsetPositionsFirst: "recurrenceEditorOffsetPositionsFirst",
      recurrenceEditorOffsetPositionsSecond: "recurrenceEditorOffsetPositionsSecond",
      recurrenceEditorOffsetPositionsThird: "recurrenceEditorOffsetPositionsThird",
      recurrenceEditorOffsetPositionsFourth: "recurrenceEditorOffsetPositionsFourth",
      recurrenceEditorOffsetPositionsLast: "recurrenceEditorOffsetPositionsLast",
      recurrenceEditorWeekdaysDay: "recurrenceEditorWeekdaysDay",
      recurrenceEditorWeekdaysWeekday: "recurrenceEditorWeekdaysWeekday",
      recurrenceEditorWeekdaysWeekendday: "recurrenceEditorWeekdaysWeekendday",
      recurrenceEditorEndAfter: "recurrenceEditorEndAfter",
      recurrenceEditorEndOccurrence: "recurrenceEditorEndOccurrence",
      recurrenceEditorEndLabel: "recurrenceEditorEndLabel",
      recurrenceEditorEndNever: "recurrenceEditorEndNever",
      recurrenceEditorEndOn: "recurrenceEditorEndOn",
      editorTitle: "editorTitle",
      destroy: "destroy",
      deleteConfirmation: "deleteConfirmation",
      editRecurringConfirmation: "editRecurringConfirmation",
      editOccurrence: "editOccurrence",
      editSeries: "editSeries",
      deleteRecurringConfirmation: "deleteRecurringConfirmation",
      deleteOccurrence: "deleteOccurrence",
      deleteSeries: "deleteSeries",
      deleteDialogTitle: "deleteDialogTitle",
      deleteRecurringDialogTitle: "deleteRecurringDialogTitle",
      editRecurringDialogTitle: "editRecurringDialogTitle",
      selectView: "selectView"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages3, [{
    type: Directive
  }], null, {
    allEvents: [{
      type: Input
    }],
    allDay: [{
      type: Input
    }],
    dateHeader: [{
      type: Input
    }],
    timeHeader: [{
      type: Input
    }],
    eventHeader: [{
      type: Input
    }],
    deleteTitle: [{
      type: Input
    }],
    nextTitle: [{
      type: Input
    }],
    previousTitle: [{
      type: Input
    }],
    today: [{
      type: Input
    }],
    calendarToday: [{
      type: Input
    }],
    showFullDay: [{
      type: Input
    }],
    showWorkDay: [{
      type: Input
    }],
    dayViewTitle: [{
      type: Input
    }],
    multiDayViewTitle: [{
      type: Input
    }],
    weekViewTitle: [{
      type: Input
    }],
    workWeekViewTitle: [{
      type: Input
    }],
    monthViewTitle: [{
      type: Input
    }],
    multiWeekViewTitle: [{
      type: Input
    }],
    timelineViewTitle: [{
      type: Input
    }],
    timelineWeekViewTitle: [{
      type: Input
    }],
    timelineMonthViewTitle: [{
      type: Input
    }],
    agendaViewTitle: [{
      type: Input
    }],
    yearViewTitle: [{
      type: Input
    }],
    yearViewNoEvents: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    save: [{
      type: Input
    }],
    editorEventTitle: [{
      type: Input
    }],
    editorEventStart: [{
      type: Input
    }],
    editorEventStartTimeZone: [{
      type: Input
    }],
    editorEventEnd: [{
      type: Input
    }],
    editorEventEndTimeZone: [{
      type: Input
    }],
    editorEventAllDay: [{
      type: Input
    }],
    editorEventDescription: [{
      type: Input
    }],
    editorEventSeparateTimeZones: [{
      type: Input
    }],
    editorEventTimeZone: [{
      type: Input
    }],
    editorDateInputsToday: [{
      type: Input
    }],
    editorDateInputsToggle: [{
      type: Input
    }],
    editorDateInputsParentViewButton: [{
      type: Input
    }],
    editorDateInputsNow: [{
      type: Input
    }],
    editorDateInputsNowLabel: [{
      type: Input
    }],
    editorDateInputsAccept: [{
      type: Input
    }],
    editorDateInputsAcceptLabel: [{
      type: Input
    }],
    editorDateInputsCancel: [{
      type: Input
    }],
    editorDateInputsCancelLabel: [{
      type: Input
    }],
    editorDateInputsDateTab: [{
      type: Input
    }],
    editorDateInputsDateTabLabel: [{
      type: Input
    }],
    editorDateInputsTimeTab: [{
      type: Input
    }],
    editorDateInputsTimeTabLabel: [{
      type: Input
    }],
    recurrenceEditorDateInputsToday: [{
      type: Input
    }],
    recurrenceEditorDateInputsToggle: [{
      type: Input
    }],
    recurrenceEditorDateInputsParentViewButton: [{
      type: Input
    }],
    recurrenceEditorNumericIncrement: [{
      type: Input
    }],
    recurrenceEditorNumericDecrement: [{
      type: Input
    }],
    recurrenceEditorRepeat: [{
      type: Input
    }],
    recurrenceEditorDailyInterval: [{
      type: Input
    }],
    recurrenceEditorDailyRepeatEvery: [{
      type: Input
    }],
    recurrenceEditorWeeklyInterval: [{
      type: Input
    }],
    recurrenceEditorWeeklyRepeatEvery: [{
      type: Input
    }],
    recurrenceEditorWeeklyRepeatOn: [{
      type: Input
    }],
    recurrenceEditorMonthlyDay: [{
      type: Input
    }],
    recurrenceEditorMonthlyInterval: [{
      type: Input
    }],
    recurrenceEditorMonthlyRepeatEvery: [{
      type: Input
    }],
    recurrenceEditorMonthlyRepeatOn: [{
      type: Input
    }],
    recurrenceEditorYearlyOf: [{
      type: Input
    }],
    recurrenceEditorYearlyRepeatEvery: [{
      type: Input
    }],
    recurrenceEditorYearlyRepeatOn: [{
      type: Input
    }],
    recurrenceEditorYearlyInterval: [{
      type: Input
    }],
    recurrenceEditorFrequenciesDaily: [{
      type: Input
    }],
    recurrenceEditorFrequenciesMonthly: [{
      type: Input
    }],
    recurrenceEditorFrequenciesNever: [{
      type: Input
    }],
    recurrenceEditorFrequenciesWeekly: [{
      type: Input
    }],
    recurrenceEditorFrequenciesYearly: [{
      type: Input
    }],
    recurrenceEditorOffsetPositionsFirst: [{
      type: Input
    }],
    recurrenceEditorOffsetPositionsSecond: [{
      type: Input
    }],
    recurrenceEditorOffsetPositionsThird: [{
      type: Input
    }],
    recurrenceEditorOffsetPositionsFourth: [{
      type: Input
    }],
    recurrenceEditorOffsetPositionsLast: [{
      type: Input
    }],
    recurrenceEditorWeekdaysDay: [{
      type: Input
    }],
    recurrenceEditorWeekdaysWeekday: [{
      type: Input
    }],
    recurrenceEditorWeekdaysWeekendday: [{
      type: Input
    }],
    recurrenceEditorEndAfter: [{
      type: Input
    }],
    recurrenceEditorEndOccurrence: [{
      type: Input
    }],
    recurrenceEditorEndLabel: [{
      type: Input
    }],
    recurrenceEditorEndNever: [{
      type: Input
    }],
    recurrenceEditorEndOn: [{
      type: Input
    }],
    editorTitle: [{
      type: Input
    }],
    destroy: [{
      type: Input
    }],
    deleteConfirmation: [{
      type: Input
    }],
    editRecurringConfirmation: [{
      type: Input
    }],
    editOccurrence: [{
      type: Input
    }],
    editSeries: [{
      type: Input
    }],
    deleteRecurringConfirmation: [{
      type: Input
    }],
    deleteOccurrence: [{
      type: Input
    }],
    deleteSeries: [{
      type: Input
    }],
    deleteDialogTitle: [{
      type: Input
    }],
    deleteRecurringDialogTitle: [{
      type: Input
    }],
    editRecurringDialogTitle: [{
      type: Input
    }],
    selectView: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective3 = class _LocalizedMessagesDirective extends Messages3 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoSchedulerLocalizedMessages", ""]],
    features: [ɵɵProvidersFeature([{
      provide: Messages3,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective3, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages3,
        useExisting: forwardRef(() => LocalizedMessagesDirective3)
      }],
      selector: "[kendoSchedulerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var todayDate = () => getDate(/* @__PURE__ */ new Date());
var DAYS_IN_WEEK$1 = 7;
var SchedulerComponent = class _SchedulerComponent {
  wrapper;
  viewContext;
  viewState;
  editService;
  dialogsService;
  intlService;
  changeDetector;
  zone;
  pdfService;
  localization;
  domEvents;
  renderer;
  focusService;
  hostClasses = true;
  ariaRole = "application";
  rtl = false;
  get dir() {
    return this.direction;
  }
  /**
   * The index of the currently selected view.
   *
   * By default, the selected view index is `0` and
   * indicates that the first declared view is visible.
   */
  set selectedViewIndex(index) {
    this.viewIndex = index;
    this.onViewIndexChange();
  }
  get selectedViewIndex() {
    return this.viewIndex;
  }
  /**
   * Specifies if the Scheduler is editable.
   */
  editable = false;
  /**
   * Specifies if the Scheduler's day or time slots are selectable ([see example]({% slug slotselection_scheduler %}#toc-custom-callback)).
   *
   * When this input is set to `true`, the Scheduler component will emit [`slotDragStart`]({% slug api_scheduler_schedulercomponent %}#toc-slotdragstart), [`slotDrag`]({% slug api_scheduler_schedulercomponent %}#toc-slotdrag), and [`slotDragEnd`]({% slug api_scheduler_schedulercomponent %}#toc-slotdragend) events upon user interaction.
   */
  selectable = false;
  /**
   * The minimum date that can be selected by using the navigation of the Scheduler.
   */
  min;
  /**
   * The maximum date that can be selected by using the navigation of the Scheduler.
   */
  max;
  /**
   * The height of the events in the **Month** and **Timeline** views, and the height of the **All day** events in the **Day** and **Week** views.
   * @default 25
   */
  eventHeight = 25;
  /**
   * Specifies the columns width. Applicable for the **Timeline** views.
   * @default 100
   */
  columnWidth = 100;
  /**
   * If set to `true`, the view will be initially shown in the business-hours mode.
   * By default, the view is displayed in the full-day mode. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default false
   */
  showWorkHours;
  /**
   * The start time of the view. The Scheduler displays events which start after the start time.
   * Accepts string values in the `HH:mm` format. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default '00:00'
   */
  startTime = "00:00";
  /**
   * The end time of the view. The Scheduler displays events which end before the end time.
   * Accepts string values in the `HH:mm` format. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default '00:00'
   */
  endTime = "00:00";
  /**
   * The start time of the view when `showWorkHours` is set to `true`.
   * Accepts string values in the `HH:mm` format. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default '08:00'
   */
  workDayStart = "08:00";
  /**
   * The end time of the view when `showWorkHours` is set to `true`.
   * Accepts string values in the `HH:mm` format. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default '17:00'
   */
  workDayEnd = "17:00";
  /**
   * The start of the work week. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default 1
   */
  workWeekStart;
  /**
   * The end of the work week. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default 5
   */
  workWeekEnd;
  /**
   * The first day of the week. Applicable to **Week**, **Month** and **TimelineWeek** views.
   * Defaults to the locale settings.
   */
  set weekStart(value2) {
    this._weekStart = value2;
  }
  get weekStart() {
    if (isPresent4(this._weekStart)) {
      return this._weekStart;
    }
    return this.intlService.firstDay();
  }
  /**
   * The duration (in minutes) of the time slots. Applicable for the day, week and timeline views.
   * @default 60
   */
  slotDuration = 60;
  /**
   * The number of divisions of the time slots. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default 2
   */
  slotDivisions = 2;
  /**
   * A numeric value between 0 and 1 that specifies what percentage of the slot will be filled by the events.
   * Applicable for the **Day** and **Week** views.
   * @default 0.9
   */
  slotFill = 0.9;
  /**
   * Toggles the visibility of the all-day slot.
   * Applicable for the **Day**, **Multi-Day**, **Week**, and **Work-Week** views.
   * @default true
   */
  allDaySlot = true;
  /**
   * The time to which the view will initially be scrolled.
   * Accepts string values in the `HH:mm` format or a JavaScript `Date`. Applicable for the **Day**, **Week**, and **Timeline** views.
   * @default '08:00'
   */
  scrollTime = this.workDayStart;
  /**
   * Specifies the groups of the Scheduler.
   */
  group;
  /**
   * Specifies the resources of the Scheduler.
   */
  resources;
  /**
   * Specifies if the Scheduler will display a loading indicator.
   * @default false
   */
  loading;
  /**
   * Specifies the id of the timezone that will be displayed in the Scheduler.
   * For example, `Europe/Sofia`.
   * @default 'Etc/UTC'
   */
  set timezone(value2) {
    this._timezone = value2;
    this.events = this.events || [];
  }
  get timezone() {
    return this._timezone;
  }
  /**
   * The currently selected view.
   */
  selectedView;
  /**
   * An array of event instances which will be shown by the Scheduler.
   */
  set events(value2) {
    this._events = value2;
    this.processEvents(value2);
  }
  get events() {
    return this._events;
  }
  /**
   * The currently selected date of the Scheduler.
   * Determines the period which is displayed.
   */
  set selectedDate(value2) {
    if (!value2) {
      return;
    }
    this._selectedDate = value2;
    this.viewContext.notifySelectedDate(value2);
  }
  get selectedDate() {
    return this._selectedDate;
  }
  /**
   * The names of the model fields from which the Scheduler will read its data
   * ([see example]({% slug databinding_scheduler %}#toc-binding-to-models)).
   */
  set modelFields(value2) {
    this._modelFields = __spreadValues(__spreadValues({}, defaultModelFields), value2);
  }
  get modelFields() {
    return this._modelFields;
  }
  /**
   * Specifies the Scheduler current time marker settings.
   * @default true
   */
  currentTimeMarker = true;
  /**
   * Specifies the settings for the ongoing events highlight of the Scheduler.
   * @default true
   */
  highlightOngoingEvents = true;
  /**
   * Specifies whether to display the toolbar of the Scheduler.
   * @default true
   */
  showToolbar = true;
  /**
   * Specifies whether to display the footer of the Scheduler.
   * @default true
   */
  showFooter = true;
  /**
   * Defines a function that is executed for every slot in the view.
   * The function returns a value which is supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).
   */
  slotClass;
  /**
   * Defines a function that is executed for every event in the view.
   * The function returns a value which is supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).
   */
  eventClass;
  /**
   * Defines a function that is executed for every event in the view.
   * The function returns a value which is supported by [`ngStyle`](link:site.data.urls.angular['ngstyleapi']).
   */
  eventStyles;
  /**
   * A callback that executes for each slot of the Scheduler view.
   * If it returns `true`, the `k-selected` CSS class will be added to the cell, making it visibly selected.
   * @default () => false
   */
  isSlotSelected = alwaysFalse;
  /**
   * @hidden
   */
  selectedViewIndexChange = new EventEmitter();
  /**
   * Fires when the Scheduler is about to execute a navigation action
   * (a view, date, or focus change).
   */
  navigate = new EventEmitter();
  /**
   * Fires when the date range that is displayed in the Scheduler changes.
   */
  dateChange = new EventEmitter();
  /**
   * Fires when a Scheduler view slot is clicked.
   */
  slotClick = new EventEmitter();
  /**
   * Fires when a Scheduler view slot is double-clicked.
   */
  slotDblClick = new EventEmitter();
  /**
   * Fires when the user creates a new event using the `'c'` key.
   * ([see example]({% slug keyboard_navigation_scheduler %})).
   */
  create = new EventEmitter();
  /**
   * Fires when a Scheduler event is clicked.
   */
  eventClick = new EventEmitter();
  /**
   * Fires when a Scheduler event is double-clicked.
   */
  eventDblClick = new EventEmitter();
  /**
   * Fires when a key is pressed on a focused Scheduler event.
   */
  eventKeydown = new EventEmitter();
  /**
   * Fires when the user cancels the editing by clicking the **Cancel** command button.
   */
  cancel = new EventEmitter();
  /**
   * Fires when the user clicks the **Save** command button to save the changes of the edited event.
   */
  save = new EventEmitter();
  /**
   * Fires when the user clicks the **Remove** icon of a Scheduler event.
   */
  remove = new EventEmitter();
  /**
   * Fires when the user starts resizing a Scheduler event.
   */
  resizeStart = new EventEmitter();
  /**
   * Fires when the user is resizing a Scheduler event.
   */
  resize = new EventEmitter();
  /**
   * Fires when the user stops resizing a Scheduler event.
   */
  resizeEnd = new EventEmitter();
  /**
   * Fires when the user starts dragging a Scheduler event.
   */
  dragStart = new EventEmitter();
  /**
   * Fires when the user is dragging a Scheduler event.
   */
  drag = new EventEmitter();
  /**
   * Fires when the user stops dragging a Scheduler event.
   */
  dragEnd = new EventEmitter();
  /**
   * Fires when the user starts drag-selecting a Scheduler slot range.
   */
  slotDragStart = new EventEmitter();
  /**
   * Fires when the user is drag-selecting a Scheduler slot range.
   */
  slotDrag = new EventEmitter();
  /**
   * Fires when the user stops drag-selecting a Scheduler slot range.
   */
  slotDragEnd = new EventEmitter();
  /**
   * Fires when the user clicks the **PDF export** command button.
   */
  pdfExport = new EventEmitter();
  /**
   * Fires when the Scheduler is resized horizontally.
   */
  schedulerResize = new EventEmitter();
  /**
   * @hidden
   */
  dragEndConfirmed = new EventEmitter();
  /**
   * @hidden
   */
  resizeEndConfirmed = new EventEmitter();
  /**
   * @hidden
   */
  removeConfirmed = new EventEmitter();
  /**
   * @hidden
   */
  editDialogTemplate;
  /**
   * @hidden
   */
  toolbarTemplate;
  /**
   * @hidden
   */
  dateRangeStream;
  /**
   * @hidden
   */
  selectedDateStream;
  /**
   * @hidden
   */
  views;
  /**
   * @hidden
   */
  resizeSensor;
  /**
   * @hidden
   */
  confirmationDialogContainerRef;
  /**
   * @hidden
   */
  loadingComponent;
  /**
   * @hidden
   */
  allDayEventTemplate;
  /**
   * @hidden
   */
  eventTemplate;
  /**
   * @hidden
   */
  timeSlotTemplate;
  /**
   * @hidden
   */
  minorTimeHeaderTemplate;
  /**
   * @hidden
   */
  majorTimeHeaderTemplate;
  /**
   * @hidden
   */
  monthDaySlotTemplate;
  /**
   * @hidden
   */
  multiWeekDaySlotTemplate;
  /**
   * @hidden
   */
  dateHeaderTemplate;
  /**
   * @hidden
   */
  allDaySlotTemplate;
  /**
   * @hidden
   */
  groupHeaderTemplate;
  /**
   * @hidden
   */
  agendaDateTemplate;
  /**
   * @hidden
   */
  agendaTimeTemplate;
  /**
   * @hidden
   */
  showLicenseWatermark = false;
  /**
   * @hidden
   */
  get viewToolbar() {
    return this.viewState?.toolbarVisibilityByView.get(this.selectedView);
  }
  direction;
  subs;
  viewIndex = 0;
  _selectedDate;
  _events;
  _timezone = "";
  _modelFields = defaultModelFields;
  viewItems;
  detachElementEventHandlers;
  _weekStart;
  constructor(wrapper, viewContext, viewState, editService, dialogsService, intlService, changeDetector, zone, pdfService, localization, domEvents, renderer, focusService) {
    this.wrapper = wrapper;
    this.viewContext = viewContext;
    this.viewState = viewState;
    this.editService = editService;
    this.dialogsService = dialogsService;
    this.intlService = intlService;
    this.changeDetector = changeDetector;
    this.zone = zone;
    this.pdfService = pdfService;
    this.localization = localization;
    this.domEvents = domEvents;
    this.renderer = renderer;
    this.focusService = focusService;
    const isValid = validatePackage(packageMetadata3);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.dateRangeStream = viewState.dateRange;
    this.selectedDateStream = viewContext.selectedDate;
  }
  ngOnInit() {
    if (!this.selectedDate) {
      this.selectedDate = todayDate();
    }
  }
  ngAfterContentInit() {
    if (isDevMode() && this.views.length === 0) {
      throw new Error("No views declared for <kendo-scheduler>. Please, declare at least one view.");
    }
    this.subs = this.views.changes.subscribe(() => this.resetViewIndex());
    this.subs.add(this.intlService.changes.subscribe(this.intlChange.bind(this)));
    this.subs.add(this.viewState.nextDate.subscribe((nextDate) => {
      this.selectedDate = nextDate;
    }));
    this.subs.add(this.viewState.dateRange.subscribe((dateRange) => {
      const isEmpty = dateRange.start.getTime() === 0;
      if (!isEmpty) {
        const args = new DateChangeEvent(this, this.selectedDate, dateRange);
        this.dateChange.emit(args);
      }
    }));
    this.subs.add(this.viewState.navigate.subscribe(({
      viewName,
      date
    }) => {
      const views = this.views.toArray();
      const view2 = views.find((v) => v.name === viewName);
      const args = new NavigateEvent(this, {
        type: "show-date",
        view: view2 || {
          name: viewName,
          title: viewName
        },
        date
      });
      this.navigate.next(args);
      if (view2 && !args.isDefaultPrevented()) {
        const index = views.indexOf(view2);
        this.selectedView = view2;
        this.setViewIndex(index);
        this.selectedDate = date;
      }
    }));
    this.subs.add(this.viewState.viewEvent.subscribe(({
      name,
      args
    }) => {
      const emitter = this[name];
      const confirmedEmitter = this[`${name}Confirmed`];
      if (hasObservers(emitter) || confirmedEmitter && hasObservers(confirmedEmitter)) {
        this.zone.run(() => {
          const eventInstance = new VIEW_EVENT_MAP[name](this, args);
          emitter.emit(eventInstance);
          args.prevented = eventInstance.prevented;
          if (confirmedEmitter && !args.prevented) {
            confirmedEmitter.emit(eventInstance);
          }
        });
      }
    }));
    this.subs.add(this.viewState.layoutEnd.subscribe(() => {
      if (this.resizeSensor) {
        this.resizeSensor.acceptSize();
      }
    }));
    this.subs.add(this.viewState.slotSelectionStart.subscribe((e) => {
      if (hasObservers(this.slotDragStart)) {
        this.zone.run(() => {
          this.slotDragStart.emit(Object.assign(e, {
            sender: this
          }));
        });
      }
    }));
    this.subs.add(this.viewState.slotSelectionDrag.subscribe((value2) => {
      if (hasObservers(this.slotDrag)) {
        this.zone.run(() => {
          this.slotDrag.emit(new SlotDragEvent(this, value2));
        });
      }
    }));
    this.subs.add(this.viewState.slotSelectionEnd.subscribe((value2) => {
      if (hasObservers(this.slotDragEnd)) {
        this.zone.run(() => {
          this.slotDragEnd.emit(new SlotDragEndEvent(this, value2));
        });
      }
    }));
    this.onViewIndexChange();
    this.notifyOptionsChange = this.notifyOptionsChange.bind(this);
    this.subs.add(this.allDayEventTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.eventTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.timeSlotTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.timeSlotTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.minorTimeHeaderTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.majorTimeHeaderTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.monthDaySlotTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.multiWeekDaySlotTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.dateHeaderTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.allDaySlotTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.groupHeaderTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.agendaDateTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.agendaTimeTemplate.changes.subscribe(this.notifyOptionsChange));
    this.subs.add(this.views.changes.subscribe(() => {
      this.changeDetector.markForCheck();
    }));
    this.attachEditHandlers();
    this.dialogsService.container = this.confirmationDialogContainerRef;
    this.notifyOptionsChange();
    this.subs.add(this.pdfService.exportClick.subscribe(() => {
      const args = new PDFExportEvent();
      this.pdfExport.emit(args);
      if (!args.isDefaultPrevented()) {
        this.saveAsPDF();
      }
    }));
    this.subs.add(this.pdfService.done.subscribe(() => {
      this.loadingComponent.toggle(false);
    }));
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    }));
    this.subs.add(this.viewState.optionsChange.subscribe(() => {
      this.changeDetector.markForCheck();
    }));
    this.attachElementEventHandlers();
  }
  ngOnChanges(changes) {
    if (isChanged("resources", changes) && !isChanged("events", changes) && this.viewItems) {
      this.viewItems.forEach((item) => {
        copyResources(item.event, this.resources);
      });
    }
    if (anyChanged(["group", "resources", "min", "max", "showWorkHours", "startTime", "scrollTime", "endTime", "eventHeight", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "weekStart", "slotDuration", "slotDivisions", "editable", "timezone", "slotClass", "slotFill", "columnWidth", "eventClass", "eventStyles", "isSlotSelected", "selectable", "allDaySlot", "showToolbar", "showFooter"], changes)) {
      this.notifyOptionsChange(changes);
    }
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
    if (this.detachElementEventHandlers) {
      this.detachElementEventHandlers();
    }
  }
  /**
   * @hidden
   */
  onResize(_event) {
    this.viewContext.notifyResize();
  }
  /**
   * @hidden
   */
  onNavigationAction(action) {
    const args = new NavigateEvent(this, action);
    this.navigate.next(args);
    if (args.isDefaultPrevented()) {
      return true;
    }
    if (action.type === "view-change") {
      const views = this.views.toArray();
      const index = views.indexOf(action.view);
      this.selectedView = action.view;
      this.setViewIndex(index);
    } else if (action.type === "select-date") {
      if (this.isInRange(action.date)) {
        this.selectedDate = action.date;
      }
    } else if (action.type === "today") {
      const date = /* @__PURE__ */ new Date();
      if (this.isInRange(date)) {
        this.selectedDate = date;
      }
    } else if (action.type === "toggle-business-hours") {
      this.viewState.toggleWorkHours.next(null);
    } else if (action.type === "focus-toolbar") {
      this.focusService.focusToolbar();
    } else {
      this.viewContext.notifyAction(action);
    }
  }
  /**
   * @hidden
   */
  onToolbarWidthChange(width2) {
    this.schedulerResize.emit(width2);
  }
  /**
   * Creates a popup editor for the new event.
   *
   * @param group - The [`FormGroup`](https://angular.io/docs/ts/latest/api/forms/index/FormGroup-class.html) that describes
   * the edit form. If called with a data item, the parameter will build the `FormGroup` from the data item fields.
   */
  addEvent(group3) {
    const isFormGroup = group3 instanceof FormGroup;
    if (!isFormGroup) {
      const createControl = (source) => (acc, key) => {
        acc[key] = new FormControl(source[key]);
        return acc;
      };
      const fields = Object.keys(group3).reduce(createControl(group3), {});
      group3 = new FormGroup(fields);
    }
    this.editService.addEvent(group3);
  }
  /**
   * Switches the specified event in edit mode.
   *
   * @param dataItem - The event that will be switched to edit mode.
   * @param options - An object which contains the form `group` that will be bound in the edit dialog and the current edit `mode`.
   *
   */
  editEvent(dataItem, options = {}) {
    const {
      group: group3,
      mode
    } = options;
    this.editService.editEvent(dataItem, group3, mode);
  }
  /**
   * Closes the event editor, if open.
   */
  closeEvent() {
    this.editService.close();
  }
  /**
   * Returns a flag which indicates if an event is currently edited.
   *
   * @return {boolean} - A flag which indicates if an event is currently edited.
   */
  isEditing() {
    return this.editService.isEditing();
  }
  /**
   * Opens the built-in confirmation dialog for defining the edit mode
   * that will be used when the user edits or removes a recurring event.
   *
   * @param operation - The type of operation that will be confirmed. Has to be either **Edit** or **Remove**.
   *
   * @returns the result from the confirmation dialog.
   */
  openRecurringConfirmationDialog(operation) {
    return this.dialogsService.openRecurringConfirmationDialog(operation);
  }
  /**
   * Opens the built-in removal confirmation dialog.
   *
   * @return the result from the confirmation dialog.
   */
  openRemoveConfirmationDialog() {
    return this.dialogsService.openRemoveConfirmationDialog();
  }
  /**
   * Saves the current view as PDF.
   */
  saveAsPDF() {
    this.loadingComponent.toggle(true);
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        this.pdfService.save();
      }, 0);
    });
  }
  /**
   * Scrolls the view to the specified time.
   */
  scrollToTime(time) {
    this.viewContext.notifyAction({
      type: "scroll-time",
      time
    });
  }
  /**
   * Returns the current view slot that matches the passed document position.
   *
   * @param x - The x document position.
   * @param y - The y document position.
   *
   * @return {SchedulerSlot} - The slot.
   */
  slotByPosition(x, y) {
    return this.viewContext.executeMethod("slotByPosition", {
      x,
      y
    });
  }
  /**
   * Returns the event associated with the specified DOM element, if any.
   *
   * @param element - The DOM element document position.
   * @return the event instance, if found.
   */
  eventFromElement(element) {
    return this.viewContext.executeMethod("eventFromElement", {
      element
    });
  }
  /**
   * Gets the currently active event, if any.
   * The active event is the event that can currently receive focus.
   */
  get activeEvent() {
    const activeElement = this.focusService.activeElement;
    if (activeElement && activeElement.nativeElement.matches(".k-event, [data-task-index]")) {
      return this.eventFromElement(activeElement.nativeElement);
    }
  }
  /**
   * Focuses the next event or an event at a specified relative position.
   * The `options` parameter can be used to set a positive or negative offset
   * that is relative to the currently focused event ([see example](slug:keyboard_navigation_scheduler#toc-event-navigation-with-the-tab-key)).
   * A `nowrap` flag toggles the wrapping to the first or to the last item.
   *
   * @param position The relative position of the event to focus.
   * @returns `true` if the focused event changed. Otherwise, returns `false`.
   */
  focusNext(position) {
    const changed = this.focusService.focusNext(position);
    this.zone.onStable.pipe(take(1)).subscribe(() => this.focusService.focus());
    return changed;
  }
  /**
   * Focuses the previous event or an event at a specified relative position.
   * The `options` parameter can be used to set a positive or negative offset
   * that is relative to the currently focused event ([see example](slug:keyboard_navigation_scheduler#toc-event-navigation-with-the-tab-key)).
   * A `nowrap` flag toggles the wrapping to the first or to the last item.
   *
   * @param position The relative position of the event to focus.
   * @returns `true` if the focused event changed. Otherwise, returns `false`.
   */
  focusPrev(position) {
    const prevPosition = __spreadValues({
      offset: -1
    }, position);
    const changed = this.focusService.focusNext(prevPosition);
    this.zone.onStable.pipe(take(1)).subscribe(() => this.focusService.focus());
    return changed;
  }
  /**
   * Focuses the last focused scheduler element or the Scheduler element, if no events are available.
   */
  focus() {
    this.zone.onStable.pipe(take(1)).subscribe(() => this.focusService.focus());
  }
  /**
   * @hidden
   */
  get toolbarVisibilityState() {
    return isPresent4(this.viewToolbar) ? this.viewToolbar : this.showToolbar;
  }
  isInRange(date) {
    return (!this.min || this.min <= date) && (!this.max || date <= this.max);
  }
  notifyOptionsChange(changes) {
    const workweek = this.workWeek;
    this.viewContext.notifyOptionsChange({
      group: this.group,
      resources: this.resources,
      allDayEventTemplate: this.allDayEventTemplate ? this.allDayEventTemplate.first : null,
      eventTemplate: this.eventTemplate ? this.eventTemplate.first : null,
      timeSlotTemplate: this.timeSlotTemplate ? this.timeSlotTemplate.first : null,
      minorTimeHeaderTemplate: this.minorTimeHeaderTemplate ? this.minorTimeHeaderTemplate.first : null,
      majorTimeHeaderTemplate: this.majorTimeHeaderTemplate ? this.majorTimeHeaderTemplate.first : null,
      monthDaySlotTemplate: this.monthDaySlotTemplate ? this.monthDaySlotTemplate.first : null,
      multiWeekDaySlotTemplate: this.multiWeekDaySlotTemplate ? this.multiWeekDaySlotTemplate.first : null,
      dateHeaderTemplate: this.dateHeaderTemplate ? this.dateHeaderTemplate.first : null,
      allDaySlotTemplate: this.allDaySlotTemplate ? this.allDaySlotTemplate.first : null,
      groupHeaderTemplate: this.groupHeaderTemplate ? this.groupHeaderTemplate.first : null,
      agendaDateTemplate: this.agendaDateTemplate ? this.agendaDateTemplate.first : null,
      agendaTimeTemplate: this.agendaTimeTemplate ? this.agendaTimeTemplate.first : null,
      min: this.min,
      max: this.max,
      showWorkHours: this.showWorkHours,
      startTime: this.startTime,
      scrollTime: this.scrollTime,
      endTime: this.endTime,
      workDayStart: this.workDayStart,
      workDayEnd: this.workDayEnd,
      workWeekStart: workweek.start,
      workWeekEnd: workweek.end,
      weekStart: this.weekStart,
      allDaySlot: this.allDaySlot,
      slotDuration: this.slotDuration,
      slotDivisions: this.slotDivisions,
      eventHeight: this.eventHeight,
      editable: this.editable,
      selectable: this.selectable,
      timezone: this.timezone,
      currentTimeMarker: this.currentTimeMarker,
      highlightOngoingEvents: this.highlightOngoingEvents,
      showToolbar: this.showToolbar,
      showFooter: this.showFooter,
      slotClass: this.slotClass,
      slotFill: this.slotFill,
      columnWidth: this.columnWidth,
      eventClass: this.eventClass,
      eventStyles: this.eventStyles,
      isSlotSelected: this.isSlotSelected,
      changes
    });
  }
  get workWeek() {
    const {
      start,
      end
    } = this.intlService.weekendRange();
    const workWeekStart = isPresent4(this.workWeekStart) ? this.workWeekStart : (end + 1) % DAYS_IN_WEEK$1;
    const weekEnd = start > 0 ? start - 1 : Day.Saturday;
    const workWeekEnd = isPresent4(this.workWeekEnd) ? this.workWeekEnd : weekEnd;
    return {
      start: workWeekStart,
      end: workWeekEnd
    };
  }
  resetViewIndex() {
    const index = this.selectedViewIndex;
    const newIndex = Math.max(0, Math.min(index, this.views.length - 1));
    this.setViewIndex(newIndex);
    this.onViewIndexChange();
  }
  onViewIndexChange() {
    if (!this.views) {
      return;
    }
    const views = this.views.toArray();
    const selectedView = views[this.viewIndex];
    if (selectedView) {
      this.selectedView = selectedView;
    }
  }
  setViewIndex(newIndex) {
    const changed = this.selectedViewIndex !== newIndex;
    if (changed) {
      this.selectedViewIndex = newIndex;
      this.selectedViewIndexChange.emit(newIndex);
    }
    return changed;
  }
  processEvents(dataItems) {
    const timezone = this.timezone;
    const fields = this.modelFields;
    const items = dataItems.map((dataItem) => readEvent(dataItem, fields, this.resources)).filter((event2) => !isRecurrenceMaster$1(event2)).map((event2) => {
      const start = ZonedDate.fromLocalDate(event2.start, timezone);
      const end = ZonedDate.fromLocalDate(event2.end, timezone);
      return {
        start,
        end,
        event: event2
      };
    });
    this.viewItems = items;
    this.viewContext.notifyItems(items);
  }
  attachEditHandlers() {
    if (!this.editService) {
      return;
    }
    this.subs.add(this.editService.changes.subscribe(this.emitCRUDEvent.bind(this)));
  }
  emitCRUDEvent(args) {
    Object.assign(args, {
      sender: this
    });
    switch (args.action) {
      case "cancel":
        this.cancel.emit(args);
        break;
      case "save":
        this.save.emit(args);
        break;
      default:
        break;
    }
  }
  intlChange() {
    const currentView = this.selectedView;
    this.selectedView = null;
    if (!isPresent4(this.workWeekStart) || !isPresent4(this.workWeekEnd)) {
      this.notifyOptionsChange();
    }
    this.changeDetector.detectChanges();
    this.selectedView = currentView;
    if (NgZone.isInAngularZone()) {
      this.changeDetector.markForCheck();
    } else {
      this.changeDetector.detectChanges();
    }
  }
  attachElementEventHandlers() {
    if (!isDocumentAvailable()) {
      return;
    }
    const wrapper = this.wrapper.nativeElement;
    this.zone.runOutsideAngular(() => {
      const windowBlurSubscription = this.renderer.listen("window", "blur", (args) => {
        this.domEvents.windowBlur.emit(args);
      });
      const clickSubscription = this.renderer.listen(wrapper, "click", (args) => {
        this.domEvents.click.emit(args);
      });
      const keydownSubscription = this.renderer.listen(wrapper, "keydown", (args) => {
        this.domEvents.keydown.emit(args);
      });
      let focused = false;
      const focusInSubscription = this.renderer.listen(wrapper, "focusin", (args) => {
        this.domEvents.focus.emit(args);
        if (!focused) {
          this.domEvents.focusIn.emit(args);
          this.renderer.addClass(this.wrapper.nativeElement, "k-focus");
          focused = true;
        }
      });
      const focusOutSubscription = this.renderer.listen(wrapper, "focusout", (args) => {
        const next = args.relatedTarget || document.activeElement;
        const outside = !closest3(next, (node) => node === wrapper);
        if (outside) {
          this.domEvents.focusOut.emit(args);
          this.renderer.removeClass(this.wrapper.nativeElement, "k-focus");
          focused = false;
        }
      });
      this.detachElementEventHandlers = () => {
        windowBlurSubscription();
        clickSubscription();
        keydownSubscription();
        focusInSubscription();
        focusOutSubscription();
      };
    });
  }
  static ɵfac = function SchedulerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SchedulerComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(DialogsService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(FocusService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SchedulerComponent,
    selectors: [["kendo-scheduler"]],
    contentQueries: function SchedulerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, EditDialogTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ToolbarTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, SchedulerView, 4);
        ɵɵcontentQuery(dirIndex, AllDayEventTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, EventTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, TimeSlotTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, MinorTimeHeaderTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, MajorTimeHeaderTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, MonthDaySlotTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, MultiWeekDaySlotTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, DateHeaderTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, AllDaySlotTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, AgendaDateTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, AgendaTimeTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.editDialogTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toolbarTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.views = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allDayEventTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.eventTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timeSlotTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.minorTimeHeaderTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.majorTimeHeaderTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthDaySlotTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiWeekDaySlotTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateHeaderTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allDaySlotTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.agendaDateTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.agendaTimeTemplate = _t);
      }
    },
    viewQuery: function SchedulerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ResizeSensorComponent, 7);
        ɵɵviewQuery(_c112, 7, ViewContainerRef);
        ɵɵviewQuery(LoadingComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.confirmationDialogContainerRef = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.loadingComponent = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function SchedulerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.ariaRole)("dir", ctx.dir);
        ɵɵclassProp("k-scheduler", ctx.hostClasses)("k-rtl", ctx.rtl);
      }
    },
    inputs: {
      selectedViewIndex: "selectedViewIndex",
      editable: "editable",
      selectable: "selectable",
      min: "min",
      max: "max",
      eventHeight: "eventHeight",
      columnWidth: "columnWidth",
      showWorkHours: "showWorkHours",
      startTime: "startTime",
      endTime: "endTime",
      workDayStart: "workDayStart",
      workDayEnd: "workDayEnd",
      workWeekStart: "workWeekStart",
      workWeekEnd: "workWeekEnd",
      weekStart: "weekStart",
      slotDuration: "slotDuration",
      slotDivisions: "slotDivisions",
      slotFill: "slotFill",
      allDaySlot: "allDaySlot",
      scrollTime: "scrollTime",
      group: "group",
      resources: "resources",
      loading: "loading",
      timezone: "timezone",
      events: "events",
      selectedDate: "selectedDate",
      modelFields: "modelFields",
      currentTimeMarker: "currentTimeMarker",
      highlightOngoingEvents: "highlightOngoingEvents",
      showToolbar: "showToolbar",
      showFooter: "showFooter",
      slotClass: "slotClass",
      eventClass: "eventClass",
      eventStyles: "eventStyles",
      isSlotSelected: "isSlotSelected"
    },
    outputs: {
      selectedViewIndexChange: "selectedViewIndexChange",
      navigate: "navigate",
      dateChange: "dateChange",
      slotClick: "slotClick",
      slotDblClick: "slotDblClick",
      create: "create",
      eventClick: "eventClick",
      eventDblClick: "eventDblClick",
      eventKeydown: "eventKeydown",
      cancel: "cancel",
      save: "save",
      remove: "remove",
      resizeStart: "resizeStart",
      resize: "resize",
      resizeEnd: "resizeEnd",
      dragStart: "dragStart",
      drag: "drag",
      dragEnd: "dragEnd",
      slotDragStart: "slotDragStart",
      slotDrag: "slotDrag",
      slotDragEnd: "slotDragEnd",
      pdfExport: "pdfExport",
      schedulerResize: "schedulerResize"
    },
    features: [ɵɵProvidersFeature([EditService, DialogsService, DomEventsService, LocalDataChangesService, FocusService, SchedulerLocalizationService, {
      provide: LocalizationService,
      useExisting: SchedulerLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.scheduler"
    }, ToolbarService, ViewContextService, ViewStateService, PDFService]), ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 9,
    consts: () => {
      let i18n_37;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_37 = goog.getMsg("All events");
        i18n_37 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_37;
      } else {
        i18n_37 = $localize`:kendo.scheduler.allEvents|The All events text displayed in the timeline views when there is no vertical grouping.:All events`;
      }
      let i18n_38;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_38 = goog.getMsg("all day");
        i18n_38 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_38;
      } else {
        i18n_38 = $localize`:kendo.scheduler.allDay|The all day text displayed in the day and week views.:all day`;
      }
      let i18n_39;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_39 = goog.getMsg("Date");
        i18n_39 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_39;
      } else {
        i18n_39 = $localize`:kendo.scheduler.dateHeader|The date header text displayed in the agenda view.:Date`;
      }
      let i18n_40;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_40 = goog.getMsg("Time");
        i18n_40 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_40;
      } else {
        i18n_40 = $localize`:kendo.scheduler.timeHeader|The time header text displayed in the agenda view.:Time`;
      }
      let i18n_41;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_41 = goog.getMsg("Delete");
        i18n_41 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_41;
      } else {
        i18n_41 = $localize`:kendo.scheduler.deleteTitle|The delete icon title.:Delete`;
      }
      let i18n_42;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_42 = goog.getMsg("Event");
        i18n_42 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_42;
      } else {
        i18n_42 = $localize`:kendo.scheduler.eventHeader|The event header text displayed in the agenda view.:Event`;
      }
      let i18n_43;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_43 = goog.getMsg("Next");
        i18n_43 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_43;
      } else {
        i18n_43 = $localize`:kendo.scheduler.nextTitle|The title of the navigation next button.:Next`;
      }
      let i18n_44;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_44 = goog.getMsg("Previous");
        i18n_44 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_44;
      } else {
        i18n_44 = $localize`:kendo.scheduler.previousTitle|The title of the navigation previous button.:Previous`;
      }
      let i18n_45;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_45 = goog.getMsg("Show full day");
        i18n_45 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_45;
      } else {
        i18n_45 = $localize`:kendo.scheduler.showFullDay|The text of the show full day button displayed in the footer of the day, week and timeline views.:Show full day`;
      }
      let i18n_46;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_46 = goog.getMsg("Show business hours");
        i18n_46 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_46;
      } else {
        i18n_46 = $localize`:kendo.scheduler.showWorkDay|The text of the show work day button displayed in the footer of the day, week and timeline views.:Show business hours`;
      }
      let i18n_47;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_47 = goog.getMsg("Today");
        i18n_47 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_47;
      } else {
        i18n_47 = $localize`:kendo.scheduler.today|The today button text displayed in the navigation.:Today`;
      }
      let i18n_48;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_48 = goog.getMsg("TODAY");
        i18n_48 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_48;
      } else {
        i18n_48 = $localize`:kendo.scheduler.calendarToday|The text of today's date in the header of the Calendar.:TODAY`;
      }
      let i18n_49;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_49 = goog.getMsg("Day");
        i18n_49 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_49;
      } else {
        i18n_49 = $localize`:kendo.scheduler.dayViewTitle|The day view title.:Day`;
      }
      let i18n_50;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_50 = goog.getMsg("Multi-Day");
        i18n_50 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_50;
      } else {
        i18n_50 = $localize`:kendo.scheduler.multiDayViewTitle|The multi day view title.:Multi-Day`;
      }
      let i18n_51;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_51 = goog.getMsg("Week");
        i18n_51 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_51;
      } else {
        i18n_51 = $localize`:kendo.scheduler.weekViewTitle|The week view title.:Week`;
      }
      let i18n_52;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_52 = goog.getMsg("Work Week");
        i18n_52 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_52;
      } else {
        i18n_52 = $localize`:kendo.scheduler.workWeekViewTitle|The work week view title.:Work Week`;
      }
      let i18n_53;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_53 = goog.getMsg("Month");
        i18n_53 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_53;
      } else {
        i18n_53 = $localize`:kendo.scheduler.monthViewTitle|The month view title.:Month`;
      }
      let i18n_54;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_54 = goog.getMsg("Multi-Week");
        i18n_54 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_54;
      } else {
        i18n_54 = $localize`:kendo.scheduler.multiWeekViewTitle|The multi week view title.:Multi-Week`;
      }
      let i18n_55;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_55 = goog.getMsg("Timeline");
        i18n_55 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_55;
      } else {
        i18n_55 = $localize`:kendo.scheduler.timelineViewTitle|The timeline view title.:Timeline`;
      }
      let i18n_56;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_56 = goog.getMsg("Timeline Week");
        i18n_56 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_56;
      } else {
        i18n_56 = $localize`:kendo.scheduler.timelineWeekViewTitle|The timeline week view title.:Timeline Week`;
      }
      let i18n_57;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_57 = goog.getMsg("Timeline Month");
        i18n_57 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_57;
      } else {
        i18n_57 = $localize`:kendo.scheduler.timelineMonthViewTitle|The timeline month view title.:Timeline Month`;
      }
      let i18n_58;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_58 = goog.getMsg("Agenda");
        i18n_58 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_58;
      } else {
        i18n_58 = $localize`:kendo.scheduler.agendaViewTitle|The agenda view title.:Agenda`;
      }
      let i18n_59;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_59 = goog.getMsg("Year");
        i18n_59 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_59;
      } else {
        i18n_59 = $localize`:kendo.scheduler.yearViewTitle|The year view title.:Year`;
      }
      let i18n_60;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_60 = goog.getMsg("No events on this date.");
        i18n_60 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_60;
      } else {
        i18n_60 = $localize`:kendo.scheduler.yearViewNoEvents|The year view no events message.:No events on this date.`;
      }
      let i18n_61;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_61 = goog.getMsg("Cancel");
        i18n_61 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_61;
      } else {
        i18n_61 = $localize`:kendo.scheduler.cancel|The text similar to 'Cancel' displayed in the Scheduler.:Cancel`;
      }
      let i18n_62;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_62 = goog.getMsg("Save");
        i18n_62 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_62;
      } else {
        i18n_62 = $localize`:kendo.scheduler.save|The text similar to 'Save' displayed in the Scheduler.:Save`;
      }
      let i18n_63;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_63 = goog.getMsg("Title");
        i18n_63 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_63;
      } else {
        i18n_63 = $localize`:kendo.scheduler.editorEventTitle|The text similar to 'Title' displayed in the Scheduler event editor.:Title`;
      }
      let i18n_64;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_64 = goog.getMsg("Start");
        i18n_64 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_64;
      } else {
        i18n_64 = $localize`:kendo.scheduler.editorEventStart|The text similar to 'Start' displayed in the Scheduler event editor.:Start`;
      }
      let i18n_65;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_65 = goog.getMsg("Start Time Zone");
        i18n_65 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_65;
      } else {
        i18n_65 = $localize`:kendo.scheduler.editorEventStartTimeZone|The text similar to 'Start Time Zone' displayed in the Scheduler event editor.:Start Time Zone`;
      }
      let i18n_66;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_66 = goog.getMsg("End");
        i18n_66 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_66;
      } else {
        i18n_66 = $localize`:kendo.scheduler.editorEventEnd|The text similar to 'End' displayed in the Scheduler event editor.:End`;
      }
      let i18n_67;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_67 = goog.getMsg("End Time Zone");
        i18n_67 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_67;
      } else {
        i18n_67 = $localize`:kendo.scheduler.editorEventEndTimeZone|The text similar to 'End Time Zone' displayed in the Scheduler event editor.:End Time Zone`;
      }
      let i18n_68;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_68 = goog.getMsg("All Day Event");
        i18n_68 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_68;
      } else {
        i18n_68 = $localize`:kendo.scheduler.editorEventAllDay|The text similar to 'All Day event' displayed in the Scheduler event editor.:All Day Event`;
      }
      let i18n_69;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_69 = goog.getMsg("Description");
        i18n_69 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_69;
      } else {
        i18n_69 = $localize`:kendo.scheduler.editorEventDescription|The text similar to 'Description' displayed in the Scheduler event editor.:Description`;
      }
      let i18n_70;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_70 = goog.getMsg("End in different Time Zone");
        i18n_70 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_70;
      } else {
        i18n_70 = $localize`:kendo.scheduler.editorEventSeparateTimeZones|The text similar to 'Use separate Start and End Time Zones' displayed in the Scheduler event editor.:End in different Time Zone`;
      }
      let i18n_71;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_71 = goog.getMsg("Specify Time Zone");
        i18n_71 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_71;
      } else {
        i18n_71 = $localize`:kendo.scheduler.editorEventTimeZone|The text similar to 'Time Zone' displayed in the Scheduler event editor.:Specify Time Zone`;
      }
      let i18n_72;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_72 = goog.getMsg("Event");
        i18n_72 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_72;
      } else {
        i18n_72 = $localize`:kendo.scheduler.editorTitle|The text similar to 'Event' displayed as title of the Scheduler event editor.:Event`;
      }
      let i18n_73;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_73 = goog.getMsg("Today");
        i18n_73 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_73;
      } else {
        i18n_73 = $localize`:kendo.scheduler.editorDateInputsToday|The Today button text in the popup of the DateTimePickers and DatePickers in the Scheduler event editor.:Today`;
      }
      let i18n_74;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_74 = goog.getMsg("Toggle calendar");
        i18n_74 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_74;
      } else {
        i18n_74 = $localize`:kendo.scheduler.editorDateInputsToggle|The title of the Toggle button of the DateTimePickers and DatePickers in the Scheduler event editor.:Toggle calendar`;
      }
      let i18n_75;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_75 = goog.getMsg("Navigate to parent view");
        i18n_75 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_75;
      } else {
        i18n_75 = $localize`:kendo.scheduler.editorDateInputsParentViewButton|The title of the Parent View button in the popup of the DateTimePickers and DatePickers in the Scheduler event editor.:Navigate to parent view`;
      }
      let i18n_76;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_76 = goog.getMsg("Now");
        i18n_76 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_76;
      } else {
        i18n_76 = $localize`:kendo.scheduler.editorDateInputsAccept|The text of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.:Now`;
      }
      let i18n_77;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_77 = goog.getMsg("Select now");
        i18n_77 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_77;
      } else {
        i18n_77 = $localize`:kendo.scheduler.editorDateInputsAcceptLabel|The label of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.:Select now`;
      }
      let i18n_78;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_78 = goog.getMsg("Set");
        i18n_78 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_78;
      } else {
        i18n_78 = $localize`:kendo.scheduler.editorDateInputsAccept|The text of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.:Set`;
      }
      let i18n_79;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_79 = goog.getMsg("Set");
        i18n_79 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_79;
      } else {
        i18n_79 = $localize`:kendo.scheduler.editorDateInputsAcceptLabel|The label of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.:Set`;
      }
      let i18n_80;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_80 = goog.getMsg("Cancel");
        i18n_80 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_80;
      } else {
        i18n_80 = $localize`:kendo.scheduler.editorDateInputsCancel|The text of the Cancel button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.:Cancel`;
      }
      let i18n_81;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_81 = goog.getMsg("Cancel");
        i18n_81 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_81;
      } else {
        i18n_81 = $localize`:kendo.scheduler.editorDateInputsCancelLabel|The label of the Cancel button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor.:Cancel`;
      }
      let i18n_82;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_82 = goog.getMsg("Date");
        i18n_82 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_82;
      } else {
        i18n_82 = $localize`:kendo.scheduler.editorDateInputsDateTab|The text of the Date tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor.:Date`;
      }
      let i18n_83;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_83 = goog.getMsg("Date tab");
        i18n_83 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_83;
      } else {
        i18n_83 = $localize`:kendo.scheduler.editorDateInputsDateTabLabel|The label of the Date tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor.:Date tab`;
      }
      let i18n_84;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_84 = goog.getMsg("Time");
        i18n_84 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_84;
      } else {
        i18n_84 = $localize`:kendo.scheduler.editorDateInputsTimeTab|The text of the Time tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor.:Time`;
      }
      let i18n_85;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_85 = goog.getMsg("Time tab");
        i18n_85 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_85;
      } else {
        i18n_85 = $localize`:kendo.scheduler.editorDateInputsTimeTabLabel|The label of the Time tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor.:Time tab`;
      }
      let i18n_86;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_86 = goog.getMsg("Today");
        i18n_86 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_86;
      } else {
        i18n_86 = $localize`:kendo.scheduler.recurrenceEditorDateInputsToday|The Today button text in the popup of the DatePickers in the Scheduler recurrence editor.:Today`;
      }
      let i18n_87;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_87 = goog.getMsg("Toggle calendar");
        i18n_87 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_87;
      } else {
        i18n_87 = $localize`:kendo.scheduler.recurrenceEditorDateInputsToggle|The title of the Toggle button of the DatePickers in the Scheduler recurrence editor.:Toggle calendar`;
      }
      let i18n_88;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_88 = goog.getMsg("Navigate to parent view");
        i18n_88 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_88;
      } else {
        i18n_88 = $localize`:kendo.scheduler.recurrenceEditorDateInputsParentViewButton|The title of the Parent View button in the popup of the DatePickers in the Scheduler recurrence editor.:Navigate to parent view`;
      }
      let i18n_89;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_89 = goog.getMsg("Increase value");
        i18n_89 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_89;
      } else {
        i18n_89 = $localize`:kendo.scheduler.recurrenceEditorNumericIncrement|The title of the Increment button of the NumericTextBox in the Scheduler recurrence editor.:Increase value`;
      }
      let i18n_90;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_90 = goog.getMsg("Decrease value");
        i18n_90 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_90;
      } else {
        i18n_90 = $localize`:kendo.scheduler.recurrenceEditorNumericDecrement|The title of the Decrement button of the NumericTextBox in the Scheduler recurrence editor.:Decrease value`;
      }
      let i18n_91;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_91 = goog.getMsg("Repeat");
        i18n_91 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_91;
      } else {
        i18n_91 = $localize`:kendo.scheduler.recurrenceEditorRepeat|The text similar to 'Repeat' displayed in the Scheduler recurrence editor.:Repeat`;
      }
      let i18n_92;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_92 = goog.getMsg("day(s)");
        i18n_92 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_92;
      } else {
        i18n_92 = $localize`:kendo.scheduler.recurrenceEditorDailyInterval|The text similar to 'day(s)' displayed in the Scheduler recurrence editor.:day(s)`;
      }
      let i18n_93;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_93 = goog.getMsg("Repeat every");
        i18n_93 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_93;
      } else {
        i18n_93 = $localize`:kendo.scheduler.recurrenceEditorDailyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor.:Repeat every`;
      }
      let i18n_94;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_94 = goog.getMsg("week(s)");
        i18n_94 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_94;
      } else {
        i18n_94 = $localize`:kendo.scheduler.recurrenceEditorWeeklyInterval|The text similar to 'week(s)' displayed in the Scheduler recurrence editor.:week(s)`;
      }
      let i18n_95;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_95 = goog.getMsg("Repeat every");
        i18n_95 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_95;
      } else {
        i18n_95 = $localize`:kendo.scheduler.recurrenceEditorWeeklyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor.:Repeat every`;
      }
      let i18n_96;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_96 = goog.getMsg("Repeat on");
        i18n_96 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_96;
      } else {
        i18n_96 = $localize`:kendo.scheduler.recurrenceEditorWeeklyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor.:Repeat on`;
      }
      let i18n_97;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_97 = goog.getMsg("Day");
        i18n_97 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_97;
      } else {
        i18n_97 = $localize`:kendo.scheduler.recurrenceEditorMonthlyDay|The text similar to 'Day' displayed in the Scheduler recurrence editor.:Day`;
      }
      let i18n_98;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_98 = goog.getMsg("month(s)");
        i18n_98 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_98;
      } else {
        i18n_98 = $localize`:kendo.scheduler.recurrenceEditorMonthlyInterval|The text similar to 'month(s)' displayed in the Scheduler recurrence editor.:month(s)`;
      }
      let i18n_99;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_99 = goog.getMsg("Repeat every");
        i18n_99 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_99;
      } else {
        i18n_99 = $localize`:kendo.scheduler.recurrenceEditorMonthlyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor.:Repeat every`;
      }
      let i18n_100;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_100 = goog.getMsg("Repeat on");
        i18n_100 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_100;
      } else {
        i18n_100 = $localize`:kendo.scheduler.recurrenceEditorMonthlyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor.:Repeat on`;
      }
      let i18n_101;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_101 = goog.getMsg("of");
        i18n_101 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_101;
      } else {
        i18n_101 = $localize`:kendo.scheduler.recurrenceEditorYearlyOf|The text similar to 'of' displayed in the Scheduler recurrence editor.:of`;
      }
      let i18n_102;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_102 = goog.getMsg("Repeat every");
        i18n_102 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_102;
      } else {
        i18n_102 = $localize`:kendo.scheduler.recurrenceEditorYearlyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor.:Repeat every`;
      }
      let i18n_103;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_103 = goog.getMsg("Repeat on");
        i18n_103 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_103;
      } else {
        i18n_103 = $localize`:kendo.scheduler.recurrenceEditorYearlyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor.:Repeat on`;
      }
      let i18n_104;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_104 = goog.getMsg("year(s)");
        i18n_104 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_104;
      } else {
        i18n_104 = $localize`:kendo.scheduler.recurrenceEditorYearlyInterval|The text similar to 'year(s)' displayed in the Scheduler recurrence editor.:year(s)`;
      }
      let i18n_105;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_105 = goog.getMsg("Daily");
        i18n_105 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_105;
      } else {
        i18n_105 = $localize`:kendo.scheduler.recurrenceEditorFrequenciesDaily|The text similar to 'Daily' displayed in the Scheduler recurrence editor.:Daily`;
      }
      let i18n_106;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_106 = goog.getMsg("Monthly");
        i18n_106 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_106;
      } else {
        i18n_106 = $localize`:kendo.scheduler.recurrenceEditorFrequenciesMonthly|The text similar to 'Monthly' displayed in the Scheduler recurrence editor.:Monthly`;
      }
      let i18n_107;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_107 = goog.getMsg("Never");
        i18n_107 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_107;
      } else {
        i18n_107 = $localize`:kendo.scheduler.recurrenceEditorFrequenciesNever|The text similar to 'Never' displayed in the Scheduler recurrence editor.:Never`;
      }
      let i18n_108;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_108 = goog.getMsg("Weekly");
        i18n_108 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_108;
      } else {
        i18n_108 = $localize`:kendo.scheduler.recurrenceEditorFrequenciesWeekly|The text similar to 'Weekly' displayed in the Scheduler recurrence editor.:Weekly`;
      }
      let i18n_109;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_109 = goog.getMsg("Yearly");
        i18n_109 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_109;
      } else {
        i18n_109 = $localize`:kendo.scheduler.recurrenceEditorFrequenciesYearly|The text similar to 'Yearly' displayed in the Scheduler recurrence editor.:Yearly`;
      }
      let i18n_110;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_110 = goog.getMsg("First");
        i18n_110 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_110;
      } else {
        i18n_110 = $localize`:kendo.scheduler.recurrenceEditorOffsetPositionsFirst|The text similar to 'First' displayed in the Scheduler recurrence editor.:First`;
      }
      let i18n_111;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_111 = goog.getMsg("Second");
        i18n_111 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_111;
      } else {
        i18n_111 = $localize`:kendo.scheduler.recurrenceEditorOffsetPositionsSecond|The text similar to 'Second' displayed in the Scheduler recurrence editor.:Second`;
      }
      let i18n_112;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_112 = goog.getMsg("Third");
        i18n_112 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_112;
      } else {
        i18n_112 = $localize`:kendo.scheduler.recurrenceEditorOffsetPositionsThird|The text similar to 'Third' displayed in the Scheduler recurrence editor.:Third`;
      }
      let i18n_113;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_113 = goog.getMsg("Fourth");
        i18n_113 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_113;
      } else {
        i18n_113 = $localize`:kendo.scheduler.recurrenceEditorOffsetPositionsFourth|The text similar to 'Fourth' displayed in the Scheduler recurrence editor.:Fourth`;
      }
      let i18n_114;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_114 = goog.getMsg("Last");
        i18n_114 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_114;
      } else {
        i18n_114 = $localize`:kendo.scheduler.recurrenceEditorOffsetPositionsLast|The text similar to 'Last' displayed in the Scheduler recurrence editor.:Last`;
      }
      let i18n_115;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_115 = goog.getMsg("Day");
        i18n_115 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_115;
      } else {
        i18n_115 = $localize`:kendo.scheduler.recurrenceEditorWeekdaysDay|The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern.:Day`;
      }
      let i18n_116;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_116 = goog.getMsg("Weekday");
        i18n_116 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_116;
      } else {
        i18n_116 = $localize`:kendo.scheduler.recurrenceEditorWeekdaysWeekday|The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern.:Weekday`;
      }
      let i18n_117;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_117 = goog.getMsg("Weekend Day");
        i18n_117 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_117;
      } else {
        i18n_117 = $localize`:kendo.scheduler.recurrenceEditorWeekdaysWeekendday|The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern.:Weekend Day`;
      }
      let i18n_118;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_118 = goog.getMsg("After");
        i18n_118 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_118;
      } else {
        i18n_118 = $localize`:kendo.scheduler.recurrenceEditorEndAfter|The text similar to 'After' displayed in the Scheduler recurrence editor.:After`;
      }
      let i18n_119;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_119 = goog.getMsg("occurrence(s)");
        i18n_119 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_119;
      } else {
        i18n_119 = $localize`:kendo.scheduler.recurrenceEditorEndOccurrence|The text similar to 'occurrence(s)' displayed in the Scheduler recurrence editor.:occurrence(s)`;
      }
      let i18n_120;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_120 = goog.getMsg("End");
        i18n_120 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_120;
      } else {
        i18n_120 = $localize`:kendo.scheduler.recurrenceEditorEndLabel|The text similar to 'End' displayed in the Scheduler recurrence editor.:End`;
      }
      let i18n_121;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_121 = goog.getMsg("Never");
        i18n_121 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_121;
      } else {
        i18n_121 = $localize`:kendo.scheduler.recurrenceEditorEndNever|The text similar to 'Never' displayed in the Scheduler recurrence editor.:Never`;
      }
      let i18n_122;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_122 = goog.getMsg("On");
        i18n_122 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_122;
      } else {
        i18n_122 = $localize`:kendo.scheduler.recurrenceEditorEndOn|The text similar to 'On' displayed in the Scheduler recurrence editor.:On`;
      }
      let i18n_123;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_123 = goog.getMsg("Delete");
        i18n_123 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_123;
      } else {
        i18n_123 = $localize`:kendo.scheduler.destroy|The text of the 'Delete' button displayed in the Scheduler remove confirmation dialog.:Delete`;
      }
      let i18n_124;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_124 = goog.getMsg("Are you sure you want to delete this event?");
        i18n_124 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_124;
      } else {
        i18n_124 = $localize`:kendo.scheduler.deleteConfirmation|The text similar to 'Are you sure you want to delete this event?' displayed in Scheduler remove confirmation dialog.:Are you sure you want to delete this event?`;
      }
      let i18n_125;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_125 = goog.getMsg("Do you want to edit only this event occurrence or the whole series?");
        i18n_125 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_125;
      } else {
        i18n_125 = $localize`:kendo.scheduler.editRecurringConfirmation|The text similar to 'Do you want to edit only this event occurrence or the whole series?' displayed in the Scheduler recurring confirmation dialog.:Do you want to edit only this event occurrence or the whole series?`;
      }
      let i18n_126;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_126 = goog.getMsg("Edit current occurrence");
        i18n_126 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_126;
      } else {
        i18n_126 = $localize`:kendo.scheduler.editOccurrence|The text of the 'Edit current occurrence' button displayed in the Scheduler recurring confirmation dialog.:Edit current occurrence`;
      }
      let i18n_127;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_127 = goog.getMsg("Edit the series");
        i18n_127 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_127;
      } else {
        i18n_127 = $localize`:kendo.scheduler.editSeries|The text of the 'Edit the series' button displayed in the Scheduler recurring confirmation dialog.:Edit the series`;
      }
      let i18n_128;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_128 = goog.getMsg("Do you want to delete only this event occurrence or the whole series?");
        i18n_128 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_128;
      } else {
        i18n_128 = $localize`:kendo.scheduler.deleteRecurringConfirmation|The text similar to 'Do you want to delete only this event occurrence or the whole series?' displayed in the Scheduler recurring confirmation dialog.:Do you want to delete only this event occurrence or the whole series?`;
      }
      let i18n_129;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_129 = goog.getMsg("Delete current occurrence");
        i18n_129 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_129;
      } else {
        i18n_129 = $localize`:kendo.scheduler.deleteOccurrence|The text of the 'Delete current occurrence' button displayed in the Scheduler recurring confirmation dialog.:Delete current occurrence`;
      }
      let i18n_130;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_130 = goog.getMsg("Delete the series");
        i18n_130 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_130;
      } else {
        i18n_130 = $localize`:kendo.scheduler.deleteSeries|The text similar of the 'Delete the series' button displayed in the Scheduler recurring confirmation dialog.:Delete the series`;
      }
      let i18n_131;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_131 = goog.getMsg("Delete Event");
        i18n_131 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_131;
      } else {
        i18n_131 = $localize`:kendo.scheduler.deleteDialogTitle|The title of the remove confirmation dialog, similar to 'Delete Event'.:Delete Event`;
      }
      let i18n_132;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_132 = goog.getMsg("Delete Recurring Item");
        i18n_132 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_132;
      } else {
        i18n_132 = $localize`:kendo.scheduler.deleteRecurringDialogTitle|The title of the recurring remove confirmation dialog, similar to 'Delete Recurring Item':Delete Recurring Item`;
      }
      let i18n_133;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_133 = goog.getMsg("Edit Recurring Item");
        i18n_133 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_133;
      } else {
        i18n_133 = $localize`:kendo.scheduler.editRecurringDialogTitle|The title of the recurring edit confirmation dialog, similar to 'Edit Recurring Item':Edit Recurring Item`;
      }
      let i18n_134;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_134 = goog.getMsg("Select View");
        i18n_134 = MSG_C__USERS_KRYST_ONEDRIVE_DESKTOP_SEMESTR_7_OPTISCHED_OPTISCHED_FRONTEND_NODE_MODULES__PROGRESS_KENDO_ANGULAR_SCHEDULER_FESM2022_PROGRESS_KENDO_ANGULAR_SCHEDULER_MJS_134;
      } else {
        i18n_134 = $localize`:kendo.scheduler.selectView|The value of the aria-label attribute of the <select> element used for switching the Scheduler views.:Select View`;
      }
      return [["confirmationDialogContainer", ""], ["kendoSchedulerLocalizedMessages", "", "allEvents", i18n_37, "allDay", i18n_38, "dateHeader", i18n_39, "timeHeader", i18n_40, "deleteTitle", i18n_41, "eventHeader", i18n_42, "nextTitle", i18n_43, "previousTitle", i18n_44, "showFullDay", i18n_45, "showWorkDay", i18n_46, "today", i18n_47, "calendarToday", i18n_48, "dayViewTitle", i18n_49, "multiDayViewTitle", i18n_50, "weekViewTitle", i18n_51, "workWeekViewTitle", i18n_52, "monthViewTitle", i18n_53, "multiWeekViewTitle", i18n_54, "timelineViewTitle", i18n_55, "timelineWeekViewTitle", i18n_56, "timelineMonthViewTitle", i18n_57, "agendaViewTitle", i18n_58, "yearViewTitle", i18n_59, "yearViewNoEvents", i18n_60, "cancel", i18n_61, "save", i18n_62, "editorEventTitle", i18n_63, "editorEventStart", i18n_64, "editorEventStartTimeZone", i18n_65, "editorEventEnd", i18n_66, "editorEventEndTimeZone", i18n_67, "editorEventAllDay", i18n_68, "editorEventDescription", i18n_69, "editorEventSeparateTimeZones", i18n_70, "editorEventTimeZone", i18n_71, "editorTitle", i18n_72, "editorDateInputsToday", i18n_73, "editorDateInputsToggle", i18n_74, "editorDateInputsParentViewButton", i18n_75, "editorDateInputsAccept", i18n_76, "editorDateInputsAcceptLabel", i18n_77, "editorDateInputsAccept", i18n_78, "editorDateInputsAcceptLabel", i18n_79, "editorDateInputsCancel", i18n_80, "editorDateInputsCancelLabel", i18n_81, "editorDateInputsDateTab", i18n_82, "editorDateInputsDateTabLabel", i18n_83, "editorDateInputsTimeTab", i18n_84, "editorDateInputsTimeTabLabel", i18n_85, "recurrenceEditorDateInputsToday", i18n_86, "recurrenceEditorDateInputsToggle", i18n_87, "recurrenceEditorDateInputsParentViewButton", i18n_88, "recurrenceEditorNumericIncrement", i18n_89, "recurrenceEditorNumericDecrement", i18n_90, "recurrenceEditorRepeat", i18n_91, "recurrenceEditorDailyInterval", i18n_92, "recurrenceEditorDailyRepeatEvery", i18n_93, "recurrenceEditorWeeklyInterval", i18n_94, "recurrenceEditorWeeklyRepeatEvery", i18n_95, "recurrenceEditorWeeklyRepeatOn", i18n_96, "recurrenceEditorMonthlyDay", i18n_97, "recurrenceEditorMonthlyInterval", i18n_98, "recurrenceEditorMonthlyRepeatEvery", i18n_99, "recurrenceEditorMonthlyRepeatOn", i18n_100, "recurrenceEditorYearlyOf", i18n_101, "recurrenceEditorYearlyRepeatEvery", i18n_102, "recurrenceEditorYearlyRepeatOn", i18n_103, "recurrenceEditorYearlyInterval", i18n_104, "recurrenceEditorFrequenciesDaily", i18n_105, "recurrenceEditorFrequenciesMonthly", i18n_106, "recurrenceEditorFrequenciesNever", i18n_107, "recurrenceEditorFrequenciesWeekly", i18n_108, "recurrenceEditorFrequenciesYearly", i18n_109, "recurrenceEditorOffsetPositionsFirst", i18n_110, "recurrenceEditorOffsetPositionsSecond", i18n_111, "recurrenceEditorOffsetPositionsThird", i18n_112, "recurrenceEditorOffsetPositionsFourth", i18n_113, "recurrenceEditorOffsetPositionsLast", i18n_114, "recurrenceEditorWeekdaysDay", i18n_115, "recurrenceEditorWeekdaysWeekday", i18n_116, "recurrenceEditorWeekdaysWeekendday", i18n_117, "recurrenceEditorEndAfter", i18n_118, "recurrenceEditorEndOccurrence", i18n_119, "recurrenceEditorEndLabel", i18n_120, "recurrenceEditorEndNever", i18n_121, "recurrenceEditorEndOn", i18n_122, "destroy", i18n_123, "deleteConfirmation", i18n_124, "editRecurringConfirmation", i18n_125, "editOccurrence", i18n_126, "editSeries", i18n_127, "deleteRecurringConfirmation", i18n_128, "deleteOccurrence", i18n_129, "deleteSeries", i18n_130, "deleteDialogTitle", i18n_131, "deleteRecurringDialogTitle", i18n_132, "editRecurringDialogTitle", i18n_133, "selectView", i18n_134], [3, "dateRange", "selectedDate", "views", "selectedView", "template", "min", "max", "navigate", "toolbarWidthChange", 4, "ngIf"], [4, "ngTemplateOutlet"], [3, "resources", "editTemplate", "timezone", "weekStart", "fields"], [3, "resize"], ["kendoSchedulerLoading", "", 3, "loading"], ["kendoWatermarkOverlay", "", 4, "ngIf"], [3, "navigate", "toolbarWidthChange", "dateRange", "selectedDate", "views", "selectedView", "template", "min", "max"], ["kendoWatermarkOverlay", ""]];
    },
    template: function SchedulerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 1);
        ɵɵtemplate(1, SchedulerComponent_kendo_scheduler_toolbar_1_Template, 1, 7, "kendo-scheduler-toolbar", 2)(2, SchedulerComponent_ng_container_2_Template, 1, 0, "ng-container", 3);
        ɵɵelementContainer(3, null, 0);
        ɵɵelement(5, "kendo-scheduler-edit-dialog", 4);
        ɵɵelementStart(6, "kendo-resize-sensor", 5);
        ɵɵlistener("resize", function SchedulerComponent_Template_kendo_resize_sensor_resize_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onResize());
        });
        ɵɵelementEnd();
        ɵɵelement(7, "div", 6);
        ɵɵtemplate(8, SchedulerComponent_div_8_Template, 1, 0, "div", 7);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.toolbarVisibilityState);
        ɵɵadvance();
        ɵɵproperty("ngTemplateOutlet", ctx.selectedView == null ? null : ctx.selectedView.template);
        ɵɵadvance(3);
        ɵɵproperty("resources", ctx.resources)("editTemplate", ctx.editDialogTemplate)("timezone", ctx.timezone)("weekStart", ctx.weekStart)("fields", ctx.modelFields);
        ɵɵadvance(2);
        ɵɵproperty("loading", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showLicenseWatermark);
      }
    },
    dependencies: [LocalizedMessagesDirective3, ToolbarComponent, NgTemplateOutlet, EditDialogComponent, ResizeSensorComponent, LoadingComponent, NgIf, WatermarkOverlayComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchedulerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler",
      providers: [EditService, DialogsService, DomEventsService, LocalDataChangesService, FocusService, SchedulerLocalizationService, {
        provide: LocalizationService,
        useExisting: SchedulerLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.scheduler"
      }, ToolbarService, ViewContextService, ViewStateService, PDFService],
      template: `
        <ng-container kendoSchedulerLocalizedMessages
            i18n-allEvents="kendo.scheduler.allEvents|The All events text displayed in the timeline views when there is no vertical grouping."
            allEvents="All events"

            i18n-allDay="kendo.scheduler.allDay|The all day text displayed in the day and week views."
            allDay="all day"

            i18n-dateHeader="kendo.scheduler.dateHeader|The date header text displayed in the agenda view."
            dateHeader="Date"

            i18n-timeHeader="kendo.scheduler.timeHeader|The time header text displayed in the agenda view."
            timeHeader="Time"

            i18n-deleteTitle="kendo.scheduler.deleteTitle|The delete icon title."
            deleteTitle="Delete"

            i18n-eventHeader="kendo.scheduler.eventHeader|The event header text displayed in the agenda view."
            eventHeader="Event"

            i18n-nextTitle="kendo.scheduler.nextTitle|The title of the navigation next button."
            nextTitle="Next"

            i18n-previousTitle="kendo.scheduler.previousTitle|The title of the navigation previous button."
            previousTitle="Previous"

            i18n-showFullDay="kendo.scheduler.showFullDay|The text of the show full day button displayed in the footer of the day, week and timeline views."
            showFullDay="Show full day"

            i18n-showWorkDay="kendo.scheduler.showWorkDay|The text of the show work day button displayed in the footer of the day, week and timeline views."
            showWorkDay="Show business hours"

            i18n-today="kendo.scheduler.today|The today button text displayed in the navigation."
            today="Today"

            i18n-calendarToday="kendo.scheduler.calendarToday|The text of today's date in the header of the Calendar."
            calendarToday="TODAY"

            i18n-dayViewTitle="kendo.scheduler.dayViewTitle|The day view title."
            dayViewTitle="Day"

            i18n-multiDayViewTitle="kendo.scheduler.multiDayViewTitle|The multi day view title."
            multiDayViewTitle="Multi-Day"

            i18n-weekViewTitle="kendo.scheduler.weekViewTitle|The week view title."
            weekViewTitle="Week"

            i18n-workWeekViewTitle="kendo.scheduler.workWeekViewTitle|The work week view title."
            workWeekViewTitle="Work Week"

            i18n-monthViewTitle="kendo.scheduler.monthViewTitle|The month view title."
            monthViewTitle="Month"

            i18n-multiWeekViewTitle="kendo.scheduler.multiWeekViewTitle|The multi week view title."
            multiWeekViewTitle="Multi-Week"

            i18n-timelineViewTitle="kendo.scheduler.timelineViewTitle|The timeline view title."
            timelineViewTitle="Timeline"

            i18n-timelineWeekViewTitle="kendo.scheduler.timelineWeekViewTitle|The timeline week view title."
            timelineWeekViewTitle="Timeline Week"

            i18n-timelineMonthViewTitle="kendo.scheduler.timelineMonthViewTitle|The timeline month view title."
            timelineMonthViewTitle="Timeline Month"

            i18n-agendaViewTitle="kendo.scheduler.agendaViewTitle|The agenda view title."
            agendaViewTitle="Agenda"

            i18n-yearViewTitle="kendo.scheduler.yearViewTitle|The year view title."
            yearViewTitle="Year"

            i18n-yearViewNoEvents="kendo.scheduler.yearViewNoEvents|The year view no events message."
            yearViewNoEvents="No events on this date."

            i18n-cancel="kendo.scheduler.cancel|The text similar to 'Cancel' displayed in the Scheduler."
            cancel="Cancel"

            i18n-save="kendo.scheduler.save|The text similar to 'Save' displayed in the Scheduler."
            save="Save"

            i18n-editorEventTitle="kendo.scheduler.editorEventTitle|The text similar to 'Title' displayed in the Scheduler event editor."
            editorEventTitle='Title'

            i18n-editorEventStart="kendo.scheduler.editorEventStart|The text similar to 'Start' displayed in the Scheduler event editor."
            editorEventStart="Start"

            i18n-editorEventStartTimeZone="kendo.scheduler.editorEventStartTimeZone|The text similar to 'Start Time Zone' displayed in the Scheduler event editor."
            editorEventStartTimeZone="Start Time Zone"

            i18n-editorEventEnd="kendo.scheduler.editorEventEnd|The text similar to 'End' displayed in the Scheduler event editor."
            editorEventEnd="End"

            i18n-editorEventEndTimeZone="kendo.scheduler.editorEventEndTimeZone|The text similar to 'End Time Zone' displayed in the Scheduler event editor."
            editorEventEndTimeZone="End Time Zone"

            i18n-editorEventAllDay="kendo.scheduler.editorEventAllDay|The text similar to 'All Day event' displayed in the Scheduler event editor."
            editorEventAllDay="All Day Event"

            i18n-editorEventDescription="kendo.scheduler.editorEventDescription|The text similar to 'Description' displayed in the Scheduler event editor."
            editorEventDescription="Description"

            i18n-editorEventSeparateTimeZones="kendo.scheduler.editorEventSeparateTimeZones|The text similar to 'Use separate Start and End Time Zones' displayed in the Scheduler event editor."
            editorEventSeparateTimeZones="End in different Time Zone"

            i18n-editorEventTimeZone="kendo.scheduler.editorEventTimeZone|The text similar to 'Time Zone' displayed in the Scheduler event editor."
            editorEventTimeZone='Specify Time Zone'

            i18n-editorTitle="kendo.scheduler.editorTitle|The text similar to 'Event' displayed as title of the Scheduler event editor."
            editorTitle='Event'

            i18n-editorDateInputsToday="kendo.scheduler.editorDateInputsToday|The Today button text in the popup of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsToday='Today'

            i18n-editorDateInputsToggle="kendo.scheduler.editorDateInputsToggle|The title of the Toggle button of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsToggle='Toggle calendar'

            i18n-editorDateInputsParentViewButton="kendo.scheduler.editorDateInputsParentViewButton|The title of the Parent View button in the popup of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsParentViewButton='Navigate to parent view'

            i18n-editorDateInputsNow="kendo.scheduler.editorDateInputsAccept|The text of the Now button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAccept='Now'

            i18n-editorDateInputsNowLabel="kendo.scheduler.editorDateInputsAcceptLabel|The label of the Now button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAcceptLabel='Select now'

            i18n-editorDateInputsAccept="kendo.scheduler.editorDateInputsAccept|The text of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAccept='Set'

            i18n-editorDateInputsAcceptLabel="kendo.scheduler.editorDateInputsAcceptLabel|The label of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAcceptLabel='Set'

            i18n-editorDateInputsCancel="kendo.scheduler.editorDateInputsCancel|The text of the Cancel button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsCancel='Cancel'

            i18n-editorDateInputsCancelLabel="kendo.scheduler.editorDateInputsCancelLabel|The label of the Cancel button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsCancelLabel='Cancel'

            i18n-editorDateInputsDateTab="kendo.scheduler.editorDateInputsDateTab|The text of the Date tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsDateTab='Date'

            i18n-editorDateInputsDateTabLabel="kendo.scheduler.editorDateInputsDateTabLabel|The label of the Date tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsDateTabLabel='Date tab'

            i18n-editorDateInputsTimeTab="kendo.scheduler.editorDateInputsTimeTab|The text of the Time tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsTimeTab='Time'

            i18n-editorDateInputsTimeTabLabel="kendo.scheduler.editorDateInputsTimeTabLabel|The label of the Time tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsTimeTabLabel='Time tab'

            i18n-recurrenceEditorDateInputsToday="kendo.scheduler.recurrenceEditorDateInputsToday|The Today button text in the popup of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsToday='Today'

            i18n-recurrenceEditorDateInputsToggle="kendo.scheduler.recurrenceEditorDateInputsToggle|The title of the Toggle button of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsToggle='Toggle calendar'

            i18n-recurrenceEditorDateInputsParentViewButton="kendo.scheduler.recurrenceEditorDateInputsParentViewButton|The title of the Parent View button in the popup of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsParentViewButton='Navigate to parent view'

            i18n-recurrenceEditorNumericIncrement="kendo.scheduler.recurrenceEditorNumericIncrement|The title of the Increment button of the NumericTextBox in the Scheduler recurrence editor."
            recurrenceEditorNumericIncrement='Increase value'

            i18n-recurrenceEditorNumericDecrement="kendo.scheduler.recurrenceEditorNumericDecrement|The title of the Decrement button of the NumericTextBox in the Scheduler recurrence editor."
            recurrenceEditorNumericDecrement='Decrease value'

            i18n-recurrenceEditorRepeat="kendo.scheduler.recurrenceEditorRepeat|The text similar to 'Repeat' displayed in the Scheduler recurrence editor."
            recurrenceEditorRepeat='Repeat'

            i18n-recurrenceEditorDailyInterval="kendo.scheduler.recurrenceEditorDailyInterval|The text similar to 'day(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorDailyInterval='day(s)'

            i18n-recurrenceEditorDailyRepeatEvery="kendo.scheduler.recurrenceEditorDailyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorDailyRepeatEvery='Repeat every'

            i18n-recurrenceEditorWeeklyInterval="kendo.scheduler.recurrenceEditorWeeklyInterval|The text similar to 'week(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyInterval='week(s)'

            i18n-recurrenceEditorWeeklyRepeatEvery="kendo.scheduler.recurrenceEditorWeeklyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyRepeatEvery='Repeat every'

            i18n-recurrenceEditorWeeklyRepeatOn="kendo.scheduler.recurrenceEditorWeeklyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyRepeatOn='Repeat on'

            i18n-recurrenceEditorMonthlyDay="kendo.scheduler.recurrenceEditorMonthlyDay|The text similar to 'Day' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyDay='Day'

            i18n-recurrenceEditorMonthlyInterval="kendo.scheduler.recurrenceEditorMonthlyInterval|The text similar to 'month(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyInterval='month(s)'

            i18n-recurrenceEditorMonthlyRepeatEvery="kendo.scheduler.recurrenceEditorMonthlyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyRepeatEvery='Repeat every'

            i18n-recurrenceEditorMonthlyRepeatOn="kendo.scheduler.recurrenceEditorMonthlyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyRepeatOn='Repeat on'

            i18n-recurrenceEditorYearlyOf="kendo.scheduler.recurrenceEditorYearlyOf|The text similar to 'of' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyOf='of'

            i18n-recurrenceEditorYearlyRepeatEvery="kendo.scheduler.recurrenceEditorYearlyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyRepeatEvery='Repeat every'

            i18n-recurrenceEditorYearlyRepeatOn="kendo.scheduler.recurrenceEditorYearlyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyRepeatOn='Repeat on'

            i18n-recurrenceEditorYearlyInterval="kendo.scheduler.recurrenceEditorYearlyInterval|The text similar to 'year(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyInterval='year(s)'

            i18n-recurrenceEditorFrequenciesDaily="kendo.scheduler.recurrenceEditorFrequenciesDaily|The text similar to 'Daily' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesDaily='Daily'

            i18n-recurrenceEditorFrequenciesMonthly="kendo.scheduler.recurrenceEditorFrequenciesMonthly|The text similar to 'Monthly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesMonthly='Monthly'

            i18n-recurrenceEditorFrequenciesNever="kendo.scheduler.recurrenceEditorFrequenciesNever|The text similar to 'Never' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesNever='Never'

            i18n-recurrenceEditorFrequenciesWeekly="kendo.scheduler.recurrenceEditorFrequenciesWeekly|The text similar to 'Weekly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesWeekly='Weekly'

            i18n-recurrenceEditorFrequenciesYearly="kendo.scheduler.recurrenceEditorFrequenciesYearly|The text similar to 'Yearly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesYearly='Yearly'

            i18n-recurrenceEditorOffsetPositionsFirst="kendo.scheduler.recurrenceEditorOffsetPositionsFirst|The text similar to 'First' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsFirst='First'

            i18n-recurrenceEditorOffsetPositionsSecond="kendo.scheduler.recurrenceEditorOffsetPositionsSecond|The text similar to 'Second' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsSecond='Second'

            i18n-recurrenceEditorOffsetPositionsThird="kendo.scheduler.recurrenceEditorOffsetPositionsThird|The text similar to 'Third' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsThird='Third'

            i18n-recurrenceEditorOffsetPositionsFourth="kendo.scheduler.recurrenceEditorOffsetPositionsFourth|The text similar to 'Fourth' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsFourth='Fourth'

            i18n-recurrenceEditorOffsetPositionsLast="kendo.scheduler.recurrenceEditorOffsetPositionsLast|The text similar to 'Last' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsLast='Last'

            i18n-recurrenceEditorWeekdaysDay="kendo.scheduler.recurrenceEditorWeekdaysDay|The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysDay='Day'

            i18n-recurrenceEditorWeekdaysWeekday="kendo.scheduler.recurrenceEditorWeekdaysWeekday|The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysWeekday='Weekday'

            i18n-recurrenceEditorWeekdaysWeekendday="kendo.scheduler.recurrenceEditorWeekdaysWeekendday|The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysWeekendday='Weekend Day'

            i18n-recurrenceEditorEndAfter="kendo.scheduler.recurrenceEditorEndAfter|The text similar to 'After' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndAfter='After'

            i18n-recurrenceEditorEndOccurrence="kendo.scheduler.recurrenceEditorEndOccurrence|The text similar to 'occurrence(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndOccurrence='occurrence(s)'

            i18n-recurrenceEditorEndLabel="kendo.scheduler.recurrenceEditorEndLabel|The text similar to 'End' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndLabel='End'

            i18n-recurrenceEditorEndNever="kendo.scheduler.recurrenceEditorEndNever|The text similar to 'Never' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndNever='Never'

            i18n-recurrenceEditorEndOn="kendo.scheduler.recurrenceEditorEndOn|The text similar to 'On' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndOn='On'

            i18n-destroy="kendo.scheduler.destroy|The text of the 'Delete' button displayed in the Scheduler remove confirmation dialog."
            destroy='Delete'

            i18n-deleteConfirmation="kendo.scheduler.deleteConfirmation|The text similar to 'Are you sure you want to delete this event?' displayed in Scheduler remove confirmation dialog."
            deleteConfirmation='Are you sure you want to delete this event?'

            i18n-editRecurringConfirmation="kendo.scheduler.editRecurringConfirmation|The text similar to 'Do you want to edit only this event occurrence or the whole series?' displayed in the Scheduler recurring confirmation dialog."
            editRecurringConfirmation='Do you want to edit only this event occurrence or the whole series?'

            i18n-editOccurrence="kendo.scheduler.editOccurrence|The text of the 'Edit current occurrence' button displayed in the Scheduler recurring confirmation dialog."
            editOccurrence='Edit current occurrence'

            i18n-editSeries="kendo.scheduler.editSeries|The text of the 'Edit the series' button displayed in the Scheduler recurring confirmation dialog."
            editSeries='Edit the series'

            i18n-deleteRecurringConfirmation="kendo.scheduler.deleteRecurringConfirmation|The text similar to 'Do you want to delete only this event occurrence or the whole series?' displayed in the Scheduler recurring confirmation dialog."
            deleteRecurringConfirmation='Do you want to delete only this event occurrence or the whole series?'

            i18n-deleteOccurrence="kendo.scheduler.deleteOccurrence|The text of the 'Delete current occurrence' button displayed in the Scheduler recurring confirmation dialog."
            deleteOccurrence='Delete current occurrence'

            i18n-deleteSeries="kendo.scheduler.deleteSeries|The text similar of the 'Delete the series' button displayed in the Scheduler recurring confirmation dialog."
            deleteSeries='Delete the series'

            i18n-deleteDialogTitle="kendo.scheduler.deleteDialogTitle|The title of the remove confirmation dialog, similar to 'Delete Event'."
            deleteDialogTitle='Delete Event'

            i18n-deleteRecurringDialogTitle="kendo.scheduler.deleteRecurringDialogTitle|The title of the recurring remove confirmation dialog, similar to 'Delete Recurring Item'"
            deleteRecurringDialogTitle='Delete Recurring Item'

            i18n-editRecurringDialogTitle="kendo.scheduler.editRecurringDialogTitle|The title of the recurring edit confirmation dialog, similar to 'Edit Recurring Item'"
            editRecurringDialogTitle='Edit Recurring Item'

            i18n-selectView="kendo.scheduler.selectView|The value of the aria-label attribute of the <select> element used for switching the Scheduler views."
            selectView='Select View'
        >
        </ng-container>

        <kendo-scheduler-toolbar
            *ngIf="toolbarVisibilityState"
            [dateRange]="dateRangeStream"
            [selectedDate]="selectedDateStream"
            [views]="$any(views)"
            [selectedView]="selectedView"
            [template]="toolbarTemplate"
            [min]="min"
            [max]="max"
            (navigate)="onNavigationAction($event)"
            (toolbarWidthChange)="onToolbarWidthChange($event)"
        ></kendo-scheduler-toolbar>

        <ng-container *ngTemplateOutlet="selectedView?.template">
        </ng-container>

        <ng-container #confirmationDialogContainer>
        </ng-container>

        <kendo-scheduler-edit-dialog
            [resources]="resources"
            [editTemplate]="editDialogTemplate"
            [timezone]="timezone"
            [weekStart]="weekStart"
            [fields]="modelFields"
        ></kendo-scheduler-edit-dialog>

        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>

        <div [loading]="loading" kendoSchedulerLoading>
        </div>

        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, ToolbarComponent, NgTemplateOutlet, EditDialogComponent, ResizeSensorComponent, LoadingComponent, NgIf, WatermarkOverlayComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: EditService
    }, {
      type: DialogsService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: PDFService
    }, {
      type: LocalizationService
    }, {
      type: DomEventsService
    }, {
      type: Renderer2
    }, {
      type: FocusService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-scheduler"]
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    rtl: [{
      type: HostBinding,
      args: ["class.k-rtl"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    selectedViewIndex: [{
      type: Input
    }],
    editable: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    columnWidth: [{
      type: Input
    }],
    showWorkHours: [{
      type: Input
    }],
    startTime: [{
      type: Input
    }],
    endTime: [{
      type: Input
    }],
    workDayStart: [{
      type: Input
    }],
    workDayEnd: [{
      type: Input
    }],
    workWeekStart: [{
      type: Input
    }],
    workWeekEnd: [{
      type: Input
    }],
    weekStart: [{
      type: Input
    }],
    slotDuration: [{
      type: Input
    }],
    slotDivisions: [{
      type: Input
    }],
    slotFill: [{
      type: Input
    }],
    allDaySlot: [{
      type: Input
    }],
    scrollTime: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    resources: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    timezone: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    selectedDate: [{
      type: Input
    }],
    modelFields: [{
      type: Input
    }],
    currentTimeMarker: [{
      type: Input
    }],
    highlightOngoingEvents: [{
      type: Input
    }],
    showToolbar: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    slotClass: [{
      type: Input
    }],
    eventClass: [{
      type: Input
    }],
    eventStyles: [{
      type: Input
    }],
    isSlotSelected: [{
      type: Input
    }],
    selectedViewIndexChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    dateChange: [{
      type: Output
    }],
    slotClick: [{
      type: Output
    }],
    slotDblClick: [{
      type: Output
    }],
    create: [{
      type: Output
    }],
    eventClick: [{
      type: Output
    }],
    eventDblClick: [{
      type: Output
    }],
    eventKeydown: [{
      type: Output
    }],
    cancel: [{
      type: Output
    }],
    save: [{
      type: Output
    }],
    remove: [{
      type: Output
    }],
    resizeStart: [{
      type: Output
    }],
    resize: [{
      type: Output
    }],
    resizeEnd: [{
      type: Output
    }],
    dragStart: [{
      type: Output
    }],
    drag: [{
      type: Output
    }],
    dragEnd: [{
      type: Output
    }],
    slotDragStart: [{
      type: Output
    }],
    slotDrag: [{
      type: Output
    }],
    slotDragEnd: [{
      type: Output
    }],
    pdfExport: [{
      type: Output
    }],
    schedulerResize: [{
      type: Output
    }],
    editDialogTemplate: [{
      type: ContentChild,
      args: [EditDialogTemplateDirective, {
        static: false
      }]
    }],
    toolbarTemplate: [{
      type: ContentChild,
      args: [ToolbarTemplateDirective, {
        static: false
      }]
    }],
    views: [{
      type: ContentChildren,
      args: [SchedulerView]
    }],
    resizeSensor: [{
      type: ViewChild,
      args: [ResizeSensorComponent, {
        static: true
      }]
    }],
    confirmationDialogContainerRef: [{
      type: ViewChild,
      args: ["confirmationDialogContainer", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    loadingComponent: [{
      type: ViewChild,
      args: [LoadingComponent, {
        static: true
      }]
    }],
    allDayEventTemplate: [{
      type: ContentChildren,
      args: [AllDayEventTemplateDirective]
    }],
    eventTemplate: [{
      type: ContentChildren,
      args: [EventTemplateDirective]
    }],
    timeSlotTemplate: [{
      type: ContentChildren,
      args: [TimeSlotTemplateDirective]
    }],
    minorTimeHeaderTemplate: [{
      type: ContentChildren,
      args: [MinorTimeHeaderTemplateDirective]
    }],
    majorTimeHeaderTemplate: [{
      type: ContentChildren,
      args: [MajorTimeHeaderTemplateDirective]
    }],
    monthDaySlotTemplate: [{
      type: ContentChildren,
      args: [MonthDaySlotTemplateDirective]
    }],
    multiWeekDaySlotTemplate: [{
      type: ContentChildren,
      args: [MultiWeekDaySlotTemplateDirective]
    }],
    dateHeaderTemplate: [{
      type: ContentChildren,
      args: [DateHeaderTemplateDirective]
    }],
    allDaySlotTemplate: [{
      type: ContentChildren,
      args: [AllDaySlotTemplateDirective]
    }],
    groupHeaderTemplate: [{
      type: ContentChildren,
      args: [GroupHeaderTemplateDirective]
    }],
    agendaDateTemplate: [{
      type: ContentChildren,
      args: [AgendaDateTemplateDirective]
    }],
    agendaTimeTemplate: [{
      type: ContentChildren,
      args: [AgendaTimeTemplateDirective]
    }]
  });
})();
var occurrences = (item, fields, range3, timezone, weekStart) => {
  const rrule = parseRule({
    recurrenceRule: getField(item, fields.recurrenceRule),
    weekStart
  });
  if (!rrule.start) {
    const start = getField(item, fields.start);
    rrule.start = ZonedDate.fromLocalDate(start, timezone);
  }
  if (!rrule.end) {
    const end = getField(item, fields.end);
    rrule.end = ZonedDate.fromLocalDate(end, timezone);
  }
  const exceptions = getField(item, fields.recurrenceExceptions);
  if (exceptions) {
    rrule.exceptionDates = exceptions.map((exDate) => ZonedDate.fromLocalDate(exDate, timezone));
  }
  const utcRangeStart = toUTCDateTime2(range3.start);
  const utcRangeEnd = toUTCDateTime2(range3.end);
  const series = expand(rrule, {
    rangeStart: ZonedDate.fromUTCDate(utcRangeStart, timezone),
    rangeEnd: ZonedDate.fromUTCDate(utcRangeEnd, timezone)
  });
  if (!series.events.length) {
    return [];
  }
  const expanded = series.events.map((occ) => {
    const event2 = clone(item);
    setField(event2, fields.id, OCCURRENCE_ID);
    setField(event2, fields.recurrenceId, getField(item, fields.id));
    setField(event2, fields.start, occ.start.toLocalDate());
    setField(event2, fields.end, occ.end.toLocalDate());
    return event2;
  });
  return [item, ...expanded];
};
var DataBindingDirective = class _DataBindingDirective {
  scheduler;
  changeDetector;
  intl;
  localDataChangesService;
  /**
   * The array of data which will populate the Scheduler.
   */
  set data(value2) {
    this.originalData = value2 || [];
    if (this.localDataChangesService) {
      this.localDataChangesService.data = value2;
    }
    this.scheduler.events = this.process();
  }
  dateRange;
  originalData = [];
  subscription;
  dataChangedSubscription;
  constructor(scheduler, changeDetector, intl, localDataChangesService) {
    this.scheduler = scheduler;
    this.changeDetector = changeDetector;
    this.intl = intl;
    this.localDataChangesService = localDataChangesService;
    if (localDataChangesService) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));
    }
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscription = this.scheduler.dateChange.subscribe((e) => this.onDateChange(e));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  rebind() {
    this.data = this.originalData;
    this.changeDetector.markForCheck();
  }
  process() {
    if (!this.dateRange) {
      return [];
    }
    const data = [];
    const fields = this.scheduler.modelFields;
    this.originalData.forEach((item) => {
      if (getField(item, fields.recurrenceRule)) {
        const series = occurrences(item, fields, this.dateRange, this.scheduler.timezone, this.scheduler.weekStart);
        data.push(...series);
      } else {
        data.push(item);
      }
    });
    return data;
  }
  onDateChange(e) {
    this.dateRange = e.dateRange;
    this.rebind();
  }
  static ɵfac = function DataBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataBindingDirective)(ɵɵdirectiveInject(SchedulerComponent), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DataBindingDirective,
    selectors: [["", "kendoSchedulerBinding", ""]],
    inputs: {
      data: [0, "kendoSchedulerBinding", "data"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: SchedulerComponent
    }, {
      type: ChangeDetectorRef
    }, {
      type: IntlService
    }, {
      type: LocalDataChangesService
    }];
  }, {
    data: [{
      type: Input,
      args: ["kendoSchedulerBinding"]
    }]
  });
})();
var SchedulerCustomMessagesComponent = class _SchedulerCustomMessagesComponent extends Messages3 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function SchedulerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SchedulerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SchedulerCustomMessagesComponent,
    selectors: [["kendo-scheduler-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages3,
      useExisting: forwardRef(() => _SchedulerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function SchedulerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchedulerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages3,
        useExisting: forwardRef(() => SchedulerCustomMessagesComponent)
      }],
      selector: "kendo-scheduler-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PDFCommandDirective = class _PDFCommandDirective extends ButtonComponent {
  pdfService;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.pdfService.exportClick.emit();
  }
  constructor(pdfService, element, renderer, localization, ngZone) {
    super(element, renderer, null, localization, ngZone);
    this.pdfService = pdfService;
  }
  ngOnInit() {
    this.icon = "pdf";
    this.svgIcon = filePdfIcon;
  }
  static ɵfac = function PDFCommandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFCommandDirective)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFCommandDirective,
    selectors: [["", "kendoSchedulerPDFCommand", ""]],
    hostBindings: function PDFCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function PDFCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c122,
    ngContentSelectors: _c132,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function PDFCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, PDFCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, PDFCommandDirective_span_1_Template, 2, 1, "span", 1)(2, PDFCommandDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoSchedulerPDFCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: PDFService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var createElement = (tagName, className) => {
  const element = document.createElement(tagName);
  if (className) {
    element.className = className;
  }
  return element;
};
var createDiv = (className) => createElement("div", className);
var PDFComponent = class _PDFComponent {
  pdfService;
  ngZone;
  /**
   * The author (metadata) of the PDF document.
   */
  author;
  /**
   * A flag that indicates whether to produce actual hyperlinks in the exported PDF file.
   * It is also possible to set a CSS selector. All matching links will be ignored.
   */
  avoidLinks;
  /**
   * The creator of the PDF document.
   * @default 'Kendo UI PDF Generator'
   */
  creator = "Kendo UI PDF Generator";
  /**
   * The date when the PDF document is created. Defaults to `new Date()`.
   */
  date;
  /**
   * The forced resolution of the images in the exported PDF document.
   * By default, the images are exported at their full resolution.
   */
  imageResolution;
  /**
   * Specifies the name of the exported PDF file.
   */
  fileName;
  /**
   * If set to `true`, the content is forwarded to `proxyURL` even if the
   * browser supports local saving of files.
   */
  forceProxy;
  /**
   * The keywords (metadata) of the PDF document.
   */
  keywords;
  /**
   * Specifies the margins of the page.
   * @default 'pt'
   */
  margin;
  /**
   * A scale factor. The text size on the screen might be too big for printing.
   * To scale down the output in PDF, use this option.
   * @default 1
   */
  scale;
  /**
   * A key/value dictionary of form values which will be sent to the proxy.
   * Can be used to submit Anti-Forgery tokens and other metadata.
   */
  proxyData;
  /**
   * The URL of the server-side proxy which streams the file to the end user. You need to use a proxy if
   * the browser is not capable of saving files locally&mdash;for example, Internet Explorer 9 and Safari.
   * It is your responsibility to implement the server-side proxy. The proxy returns the decoded file with
   * the `"Content-Disposition"` header set to `attachment; filename="<fileName.pdf>"`.
   *
   * In the request body, the proxy receives a POST request with the following parameters:
   * - `"contentType"`&mdash;The MIME type of the file.
   * - `"base64"`&mdash;The base-64 encoded file content.
   * - `"fileName"`&mdash;The file name, as requested by the caller.
   *
   */
  proxyURL;
  /**
   * A name or keyword which indicates where to display the document that is
   * returned from the proxy.
   *
   * To display the document in a new window or iframe, the proxy has to have the
   * `"Content-Disposition"` header set to `inline; filename="<fileName.pdf>"`.
   * @default '_self'
   */
  proxyTarget;
  /**
   * The producer (metadata) of the PDF document.
   */
  producer;
  /**
   * The subject (metadata) of the PDF document.
   */
  subject;
  /**
   * The title (metadata) of the PDF document.
   */
  title;
  subscriptions;
  container;
  constructor(pdfService, ngZone) {
    this.pdfService = pdfService;
    this.ngZone = ngZone;
    this.subscriptions = this.pdfService.elementReady.subscribe(this.createElement.bind(this));
    this.saveDataUri = this.saveDataUri.bind(this);
    this.exportGroup = this.exportGroup.bind(this);
    this.done = this.done.bind(this);
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get drawOptions() {
    return {
      _destructive: true,
      avoidLinks: this.avoidLinks,
      margin: this.margin,
      scale: this.scale
    };
  }
  get pdfOptions() {
    return {
      author: this.author,
      creator: this.creator,
      date: this.date,
      imgDPI: this.imageResolution,
      keywords: this.keywords,
      margin: this.margin,
      producer: this.producer,
      subject: this.subject,
      title: this.title
    };
  }
  get saveOptions() {
    return {
      forceProxy: this.forceProxy,
      proxyData: this.proxyData,
      proxyTarget: this.proxyTarget,
      proxyURL: this.proxyURL
    };
  }
  createElement(args) {
    this.ngZone.runOutsideAngular(() => {
      const container = this.container = createDiv();
      container.style.top = container.style.left = "-10000px";
      container.style.position = "absolute";
      const wrapper = createDiv("k-scheduler");
      wrapper.style.position = "relative";
      wrapper.appendChild(args.element);
      container.appendChild(wrapper);
      document.body.appendChild(container);
      this.save(wrapper);
    });
  }
  save(element) {
    this.drawElement(element, this.drawOptions).then(this.exportGroup).then(this.saveDataUri).then(this.done, this.done);
  }
  drawElement(element, options) {
    return drawDOM(element, options);
  }
  exportGroup(group3) {
    return exportPDF(group3, this.pdfOptions);
  }
  saveDataUri(dataUri) {
    saveAs(dataUri, this.fileName, this.saveOptions);
  }
  done() {
    if (this.container) {
      document.body.removeChild(this.container);
      this.container = null;
    }
    this.pdfService.done.emit();
  }
  static ɵfac = function PDFComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFComponent)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFComponent,
    selectors: [["kendo-scheduler-pdf"]],
    inputs: {
      author: "author",
      avoidLinks: "avoidLinks",
      creator: "creator",
      date: "date",
      imageResolution: "imageResolution",
      fileName: "fileName",
      forceProxy: "forceProxy",
      keywords: "keywords",
      margin: "margin",
      scale: "scale",
      proxyData: "proxyData",
      proxyURL: "proxyURL",
      proxyTarget: "proxyTarget",
      producer: "producer",
      subject: "subject",
      title: "title"
    },
    decls: 0,
    vars: 0,
    template: function PDFComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFComponent, [{
    type: Component,
    args: [{
      selector: "kendo-scheduler-pdf",
      template: "",
      standalone: true
    }]
  }], function() {
    return [{
      type: PDFService
    }, {
      type: NgZone
    }];
  }, {
    author: [{
      type: Input
    }],
    avoidLinks: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    imageResolution: [{
      type: Input
    }],
    fileName: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    keywords: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    proxyData: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    proxyTarget: [{
      type: Input
    }],
    producer: [{
      type: Input
    }],
    subject: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var SlotSelectableDirective = class _SlotSelectableDirective {
  scheduler;
  cdr;
  /**
   * The currently selected slot range.
   */
  slotSelection;
  /**
   * Fires when the currently selected slot range has changed through user interaction.
   */
  slotSelectionChange = new EventEmitter();
  /**
   * @hidden
   * The resources of the cell where the selection started.
   * When dragging over the slots of a different resource in grouped mode, the ongoing selection will not be affected.
   */
  selectionOriginResources;
  selectedRange = null;
  slotSelectionChangeSource = new EventEmitter();
  subscriptions = new Subscription();
  constructor(scheduler, cdr) {
    this.scheduler = scheduler;
    this.cdr = cdr;
    this.scheduler.selectable = true;
    this.subscriptions.add(this.slotSelectionChangeSource.pipe(distinctUntilChanged(isSameRange)).subscribe((v) => {
      this.slotSelectionChange.emit(v);
    }));
    const start$ = this.scheduler.slotDragStart;
    const drag$ = this.scheduler.slotDrag;
    const end$ = this.scheduler.slotDragEnd;
    const startSource = start$.pipe(filter((e) => !e.isDefaultPrevented()));
    this.subscriptions.add(startSource.subscribe((e) => this.initDragSelect(e)));
    this.subscriptions.add(drag$.subscribe((e) => this.onDrag(e)));
    this.subscriptions.add(end$.subscribe(() => this.onRelease()));
  }
  ngOnInit() {
    this.scheduler.isSlotSelected = this.isSlotSelected.bind(this);
  }
  ngOnChanges(changes) {
    if (isChanged("slotSelection", changes, false)) {
      const defaults = {
        isAllDay: false,
        resources: this.scheduler?.resources ? this.scheduler.resources.reduce((result, resource) => {
          result.push(...resource.data);
          return result;
        }, []) : []
      };
      this.selectedRange = Object.assign(defaults, changes["slotSelection"].currentValue);
      this.cdr.markForCheck();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  isSlotSelected({
    start,
    end,
    isAllDay,
    resources
  }) {
    if (!start || !end || !this.selectedRange) {
      return false;
    }
    const match = resourcesMatch(this.selectedRange.resources, resources);
    if (!match) {
      return false;
    }
    return this.selectedRange && isAllDay === this.selectedRange.isAllDay && this.isInRange(start, end);
  }
  initDragSelect({
    start,
    end,
    isAllDay,
    resources
  }) {
    this.selectionOriginResources = resources.slice();
    this.selectedRange = {
      start,
      end,
      isAllDay,
      resources: resources.slice()
    };
    this.cdr.markForCheck();
  }
  onDrag({
    start,
    end,
    resources
  }) {
    const match = resourcesMatch(this.selectionOriginResources, resources);
    if (!match) {
      return;
    }
    this.selectedRange.start = start;
    this.selectedRange.end = end;
    this.cdr.markForCheck();
  }
  onRelease() {
    this.selectionOriginResources = null;
    if (this.selectedRange) {
      this.slotSelectionChangeSource.emit(this.selectedRange);
    }
  }
  /**
   * @hidden
   * Checks if the selected range contains a local date range.
   */
  isInRange(start, end) {
    if (!this.selectedRange) {
      return;
    }
    return intersects(start, end, this.selectedRange.start, this.selectedRange.end);
  }
  static ɵfac = function SlotSelectableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SlotSelectableDirective)(ɵɵdirectiveInject(SchedulerComponent), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SlotSelectableDirective,
    selectors: [["", "kendoSchedulerSlotSelectable", ""]],
    inputs: {
      slotSelection: "slotSelection"
    },
    outputs: {
      slotSelectionChange: "slotSelectionChange"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SlotSelectableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerSlotSelectable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: SchedulerComponent
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    slotSelection: [{
      type: Input
    }],
    slotSelectionChange: [{
      type: Output
    }]
  });
})();
var SchedulerViewDirective = class _SchedulerViewDirective extends SchedulerView {
  template;
  /**
   * The user-friendly name of this view.
   */
  title;
  /**
   * The invariant name for this view. For example, `day`.
   * If not set, the name will be the same as the title.
   */
  get name() {
    return this._name || this.title;
  }
  set name(value2) {
    this._name = value2;
  }
  _name;
  constructor(template) {
    super();
    this.template = template;
  }
  static ɵfac = function SchedulerViewDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SchedulerViewDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SchedulerViewDirective,
    selectors: [["", "kendoSchedulerView", ""]],
    inputs: {
      title: [0, "kendoSchedulerView", "title"],
      name: [0, "kendoSchedulerViewName", "name"]
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _SchedulerViewDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchedulerViewDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => SchedulerViewDirective)
      }],
      selector: "[kendoSchedulerView]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, {
    title: [{
      type: Input,
      args: ["kendoSchedulerView"]
    }],
    name: [{
      type: Input,
      args: ["kendoSchedulerViewName"]
    }]
  });
})();
var defaultSlotClass = (_args) => null;
var ConfigurationViewBase = class _ConfigurationViewBase extends SchedulerView {
  localization;
  changeDetector;
  viewContext;
  viewState;
  /**
   * Defines a function that is executed for every slot in the view.
   * The function returns a value which is supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']) [see example](slug:styling_scheduler#toc-styling-the-slots).
   */
  slotClass;
  /**
   * Defines a function that is executed for every event in the view.
   * The function returns a value which is supported by [`ngClass`](link:site.data.urls.angular['ngclassapi']).
   */
  eventClass;
  /**
   * Defines a function that is executed for every event in the view.
   * The function returns a value which is supported by [`ngStyle`](link:site.data.urls.angular['ngstyleapi']).
   */
  eventStyles;
  /**
   * Specifies the settings for the ongoing events highlight of the Scheduler.
   */
  highlightOngoingEvents;
  /**
   * Specifies whether to display the toolbar of the Scheduler.
   */
  get showToolbar() {
    return this._showToolbar;
  }
  set showToolbar(value2) {
    this._showToolbar = value2;
    this.viewState.toolbarVisibilityByView.set(this, value2);
  }
  /**
   * @hidden
   */
  template;
  /**
   * @hidden
   */
  eventTemplate;
  /**
   * @hidden
   */
  groupHeaderTemplate;
  /**
   * @hidden
   */
  get viewSlotClass() {
    return isPresent4(this.slotClass) ? this.slotClass : this.schedulerOptions.slotClass || defaultSlotClass;
  }
  /**
   * @hidden
   */
  get viewEventClass() {
    return isPresent4(this.eventClass) ? this.eventClass : this.schedulerOptions.eventClass;
  }
  /**
   * @hidden
   */
  get viewEventStyles() {
    return isPresent4(this.eventStyles) ? this.eventStyles : this.schedulerOptions.eventStyles;
  }
  /**
   * @hidden
   */
  get viewHighlightOngoingEvents() {
    return isPresent4(this.highlightOngoingEvents) ? this.highlightOngoingEvents : this.schedulerOptions.highlightOngoingEvents;
  }
  /**
   * @hidden
   */
  get viewWeekStart() {
    return this.schedulerOptions.weekStart;
  }
  subs;
  schedulerOptions = {};
  constructor(localization, changeDetector, viewContext, viewState) {
    super();
    this.localization = localization;
    this.changeDetector = changeDetector;
    this.viewContext = viewContext;
    this.viewState = viewState;
    this.subs = this.localization.changes.subscribe(() => {
      changeDetector.markForCheck();
    });
    this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
  }
  ngOnChanges(changes) {
    this.viewState.notifyOptionsChange(changes);
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    this.viewState.toolbarVisibilityByView.delete(this);
  }
  optionsChange(options) {
    this.schedulerOptions = options;
  }
  _showToolbar;
  static ɵfac = function ConfigurationViewBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConfigurationViewBase)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ConfigurationViewBase,
    contentQueries: function ConfigurationViewBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, EventTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.eventTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
      }
    },
    viewQuery: function ConfigurationViewBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c142, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      }
    },
    inputs: {
      slotClass: "slotClass",
      eventClass: "eventClass",
      eventStyles: "eventStyles",
      highlightOngoingEvents: "highlightOngoingEvents",
      showToolbar: "showToolbar"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurationViewBase, [{
    type: Directive
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    slotClass: [{
      type: Input
    }],
    eventClass: [{
      type: Input
    }],
    eventStyles: [{
      type: Input
    }],
    highlightOngoingEvents: [{
      type: Input
    }],
    showToolbar: [{
      type: Input
    }],
    template: [{
      type: ViewChild,
      args: ["content", {
        static: true
      }]
    }],
    eventTemplate: [{
      type: ContentChild,
      args: [EventTemplateDirective, {
        static: false
      }]
    }],
    groupHeaderTemplate: [{
      type: ContentChild,
      args: [GroupHeaderTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var flip = (fn) => (a) => (b) => fn(b, a);
var sort2 = flip(orderBy);
var group2 = flip(groupBy);
var compose2 = (...args) => (data) => args.reduceRight((acc, curr) => curr(acc), data);
var processEvents = (_start, _end) => compose2(group2([{
  field: "startDate"
}]), sort2([{
  field: "start",
  dir: "asc"
}, {
  field: "end",
  dir: "asc"
}]));
function flattenGroupsAndAddIds(scope) {
  return function* flattenGroups(groups) {
    for (let index = 0; index < groups.length; index++) {
      const groupItem = groups[index];
      yield {
        type: "group",
        dataItem: groupItem,
        rowSpan: groupItem.items.length,
        elementId: `k-scheduler-${scope.counter}-${index}`
      };
      for (let itemIndex = 1; itemIndex < groupItem.items.length; itemIndex++) {
        const item = groupItem.items[itemIndex];
        yield {
          type: "event",
          dataItem: item,
          elementId: `k-scheduler-${scope.counter}-${index}-item-${itemIndex}`
        };
      }
    }
  };
}
var EmptyIterator = class {
  [iterator]() {
    return {
      next: () => ({
        done: true,
        value: null
      })
    };
  }
  toString() {
    return "Empty Iterator";
  }
};
var seed = 0;
var TaskCollection = class {
  start;
  end;
  events;
  counter;
  // used to give unique ids to event elements
  static empty() {
    return new EmptyIterator();
  }
  constructor(start, end, events) {
    this.start = start;
    this.end = end;
    this.events = events;
    this.counter = seed;
    seed++;
  }
  createIterator = compose2(flattenGroupsAndAddIds(this), processEvents(this.start, this.end));
  [iterator]() {
    return this.createIterator(this.events);
  }
  itemAt(index) {
    const taskIterator = this.createIterator(this.events);
    let idx2 = 0;
    let item;
    do {
      item = taskIterator.next();
      if (item && idx2 === index) {
        const value2 = item.value;
        return value2.type === "group" ? value2.dataItem.items[0] : value2.dataItem;
      }
      idx2++;
    } while (item);
  }
  toString() {
    return this.events.toString();
  }
};
function createResourceGroups(groupedResources) {
  let result = [];
  const firstResource = groupedResources[0];
  const firstResourceData = firstResource.data;
  for (let dataIdx = 0; dataIdx < firstResourceData.length; dataIdx++) {
    const item = firstResourceData[dataIdx];
    result.push({
      resources: [getField(item, firstResource.textField)]
    });
  }
  for (let idx2 = 1; idx2 < groupedResources.length; idx2++) {
    const resource = groupedResources[idx2];
    const data = resource.data;
    const current = [];
    for (let resourceIdx = 0; resourceIdx < result.length; resourceIdx++) {
      const resourceItem2 = result[resourceIdx];
      for (let dataIdx = 0; dataIdx < data.length; dataIdx++) {
        const item = data[dataIdx];
        current.push({
          resources: resourceItem2.resources.concat(getField(item, resource.textField))
        });
      }
    }
    result = current;
  }
  return result;
}
function createTask(item, resourceIdx, resources, color) {
  const event2 = item.event;
  return {
    event: event2,
    start: item.start.toUTCDate(),
    end: item.end.toUTCDate(),
    title: event2.title,
    isAllDay: event2.isAllDay,
    color,
    resourceIdx,
    resources
  };
}
var durationInDays = ({
  start,
  end,
  isAllDay = false
}) => {
  const eventEnd = isAllDay ? getUTCDate(end) : end;
  const duration2 = Math.ceil((eventEnd - +getUTCDate(start)) / MS_PER_DAY);
  if (isAllDay && duration2 > 0 && !endsAtMidnight(end)) {
    return duration2 + 1;
  }
  return duration2;
};
var endsAtMidnight = (end) => {
  end = toLocalDate(end);
  return end.getHours() === 0 && end.getMinutes() === 0 && end.getSeconds() === 0 && end.getMilliseconds() === 0;
};
var curry = (fn) => {
  const len = fn.length;
  return (...args) => len === args.length ? fn(...args) : curry(fn.bind(null, ...args));
};
var range2 = (num) => Array.from(new Array(num).keys());
var cloneTask = (eventStart, eventEnd) => (task) => __spreadProps(__spreadValues({}, task), {
  start: getUTCDate(eventStart),
  end: task.tail && !task.isAllDay ? eventEnd : addUTCDays(eventStart, 1),
  startDate: getUTCDate(eventStart)
});
var previousEventEnd = (start, events) => events.length ? events[events.length - 1].end : start;
var markAsTail = (isLast) => (task) => {
  if (isLast) {
    task.tail = true;
  }
  return task;
};
var markAsMid = (task) => {
  if (!task.tail) {
    task.mid = true;
  }
  return task;
};
var addTaskPart = (task, start) => (tasks, _, day, days) => tasks.concat(compose2(markAsMid, cloneTask(previousEventEnd(start, tasks), task.end), markAsTail(day === days.length - 1))(task));
var splitMultiDayTask = (task, start) => range2(durationInDays(task) - 1).reduce(addTaskPart(task, start), []);
var splitTasks = curry((periodStart, periodEnd, tasks) => {
  const result = [];
  for (let index = 0; index < tasks.length; index++) {
    const task = __spreadValues({}, tasks[index]);
    task.startDate = getUTCDate(task.start);
    if (task.start >= periodStart && task.start <= periodEnd) {
      result.push(task);
    }
    if (durationInDays(task) > 1) {
      task.end = addUTCDays(task.startDate, 1);
      task.head = true;
      result.push(...splitMultiDayTask(__spreadValues({}, tasks[index]), task.end).filter((tsk) => getUTCDate(tsk.end) <= periodEnd && tsk.start >= periodStart));
    }
  }
  return result;
});
function groupByResource(groupedResources, resourceGroups, dateRange) {
  const groups = resourceGroups.filter((group3) => group3.tasks && group3.tasks.length);
  if (!groups.length) {
    return [];
  }
  const values = groups[0].resources.map((resource) => ({
    value: resource,
    span: 0,
    groupIdx: 0
  }));
  const periodStart = toUTCDate(dateRange.start);
  const periodEnd = toUTCDate(dateRange.end);
  for (let groupIdx = 0; groupIdx < groups.length; groupIdx++) {
    const group3 = groups[groupIdx];
    group3.tasks = splitTasks(periodStart, periodEnd, group3.tasks);
    const count = group3.tasks.length;
    group3.tasks = new TaskCollection(periodStart, periodEnd, group3.tasks);
    let invalidate = false;
    for (let resourceIdx = 0; resourceIdx < groupedResources.length; resourceIdx++) {
      const resourceValue = values[resourceIdx];
      if (resourceValue.value !== group3.resources[resourceIdx] || invalidate) {
        resourceValue.value = group3.resources[resourceIdx];
        const spanGroup = groups[resourceValue.groupIdx];
        spanGroup.spans = spanGroup.spans || [];
        spanGroup.spans[resourceIdx] = resourceValue.span;
        resourceValue.span = count;
        resourceValue.groupIdx = groupIdx;
        invalidate = true;
      } else {
        resourceValue.span += count;
      }
    }
  }
  values.forEach((value2, index) => {
    const group3 = groups[value2.groupIdx];
    group3.spans = group3.spans || [];
    group3.spans[index] = value2.span;
  });
  return groups;
}
function groupEvents(items, {
  taskResources,
  resourceGroups,
  spans,
  allResources,
  dateRange
}) {
  const groups = resourceGroups || [{}];
  const periodStart = toUTCDate(dateRange.start);
  const periodEnd = toUTCDate(dateRange.end);
  for (let idx2 = 0; idx2 < items.length; idx2++) {
    const item = items[idx2];
    const event2 = item.event;
    if (!intersects(item.start.toUTCDate(), item.end.toUTCDate(), periodStart, periodEnd)) {
      continue;
    }
    const resources = eventResources(event2, {
      taskResources,
      hasGroups: resourceGroups && resourceGroups.length > 0,
      spans,
      allResources
    });
    if (resources.length && resources[0].leafIdx >= 0) {
      for (let resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {
        const current = resources[resourceIdx];
        const task = createTask(item, current.leafIdx, current.resources, current.color);
        const tasks = groups[current.leafIdx].tasks = groups[current.leafIdx].tasks || [];
        tasks.push(task);
      }
    }
  }
  if (resourceGroups) {
    return groupByResource(taskResources, groups, dateRange);
  }
  groups[0].tasks = new TaskCollection(periodStart, periodEnd, splitTasks(periodStart, periodEnd, groups[0].tasks || []));
  return groups;
}
var AgendaTaskItemComponent = class _AgendaTaskItemComponent {
  localization;
  localeId;
  arrowRotateCWIcon = arrowRotateCwIcon;
  arrowsNoRepeatIcon = arrowsNoRepeatIcon;
  xIcon = xIcon;
  item;
  color;
  eventTemplate;
  editable;
  cellClass = true;
  get eventTitle() {
    const start = toLocalDate(this.item.start);
    const end = toLocalDate(this.item.end);
    const time = formatEventTime(start, end, this.item.isAllDay, this.localeId);
    return `${time}, ${this.item.event.title}`;
  }
  get eventColor() {
    return this.item.color;
  }
  get deleteMessage() {
    return this.localization.get("deleteTitle");
  }
  get isRecurrence() {
    return isRecurrence(this.item);
  }
  get isRecurrenceException() {
    return isRecurrenceException(this.item);
  }
  get removable() {
    return this.editable && this.editable.remove !== false;
  }
  constructor(localization, localeId) {
    this.localization = localization;
    this.localeId = localeId;
  }
  static ɵfac = function AgendaTaskItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AgendaTaskItemComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(LOCALE_ID));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AgendaTaskItemComponent,
    selectors: [["", "kendoSchedulerAgendaTaskItem", ""]],
    hostVars: 3,
    hostBindings: function AgendaTaskItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-label", ctx.eventTitle);
        ɵɵclassProp("k-scheduler-cell", ctx.cellClass);
      }
    },
    inputs: {
      item: [0, "kendoSchedulerAgendaTaskItem", "item"],
      color: "color",
      eventTemplate: "eventTemplate",
      editable: "editable"
    },
    attrs: _c152,
    decls: 7,
    vars: 7,
    consts: [[1, "k-task", 3, "title"], ["class", "k-scheduler-mark", 3, "background-color", 4, "ngIf"], ["name", "arrow-rotate-cw", 3, "svgIcon", 4, "ngIf"], ["name", "arrows-no-repeat", 3, "svgIcon", 4, "ngIf"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], ["class", "k-link k-event-delete", "aria-hidden", "true", 4, "ngIf"], [1, "k-scheduler-mark"], ["name", "arrow-rotate-cw", 3, "svgIcon"], ["name", "arrows-no-repeat", 3, "svgIcon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["aria-hidden", "true", 1, "k-link", "k-event-delete"], ["name", "x", 3, "svgIcon"]],
    template: function AgendaTaskItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, AgendaTaskItemComponent_span_1_Template, 1, 2, "span", 1)(2, AgendaTaskItemComponent_kendo_icon_wrapper_2_Template, 1, 1, "kendo-icon-wrapper", 2)(3, AgendaTaskItemComponent_kendo_icon_wrapper_3_Template, 1, 1, "kendo-icon-wrapper", 3)(4, AgendaTaskItemComponent_ng_container_4_Template, 2, 1, "ng-container", 4)(5, AgendaTaskItemComponent_ng_container_5_Template, 1, 6, "ng-container", 5)(6, AgendaTaskItemComponent_span_6_Template, 2, 2, "span", 6);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("title", ctx.item.title);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.eventColor);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isRecurrence);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isRecurrenceException);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.eventTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.eventTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.removable);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AgendaTaskItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoSchedulerAgendaTaskItem]",
      template: `
        <div class="k-task" [title]="item.title">
            <span class="k-scheduler-mark" *ngIf="eventColor" [style.background-color]="eventColor"></span>
            <kendo-icon-wrapper *ngIf="isRecurrence" name="arrow-rotate-cw" [svgIcon]="arrowRotateCWIcon"></kendo-icon-wrapper>

            <kendo-icon-wrapper *ngIf="isRecurrenceException" name="arrows-no-repeat" [svgIcon]="arrowsNoRepeatIcon"></kendo-icon-wrapper>
            <ng-container *ngIf="!eventTemplate">
                {{item?.title }}
            </ng-container>
            <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
                [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: item.resources }">
            </ng-container>

            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
        </div>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, {
    item: [{
      type: Input,
      args: ["kendoSchedulerAgendaTaskItem"]
    }],
    color: [{
      type: Input
    }],
    eventTemplate: [{
      type: Input
    }],
    editable: [{
      type: Input
    }],
    cellClass: [{
      type: HostBinding,
      args: ["class.k-scheduler-cell"]
    }],
    eventTitle: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }]
  });
})();
var AgendaHeaderItemComponent = class _AgendaHeaderItemComponent {
  classes = true;
  get firstClass() {
    return this.hasFirstClass;
  }
  roleAttribute = "rowheader";
  get rowSpan() {
    return this.item.rowSpan;
  }
  item;
  agendaDateTemplate;
  hasFirstClass = true;
  get itemDate() {
    return toLocalDate(this.item.dataItem.value);
  }
  static ɵfac = function AgendaHeaderItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AgendaHeaderItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AgendaHeaderItemComponent,
    selectors: [["", "kendoSchedulerAgendaHeaderItem", ""]],
    hostVars: 8,
    hostBindings: function AgendaHeaderItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.roleAttribute)("rowspan", ctx.rowSpan);
        ɵɵclassProp("k-scheduler-datecolumn", ctx.classes)("k-scheduler-cell", ctx.classes)("k-first", ctx.firstClass);
      }
    },
    inputs: {
      item: [0, "kendoSchedulerAgendaHeaderItem", "item"],
      agendaDateTemplate: "agendaDateTemplate",
      hasFirstClass: "hasFirstClass"
    },
    attrs: _c172,
    decls: 2,
    vars: 2,
    consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [1, "k-scheduler-agendaday"], [1, "k-scheduler-agendaweek"], [1, "k-scheduler-agendadate"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function AgendaHeaderItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, AgendaHeaderItemComponent_ng_container_0_Template, 10, 12, "ng-container", 0)(1, AgendaHeaderItemComponent_ng_container_1_Template, 1, 4, "ng-container", 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.agendaDateTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.agendaDateTemplate);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, DatePipe],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AgendaHeaderItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoSchedulerAgendaHeaderItem]",
      template: `
        <ng-container *ngIf="!agendaDateTemplate">
            <strong class="k-scheduler-agendaday">{{itemDate | kendoDate: 'dd'}}</strong>
            <em class="k-scheduler-agendaweek">{{itemDate | kendoDate: 'EEEE'}}</em>
            <span class="k-scheduler-agendadate">{{itemDate | kendoDate: 'y'}}</span>
        </ng-container>
        <ng-container *ngIf="agendaDateTemplate" [ngTemplateOutlet]="agendaDateTemplate"
            [ngTemplateOutletContext]="{ date: itemDate }">
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, DatePipe]
    }]
  }], null, {
    classes: [{
      type: HostBinding,
      args: ["class.k-scheduler-datecolumn"]
    }, {
      type: HostBinding,
      args: ["class.k-scheduler-cell"]
    }],
    firstClass: [{
      type: HostBinding,
      args: ["class.k-first"]
    }],
    roleAttribute: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    rowSpan: [{
      type: HostBinding,
      args: ["attr.rowspan"]
    }],
    item: [{
      type: Input,
      args: ["kendoSchedulerAgendaHeaderItem"]
    }],
    agendaDateTemplate: [{
      type: Input
    }],
    hasFirstClass: [{
      type: Input
    }]
  });
})();
var AgendaListComponent = class _AgendaListComponent {
  intlService;
  localization;
  classes = true;
  tasks;
  eventTemplate;
  slotClass;
  eventClass;
  eventStyles;
  agendaTimeTemplate;
  agendaDateTemplate;
  editable;
  caretAltLeftIcon = caretAltLeftIcon;
  caretAltRightIcon = caretAltRightIcon;
  constructor(intlService, localization) {
    this.intlService = intlService;
    this.localization = localization;
  }
  extractDataItem(item) {
    return item.type === "group" ? item.dataItem.items[0] : item.dataItem;
  }
  extractDataItemInLocalTime(item) {
    let currentItem;
    if (item.type === "group") {
      currentItem = __spreadValues({}, item.dataItem.items[0]);
      currentItem.start = toLocalDate(item.dataItem.items[0].start);
      currentItem.end = toLocalDate(item.dataItem.items[0].end);
    } else {
      currentItem = __spreadValues({}, item.dataItem);
      currentItem.start = toLocalDate(item.dataItem.start);
      currentItem.end = toLocalDate(item.dataItem.end);
    }
    return currentItem;
  }
  formatTime(dataItem) {
    if (dataItem.isAllDay) {
      return this.localization.get("allDay");
    }
    let format = "{0:t}-{1:t}";
    if (dataItem.head) {
      format = "{0:t}";
    } else if (dataItem.tail) {
      format = "{1:t}";
    }
    return this.intlService.format(format, toLocalDate(dataItem.start), toLocalDate(dataItem.end));
  }
  trackByFn(index, _item) {
    return index;
  }
  cellClasses(item) {
    const task = this.extractDataItem(item);
    let result = [];
    if (this.slotClass) {
      result = result.concat(convertNgClassBindings(this.slotClass({
        start: task.start,
        end: task.end,
        resources: task.resources,
        event: task.event
      })));
    }
    if (this.eventClass) {
      result = result.concat(convertNgClassBindings(this.eventClass({
        event: task.event,
        resources: task.resources
      })));
    }
    return result;
  }
  getEventStyles(item) {
    if (this.eventStyles) {
      const task = this.extractDataItem(item);
      return this.eventStyles({
        event: task.event,
        resources: task.resources
      });
    }
  }
  get arrowIcons() {
    return !this.localization.rtl ? ["caret-alt-left", "caret-alt-right"] : ["caret-alt-right", "caret-alt-left"];
  }
  get arrowSVGIcons() {
    return !this.localization.rtl ? [this.caretAltLeftIcon, this.caretAltRightIcon] : [this.caretAltRightIcon, this.caretAltLeftIcon];
  }
  static ɵfac = function AgendaListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AgendaListComponent)(ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AgendaListComponent,
    selectors: [["", "kendoSchedulerAgendaList", ""]],
    hostVars: 2,
    hostBindings: function AgendaListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-scheduler-content", ctx.classes);
      }
    },
    inputs: {
      tasks: "tasks",
      eventTemplate: "eventTemplate",
      slotClass: "slotClass",
      eventClass: "eventClass",
      eventStyles: "eventStyles",
      agendaTimeTemplate: "agendaTimeTemplate",
      agendaDateTemplate: "agendaDateTemplate",
      editable: "editable"
    },
    attrs: _c192,
    decls: 3,
    vars: 1,
    consts: [["role", "none", 1, "k-scheduler-table"], ["role", "rowgroup"], [4, "ngFor", "ngForOf"], ["role", "row", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "row"], [3, "kendoSchedulerAgendaHeaderItem", "hasFirstClass", "agendaDateTemplate", 4, "ngIf"], ["role", "gridcell", 1, "k-scheduler-timecolumn", "k-scheduler-cell"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], ["role", "gridcell", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "kendoSchedulerAgendaTaskItem", "editable", "eventTemplate"], ["class", "k-scheduler-groupcolumn k-first", "role", "rowheader", 4, "ngIf"], ["role", "rowheader", 1, "k-scheduler-groupcolumn", "k-first"], [3, "kendoSchedulerAgendaHeaderItem", "hasFirstClass", "agendaDateTemplate"], [3, "name", "svgIcon", 4, "ngIf"], [3, "name", "svgIcon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function AgendaListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "table", 0)(1, "tbody", 1);
        ɵɵtemplate(2, AgendaListComponent_ng_container_2_Template, 2, 2, "ng-container", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.tasks);
      }
    },
    dependencies: [NgForOf, NgIf, AgendaHeaderItemComponent, IconWrapperComponent, NgTemplateOutlet, NgClass, NgStyle, FocusableDirective, AgendaTaskItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AgendaListComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoSchedulerAgendaList]",
      template: `
        <table class="k-scheduler-table" role="none">
            <tbody role="rowgroup">
                <ng-container *ngFor="let group of tasks; let groupIndex = index;">
                    <tr *ngFor="let item of group.tasks; let index = index; trackBy: trackByFn" role="row">
                        <ng-container *ngFor="let resource of group.resources; let resourceIndex = index">
                            <td *ngIf="group.spans[resourceIndex] && index === 0" class="k-scheduler-groupcolumn k-first" [attr.rowspan]="group.spans[resourceIndex]" role="rowheader">
                                {{ resource }}
                            </td>
                        </ng-container>
                        <td *ngIf="item.type === 'group'"
                            [kendoSchedulerAgendaHeaderItem]="item"
                            [hasFirstClass]="!group.resources || group.resources.length === 0"
                            [agendaDateTemplate]="agendaDateTemplate">
                        </td>
                        <td class="k-scheduler-timecolumn k-scheduler-cell" role="gridcell">
                            <div *ngIf="!agendaTimeTemplate">
                                <kendo-icon-wrapper
                                    *ngIf="extractDataItem(item).tail || extractDataItem(item).mid"
                                    [name]="arrowIcons[0]"
                                    [svgIcon]="arrowSVGIcons[0]"
                                    >
                                </kendo-icon-wrapper>

                                {{ formatTime(extractDataItem(item)) }}
                                <kendo-icon-wrapper
                                    *ngIf="extractDataItem(item).head || extractDataItem(item).mid"
                                    [name]="arrowIcons[1]"
                                    [svgIcon]="arrowSVGIcons[1]"
                                    >
                                </kendo-icon-wrapper>
                            </div>
                            <ng-container *ngIf="agendaTimeTemplate" [ngTemplateOutlet]="agendaTimeTemplate"
                                [ngTemplateOutletContext]="extractDataItemInLocalTime(item)">
                            </ng-container>
                        </td>
                        <td [attr.data-group-index]="groupIndex" [attr.data-task-index]="index" role="gridcell"
                            [ngClass]="cellClasses(item)" [ngStyle]="getEventStyles(item)"
                            [kendoSchedulerFocusIndex]="groupIndex"
                            [id]="item.elementId"
                            [kendoSchedulerAgendaTaskItem]="extractDataItem(item)"
                                [editable]="editable"
                                [eventTemplate]="eventTemplate"
                        ></td>
                    </tr>
                </ng-container>
            </tbody>
        </table>
    `,
      standalone: true,
      imports: [NgForOf, NgIf, AgendaHeaderItemComponent, IconWrapperComponent, NgTemplateOutlet, NgClass, NgStyle, FocusableDirective, AgendaTaskItemComponent]
    }]
  }], function() {
    return [{
      type: IntlService
    }, {
      type: LocalizationService
    }];
  }, {
    classes: [{
      type: HostBinding,
      args: ["class.k-scheduler-content"]
    }],
    tasks: [{
      type: Input
    }],
    eventTemplate: [{
      type: Input
    }],
    slotClass: [{
      type: Input
    }],
    eventClass: [{
      type: Input
    }],
    eventStyles: [{
      type: Input
    }],
    agendaTimeTemplate: [{
      type: Input
    }],
    agendaDateTemplate: [{
      type: Input
    }],
    editable: [{
      type: Input
    }]
  });
})();
var AgendaHeaderComponent = class _AgendaHeaderComponent {
  localization;
  classes = true;
  resources;
  get dateMessage() {
    return this.localization.get("dateHeader");
  }
  get timeMessage() {
    return this.localization.get("timeHeader");
  }
  get eventMessage() {
    return this.localization.get("eventHeader");
  }
  constructor(localization) {
    this.localization = localization;
  }
  static ɵfac = function AgendaHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AgendaHeaderComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AgendaHeaderComponent,
    selectors: [["", "kendoSchedulerAgendaHeader", ""]],
    hostVars: 2,
    hostBindings: function AgendaHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-scheduler-header", ctx.classes);
      }
    },
    inputs: {
      resources: "resources"
    },
    attrs: _c202,
    decls: 11,
    vars: 4,
    consts: [[1, "k-scheduler-header-wrap"], ["role", "none", 1, "k-scheduler-table"], ["role", "rowgroup"], ["role", "row"], ["class", "k-scheduler-groupcolumn k-first", "role", "columnheader", 4, "ngFor", "ngForOf"], ["role", "columnheader", 1, "k-scheduler-cell", "k-heading-cell", "k-scheduler-datecolumn"], ["role", "columnheader", 1, "k-scheduler-cell", "k-heading-cell", "k-scheduler-timecolumn"], ["role", "columnheader", 1, "k-scheduler-cell", "k-heading-cell"], ["role", "columnheader", 1, "k-scheduler-groupcolumn", "k-first"]],
    template: function AgendaHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "table", 1)(2, "tbody", 2)(3, "tr", 3);
        ɵɵtemplate(4, AgendaHeaderComponent_th_4_Template, 1, 0, "th", 4);
        ɵɵelementStart(5, "th", 5);
        ɵɵtext(6);
        ɵɵelementEnd();
        ɵɵelementStart(7, "th", 6);
        ɵɵtext(8);
        ɵɵelementEnd();
        ɵɵelementStart(9, "th", 7);
        ɵɵtext(10);
        ɵɵelementEnd()()()()();
      }
      if (rf & 2) {
        ɵɵadvance(4);
        ɵɵproperty("ngForOf", ctx.resources);
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.dateMessage);
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.timeMessage);
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.eventMessage);
      }
    },
    dependencies: [NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AgendaHeaderComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoSchedulerAgendaHeader]",
      template: `
        <div class="k-scheduler-header-wrap">
            <table class="k-scheduler-table" role="none">
                <tbody role="rowgroup">
                    <tr role="row">
                        <th *ngFor="let resource of resources" class="k-scheduler-groupcolumn k-first" role="columnheader"></th>
                        <th class="k-scheduler-cell k-heading-cell k-scheduler-datecolumn" role="columnheader">{{ dateMessage }}</th>
                        <th class="k-scheduler-cell k-heading-cell k-scheduler-timecolumn" role="columnheader">{{ timeMessage }}</th>
                        <th class="k-scheduler-cell k-heading-cell" role="columnheader">{{ eventMessage }}</th>
                    </tr>   
                </tbody>
            </table>
        </div>
    `,
      standalone: true,
      imports: [NgForOf]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    classes: [{
      type: HostBinding,
      args: ["class.k-scheduler-header"]
    }],
    resources: [{
      type: Input
    }]
  });
})();
var AgendaViewInternalComponent = class _AgendaViewInternalComponent {
  viewContext;
  viewState;
  intl;
  renderer;
  element;
  zone;
  pdfService;
  localization;
  selectedDate;
  eventTemplate;
  slotClass;
  eventClass;
  eventStyles;
  agendaTimeTemplate;
  agendaDateTemplate;
  selectedDateFormat;
  selectedShortDateFormat;
  numberOfDays;
  headerWrap;
  content;
  tasks = new BehaviorSubject(null);
  groupedResources = [];
  editable;
  get eventTemplateRef() {
    return this.eventTemplate || (this.schedulerEventTemplate || {}).templateRef;
  }
  get agendaTimeTemplateRef() {
    return this.agendaTimeTemplate || (this.schedulerAgendaTimeTemplate || {}).templateRef;
  }
  get agendaDateTemplateRef() {
    return this.agendaDateTemplate || (this.schedulerAgendaDateTemplate || {}).templateRef;
  }
  schedulerEventTemplate;
  schedulerAgendaTimeTemplate;
  schedulerAgendaDateTemplate;
  group;
  resources;
  spans = [];
  items;
  range;
  groups;
  min;
  max;
  subs = new Subscription();
  constructor(viewContext, viewState, intl, renderer, element, zone, pdfService, localization) {
    this.viewContext = viewContext;
    this.viewState = viewState;
    this.intl = intl;
    this.renderer = renderer;
    this.element = element;
    this.zone = zone;
    this.pdfService = pdfService;
    this.localization = localization;
  }
  ngOnInit() {
    this.updateContentHeight = this.updateContentHeight.bind(this);
    this.subs.add(this.viewContext.selectedDate.subscribe(this.onSelectDate.bind(this)));
    this.subs.add(this.viewContext.action.subscribe(this.onAction.bind(this)));
    this.subs.add(this.viewContext.execute.subscribe(this.execute.bind(this)));
    this.subs.add(this.viewContext.resize.subscribe(this.updateContentHeight));
    this.subs.add(combineLatest([this.viewContext.items, this.viewState.dateRange]).pipe(map(([items, dateRange]) => {
      this.items = items;
      this.range = dateRange;
      return this.createEventGroups();
    })).subscribe((tasks) => {
      this.tasks.next(tasks);
    }));
    this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
    const onStable = () => this.zone.onStable.pipe(take(1));
    this.subs.add(combineLatest(this.tasks, this.localization.changes).pipe(switchMap(onStable)).subscribe(this.updateContentHeight));
    this.subs.add(this.pdfService.createElement.subscribe(this.createPDFElement.bind(this)));
  }
  ngOnChanges(changes) {
    if (anyChanged(["selectedDateFormat", "selectedShortDateFormat", "numberOfDays"], changes)) {
      this.viewState.notifyDateRange(this.dateRange(this.selectedDate));
    }
  }
  ngAfterViewInit() {
    if (!this.element) {
      return;
    }
    const contentElement = this.content.nativeElement;
    this.zone.runOutsideAngular(() => {
      this.subs.add(merge(fromEvent(contentElement, "click"), fromEvent(contentElement, "contextmenu"), fromEvent(contentElement, "dblclick")).subscribe((e) => this.onClick(e)));
      this.subs.add(fromEvent(contentElement, "keydown").subscribe((e) => this.onKeydown(e)));
    });
  }
  onClick(e) {
    const targetTask = this.targetTask(e.target);
    if (targetTask) {
      const {
        task,
        eventTarget
      } = targetTask;
      const eventType = e.type;
      const isSingle = eventType === "click";
      const isDouble = eventType === "dblclick";
      if (isSingle && closestInScope2(e.target, (node) => hasClasses(node, "k-event-delete"), eventTarget)) {
        this.viewState.emitEvent("remove", {
          event: task.event,
          dataItem: task.event.dataItem
        });
      } else {
        const name = isDouble ? "eventDblClick" : "eventClick";
        this.viewState.emitEvent(name, {
          type: eventType,
          event: task.event,
          originalEvent: e
        });
      }
    }
  }
  onKeydown(e) {
    const targetTask = this.targetTask(e.target);
    if (targetTask) {
      const task = targetTask.task;
      this.viewState.emitEvent("eventKeydown", {
        event: task.event,
        dataItem: task.event.dataItem,
        originalEvent: e
      });
    }
  }
  targetTask(target) {
    const eventTarget = closestInScope2(target, (node) => node.hasAttribute("data-task-index"), this.element.nativeElement);
    if (eventTarget) {
      return {
        eventTarget,
        task: this.elementTask(eventTarget)
      };
    }
  }
  updateContentHeight() {
    const element = this.element.nativeElement;
    const parent = element.parentNode;
    const content2 = this.content.nativeElement;
    this.renderer.setStyle(content2, "height", "");
    let height2 = parent.clientHeight;
    for (let idx2 = 0; idx2 < parent.children.length; idx2++) {
      const child = parent.children[idx2];
      if (child !== element && !ignoreContentChild(child)) {
        height2 -= child.offsetHeight;
      }
    }
    const headerElement = this.headerWrap.nativeElement;
    height2 -= this.headerWrap ? headerElement.offsetHeight : 0;
    this.renderer.setStyle(content2, "height", `${height2}px`);
    const rtl = this.localization.rtl;
    if (!hasScrollbar(content2, "vertical")) {
      this.renderer.setStyle(headerElement, !rtl ? "padding-inline-end" : "padding-inline-start", "0px");
    }
    this.renderer.removeStyle(headerElement, rtl ? "padding-inline-end" : "padding-inline-start");
    this.viewState.notifyLayoutEnd();
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  optionsChange(changes) {
    this.group = changes.group;
    this.resources = changes.resources;
    this.groupResources();
    this.min = changes.min;
    this.max = changes.max;
    this.editable = changes.editable;
    if (this.items && this.items.length) {
      this.tasks.next(this.createEventGroups());
    }
    this.schedulerEventTemplate = changes.eventTemplate;
    this.schedulerAgendaTimeTemplate = changes.agendaTimeTemplate;
    this.schedulerAgendaDateTemplate = changes.agendaDateTemplate;
  }
  onSelectDate(date) {
    this.selectedDate = date;
    this.viewState.notifyDateRange(this.dateRange());
  }
  onAction(e) {
    const now = getDate(this.selectedDate);
    if (e.type === "next") {
      const next = getDate(addDays(now, this.numberOfDays));
      if (this.isInRange(next)) {
        this.viewState.notifyNextDate(next);
      }
    }
    if (e.type === "prev") {
      const next = getDate(addDays(now, -this.numberOfDays));
      if (this.isInRange(next)) {
        this.viewState.notifyNextDate(next);
      }
    }
  }
  createEventGroups() {
    const resourceGroups = this.groupedResources.length ? createResourceGroups(this.groupedResources) : null;
    const eventGroups = this.groups = groupEvents(this.items, {
      taskResources: this.taskResources,
      resourceGroups,
      allResources: this.resources,
      spans: this.spans,
      dateRange: this.range
    });
    return eventGroups;
  }
  dateRange(date = this.selectedDate) {
    const start = getDate(date);
    const end = getDate(addDays(start, this.numberOfDays));
    const rangeEnd = getDate(addDays(start, this.numberOfDays - 1));
    const text = this.intl.format(this.selectedDateFormat, start, rangeEnd);
    const shortText = this.intl.format(this.selectedShortDateFormat, start, rangeEnd);
    return {
      start,
      end,
      text,
      shortText
    };
  }
  groupResources() {
    const resources = this.resources || [];
    const group3 = this.group || {};
    const grouped = group3.resources;
    const groupedResources = this.groupedResources = [];
    if (grouped && grouped.length) {
      for (let groupIdx = 0; groupIdx < grouped.length; groupIdx++) {
        const name = grouped[groupIdx];
        const resource = resources.find((item) => item.name === name);
        if (resource) {
          groupedResources.push(resource);
        }
      }
    }
    this.spans = this.resourceSpans();
  }
  resourceSpans() {
    const spans = [1];
    const resources = this.groupedResources;
    let span2 = 1;
    for (let idx2 = resources.length - 1; idx2 > 0; idx2--) {
      span2 *= (resources[idx2].data || []).length || 1;
      spans.unshift(span2);
    }
    return spans;
  }
  get taskResources() {
    if (this.groupedResources.length) {
      return this.groupedResources;
    } else if (this.resources && this.resources.length) {
      return [this.resources[0]];
    } else {
      return [{}];
    }
  }
  isInRange(date) {
    const dateRange = this.dateRange(date);
    return (!this.min || this.min < dateRange.end) && (!this.max || dateRange.start <= this.max);
  }
  createPDFElement() {
    const element = this.element.nativeElement.cloneNode(true);
    element.style.width = `${this.element.nativeElement.offsetWidth}px`;
    element.querySelector(".k-scheduler-content").style.height = "auto";
    const header = element.querySelector(".k-scheduler-header");
    header.style.paddingRight = 0;
    header.style.paddingLeft = 0;
    this.pdfService.elementReady.emit({
      element
    });
  }
  elementTask(element) {
    const index = parseInt(element.getAttribute("data-task-index"), 10);
    const groupIndex = parseInt(element.getAttribute("data-group-index"), 10);
    const group3 = this.groups[groupIndex];
    const task = group3.tasks.itemAt(index);
    return task;
  }
  execute(e) {
    if (e.name === "slotByPosition") {
      const slot = this.slotByPosition(e.args);
      e.result(slot);
    } else if (e.name === "eventFromElement") {
      const task = this.elementTask(e.args.element);
      if (task) {
        e.result(task.event);
      }
    }
  }
  slotByPosition({
    x,
    y
  }) {
    const contentTable = this.content.nativeElement.querySelector("table");
    const offset2 = elementOffset(contentTable);
    if (offset2.top <= y && y <= offset2.top + offset2.height) {
      const contentRows = contentTable.rows;
      if (!contentRows.length) {
        return;
      }
      const taskOffset = elementOffset(contentRows[0].cells[contentRows[0].cells.length - 1]);
      if (taskOffset.left <= x && x <= taskOffset.left + taskOffset.width) {
        for (let idx2 = 0; idx2 < contentRows.length; idx2++) {
          const row = contentRows[idx2];
          const rowOffset = elementOffset(row);
          if (rowOffset.top <= y && y <= rowOffset.top + rowOffset.height) {
            const element = row.querySelector("[data-task-index]");
            const task = this.elementTask(element);
            const event2 = task.event;
            return {
              element: new ElementRef(element),
              start: event2.start,
              end: event2.end,
              event: event2,
              resources: task.resources,
              isAllDay: task.isAllDay
            };
          }
        }
      }
    }
  }
  static ɵfac = function AgendaViewInternalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AgendaViewInternalComponent)(ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AgendaViewInternalComponent,
    selectors: [["agenda-view-internal"]],
    viewQuery: function AgendaViewInternalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c212, 7, ElementRef);
        ɵɵviewQuery(_c142, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerWrap = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
      }
    },
    inputs: {
      eventTemplate: "eventTemplate",
      slotClass: "slotClass",
      eventClass: "eventClass",
      eventStyles: "eventStyles",
      agendaTimeTemplate: "agendaTimeTemplate",
      agendaDateTemplate: "agendaDateTemplate",
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat",
      numberOfDays: "numberOfDays"
    },
    features: [ɵɵNgOnChangesFeature],
    decls: 11,
    vars: 11,
    consts: [["headerWrap", ""], ["content", ""], ["role", "grid", 1, "k-scheduler-layout", "k-scheduler-agendaview"], ["role", "none"], [1, "k-scheduler-head"], ["kendoSchedulerAgendaHeader", "", 3, "resources"], [1, "k-scheduler-body"], ["kendoSchedulerAgendaList", "", 3, "editable", "eventTemplate", "slotClass", "eventClass", "eventStyles", "agendaTimeTemplate", "agendaDateTemplate", "tasks"]],
    template: function AgendaViewInternalComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "table", 2)(1, "tbody", 3)(2, "tr", 4)(3, "td");
        ɵɵelement(4, "div", 5, 0);
        ɵɵelementEnd()();
        ɵɵelementStart(6, "tr", 6)(7, "td");
        ɵɵelement(8, "div", 7, 1);
        ɵɵpipe(10, "async");
        ɵɵelementEnd()()()();
      }
      if (rf & 2) {
        ɵɵadvance(4);
        ɵɵproperty("resources", ctx.groupedResources);
        ɵɵadvance(4);
        ɵɵproperty("editable", ctx.editable)("eventTemplate", ctx.eventTemplateRef)("slotClass", ctx.slotClass)("eventClass", ctx.eventClass)("eventStyles", ctx.eventStyles)("agendaTimeTemplate", ctx.agendaTimeTemplateRef)("agendaDateTemplate", ctx.agendaDateTemplateRef)("tasks", ɵɵpipeBind1(10, 9, ctx.tasks));
      }
    },
    dependencies: [AgendaHeaderComponent, AgendaListComponent, AsyncPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AgendaViewInternalComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "agenda-view-internal",
      template: `
        <table class="k-scheduler-layout k-scheduler-agendaview" role="grid">
            <tbody role="none">
                <tr class="k-scheduler-head">
                    <td>
                        <div kendoSchedulerAgendaHeader [resources]="groupedResources" #headerWrap></div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div kendoSchedulerAgendaList #content
                            [editable]="editable"
                            [eventTemplate]="eventTemplateRef"
                            [slotClass]="slotClass"
                            [eventClass]="eventClass"
                            [eventStyles]="eventStyles"
                            [agendaTimeTemplate]="agendaTimeTemplateRef"
                            [agendaDateTemplate]="agendaDateTemplateRef"
                            [tasks]="tasks | async">
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `,
      standalone: true,
      imports: [AgendaHeaderComponent, AgendaListComponent, AsyncPipe]
    }]
  }], function() {
    return [{
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: PDFService
    }, {
      type: LocalizationService
    }];
  }, {
    eventTemplate: [{
      type: Input
    }],
    slotClass: [{
      type: Input
    }],
    eventClass: [{
      type: Input
    }],
    eventStyles: [{
      type: Input
    }],
    agendaTimeTemplate: [{
      type: Input
    }],
    agendaDateTemplate: [{
      type: Input
    }],
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    numberOfDays: [{
      type: Input
    }],
    headerWrap: [{
      type: ViewChild,
      args: ["headerWrap", {
        read: ElementRef,
        static: true
      }]
    }],
    content: [{
      type: ViewChild,
      args: ["content", {
        read: ElementRef,
        static: true
      }]
    }]
  });
})();
var AgendaViewComponent = class _AgendaViewComponent extends ConfigurationViewBase {
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("agendaViewTitle");
  }
  /**
   * The long-date format for displaying the
   * selected date in the Scheduler toolbar.
   * Defaults to `{0:D} - {1:D}`,
   * where `0` is the start and `1` is the end date
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   */
  selectedDateFormat = "{0:D} - {1:D}";
  /**
   * The short-date format for displaying the
   * selected date in the Scheduler toolbar.
   * Defaults to `{0:d} - {1:d}`,
   * where `0` is the start and `1` is the end date
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * @default '{0:d} - {1:d}'
   */
  selectedShortDateFormat = "{0:d} - {1:d}";
  /**
   * Specifies the number of days that the view will render.
   * @default 7
   */
  numberOfDays = 7;
  /**
   * @hidden
   */
  agendaTimeTemplate;
  /**
   * @hidden
   */
  agendaDateTemplate;
  /**
   * The invariant name for this view (`agenda`).
   * @default 'agenda'
   */
  name = "agenda";
  constructor(localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  static ɵfac = function AgendaViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AgendaViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AgendaViewComponent,
    selectors: [["kendo-scheduler-agenda-view"]],
    contentQueries: function AgendaViewComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, AgendaTimeTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, AgendaDateTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.agendaTimeTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.agendaDateTemplate = _t.first);
      }
    },
    inputs: {
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat",
      numberOfDays: "numberOfDays"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _AgendaViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], [3, "numberOfDays", "eventTemplate", "slotClass", "eventClass", "eventStyles", "agendaTimeTemplate", "agendaDateTemplate", "selectedDateFormat", "selectedShortDateFormat"]],
    template: function AgendaViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, AgendaViewComponent_ng_template_0_Template, 1, 9, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [AgendaViewInternalComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AgendaViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-agenda-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => AgendaViewComponent)
      }],
      template: `
        <ng-template #content>
            <agenda-view-internal
                [numberOfDays]="numberOfDays"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [agendaTimeTemplate]="agendaTimeTemplate?.templateRef"
                [agendaDateTemplate]="agendaDateTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </agenda-view-internal>
        </ng-template>
    `,
      standalone: true,
      imports: [AgendaViewInternalComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    numberOfDays: [{
      type: Input
    }],
    agendaTimeTemplate: [{
      type: ContentChild,
      args: [AgendaTimeTemplateDirective, {
        static: false
      }]
    }],
    agendaDateTemplate: [{
      type: ContentChild,
      args: [AgendaDateTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var MIDNIGHT_INVARIANT = new Date(1980, 0, 1);
var INVARIANT_END = new Date(1980, 0, 2);
var MS_PER_SECOND = 1e3;
var MS_PER_MINUTE3 = 60 * MS_PER_SECOND;
var MS_PER_HOUR2 = 60 * MS_PER_MINUTE3;
var MS_PER_DAY2 = 24 * MS_PER_HOUR2;
var BORDER_WIDTH = 1;
var DEFAULT_EVENT_HEIGHT = 25;
var ONGOING_EVENT_CSS_CLASS = "k-event-ongoing";
var DAYS_IN_WEEK_COUNT = 7;
var WEEKS_COUNT = 6;
var MORE_BUTTON_HEIGHT = 13;
var EVENT_SPACING = 2;
var ItemMap = class {
  count = 0;
  items = {};
  get first() {
    if (this.count > 0) {
      return this.items[Object.keys(this.items)[0]];
    }
  }
  get last() {
    if (this.count > 0) {
      const keys = Object.keys(this.items);
      return this.items[keys[keys.length - 1]];
    }
  }
  addItem(index, item) {
    if (!this.items[index]) {
      this.count++;
    }
    this.items[index] = item;
  }
  removeItem(index, item) {
    const current = this.items[index];
    if (current === item) {
      delete this.items[index];
      this.count--;
    }
  }
  toArray() {
    return Object.keys(this.items).map((index) => this.items[index]);
  }
};
var BaseSlotService = class {
  containerSize = 0;
  slotsChange = new EventEmitter();
  groups = [];
  registerItem(component) {
    const group3 = this.itemGroup(component);
    group3.registerItem(component);
  }
  unregisterItem(component, id) {
    id = id || {
      index: component.index,
      resourceIndex: component.resourceIndex,
      rangeIndex: component.rangeIndex
    };
    const group3 = this.groups[id.resourceIndex];
    if (group3) {
      group3.unregisterItem(component, id);
    }
  }
  registerSlot(slot) {
    const group3 = this.slotGroup(slot);
    group3.registerSlot(slot);
  }
  unregisterSlot(slot) {
    const group3 = this.groups[slot.id.resourceIndex];
    if (group3) {
      group3.unregisterSlot(slot);
    }
  }
  invalidate() {
    this.clearEmptyGroups();
    this.cleanRanges();
    this.slotsChange.emit();
    this.forEachSlot((slot) => {
      slot.invalidate();
    });
  }
  cleanRanges() {
    this.groups.forEach((group3) => {
      group3.cleanRanges();
    });
  }
  clearEmptyGroups() {
    const groups = this.groups;
    let index = this.groups.length - 1;
    while (index > 0 && !groups[index].hasSlots) {
      groups.splice(index, 1);
      index--;
    }
  }
  itemGroup(item) {
    const index = item.resourceIndex;
    if (!this.groups[index]) {
      this.groups[index] = this.createGroup(index);
    }
    return this.groups[index];
  }
  slotGroup(slot) {
    const index = slot.id.resourceIndex;
    if (!this.groups[index]) {
      this.groups[index] = this.createGroup(index);
    }
    return this.groups[index];
  }
  calculateScaleX() {
    if (!isDocumentAvailable()) {
      return;
    }
    const schedulerEl = document.querySelector(".k-scheduler");
    const scaleX = schedulerEl.getBoundingClientRect().width / schedulerEl.offsetWidth;
    return scaleX;
  }
};
var SlotRange$1 = class SlotRange {
  index;
  get slots() {
    return this.slotMap.toArray();
  }
  get items() {
    return this.itemMap.toArray();
  }
  slotMap = new ItemMap();
  itemMap = new ItemMap();
  get start() {
    const first = this.slotMap.first;
    if (!first) {
      return null;
    }
    return first.start;
  }
  get end() {
    const last3 = this.slotMap.last;
    if (!last3) {
      return null;
    }
    return addUTCDays(last3.end, 1);
  }
  get hasSlots() {
    return this.slotMap.count > 0;
  }
  get hasItems() {
    return this.itemMap.count > 0;
  }
  get firstSlot() {
    return this.slotMap.first;
  }
  get lastSlot() {
    return this.slotMap.last;
  }
  get rect() {
    const first = this.firstSlot.rect;
    const last3 = this.lastSlot.rect;
    return {
      left: first.left,
      top: first.top,
      width: last3.left - first.left + last3.width,
      height: last3.top - first.top + last3.height
    };
  }
  constructor(index) {
    this.index = index;
  }
  registerItem(component) {
    this.itemMap.addItem(component.item.index, component);
  }
  unregisterItem(component, index) {
    this.itemMap.removeItem(index, component);
  }
  registerSlot(slot) {
    this.slotMap.addItem(slot.id.index, slot);
  }
  unregisterSlot(slot) {
    this.slotMap.removeItem(slot.id.index, slot);
  }
  layout(eventHeight, eventsPerDay, adaptiveSlotHeight) {
    const dateHeader = this.slots[0].element.nativeElement.firstElementChild;
    if (!this.hasItems) {
      if (eventHeight !== "auto") {
        const eventsTotalHeight = adaptiveSlotHeight ? eventHeight : eventHeight * eventsPerDay;
        const height2 = eventsTotalHeight + EVENT_SPACING + dateHeader.offsetHeight + MORE_BUTTON_HEIGHT + EVENT_SPACING;
        this.slots.forEach((slot) => {
          slot.height = height2;
          slot.element.nativeElement.style.height = height2 + "px";
        });
      }
      return;
    }
    const items = this.items;
    const sorted = orderBy(items, [{
      field: "item.startTime",
      dir: "asc"
    }, {
      field: "item.endTime",
      dir: "desc"
    }]);
    const slotItems = {};
    const slots = this.slots;
    sorted.forEach((event2) => slots.filter((slot) => intersects(event2.item.startTime, event2.item.endTime, slot.start, slot.end)).forEach((slot) => {
      const value2 = slotItems[slot.key] = slotItems[slot.key] || {
        events: [],
        height: slot.linkHeight
      };
      value2.slot = slot;
      const rect = slot.rect;
      const data = event2.item.data[event2.resourceIndex];
      data.rowIndex = findRowIndex(value2.events, data);
      let showMore;
      const _eventHeight = eventHeight === "auto" ? DEFAULT_EVENT_HEIGHT : eventHeight;
      if (eventHeight === "auto" || eventsPerDay) {
        showMore = eventsPerDay && eventsPerDay !== "auto" && data.rowIndex >= eventsPerDay;
      } else {
        showMore = value2.height + _eventHeight + EVENT_SPACING + MORE_BUTTON_HEIGHT > rect.height || data.hidden;
      }
      if (showMore) {
        data.hidden = true;
        slot.hasShowMore = true;
        if (eventHeight !== "auto") {
          slot.showMore({
            width: rect.width,
            left: rect.left,
            top: rect.top + slot.linkHeight + data.rowIndex * (eventHeight + EVENT_SPACING)
          });
        }
      } else {
        if (eventHeight === "auto") {
          if (event2.item.tail) {
            event2.item.data[event2.resourceIndex].rowIndex = 0;
          }
          if (value2.events[data.rowIndex]) {
            event2.item.data[event2.resourceIndex].rowIndex = value2.events.length;
          }
        }
        value2.events[data.rowIndex] = event2;
        if (eventHeight !== "auto") {
          if (!event2.rect) {
            event2.rect = {
              top: rect.top + slot.linkHeight + data.rowIndex * (eventHeight + EVENT_SPACING),
              left: rect.left,
              height: eventHeight,
              width: 0
            };
          }
          event2.rect.width += rect.width + BORDER_WIDTH;
          value2.height += eventHeight + EVENT_SPACING;
          if (adaptiveSlotHeight) {
            slots.forEach((_slot) => {
              if (_slot.key === slot.key) {
                _slot.eventsCount = !_slot.eventsCount || data.rowIndex + 1 > _slot.eventsCount ? data.rowIndex + 1 : _slot.eventsCount;
              }
            });
          }
        }
      }
    }));
    if (eventHeight === "auto") {
      this.renderAutoHeightEvents(slotItems, dateHeader);
    } else if (eventsPerDay) {
      slots.forEach((slot) => {
        const multiplier = !adaptiveSlotHeight ? eventsPerDay : slot.eventsCount;
        const height2 = BORDER_WIDTH + dateHeader.offsetHeight + EVENT_SPACING + multiplier * (eventHeight + EVENT_SPACING) + MORE_BUTTON_HEIGHT + EVENT_SPACING;
        slot.eventsCount = 0;
        slot.height = height2;
        slot.element.nativeElement.style.height = height2 + "px";
      });
    }
    sorted.forEach((event2) => {
      if (event2.rect) {
        event2.rect.width -= BORDER_WIDTH;
      }
      event2.reflow();
    });
  }
  renderAutoHeightEvents(slotItems, dateHeader) {
    Object.keys(slotItems).forEach((key) => {
      const slotItem = slotItems[key];
      const slotRect = slotItem.slot.rect;
      let accumulatedHeight = dateHeader.offsetHeight;
      slotItem.events.forEach((event2, index) => {
        const prevEvent = slotItem.events[index - 1];
        if (!event2.rect) {
          const eventOffset = !prevEvent ? 0 : prevEvent.element.nativeElement.clientHeight + prevEvent.rect.top;
          const top = !prevEvent ? slotRect.top + slotItem.slot.linkHeight : eventOffset + EVENT_SPACING;
          event2.rect = {
            top,
            left: slotRect.left,
            width: 0
          };
        }
        let eventWidth;
        if (event2.item.isMultiDay) {
          const slotMatch = this.slots.filter((slot) => intersects(event2.item.startTime, event2.item.endTime, slot.start, slot.end));
          eventWidth = slotMatch.reduce((acc, currentValue) => acc + currentValue.rect.width + BORDER_WIDTH, 0) - BORDER_WIDTH;
          if (prevEvent) {
            const newHeight = prevEvent.element.nativeElement.clientHeight + prevEvent.rect.top;
            const newTop = newHeight + EVENT_SPACING;
            if (event2.rect.top < newTop) {
              event2.rect.top = newTop;
              slotMatch.forEach((slot) => {
                const slotKey = slot.id.resourceIndex + ":" + slot.id.rangeIndex + ":" + slot.id.index;
                if (slotKey !== key) {
                  slotItems[slotKey].events.forEach((e, index2) => {
                    if (index2 > event2.item.data[event2.resourceIndex].rowIndex) {
                      e.rect.top = event2.rect.top + event2.element.nativeElement.clientHeight + EVENT_SPACING;
                    }
                  });
                }
              });
            }
          }
        } else {
          eventWidth = slotRect.width;
        }
        event2.rect.width = eventWidth;
        event2.element.nativeElement.style.width = event2.rect.width + "px";
        event2.element.nativeElement.style.height = "auto";
        accumulatedHeight += event2.element.nativeElement.clientHeight + EVENT_SPACING;
      });
      const slotHeight = slotItem.height = BORDER_WIDTH + dateHeader.offsetHeight + EVENT_SPACING + accumulatedHeight + (slotItem.slot.hasShowMore ? 0 : MORE_BUTTON_HEIGHT);
      slotItem.slot.element.nativeElement.style.height = slotHeight + "px";
      if (slotItem.slot.hasShowMore) {
        const top = slotRect.top + slotItem.slot.linkHeight + accumulatedHeight - MORE_BUTTON_HEIGHT;
        slotItem.slot.showMore({
          width: slotRect.width,
          left: slotRect.left,
          top
        });
      }
    });
  }
};
var MonthResourceGroup = class {
  index;
  dayRanges = [];
  constructor(index) {
    this.index = index;
  }
  get hasSlots() {
    return Boolean(this.dayRanges.find((range3) => range3 && range3.hasSlots));
  }
  registerSlot(slot) {
    const range3 = this.slotRange(slot);
    range3.registerSlot(slot);
  }
  unregisterSlot(slot) {
    const range3 = this.dayRanges[slot.id.rangeIndex];
    range3.unregisterSlot(slot);
    if (!range3.hasSlots) {
      delete this.dayRanges[slot.id.rangeIndex];
    }
  }
  registerItem(component) {
    const range3 = this.dayRanges[component.rangeIndex];
    range3.registerItem(component);
  }
  unregisterItem(component, id) {
    const range3 = this.dayRanges[id.rangeIndex];
    if (range3) {
      range3.unregisterItem(component, id.index);
    }
  }
  slotRange(slot) {
    const ranges = this.dayRanges;
    const rangeIndex = slot.id.rangeIndex;
    if (!ranges[rangeIndex]) {
      ranges[rangeIndex] = new SlotRange$1(rangeIndex);
    }
    return ranges[rangeIndex];
  }
  forEachRange(callback) {
    for (let i = 0; i < this.dayRanges.length; i++) {
      callback(this.dayRanges[i]);
    }
  }
  cleanRanges() {
    this.dayRanges = this.dayRanges.filter((r) => Boolean(r));
  }
};
var MonthSlotService = class extends BaseSlotService {
  layout(eventHeight, eventsPerDay, adaptiveSlotHeight) {
    this.groups.forEach((group3) => group3.forEachRange((range3) => range3.layout(eventHeight, eventsPerDay, adaptiveSlotHeight)));
  }
  slotByIndex(slotIndex) {
    const [resourceIndex, rangeIndex, index] = slotIndex.split(":").map((part) => parseInt(part, 10));
    return this.groups[resourceIndex].dayRanges[rangeIndex].slots[index];
  }
  forEachSlot(callback) {
    this.groups.forEach((group3) => {
      group3.dayRanges.forEach((range3) => {
        range3.slots.forEach((slot) => callback(slot));
      });
    });
  }
  forEachItem(callback) {
    this.groups.forEach((group3) => {
      group3.dayRanges.forEach((range3) => {
        range3.items.forEach((viewItem) => callback(viewItem));
      });
    });
  }
  createGroup(index) {
    return new MonthResourceGroup(index);
  }
  invalidate() {
    super.invalidate();
    this.forEachItem((viewItem) => {
      const data = viewItem.item.data;
      Object.keys(data).forEach((resourceIndex) => {
        data[resourceIndex].hidden = false;
      });
    });
  }
  slotByPosition(x, y) {
    let range3;
    this.groups.find((group3) => {
      range3 = group3.dayRanges.find((r) => rectContains(r.rect, x, y, this.calculateScaleX()));
      return range3;
    });
    if (range3) {
      return range3.slots.find((slot) => rectContains(slot.rect, x, y, this.calculateScaleX()));
    }
  }
  dragRanges(currentSlot, offset2) {
    const start = new Date(currentSlot.start.getTime() - offset2.start);
    const end = new Date(currentSlot.start.getTime() + offset2.end);
    const group3 = this.groups[currentSlot.id.resourceIndex];
    const ranges = [];
    group3.dayRanges.forEach((range3) => {
      const slots = range3.slots.filter((s) => intersects(start, end, s.start, s.end));
      if (slots.length) {
        ranges.push(slots);
      }
    });
    return {
      start,
      end,
      ranges
    };
  }
  groupSlotByPosition(currentSlot, x, y) {
    const range3 = this.groups[currentSlot.id.resourceIndex].dayRanges.find((r) => rectContains(r.rect, x, y, this.calculateScaleX()));
    if (range3) {
      return range3.slots.find((slot) => rectContains(slot.rect, x, y, this.calculateScaleX()));
    }
  }
  resizeRanges(currentSlot, task, resizeStart, offset2) {
    const group3 = this.groups[task.resources[0].leafIdx];
    const ranges = [];
    const startDate = task.start.toUTCDate();
    const endDate = task.end.toUTCDate();
    let start, end;
    if (resizeStart) {
      start = currentSlot.start.getTime() + offset2.start;
      if (start > endDate.getTime()) {
        start = new Date(Math.min(dateWithTime(endDate, startDate).getTime(), endDate.getTime()));
      }
      end = endDate;
    } else {
      start = startDate;
      end = currentSlot.start.getTime() + offset2.end;
      if (end < start.getTime()) {
        end = new Date(Math.max(dateWithTime(startDate, endDate).getTime(), start.getTime()));
      }
    }
    group3.dayRanges.forEach((range3) => {
      const slots = range3.slots.filter((s) => intersects(start, end, s.start, s.end));
      if (slots.length) {
        ranges.push(slots);
      }
    });
    return {
      start: new Date(start),
      end: new Date(end),
      ranges
    };
  }
};
var last2 = (arr) => arr[arr.length - 1];
var createTasks$3 = (periodStart, periodEnd, items, ranges) => {
  const tasks = [];
  const utcStart = toUTCDate(periodStart);
  const utcEnd = toUTCDate(periodEnd);
  for (let index = 0; index < items.length; index++) {
    const item = items[index];
    const data = {};
    const startTime = item.start.toUTCDate();
    const end = item.end;
    const endTime = (item.end.getTime() !== end.getTime() ? end.addDays(1) : end).toUTCDate();
    if (intersects(startTime, endTime, utcStart, utcEnd)) {
      for (let rangeIdx = 0; rangeIdx < ranges.length; rangeIdx++) {
        const range3 = ranges[rangeIdx];
        const rangeStart = toUTCDate(range3[0]);
        const rangeEnd = addUTCDays(toUTCDate(last2(range3)), 1);
        if (intersects(startTime, endTime, rangeStart, rangeEnd)) {
          const task = {
            index,
            startTime,
            endTime,
            start: item.start,
            end: item.end,
            event: item.event,
            isAllDay: item.event.isAllDay,
            rangeIndex: rangeIdx,
            data
          };
          task.head = task.endTime > rangeEnd;
          task.tail = task.startTime < rangeStart;
          let slotMatch;
          range3.forEach((slot) => {
            const slotStartTime = slot;
            const slotEndTime = addDays(slot, 1);
            if (task.event.start >= slotStartTime && task.event.start <= slotEndTime) {
              slotMatch = {
                start: slotStartTime,
                end: slotEndTime
              };
            }
          });
          task.isMultiDay = task.event.end > slotMatch?.end || task.head || task.tail;
          tasks.push(task);
        }
      }
    }
  }
  return sortTasksByTime(tasks);
};
function clearTaskData(task) {
  const data = task.data;
  for (const key in data) {
    if (data.hasOwnProperty(key)) {
      delete data[key];
    }
  }
}
function updateTaskData(tasks) {
  for (let idx2 = 0; idx2 < tasks.length; idx2++) {
    const task = tasks[idx2];
    const resources = task.resources;
    clearTaskData(task);
    for (let resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {
      task.data[resources[resourceIdx].leafIdx] = {};
    }
  }
}
var HintContainerComponent = class _HintContainerComponent {
  changeDetector;
  hintTemplate;
  constructor(changeDetector) {
    this.changeDetector = changeDetector;
    this.changeDetector.detach();
  }
  detectChanges() {
    this.changeDetector.detectChanges();
  }
  static ɵfac = function HintContainerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HintContainerComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HintContainerComponent,
    selectors: [["kendo-hint-container"]],
    contentQueries: function HintContainerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TemplateRef, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hintTemplate = _t.first);
      }
    },
    decls: 1,
    vars: 1,
    consts: [[3, "ngTemplateOutlet"]],
    template: function HintContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngTemplateOutlet", ctx.hintTemplate);
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HintContainerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-hint-container",
      template: `
        <ng-container [ngTemplateOutlet]="hintTemplate">
        </ng-container>
    `,
      standalone: true,
      imports: [NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    hintTemplate: [{
      type: ContentChild,
      args: [TemplateRef, {
        static: false
      }]
    }]
  });
})();
var SCROLL_CHANGE = 15;
var MIN_DISTANCE = 60;
var SCROLL_INTERVAL = 50;
var MIN_MOVE_DISTANCE = 10;
var BaseView = class _BaseView {
  viewContext;
  viewState;
  intl;
  slotService;
  zone;
  renderer;
  element;
  pdfService;
  localization;
  cdr;
  scrollBarWidthService;
  eventTemplate;
  groupHeaderTemplate;
  selectedDateFormat;
  selectedShortDateFormat;
  eventHeight;
  showToolbar;
  showFooter;
  slotClass;
  eventClass;
  eventStyles;
  weekStart;
  content;
  header;
  contentTable;
  times;
  timesHeader;
  timesTable;
  headerWrap;
  hintContainer;
  get eventTemplateRef() {
    return this.eventTemplate || (this.schedulerEventTemplate || {}).templateRef;
  }
  get groupHeaderTemplateRef() {
    return this.groupHeaderTemplate || (this.schedulerGroupHeaderTemplate || {}).templateRef;
  }
  /**
   * The non-all-day events.
   */
  items = new BehaviorSubject(null);
  horizontalResources = [];
  verticalResources = [];
  dragHints = [];
  resizeHints = [];
  editable;
  selectable;
  // initialized to false in the scheduler component
  getField = getField;
  changes = new BehaviorSubject(null);
  viewRangeChange = new BehaviorSubject(null);
  subs = new Subscription();
  groupedResources = [];
  spans = [];
  contentHeight;
  /**
   * All events that the user provided.
   */
  tasks;
  group;
  resources;
  domEvents = [];
  schedulerEventTemplate;
  schedulerGroupHeaderTemplate;
  min;
  max;
  selectedDate;
  resourcesCache = {};
  timezone;
  draggable;
  /**
   * The event which is currently being resized.
   */
  resizing;
  dragging;
  dragArgs;
  /**
   * The slot which is currently being dragged over while selecting a range of slots.
   */
  dragSelecting = null;
  /**
   * The slot where the drag-selecting originated. Used for flipping the start and end of the emitted range.
   */
  dragSelectOrigin = null;
  container;
  containerOffset;
  pressLocation;
  pressTarget;
  scrollInterval;
  autoHeight = false;
  rtl = false;
  isSlotSelected = () => false;
  constructor(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, cdr, scrollBarWidthService) {
    this.viewContext = viewContext;
    this.viewState = viewState;
    this.intl = intl;
    this.slotService = slotService;
    this.zone = zone;
    this.renderer = renderer;
    this.element = element;
    this.pdfService = pdfService;
    this.localization = localization;
    this.cdr = cdr;
    this.scrollBarWidthService = scrollBarWidthService;
    this.setSlotClass = this.setSlotClass.bind(this);
    this.setHintClass = this.setHintClass.bind(this);
    this.weekStart = intl.firstDay();
  }
  /**
   * Generates a list of space-separated IDs based on a collection of items to associate scrollable containers
   * with the respective tasks through the aria-owns attribute for a11y compliance.
   */
  matchOwned(items) {
    const ids = items.reduce((acc, curr) => [...acc, ...curr.resources.map((ir) => `${curr.elementId}_${ir.leafIdx}`)], []);
    return ids.join(" ");
  }
  ngOnInit() {
    const updateView = this.updateView.bind(this);
    this.resourcesByIndex = this.resourcesByIndex.bind(this);
    this.subs.add(this.viewContext.selectedDate.subscribe(this.onSelectDate.bind(this)));
    this.subs.add(this.viewState.optionsChange.subscribe(this.onStateOptionsChange.bind(this)));
    this.subs.add(this.viewContext.action.subscribe(this.onAction.bind(this)));
    this.subs.add(this.viewContext.execute.subscribe(this.execute.bind(this)));
    this.subs.add(this.viewContext.resize.subscribe(() => {
      this.toggleElement(false);
      this.updateView();
    }));
    this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
    this.subs.add(this.changes.subscribe(() => {
      this.toggleElement(false);
    }));
    this.subs.add(combineLatest(this.viewContext.items, this.viewState.dateRange, this.viewRangeChange).pipe(map(([items, dateRange]) => this.createTasks(items, dateRange))).subscribe((tasks) => {
      this.tasks = tasks.map((t) => __spreadProps(__spreadValues({}, t), {
        elementId: guid()
      }));
      this.assignResources();
      this.onTasksChange();
    }));
    this.subs.add(combineLatest(this.items, this.changes, this.localization.changes).pipe(switchMap(() => this.onStable())).subscribe(updateView));
    this.subs.add(this.pdfService.createElement.subscribe(this.createPDFElement.bind(this)));
  }
  ngOnChanges(changes) {
    if (anyChanged(["selectedDateFormat", "selectedShortDateFormat"], changes)) {
      this.viewState.notifyDateRange(this.dateRange(this.selectedDate));
    }
    if (changes.eventHeight) {
      this.changes.next(null);
    }
  }
  ngAfterViewInit() {
    this.bindEvents();
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
    }));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    this.domEvents.forEach((unbindHandler) => unbindHandler());
    this.domEvents = [];
    if (this.draggable) {
      this.draggable.destroy();
      this.draggable = null;
    }
  }
  itemIndex(index, _) {
    return index;
  }
  resourcesByIndex(index) {
    if (!this.resources) {
      return [];
    }
    if (!this.group) {
      return this.resources.reduce((result, resource) => result.concat(resource.data || []), []);
    }
    if (!this.resourcesCache[index]) {
      const resources = this.taskResources;
      const result = [];
      let currentIndex = index;
      for (let idx2 = 0; idx2 < resources.length; idx2++) {
        const data = resources[idx2].data || [];
        const dataIdx = Math.floor(currentIndex / this.spans[idx2]);
        result.push(data[dataIdx]);
        currentIndex -= dataIdx * this.spans[idx2];
      }
      this.resourcesCache[index] = result;
    }
    return this.resourcesCache[index];
  }
  dragResourcesByIndex(index) {
    const allResources = this.resources || [];
    const result = [];
    if (this.groupedResources.length) {
      const resources = this.resourcesByIndex(index).slice(0);
      const taskResources = this.taskResources;
      for (let idx2 = 0; idx2 < taskResources.length; idx2++) {
        const index2 = this.resources.indexOf(taskResources[idx2]);
        if (index2 >= 0) {
          result[index2] = resources[idx2];
        }
      }
    }
    for (let idx2 = 0; idx2 < allResources.length; idx2++) {
      if (!result[idx2]) {
        result[idx2] = resourceItemByValue(this.dragging.task.event, allResources[idx2]);
      }
    }
    return result;
  }
  getEventClasses(item, resources, isAllDay) {
    if (this.eventClass) {
      return this.eventClass({
        event: item.event,
        resources,
        isAllDay
      });
    }
  }
  getEventStyles(item, itemResource, isAllDay) {
    const result = {
      backgroundColor: itemResource.color,
      borderColor: itemResource.color
    };
    if (this.eventStyles) {
      Object.assign(result, this.eventStyles({
        event: item.event,
        resources: itemResource.resources,
        isAllDay
      }));
    }
    return result;
  }
  // Similar to https://tc39.es/proposal-temporal/docs/plaindate.html
  // Stores a "plain date" in the UTC parts of a regular `Date`.
  toPlainDate(date) {
    const result = toUTCDateTime2(this.convertDate(date));
    return result;
  }
  // Similar to https://tc39.es/proposal-temporal/docs/plaindatetime.html
  // Stores a "plain date-time" in the UTC parts of a regular `Date`.
  toPlainDateTime(date, time) {
    if (!date || !time) {
      return null;
    }
    return this.toPlainDate(dateWithTime(date, time));
  }
  optionsChange(options) {
    this.schedulerEventTemplate = options.eventTemplate;
    this.schedulerGroupHeaderTemplate = options.groupHeaderTemplate;
    this.min = options.min;
    this.max = options.max;
    this.editable = options.editable;
    this.timezone = options.timezone;
    this.selectable = options.selectable;
    this.isSlotSelected = options.isSlotSelected;
    if (!options.changes || anyChanged(["group", "resources"], options.changes, false) || options.group !== this.group || options.resources !== this.resources) {
      this.group = options.group;
      this.resources = options.resources;
      this.groupResources();
      this.resourcesCache = {};
      if (this.tasks && this.tasks.length) {
        this.assignResources();
        this.onTasksChange();
      }
      this.changes.next(null);
    }
    this.onStateOptionsChange(options);
  }
  toggleElement(visible) {
    if (this.element) {
      this.renderer.setStyle(this.element.nativeElement, "display", visible ? "block" : "none");
    }
  }
  onStable() {
    return this.zone.onStable.asObservable().pipe(take(1));
  }
  updateView() {
    this.slotService.invalidate();
    this.toggleElement(true);
    this.reflow();
    this.viewState.notifyLayoutEnd();
    this.viewState.emitEvent(slotDragEventName.refreshSlotSelection);
  }
  assignResources() {
    assignTasksResources(this.tasks, {
      taskResources: this.taskResources,
      hasGroups: this.groupedResources.length > 0,
      allResources: this.resources,
      spans: this.spans
    });
  }
  bindEvents() {
    const contentElement = this.content.nativeElement;
    const element = this.element.nativeElement;
    this.zone.runOutsideAngular(() => {
      if (this.times) {
        this.subs.add(merge(fromEvent(this.times.nativeElement, "mousewheel"), fromEvent(this.times.nativeElement, "DOMMouseScroll")).pipe(filter((event2) => !event2.ctrlKey), tap(preventLockedScroll(contentElement)), map(wheelDeltaY)).subscribe((x) => contentElement.scrollTop -= x));
      }
      this.subs.add(merge(fromClick(contentElement), fromEvent(contentElement, "contextmenu")).subscribe((e) => this.onClick(e)));
      this.subs.add(fromDoubleClick(contentElement).subscribe((e) => this.onClick(e, "dblclick")));
      this.subs.add(fromEvent(element, "keydown").subscribe((e) => this.onKeydown(e)));
      this.domEvents.push(this.renderer.listen(contentElement, "scroll", () => {
        if (this.headerWrap) {
          this.headerWrap.nativeElement.scrollLeft = contentElement.scrollLeft;
        }
        if (this.times) {
          this.times.nativeElement.scrollTop = contentElement.scrollTop;
        }
      }));
      this.draggable = new Draggable({
        press: this.onPress.bind(this),
        drag: this.onDrag.bind(this),
        release: this.onRelease.bind(this)
      });
      this.draggable.bindTo(element);
    });
  }
  onPress(args) {
    const editResizable = this.editable && this.editable.resize !== false;
    const editDraggable = this.editable && this.editable.drag !== false;
    const target = args.originalEvent.target;
    if (hasClasses(target, "k-resize-handle")) {
      if (!editResizable) {
        return;
      }
      this.initResize(args);
    } else if (editDraggable) {
      const task = this.targetTask(target);
      if (task) {
        if (!args.isTouch) {
          args.originalEvent.preventDefault();
        }
        this.pressLocation = {
          x: args.pageX,
          y: args.pageY
        };
        this.pressTarget = task;
      }
    }
    const notDraggingEvent = !this.pressTarget;
    if (notDraggingEvent && this.selectable) {
      this.initDragSelect(args);
    }
    this.dragArgs = args;
  }
  onDrag(args) {
    if (this.resizing) {
      this.resize(args);
      this.scrollContainer(this.resize, args);
    } else {
      this.initDrag(args);
      if (this.dragging) {
        this.drag(args);
        args.originalEvent.preventDefault();
        this.scrollContainer(this.drag, args);
      }
      if (this.dragSelecting) {
        this.dragSelect(args);
      }
    }
    this.dragArgs = args;
  }
  onRelease(args) {
    clearInterval(this.scrollInterval);
    const {
      resizing,
      dragging,
      dragSelecting
    } = this;
    if (resizing) {
      this.emitEvent("resizeEnd", {
        event: resizing.task.event,
        dataItem: resizing.task.event.dataItem,
        start: this.convertDate(resizing.start),
        end: this.convertDate(resizing.end)
      });
      this.resizeHints = [];
    }
    if (dragging) {
      this.emitEvent("dragEnd", {
        event: dragging.task.event,
        dataItem: dragging.task.event.dataItem,
        start: dragging.start ? this.convertDate(dragging.start) : dragging.task.start.toLocalDate(),
        end: dragging.end ? this.convertDate(dragging.end) : dragging.task.end.toLocalDate(),
        resources: dragging.resources,
        isAllDay: this.draggedIsAllDay(dragging.task, dragging.slot)
      });
      this.dragHints = [];
    }
    if (resizing || dragging) {
      this.removeSlotClass();
      this.updateHintContainer();
      this.resizing = null;
      this.dragging = null;
    }
    if (dragSelecting) {
      const {
        start,
        end
      } = normaliseRangeStartAndEnd(this.dragSelectOrigin, this.dragSelecting);
      const range3 = {
        start: this.convertDate(start),
        end: this.convertDate(end),
        isAllDay: this.dragSelecting.isDaySlot,
        resources: this.resourcesByIndex(this.dragSelecting.id.resourceIndex),
        originalEvent: args.originalEvent
      };
      this.viewState.notifySlotSelectionEnd(range3);
      this.dragSelectOrigin = null;
      this.dragSelecting = null;
      this.cdr.markForCheck();
    }
    this.container = null;
    this.dragArgs = null;
    this.pressLocation = null;
    this.pressTarget = null;
  }
  setHintClass(className) {
    (this.dragging || this.resizing).hintClass = className;
  }
  updateHintClass() {
    const current = this.dragging || this.resizing;
    let update2 = false;
    this.hints.forEach((hint) => {
      if (hint.class !== current.hintClass) {
        hint.class = current.hintClass;
        update2 = true;
      }
    });
    if (update2) {
      this.updateHintContainer();
    }
  }
  removeHintClass() {
    (this.dragging || this.resizing).hintClass = null;
  }
  setSlotClass(className) {
    const current = this.dragging || this.resizing;
    current.slotClass = className;
    this.renderer.addClass(current.slot.nativeElement, current.slotClass);
  }
  removeSlotClass() {
    const current = this.dragging || this.resizing;
    if (current.slotClass) {
      this.renderer.removeClass(current.slot.nativeElement, current.slotClass);
      current.slotClass = null;
    }
  }
  get hints() {
    return this.dragging ? this.dragHints : this.resizeHints;
  }
  initDrag(args) {
    if (!this.dragging && this.pressLocation && pointDistance(this.pressLocation.x, this.pressLocation.y, args.pageX, args.pageY) >= MIN_MOVE_DISTANCE) {
      const dragging = this.pressTarget;
      const task = dragging.task;
      if (this.emitEvent("dragStart", {
        event: task.event,
        dataItem: task.event.dataItem
      })) {
        this.pressLocation = null;
        this.pressTarget = null;
        return;
      }
      this.updateDragContainer(args);
      if (this.containerOffset === void 0) {
        return;
      }
      const {
        x,
        y
      } = this.coordinatesOffset(this.pressLocation.x, this.pressLocation.y);
      const slot = this.slotByPosition(Math.ceil(x), Math.ceil(y), this.container);
      if (!slot) {
        return;
      }
      this.dragging = dragging;
      this.dragging.offset = {
        start: slot.start.getTime() - task.start.toUTCDate().getTime(),
        end: task.end.toUTCDate().getTime() - slot.start.getTime()
      };
      this.dragging.slot = slot;
      this.dragging.startResources = this.dragging.resourceItems = this.dragResourcesByIndex(slot.id.resourceIndex);
      this.dragging.resources = this.resourceValues(task, this.dragging.startResources);
    }
  }
  updateDragContainer(_args) {
    if (!this.container) {
      this.container = this.content.nativeElement;
      this.containerOffset = elementOffset(this.container);
    }
  }
  drag(args) {
    this.updateDragContainer(args);
    if (!this.container) {
      return;
    }
    const {
      x,
      y
    } = this.coordinatesOffset(args.pageX, args.pageY);
    const slot = this.slotByPosition(x, y, this.container);
    if (slot && (slot !== this.dragging.slot || !this.dragHints.length)) {
      const dragging = this.dragging;
      const {
        slot: currentSlot,
        task
      } = dragging;
      const {
        ranges,
        start,
        end,
        isAllDay
      } = this.dragRanges(slot);
      let resourceItems2, resourceValues;
      if (currentSlot.id.resourceIndex !== slot.id.resourceIndex) {
        resourceItems2 = this.dragResourcesByIndex(slot.id.resourceIndex);
        resourceValues = this.resourceValues(task, resourceItems2);
      } else {
        resourceItems2 = dragging.resourceItems;
        resourceValues = dragging.resources;
      }
      this.removeSlotClass();
      dragging.start = start;
      dragging.end = end;
      dragging.slot = slot;
      dragging.resources = resourceValues;
      dragging.resourceItems = resourceItems2;
      dragging.hintClass = null;
      if (this.emitEvent("drag", {
        event: task.event,
        dataItem: task.event.dataItem,
        start: this.convertDate(start),
        end: this.convertDate(end),
        resources: resourceValues,
        isAllDay,
        setHintClass: this.setHintClass,
        setSlotClass: this.setSlotClass
      })) {
        this.updateHintClass();
        return;
      }
      const color = this.dragResourceColor(task, resourceItems2);
      const hintClasses = this.dragHintClasses();
      this.dragHints = [];
      for (let idx2 = 0; idx2 < ranges.length; idx2++) {
        const slots = ranges[idx2];
        const first = slots[0];
        const last3 = slots[slots.length - 1];
        const size = this.dragHintSize(first, last3);
        const origin = first.rect.left;
        const styles = {
          top: toPx(first.rect.top),
          left: this.localization.rtl ? "" : toPx(origin),
          right: !this.localization.rtl ? "" : toPx(origin),
          width: size.width,
          height: size.height,
          backgroundColor: color,
          borderColor: color
        };
        if (this.eventStyles) {
          Object.assign(styles, this.eventStyles(this.dragHintEventStyleArgs()));
        }
        this.dragHints.push({
          item: Object.assign({}, this.dragging.task, {
            startTime: start,
            endTime: end
          }),
          resources: resourceItems2,
          class: hintClasses,
          style: styles
        });
      }
      this.updateHintContainer();
    }
  }
  initDragSelect(args) {
    this.updateDragContainer(args);
    if (!this.containerOffset) {
      return;
    }
    const {
      x,
      y
    } = this.coordinatesOffset(args.pageX, args.pageY);
    const slot = this.slotByPosition(x, y, this.container);
    if (!slot) {
      return;
    }
    const range3 = {
      start: this.convertDate(slot.start),
      end: this.convertDate(slot.end),
      isAllDay: slot.isDaySlot,
      resources: this.resourcesByIndex(slot.id.resourceIndex),
      originalEvent: args.originalEvent
    };
    const slotDragStartEvent = new SlotDragStartEvent(null, range3);
    this.viewState.notifySlotSelectionStart(slotDragStartEvent);
    if (!slotDragStartEvent.isDefaultPrevented()) {
      this.dragSelecting = slot;
      this.dragSelectOrigin = slot;
      this.cdr.markForCheck();
    }
  }
  dragSelect(args) {
    const {
      x,
      y
    } = this.coordinatesOffset(args.pageX, args.pageY);
    const slot = this.slotByPosition(x, y, this.container);
    if (!slot) {
      return;
    }
    if (this.dragSelecting !== slot) {
      this.dragSelecting = slot;
      const {
        start,
        end
      } = normaliseRangeStartAndEnd(this.dragSelectOrigin, this.dragSelecting);
      const range3 = {
        start: this.convertDate(start),
        end: this.convertDate(end),
        isAllDay: slot.isDaySlot,
        resources: this.resourcesByIndex(slot.id.resourceIndex),
        originalEvent: args.originalEvent
      };
      this.viewState.notifySlotSelectionDrag(range3);
      this.cdr.markForCheck();
    }
  }
  dragHintClasses() {
    const hintClass = this.dragging.hintClass;
    let result = [];
    if (hintClass) {
      result.push(hintClass);
    }
    if (this.eventClass) {
      const eventClass = this.eventClass(this.dragHintEventStyleArgs());
      result = result.concat(convertNgClassBindings(eventClass));
    }
    return result;
  }
  dragHintEventStyleArgs() {
    return {
      event: this.dragging.task.event,
      resources: this.dragging.resourceItems
    };
  }
  draggedIsAllDay(task, _slot) {
    return Boolean(task.event.isAllDay);
  }
  dragResourceColor(task, slotResources) {
    if (this.groupedResources.length) {
      const index = this.resources.indexOf(this.groupedResources[0]);
      return getField(slotResources[index], this.groupedResources[0].colorField);
    } else if (this.resources && this.resources.length) {
      return task.resources[0].color;
    }
    return "";
  }
  resourceValues(task, currentResources) {
    const result = {};
    for (let idx2 = 0; idx2 < currentResources.length; idx2++) {
      const resource = this.resources[idx2];
      const resourceItem2 = currentResources[idx2];
      let value2;
      if (Array.isArray(resourceItem2)) {
        value2 = getField(task.event, resource.field);
      } else {
        value2 = getField(currentResources[idx2], resource.valueField);
        if (resource.multiple) {
          const startValue = getField(this.dragging.startResources[idx2], resource.valueField);
          if (startValue !== value2) {
            value2 = [value2];
          } else {
            value2 = getField(task.event.dataItem, resource.field);
          }
        }
      }
      setField(result, resource.field, value2);
    }
    return result;
  }
  initResize(args) {
    args.originalEvent.preventDefault();
    const target = args.originalEvent.target;
    const resizing = this.targetTask(target);
    if (this.emitEvent("resizeStart", {
      event: resizing.task.event,
      dataItem: resizing.task.event.dataItem
    })) {
      return;
    }
    this.resizing = resizing;
    resizing.start = resizing.task.start.toUTCDate();
    resizing.end = resizing.task.end.toUTCDate();
    if (hasClasses(target, "k-resize-n")) {
      resizing.direction = "n";
    } else if (hasClasses(target, "k-resize-s")) {
      resizing.direction = "s";
    } else if (hasClasses(target, "k-resize-w")) {
      resizing.direction = "w";
    } else {
      resizing.direction = "e";
    }
    this.updateDragContainer(args);
    const {
      x,
      y
    } = this.coordinatesOffset(args.pageX, args.pageY);
    resizing.slot = this.slotByPosition(Math.ceil(x), Math.ceil(y), this.container);
    resizing.offset = {
      start: resizing.task.start.toUTCDate().getTime() - resizing.slot.start.getTime(),
      end: resizing.task.end.toUTCDate().getTime() - resizing.slot.start.getTime()
    };
  }
  resize(args) {
    const {
      x,
      y
    } = this.coordinatesOffset(args.pageX, args.pageY);
    const resizing = this.resizing;
    const {
      direction,
      task,
      offset: offset2
    } = resizing;
    const slot = this.slotService.groupSlotByPosition(resizing.slot, x, y);
    if (!slot || slot === resizing.slot) {
      return;
    }
    this.removeSlotClass();
    const {
      start,
      end,
      ranges
    } = this.slotService.resizeRanges(slot, task, direction === "w" || direction === "n", offset2);
    resizing.hintClass = null;
    resizing.start = start;
    resizing.end = end;
    resizing.slot = slot;
    if (this.emitEvent("resize", {
      event: task.event,
      dataItem: task.event.dataItem,
      start: this.convertDate(start),
      end: this.convertDate(end),
      setHintClass: this.setHintClass,
      setSlotClass: this.setSlotClass
    })) {
      this.updateHintClass();
      return;
    }
    this.updateResizeHints(ranges, start, end);
    this.updateHintContainer();
  }
  updateResizeHints(ranges, _start, _end) {
    const resizing = this.resizing;
    const direction = resizing.direction;
    const horizontal2 = direction === "w" || direction === "e";
    const resizeStart = direction === "w" || direction === "n";
    this.resizeHints = [];
    for (let idx2 = 0; idx2 < ranges.length; idx2++) {
      const range3 = ranges[idx2];
      const firstSlot = range3[0];
      const lastSlot = range3[range3.length - 1];
      const first = idx2 === 0;
      const last3 = idx2 === ranges.length - 1;
      this.resizeHints.push({
        first,
        last: last3,
        rect: {
          left: firstSlot.rect.left,
          top: firstSlot.top,
          height: horizontal2 ? firstSlot.height : Math.abs(lastSlot.rect.top - firstSlot.rect.top) + lastSlot.rect.height,
          width: horizontal2 ? Math.abs(lastSlot.rect.left - firstSlot.rect.left) + lastSlot.rect.width : firstSlot.width
        },
        start: first && !resizeStart ? resizing.start : firstSlot.start,
        end: last3 && resizeStart ? resizing.end : lastSlot.end,
        class: resizing.hintClass
      });
    }
  }
  coordinatesOffset(x, y, container = this.container, offset2 = this.containerOffset) {
    const position = x - offset2.left + container.scrollLeft;
    return {
      x: !this.localization.rtl ? position : this.slotService.containerSize - position,
      y: y - offset2.top + container.scrollTop
    };
  }
  scrollContainer(callback, args) {
    clearInterval(this.scrollInterval);
    const container = this.container;
    if (!container) {
      return;
    }
    const viewPortY = args.pageY - this.containerOffset.top;
    const pointerYDistance = Math.abs(container.offsetHeight - viewPortY);
    const deltaY = args.pageY - this.dragArgs.pageY;
    const viewPortX = args.pageX - this.containerOffset.left;
    const pointerXDistance = Math.abs(container.offsetWidth - viewPortX);
    const deltaX = args.pageX - this.dragArgs.pageX;
    let scroll = false;
    let leftChange = 0;
    let topChange = 0;
    if (pointerYDistance < MIN_DISTANCE && container.scrollTop + container.offsetHeight < container.scrollHeight && deltaY > 0) {
      scroll = true;
      topChange = SCROLL_CHANGE;
      this.container.scrollTop += MIN_DISTANCE - pointerYDistance;
    } else if (viewPortY < MIN_DISTANCE && container.scrollTop > 0 && deltaY < 0) {
      scroll = true;
      topChange = -SCROLL_CHANGE;
      this.container.scrollTop -= MIN_DISTANCE - viewPortY;
    }
    if (pointerXDistance < MIN_DISTANCE && container.scrollLeft + container.offsetWidth < container.scrollWidth && deltaX > 0) {
      scroll = true;
      leftChange = SCROLL_CHANGE;
      this.container.scrollLeft += MIN_DISTANCE - pointerXDistance;
    } else if (viewPortX < MIN_DISTANCE && container.scrollLeft > 0 && deltaY < 0) {
      scroll = true;
      leftChange = -SCROLL_CHANGE;
      this.container.scrollLeft -= MIN_DISTANCE - viewPortX;
    }
    if (scroll) {
      this.scrollInterval = setInterval(() => {
        if (this.container) {
          this.container.scrollLeft += leftChange;
          this.container.scrollTop += topChange;
          callback.call(this, args);
        } else {
          clearInterval(this.scrollInterval);
        }
      }, SCROLL_INTERVAL);
    }
  }
  emitEvent(name, args) {
    this.viewState.emitEvent(name, args);
    return args.prevented;
  }
  targetTask(target) {
    const eventTarget = closestInScope2(target, (node) => node.hasAttribute("data-task-index"), this.element.nativeElement);
    if (eventTarget) {
      const index = parseInt(eventTarget.getAttribute("data-task-index"), 10);
      return {
        target: eventTarget,
        task: this.tasks.find((t) => t.index === index)
      };
    }
  }
  updateHintContainer() {
    if (this.hintContainer) {
      this.hintContainer.detectChanges();
    }
  }
  /**
   * Converts a "view date" (date stored in the UTC parts of a Date object) to a local date.
   */
  convertDate(date) {
    return ZonedDate.fromUTCDate(date, this.timezone).toLocalDate();
  }
  onClick(e, eventType = e.type) {
    this.emitSlotEvent(e, eventType);
    this.emitTaskEvent(e, eventType);
  }
  emitSlotEvent(e, eventType) {
    const targetSlot = closestInScope2(e.target, (node) => node.hasAttribute("data-slot-index"), this.element.nativeElement);
    if (targetSlot) {
      const slotIndex = targetSlot.getAttribute("data-slot-index");
      const name = eventType === "dblclick" ? "slotDblClick" : "slotClick";
      const slot = this.slotByIndex(slotIndex, e);
      this.viewState.emitEvent(name, {
        type: eventType,
        slot,
        start: this.convertDate(slot.start),
        end: this.convertDate(slot.end),
        isAllDay: slot.isDaySlot,
        originalEvent: e,
        resources: this.resources && this.resources.length ? this.resourcesByIndex(slot.id.resourceIndex) : []
      });
    }
  }
  emitTaskEvent(e, eventType) {
    const targetTask = this.targetTask(e.target);
    if (targetTask) {
      const task = targetTask.task;
      const isSingle = eventType === "click";
      const isDouble = eventType === "dblclick";
      if (isSingle && closestInScope2(e.target, (node) => hasClasses(node, "k-event-delete"), targetTask.target)) {
        this.viewState.emitEvent("remove", {
          event: task.event,
          dataItem: task.event.dataItem
        });
      } else {
        const name = isDouble ? "eventDblClick" : "eventClick";
        this.viewState.emitEvent(name, {
          type: eventType,
          event: task.event,
          originalEvent: e
        });
        targetTask.target.focus();
      }
    }
  }
  onKeydown(e) {
    const targetTask = this.targetTask(e.target);
    if (targetTask) {
      const task = targetTask.task;
      this.viewState.emitEvent("eventKeydown", {
        event: task.event,
        dataItem: task.event.dataItem,
        originalEvent: e
      });
    }
  }
  syncTables() {
    if (this.timesTable) {
      this.renderer.setStyle(this.timesTable.nativeElement, "height", `${this.contentTable.nativeElement.offsetHeight}px`);
    }
    if (!hasScrollbar(this.content.nativeElement, "vertical")) {
      this.renderer.setStyle(this.header.nativeElement, !this.localization.rtl ? "padding-inline-end" : "padding-inline-start", "0px");
    }
    this.renderer.removeStyle(this.header.nativeElement, this.localization.rtl ? "padding-inline-end" : "padding-inline-start");
    if (this.times) {
      const times = this.times.nativeElement;
      this.timesHeader.nativeElement.style.width = `${times.offsetWidth}px`;
      const contentHeight = this.contentHeight === "auto" ? this.content.nativeElement.offsetHeight : this.contentHeight;
      this.renderer.setStyle(times, "height", `${contentHeight - (hasScrollbar(this.content.nativeElement, "horizontal") ? scrollbarWidth() : 0)}px`);
      times.scrollTop = this.content.nativeElement.scrollTop;
    }
  }
  updateContentHeight() {
    const element = this.element.nativeElement;
    const parent = element.parentNode;
    const content2 = this.content.nativeElement;
    const autoHeight = this.autoHeight || !parent?.style.height;
    const scrollLeft = content2.scrollLeft;
    const scrollTop = content2.scrollTop;
    this.renderer.setStyle(content2, "height", "");
    if (this.times) {
      this.renderer.setStyle(this.times.nativeElement, "height", "");
    }
    if (autoHeight) {
      this.contentHeight = "auto";
      return;
    }
    let height2 = parent.clientHeight;
    for (let idx2 = 0; idx2 < parent.children.length; idx2++) {
      const child = parent.children[idx2];
      if (child !== element && !ignoreContentChild(child)) {
        height2 -= child.offsetHeight;
      }
    }
    height2 -= this.headerWrap ? this.headerWrap.nativeElement.offsetHeight : 0;
    this.renderer.setStyle(content2, "height", `${height2}px`);
    this.contentHeight = height2;
    content2.scrollLeft = scrollLeft;
    content2.scrollTop = scrollTop;
  }
  groupResources() {
    const resources = this.resources || [];
    const group3 = this.group || {};
    this.groupedResources = groupResources(group3, resources);
    if (group3.orientation !== "vertical") {
      this.horizontalResources = this.groupedResources;
      this.verticalResources = [];
    } else {
      this.verticalResources = this.groupedResources;
      this.horizontalResources = [];
    }
    this.spans = this.resourceSpans();
  }
  get taskResources() {
    if (this.groupedResources.length) {
      return this.groupedResources;
    } else if (this.resources && this.resources.length) {
      return [this.resources[0]];
    } else {
      return [{}];
    }
  }
  resourceSpans() {
    const spans = [1];
    const resources = this.groupedResources;
    let span2 = 1;
    for (let idx2 = resources.length - 1; idx2 > 0; idx2--) {
      span2 *= (resources[idx2].data || []).length || 1;
      spans.unshift(span2);
    }
    return spans;
  }
  isInRange(date) {
    const dateRange = this.dateRange(date);
    return (!this.min || this.min < dateRange.end) && (!this.max || dateRange.start <= this.max);
  }
  createPDFElement() {
    const contentHeight = this.contentHeight;
    const scrollTop = this.content.nativeElement.scrollTop;
    if (contentHeight !== "auto") {
      this.autoHeight = true;
      this.updateView();
    }
    const element = this.element.nativeElement.cloneNode(true);
    element.style.width = `${this.pdfWidth()}px`;
    if (contentHeight !== "auto") {
      this.autoHeight = false;
      this.updateView();
    }
    this.pdfService.elementReady.emit({
      element
    });
    this.content.nativeElement.scrollTop = scrollTop;
  }
  pdfWidth() {
    return this.element.nativeElement.offsetWidth;
  }
  containerByPosition({
    x,
    y
  }) {
    const content2 = this.content.nativeElement;
    const offset2 = elementOffset(content2);
    if (offset2.top <= y && y <= offset2.top + offset2.height && offset2.left <= x && x <= offset2.left + offset2.width) {
      return {
        element: content2,
        offset: offset2
      };
    }
  }
  execute(e) {
    if (e.name === "slotByPosition") {
      const container = this.containerByPosition(e.args);
      if (container) {
        const offset2 = this.coordinatesOffset(e.args.x, e.args.y, container.element, container.offset);
        const slot = this.slotByPosition(offset2.x, offset2.y, container.element);
        e.result(this.slotFields(slot));
      }
    } else if (e.name === "eventFromElement") {
      const target = this.targetTask(e.args.element);
      if (target) {
        e.result(target.task.event);
      }
    }
  }
  slotFields(slot) {
    return {
      element: slot.element,
      resources: this.groupedResources.length ? this.resourcesByIndex(slot.id.resourceIndex) : [],
      start: this.convertDate(slot.start),
      end: this.convertDate(slot.end)
    };
  }
  onStateOptionsChange(changes) {
    if (changes?.showFooter || changes?.showToolbar) {
      this.zone.onStable.pipe(take(1)).subscribe(() => this.updateView());
    }
  }
  static ɵfac = function BaseView_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseView)(ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(BaseSlotService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ScrollbarWidthService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseView,
    viewQuery: function BaseView_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c142, 5);
        ɵɵviewQuery(_c222, 5);
        ɵɵviewQuery(_c232, 5);
        ɵɵviewQuery(_c242, 5);
        ɵɵviewQuery(_c252, 5);
        ɵɵviewQuery(_c262, 5);
        ɵɵviewQuery(_c212, 5);
        ɵɵviewQuery(_c272, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTable = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.times = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timesHeader = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timesTable = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerWrap = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hintContainer = _t.first);
      }
    },
    inputs: {
      eventTemplate: "eventTemplate",
      groupHeaderTemplate: "groupHeaderTemplate",
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat",
      eventHeight: "eventHeight",
      showToolbar: "showToolbar",
      showFooter: "showFooter",
      slotClass: "slotClass",
      eventClass: "eventClass",
      eventStyles: "eventStyles",
      weekStart: "weekStart"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseView, [{
    type: Directive
  }], function() {
    return [{
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }, {
      type: BaseSlotService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: PDFService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ScrollbarWidthService
    }];
  }, {
    eventTemplate: [{
      type: Input
    }],
    groupHeaderTemplate: [{
      type: Input
    }],
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    showToolbar: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    slotClass: [{
      type: Input
    }],
    eventClass: [{
      type: Input
    }],
    eventStyles: [{
      type: Input
    }],
    weekStart: [{
      type: Input
    }],
    content: [{
      type: ViewChild,
      args: ["content", {
        static: false
      }]
    }],
    header: [{
      type: ViewChild,
      args: ["header", {
        static: false
      }]
    }],
    contentTable: [{
      type: ViewChild,
      args: ["contentTable", {
        static: false
      }]
    }],
    times: [{
      type: ViewChild,
      args: ["times", {
        static: false
      }]
    }],
    timesHeader: [{
      type: ViewChild,
      args: ["timesHeader", {
        static: false
      }]
    }],
    timesTable: [{
      type: ViewChild,
      args: ["timesTable", {
        static: false
      }]
    }],
    headerWrap: [{
      type: ViewChild,
      args: ["headerWrap", {
        static: false
      }]
    }],
    hintContainer: [{
      type: ViewChild,
      args: ["hintContainer", {
        static: false
      }]
    }]
  });
})();
var BaseViewItem = class _BaseViewItem {
  slotService;
  localization;
  focusService;
  element;
  renderer;
  localeId;
  item;
  resourceIndex;
  rangeIndex;
  index;
  eventTemplate;
  editable;
  dragHint;
  resources;
  className = true;
  get taskIndex() {
    return this.item.index;
  }
  get touchAction() {
    return this.editable && this.editable.drag !== false ? "none" : null;
  }
  get eventTitle() {
    const startTime = toLocalDate(this.item.startTime);
    const endTime = toLocalDate(this.item.endTime);
    const time = formatEventTime(startTime, endTime, this.item.isAllDay, this.localeId);
    return `${time}, ${this.item.event.title}`;
  }
  get deleteMessage() {
    return this.localization.get("deleteTitle");
  }
  get resizable() {
    return this.editable && this.editable.resize !== false;
  }
  get removable() {
    return this.editable && this.editable.remove !== false;
  }
  caretAltLeftIcon = caretAltLeftIcon;
  caretAltRightIcon = caretAltRightIcon;
  rect;
  subs = new Subscription();
  constructor(slotService, localization, focusService, element, renderer, localeId) {
    this.slotService = slotService;
    this.localization = localization;
    this.focusService = focusService;
    this.element = element;
    this.renderer = renderer;
    this.localeId = localeId;
  }
  get isRecurrence() {
    return isRecurrence(this.item);
  }
  get isRecurrenceException() {
    return isRecurrenceException(this.item);
  }
  get nativeElement() {
    if (this.element) {
      return this.element.nativeElement;
    }
  }
  setStyles(styles) {
    const element = this.nativeElement;
    if (element) {
      for (const name in styles) {
        if (styles.hasOwnProperty(name)) {
          this.renderer.setStyle(element, name, styles[name]);
        }
      }
    }
  }
  toggle(visible) {
    this.setStyles({
      display: visible ? null : "none"
    });
  }
  reflow() {
    const rect = this.rect;
    if (rect) {
      this.setStyles({
        left: !this.localization.rtl ? `${rect.left}px` : "",
        right: this.localization.rtl ? `${rect.left}px` : "",
        top: `${rect.top}px`,
        width: `${rect.width}px`,
        height: `${rect.height}px`
      });
    }
  }
  ngOnInit() {
    if (this.dragHint) {
      return;
    }
    this.subs.add(this.slotService.slotsChange.subscribe(() => {
      this.rect = null;
      this.setStyles({
        left: 0
      });
      const slotId = {
        index: this.index,
        resourceIndex: this.resourceIndex,
        rangeIndex: this.rangeIndex
      };
      this.slotService.unregisterItem(this, slotId);
      if (this.resourceIndex >= 0) {
        this.slotService.registerItem(this);
      }
    }));
  }
  ngOnChanges(changes) {
    if (this.dragHint) {
      return;
    }
    if (anyChanged(["index", "resourceIndex", "rangeIndex"], changes)) {
      const {
        resourceIndex,
        index,
        rangeIndex
      } = changes;
      const previousResourceIndex = resourceIndex ? resourceIndex.previousValue : this.resourceIndex;
      const previousIndex = index ? index.previousValue : this.index;
      const previousRangeIndex = rangeIndex ? rangeIndex.previousValue : this.rangeIndex;
      const slotId = {
        index: previousIndex,
        resourceIndex: previousResourceIndex,
        rangeIndex: previousRangeIndex
      };
      this.slotService.unregisterItem(this, slotId);
      if (this.resourceIndex >= 0) {
        this.slotService.registerItem(this);
        this.toggle(true);
      } else {
        this.toggle(false);
      }
    }
  }
  ngOnDestroy() {
    if (this.dragHint) {
      return;
    }
    this.slotService.unregisterItem(this);
    this.subs.unsubscribe();
  }
  get arrowIcons() {
    return !this.localization.rtl ? ["caret-alt-left", "caret-alt-right"] : ["caret-alt-right", "caret-alt-left"];
  }
  get arrowSVGIcons() {
    return !this.localization.rtl ? [this.caretAltLeftIcon, this.caretAltRightIcon] : [this.caretAltRightIcon, this.caretAltLeftIcon];
  }
  static ɵfac = function BaseViewItem_Factory(__ngFactoryType__) {
    ɵɵinvalidFactory();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseViewItem,
    hostVars: 6,
    hostBindings: function BaseViewItem_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("data-task-index", ctx.taskIndex)("aria-label", ctx.eventTitle);
        ɵɵstyleProp("touch-action", ctx.touchAction);
        ɵɵclassProp("k-event", ctx.className);
      }
    },
    inputs: {
      item: "item",
      resourceIndex: "resourceIndex",
      rangeIndex: "rangeIndex",
      index: "index",
      eventTemplate: "eventTemplate",
      editable: "editable",
      dragHint: "dragHint",
      resources: "resources"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseViewItem, [{
    type: Directive
  }], function() {
    return [{
      type: BaseSlotService
    }, {
      type: LocalizationService
    }, {
      type: FocusService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: void 0
    }];
  }, {
    item: [{
      type: Input
    }],
    resourceIndex: [{
      type: Input
    }],
    rangeIndex: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    eventTemplate: [{
      type: Input
    }],
    editable: [{
      type: Input
    }],
    dragHint: [{
      type: Input
    }],
    resources: [{
      type: Input
    }],
    className: [{
      type: HostBinding,
      args: ["class.k-event"]
    }],
    taskIndex: [{
      type: HostBinding,
      args: ["attr.data-task-index"]
    }],
    touchAction: [{
      type: HostBinding,
      args: ["style.touch-action"]
    }],
    eventTitle: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }]
  });
})();
var MonthViewItemComponent = class _MonthViewItemComponent extends BaseViewItem {
  localeId;
  caretAltLeftIcon = caretAltLeftIcon;
  caretAltRightIcon = caretAltRightIcon;
  arrowRotateCwIcon = arrowRotateCwIcon;
  arrowsNoRepeatIcon = arrowsNoRepeatIcon;
  xIcon = xIcon;
  constructor(slotService, localization, focusService, element, renderer, localeId) {
    super(slotService, localization, focusService, element, renderer, localeId);
    this.localeId = localeId;
  }
  reflow() {
    if (this.item.data[this.resourceIndex].hidden) {
      this.toggle(false);
      return;
    } else {
      this.toggle(true);
    }
    super.reflow();
  }
  static ɵfac = function MonthViewItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthViewItemComponent)(ɵɵdirectiveInject(MonthSlotService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(FocusService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LOCALE_ID));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MonthViewItemComponent,
    selectors: [["", "monthViewItem", ""]],
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c282,
    decls: 10,
    vars: 8,
    consts: [[1, "k-event-actions"], [3, "name", "svgIcon", 4, "ngIf"], ["name", "arrow-rotate-cw", 3, "svgIcon", 4, "ngIf"], ["name", "arrows-no-repeat", 3, "svgIcon", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], ["class", "k-link k-event-delete", "aria-hidden", "true", 4, "ngIf"], [3, "name", "svgIcon"], ["name", "arrow-rotate-cw", 3, "svgIcon"], ["name", "arrows-no-repeat", 3, "svgIcon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-event-template"], ["aria-hidden", "true", 1, "k-link", "k-event-delete"], ["name", "x", 3, "svgIcon"], [1, "k-resize-handle", "k-resize-w"], [1, "k-resize-handle", "k-resize-e"]],
    template: function MonthViewItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵtemplate(1, MonthViewItemComponent_kendo_icon_wrapper_1_Template, 1, 2, "kendo-icon-wrapper", 1)(2, MonthViewItemComponent_kendo_icon_wrapper_2_Template, 1, 1, "kendo-icon-wrapper", 2)(3, MonthViewItemComponent_kendo_icon_wrapper_3_Template, 1, 1, "kendo-icon-wrapper", 3);
        ɵɵelementEnd();
        ɵɵtemplate(4, MonthViewItemComponent_ng_container_4_Template, 1, 6, "ng-container", 4)(5, MonthViewItemComponent_div_5_Template, 3, 2, "div", 5);
        ɵɵelementStart(6, "span", 0);
        ɵɵtemplate(7, MonthViewItemComponent_span_7_Template, 2, 2, "span", 6)(8, MonthViewItemComponent_kendo_icon_wrapper_8_Template, 1, 2, "kendo-icon-wrapper", 1);
        ɵɵelementEnd();
        ɵɵtemplate(9, MonthViewItemComponent_ng_container_9_Template, 3, 0, "ng-container", 5);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.item.tail);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isRecurrence);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isRecurrenceException);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.eventTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.eventTemplate);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.removable);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.item.head);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.resizable);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthViewItemComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[monthViewItem]",
      template: `
        <span class="k-event-actions">
            <kendo-icon-wrapper
                *ngIf="item.tail"
                [name]="arrowIcons[0]"
                [svgIcon]="arrowSVGIcons[0]"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrence"
                name="arrow-rotate-cw"
                [svgIcon]="arrowRotateCwIcon"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrenceException"
                name="arrows-no-repeat"
                [svgIcon]="arrowsNoRepeatIcon"
                >
            </kendo-icon-wrapper>
        </span>
        <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
            [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: resources }">
        </ng-container>
        <div *ngIf="!eventTemplate" [attr.title]="eventTitle">
            <div class="k-event-template">{{ item.event.title }}</div>
        </div>

        <span class="k-event-actions">
            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
            <kendo-icon-wrapper
                *ngIf="item.head"
                [name]="arrowIcons[1]"
                [svgIcon]="arrowSVGIcons[1]"
                >
            </kendo-icon-wrapper>
        </span>

        <ng-container *ngIf="resizable">
            <span class="k-resize-handle k-resize-w"></span>
            <span class="k-resize-handle k-resize-e"></span>
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: MonthSlotService
    }, {
      type: LocalizationService
    }, {
      type: FocusService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, null);
})();
var ResourceIterator = class {
  resources;
  lastIndex;
  *[iterator]() {
    let resources = this.resources;
    const lastIndex = Math.max(0, this.lastIndex);
    if (!(resources && resources.length)) {
      resources = [{}];
    }
    const lastData = resources[lastIndex].data || [];
    const length2 = lastData.length;
    let count = 1;
    for (let idx2 = 0; idx2 <= lastIndex; idx2++) {
      count *= (resources[idx2].data || []).length || 1;
    }
    for (let idx2 = 0; idx2 < count; idx2++) {
      yield lastData[idx2 % length2];
    }
  }
  constructor(resources, lastIndex = resources.length - 1) {
    this.resources = resources;
    this.lastIndex = lastIndex;
  }
};
var ResourceIteratorPipe = class _ResourceIteratorPipe {
  transform(resources = [], lastIndex) {
    return new ResourceIterator(resources, lastIndex);
  }
  static ɵfac = function ResourceIteratorPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResourceIteratorPipe)();
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "resourceIterator",
    type: _ResourceIteratorPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResourceIteratorPipe, [{
    type: Pipe,
    args: [{
      // eslint-disable-next-line @angular-eslint/pipe-prefix
      name: "resourceIterator",
      standalone: true
    }]
  }], null, null);
})();
var NumberIterator = class {
  count;
  *[iterator]() {
    for (let i = 0; i < this.count; i++) {
      yield i;
    }
  }
  constructor(count) {
    this.count = count;
  }
};
var RepeatPipe = class _RepeatPipe {
  transform(value2) {
    return new NumberIterator(value2);
  }
  static ɵfac = function RepeatPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RepeatPipe)();
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "repeat",
    type: _RepeatPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RepeatPipe, [{
    type: Pipe,
    args: [{
      // eslint-disable-next-line @angular-eslint/pipe-prefix
      name: "repeat",
      standalone: true
    }]
  }], null, null);
})();
var ResizeHintComponent = class _ResizeHintComponent {
  hint;
  format;
  marqueeClasses = true;
  get left() {
    return this.hint.rect.left;
  }
  get top() {
    return this.hint.rect.top;
  }
  get width() {
    return this.hint.rect.width;
  }
  get height() {
    return this.hint.rect.height;
  }
  get start() {
    return toLocalDate(this.hint.start);
  }
  get end() {
    return toLocalDate(this.hint.end);
  }
  static ɵfac = function ResizeHintComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResizeHintComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ResizeHintComponent,
    selectors: [["", "kendoResizeHint", ""]],
    hostVars: 18,
    hostBindings: function ResizeHintComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("left", ctx.left, "px")("right", ctx.left, "px")("top", ctx.top, "px")("width", ctx.width, "px")("height", ctx.height, "px");
        ɵɵclassProp("k-marquee", ctx.marqueeClasses)("k-scheduler-marquee", ctx.marqueeClasses)("k-first", ctx.marqueeClasses)("k-last", ctx.marqueeClasses);
      }
    },
    inputs: {
      hint: "hint",
      format: "format"
    },
    attrs: _c292,
    decls: 4,
    vars: 2,
    consts: [[1, "k-marquee-color"], [1, "k-marquee-text"], ["class", "k-label-top", 4, "ngIf"], ["class", "k-label-bottom", 4, "ngIf"], [1, "k-label-top"], [1, "k-label-bottom"]],
    template: function ResizeHintComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "div", 0);
        ɵɵelementStart(1, "div", 1);
        ɵɵtemplate(2, ResizeHintComponent_div_2_Template, 3, 4, "div", 2)(3, ResizeHintComponent_div_3_Template, 3, 4, "div", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.hint.first);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hint.last);
      }
    },
    dependencies: [NgIf, DatePipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeHintComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoResizeHint]",
      template: `
        <div class="k-marquee-color"></div>
        <div class="k-marquee-text">
            <div class="k-label-top" *ngIf="hint.first">{{ start | kendoDate : format }}</div>
            <div class="k-label-bottom" *ngIf="hint.last">{{ end | kendoDate : format }}</div>
        </div>
    `,
      standalone: true,
      imports: [NgIf, DatePipe]
    }]
  }], null, {
    hint: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    marqueeClasses: [{
      type: HostBinding,
      args: ["class.k-marquee"]
    }, {
      type: HostBinding,
      args: ["class.k-scheduler-marquee"]
    }, {
      type: HostBinding,
      args: ["class.k-first"]
    }, {
      type: HostBinding,
      args: ["class.k-last"]
    }],
    left: [{
      type: HostBinding,
      args: ["style.left.px"]
    }, {
      type: HostBinding,
      args: ["style.right.px"]
    }],
    top: [{
      type: HostBinding,
      args: ["style.top.px"]
    }],
    width: [{
      type: HostBinding,
      args: ["style.width.px"]
    }],
    height: [{
      type: HostBinding,
      args: ["style.height.px"]
    }]
  });
})();
var BaseSlotDirective = class _BaseSlotDirective {
  element;
  slotService;
  localization;
  id;
  get slotIndex() {
    return this.key;
  }
  get start() {
    return this._start;
  }
  set start(value2) {
    this._start = value2;
  }
  get end() {
    return this._end;
  }
  set end(value2) {
    this._end = value2;
  }
  _rect = null;
  _start;
  _end;
  constructor(element, slotService, localization) {
    this.element = element;
    this.slotService = slotService;
    this.localization = localization;
  }
  get rect() {
    if (this._rect) {
      return this._rect;
    }
    const el = this.nativeElement;
    this._rect = {
      left: !this.localization.rtl ? el.offsetLeft : this.slotService.containerSize - (el.offsetLeft + el.clientWidth),
      top: el.offsetTop,
      width: el.clientWidth,
      height: el.clientHeight
    };
    return this._rect;
  }
  get top() {
    return this.element ? this.nativeElement.offsetTop : 0;
  }
  get padding() {
    if (!this.element || !isDocumentAvailable()) {
      return 0;
    }
    return parseInt(window.getComputedStyle(this.nativeElement).paddingTop, 10) * 2;
  }
  get height() {
    return this.element ? this.nativeElement.offsetHeight : 0;
  }
  set height(value2) {
    if (this.element) {
      this.nativeElement.style.height = `${value2}px`;
    }
    if (this._rect) {
      this._rect.height = value2;
    }
  }
  get width() {
    return this.element ? this.nativeElement.offsetWidth : 0;
  }
  get key() {
    return `${this.id.resourceIndex}:${this.id.rangeIndex}:${this.id.index}`;
  }
  get nativeElement() {
    return this.element.nativeElement;
  }
  ngOnInit() {
    this.slotService.registerSlot(this);
  }
  ngOnDestroy() {
    this.slotService.unregisterSlot(this);
  }
  invalidate() {
    this._rect = null;
  }
  static ɵfac = function BaseSlotDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseSlotDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(BaseSlotService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseSlotDirective,
    hostVars: 1,
    hostBindings: function BaseSlotDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("data-slot-index", ctx.slotIndex);
      }
    },
    inputs: {
      id: "id"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseSlotDirective, [{
    type: Directive
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: BaseSlotService
    }, {
      type: LocalizationService
    }];
  }, {
    id: [{
      type: Input
    }],
    slotIndex: [{
      type: HostBinding,
      args: ["attr.data-slot-index"]
    }]
  });
})();
var MonthSlotComponent = class _MonthSlotComponent extends BaseSlotDirective {
  cdr;
  style;
  showMoreButton;
  moreHorizontalIcon = moreHorizontalIcon;
  resourcesByIndex;
  monthDaySlotTemplateRef;
  eventsPerDay;
  eventHeight;
  adaptiveSlotHeight;
  set day(value2) {
    this._day = value2;
    this.start = value2;
  }
  /**
   * For the slot template we need the day value without the UTC conversion
   * - timezone does not matter for the day part in this case as the calendar month view is the same for every timezone
   * otherwise the date is incorrect for some timezones (e.g. LA timezone) -
   * For example, it displays Feb. 8, 2023 to be Thursday, wherease it is Wednesday
   */
  get day() {
    return this._day;
  }
  set start(value2) {
    this.startDate = toUTCDate(value2);
  }
  get start() {
    return this.startDate;
  }
  isDaySlot = true;
  get end() {
    return addUTCDays(this.start, 1);
  }
  isFirstDayOfMonth(day) {
    return isEqualDate(day, firstDayOfMonth(day));
  }
  get linkHeight() {
    if (this._linkHeight === null) {
      const element = firstElementChild(this.nativeElement);
      this._linkHeight = element ? element.offsetHeight + element.offsetTop : 0;
    }
    return this._linkHeight;
  }
  startDate;
  _day;
  _linkHeight = null;
  constructor(element, slotService, localization, cdr) {
    super(element, slotService, localization);
    this.cdr = cdr;
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.removeShowMore();
  }
  showMore(rect) {
    this.showMoreButton = true;
    this.style = `width: ${rect.width}px; left: ${rect.left}px; top: ${rect.top}px; border-color: inherit;`;
    this.cdr.detectChanges();
  }
  hideMore() {
    this.showMoreButton = false;
    this.removeShowMore();
  }
  invalidate() {
    super.invalidate();
    this._linkHeight = null;
    this.showMoreButton = false;
    this.removeShowMore();
  }
  removeShowMore() {
    this.showMoreButton = false;
    this.cdr.detectChanges();
  }
  static ɵfac = function MonthSlotComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthSlotComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MonthSlotService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MonthSlotComponent,
    selectors: [["", "monthSlot", ""]],
    inputs: {
      resourcesByIndex: "resourcesByIndex",
      monthDaySlotTemplateRef: "monthDaySlotTemplateRef",
      eventsPerDay: "eventsPerDay",
      eventHeight: "eventHeight",
      adaptiveSlotHeight: "adaptiveSlotHeight",
      day: [0, "monthSlot", "day"]
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c302,
    decls: 3,
    vars: 3,
    consts: [["aria-hidden", "true", "class", "k-link k-nav-day", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], ["class", "k-more-events k-button", 3, "style", 4, "ngIf"], ["aria-hidden", "true", 1, "k-link", "k-nav-day"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-more-events", "k-button"], ["name", "more-horizontal", 3, "svgIcon"]],
    template: function MonthSlotComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, MonthSlotComponent_span_0_Template, 3, 4, "span", 0)(1, MonthSlotComponent_ng_container_1_Template, 1, 5, "ng-container", 1)(2, MonthSlotComponent_div_2_Template, 2, 3, "div", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.monthDaySlotTemplateRef);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.monthDaySlotTemplateRef);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showMoreButton);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, IconWrapperComponent, DatePipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthSlotComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "[monthSlot]",
      template: `
        <span *ngIf="!monthDaySlotTemplateRef" aria-hidden="true" class="k-link k-nav-day">
            {{ day | kendoDate: isFirstDayOfMonth(day) ? 'MMM dd' : 'dd' }}
        </span>
        <ng-container
            *ngIf="monthDaySlotTemplateRef"
            [ngTemplateOutlet]="monthDaySlotTemplateRef"
            [ngTemplateOutletContext]="{ date: day, resources: resourcesByIndex }"
        >
        </ng-container>

        <div *ngIf="showMoreButton" class="k-more-events k-button" [style]="style">
            <kendo-icon-wrapper
                name="more-horizontal"
                [svgIcon]="moreHorizontalIcon"
            >
            </kendo-icon-wrapper>
        </div>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, IconWrapperComponent, DatePipe]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: MonthSlotService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    resourcesByIndex: [{
      type: Input
    }],
    monthDaySlotTemplateRef: [{
      type: Input
    }],
    eventsPerDay: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    adaptiveSlotHeight: [{
      type: Input
    }],
    day: [{
      type: Input,
      args: ["monthSlot"]
    }]
  });
})();
var MonthViewRendererComponent = class _MonthViewRendererComponent extends BaseView {
  monthDaySlotTemplate;
  highlightOngoingEvents;
  type;
  eventsPerDay;
  adaptiveSlotHeight;
  /**
   * The number of weeks to be rendered in the view
   */
  numberOfWeeks = WEEKS_COUNT;
  /**
   * Calculates the next or previous range to be displayed (for Month and Multi-Week views)
   */
  newRange;
  /**
   * Determines the displayed date range and formats the selected date (for Month and Multi-Week views)
   */
  dateRangeFn;
  resizeHintFormat = {
    skeleton: "Md"
  };
  weeks = [];
  eventElements;
  get monthDaySlotTemplateRef() {
    return this.monthDaySlotTemplate || (this.schedulerMonthDaySlotTemplate || {}).templateRef;
  }
  ongoingEventsTimeout;
  schedulerMonthDaySlotTemplate;
  constructor(viewContext, viewState, intl, slotService, zone, element, renderer, pdfService, localization, changeDetector, scrollBarWidthService) {
    super(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, changeDetector, scrollBarWidthService);
    this.updateOngoingEvents = this.updateOngoingEvents.bind(this);
  }
  ngOnChanges(changes) {
    if (isChanged("weekStart", changes)) {
      this.onSelectDate(this.selectedDate);
    }
    super.ngOnChanges(changes);
  }
  ngOnInit() {
    this.viewState.layoutEnd.subscribe(() => {
      if (this.adaptiveSlotHeight) {
        this.slotService.invalidate();
        this.reflow();
      }
    });
    super.ngOnInit();
  }
  ngAfterViewInit() {
    this.updateOngoingEvents();
    super.ngAfterViewInit();
  }
  ngOnDestroy() {
    clearTimeout(this.ongoingEventsTimeout);
    super.ngOnDestroy();
  }
  horizontalColspan(resourceIndex) {
    const resources = this.horizontalResources;
    let result = DAYS_IN_WEEK_COUNT;
    for (let idx2 = resourceIndex + 1; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return result;
  }
  verticalRowspan(resourceIndex) {
    const resources = this.verticalResources;
    let result = this.numberOfWeeks;
    for (let idx2 = resourceIndex + 1; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return result;
  }
  verticalItem(leafIndex, resourceIndex) {
    const data = this.verticalResources[resourceIndex].data || [];
    const resources = this.verticalResources;
    let result = 1;
    for (let idx2 = resourceIndex + 1; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return data[leafIndex / result % data.length];
  }
  daySlotClass(day, resourceIndex) {
    if (this.slotClass) {
      return this.slotClass({
        start: day,
        end: addDays(day, 1),
        resources: this.resourcesByIndex(resourceIndex),
        isAllDay: false
      });
    }
  }
  cellTitle(value2) {
    return this.intl.formatDate(value2, "D");
  }
  addDay(dayStart) {
    return addDays(dayStart, 1);
  }
  isDayInPreviousMonth(day) {
    const beginningOfMonth = new Date(firstDayOfMonth(this.selectedDate).setHours(0, 0, 0, 0));
    return day < beginningOfMonth;
  }
  isDayInNextMonth(day) {
    const endOfMonth = new Date(lastDayOfMonth(this.selectedDate).setHours(23, 59, 59, 59));
    return day > endOfMonth;
  }
  optionsChange(changes) {
    this.schedulerMonthDaySlotTemplate = changes[`${this.type}DaySlotTemplate`];
    super.optionsChange(changes);
  }
  createTasks(items, dateRange) {
    this.weeks = this.createDaySlots(dateRange);
    return createTasks$3(dateRange.start, dateRange.end, items, this.weeks);
  }
  onTasksChange() {
    updateTaskData(this.tasks);
    this.items.next(this.tasks);
  }
  reflow() {
    this.updateContentHeight();
    const content2 = this.content.nativeElement;
    this.slotService.containerSize = content2.scrollWidth;
    if (this.contentHeight === "auto") {
      content2.style.overflow = "visible";
    }
    this.slotService.layout(this.eventHeight, this.eventsPerDay, this.adaptiveSlotHeight);
    if (this.contentHeight === "auto") {
      content2.style.overflow = "auto";
    }
    this.syncTables();
  }
  onClick(e, eventType = e.type) {
    if (eventType === "click") {
      const eventSlot = closestInScope2(e.target, (node) => node.hasAttribute("data-slot-index"), this.element.nativeElement);
      const navigateToDay = closestInScope2(e.target, (node) => hasClasses(node, "k-more-events k-nav-day"), eventSlot);
      if (eventSlot && navigateToDay) {
        const index = eventSlot.getAttribute("data-slot-index");
        const slot = this.slotService.slotByIndex(index);
        this.zone.run(() => {
          this.viewState.navigateTo({
            viewName: "day",
            date: toLocalDate(slot.start)
          });
        });
        return;
      }
    }
    super.onClick(e, eventType);
  }
  slotByIndex(index, _args) {
    return this.slotService.slotByIndex(index);
  }
  onSelectDate(date) {
    const dateRange = this.dateRange(date);
    this.selectedDate = date;
    this.viewState.notifyDateRange(dateRange);
    this.weeks = this.createDaySlots(dateRange);
  }
  onAction(e) {
    const now = getDate(this.selectedDate);
    if (e.type === "next") {
      const next = this.newRange(now);
      if (this.isInRange(next)) {
        this.viewState.notifyNextDate(next);
      }
    }
    if (e.type === "prev") {
      const next = this.newRange(now, -1);
      if (this.isInRange(next)) {
        this.viewState.notifyNextDate(next);
      }
    }
  }
  dateRange(date = this.selectedDate) {
    return this.dateRangeFn(date, this.weekStart);
  }
  dragRanges(slot) {
    return this.slotService.dragRanges(slot, this.dragging.offset);
  }
  dragHintSize(first, last3) {
    return {
      width: toPx(last3.rect.left - first.rect.left + last3.rect.width),
      height: toPx(first.height)
    };
  }
  slotByPosition(x, y) {
    return this.slotService.slotByPosition(x, y);
  }
  updateOngoingEvents() {
    const disabled = !this.highlightOngoingEvents || this.highlightOngoingEvents.enabled === false;
    if (!isDocumentAvailable() || disabled) {
      return;
    }
    clearTimeout(this.ongoingEventsTimeout);
    this.zone.runOutsideAngular(() => {
      this.ongoingEventsTimeout = setTimeout(this.updateOngoingEvents, this.highlightOngoingEvents.updateInterval || MS_PER_MINUTE3);
    });
    this.toggleOngoingClass();
  }
  currentTime() {
    return /* @__PURE__ */ new Date();
  }
  toggleOngoingClass() {
    const now = this.currentTime();
    const cssClass = isPresent4(this.highlightOngoingEvents.cssClass) ? this.highlightOngoingEvents.cssClass : ONGOING_EVENT_CSS_CLASS;
    this.eventElements.forEach((event2) => {
      const isOngoing = dateInRange2(now, event2.item.start, event2.item.end);
      this.renderer[isOngoing ? "addClass" : "removeClass"](event2.nativeElement, cssClass);
    });
  }
  createDaySlots({
    start
  }) {
    const weeks = [];
    let date = start;
    for (let idx2 = 0; idx2 < this.numberOfWeeks; idx2++) {
      const week = [];
      weeks.push(week);
      for (let dayIdx = 0; dayIdx < DAYS_IN_WEEK_COUNT; dayIdx++) {
        week.push(date);
        date = addDays(date, 1);
      }
    }
    return weeks;
  }
  static ɵfac = function MonthViewRendererComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthViewRendererComponent)(ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(MonthSlotService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ScrollbarWidthService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MonthViewRendererComponent,
    selectors: [["month-view"]],
    viewQuery: function MonthViewRendererComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(MonthViewItemComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.eventElements = _t);
      }
    },
    inputs: {
      monthDaySlotTemplate: "monthDaySlotTemplate",
      highlightOngoingEvents: "highlightOngoingEvents",
      type: "type",
      eventsPerDay: "eventsPerDay",
      adaptiveSlotHeight: "adaptiveSlotHeight",
      numberOfWeeks: "numberOfWeeks",
      newRange: "newRange",
      dateRangeFn: "dateRangeFn"
    },
    features: [ɵɵProvidersFeature([MonthSlotService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 31,
    vars: 23,
    consts: [["header", ""], ["headerWrap", ""], ["content", ""], ["contentTable", ""], ["hintContainer", ""], ["timesHeader", ""], ["times", ""], ["timesTable", ""], [1, "k-scheduler-layout", "k-scheduler-monthview"], [1, "k-scheduler-head"], [4, "ngIf"], [1, "k-scheduler-header"], [1, "k-scheduler-header-wrap"], ["aria-hidden", "true", 1, "k-scheduler-table"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-scheduler-body"], ["tabindex", "0", "role", "group", 1, "k-scheduler-content"], ["role", "presentation", 1, "k-scheduler-table"], ["class", "k-scheduler-times", 4, "ngIf"], [1, "k-scheduler-times"], [1, "k-scheduler-cell", "k-heading-cell"], ["class", "k-scheduler-cell k-heading-cell", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-scheduler-times", "k-scheduler-resources"], [1, "k-slot-cell", "k-heading-cell", "k-empty-slot"], ["class", "k-slot-cell k-heading-cell", 3, "ngClass", 4, "ngIf"], [1, "k-slot-cell", "k-heading-cell", 3, "ngClass"], ["class", "k-scheduler-cell", 3, "monthSlot", "eventHeight", "eventsPerDay", "adaptiveSlotHeight", "monthDaySlotTemplateRef", "resourcesByIndex", "ngClass", "id", "title", "k-selected", "k-other-month", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-scheduler-cell", 3, "monthSlot", "eventHeight", "eventsPerDay", "adaptiveSlotHeight", "monthDaySlotTemplateRef", "resourcesByIndex", "ngClass", "id", "title"], ["role", "button", "monthViewItem", "", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "editable", "item", "index", "rangeIndex", "eventTemplate", "resources", "resourceIndex", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "button", "monthViewItem", "", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "editable", "item", "index", "rangeIndex", "eventTemplate", "resources", "resourceIndex"], ["class", "k-event-drag-hint", "monthViewItem", "", 3, "ngStyle", "ngClass", "dragHint", "eventTemplate", "item", "resources", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoResizeHint", "", 3, "hint", "ngClass", "format", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["monthViewItem", "", 1, "k-event-drag-hint", 3, "ngStyle", "ngClass", "dragHint", "eventTemplate", "item", "resources"], ["kendoResizeHint", "", 3, "hint", "ngClass", "format"]],
    template: function MonthViewRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "table", 8)(1, "tbody")(2, "tr", 9);
        ɵɵtemplate(3, MonthViewRendererComponent_td_3_Template, 2, 1, "td", 10);
        ɵɵelementStart(4, "td")(5, "div", 11, 0)(7, "div", 12, 1)(9, "table", 13)(10, "tbody");
        ɵɵtemplate(11, MonthViewRendererComponent_tr_11_Template, 3, 5, "tr", 14);
        ɵɵelementStart(12, "tr");
        ɵɵtemplate(13, MonthViewRendererComponent_ng_container_13_Template, 2, 2, "ng-container", 14);
        ɵɵpipe(14, "resourceIterator");
        ɵɵelementEnd()()()()()()();
        ɵɵelementStart(15, "tr", 15);
        ɵɵtemplate(16, MonthViewRendererComponent_td_16_Template, 8, 4, "td", 10);
        ɵɵelementStart(17, "td")(18, "div", 16, 2);
        ɵɵpipe(20, "async");
        ɵɵelementStart(21, "table", 17, 3)(23, "tbody");
        ɵɵtemplate(24, MonthViewRendererComponent_ng_container_24_Template, 2, 2, "ng-container", 14);
        ɵɵpipe(25, "resourceIterator");
        ɵɵelementEnd()();
        ɵɵtemplate(26, MonthViewRendererComponent_ng_container_26_Template, 2, 2, "ng-container", 14);
        ɵɵpipe(27, "async");
        ɵɵelementStart(28, "kendo-hint-container", null, 4);
        ɵɵtemplate(30, MonthViewRendererComponent_ng_template_30_Template, 2, 4, "ng-template");
        ɵɵelementEnd()()()()()();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.verticalResources.length);
        ɵɵadvance(8);
        ɵɵproperty("ngForOf", ctx.horizontalResources)("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(14, 15, ctx.horizontalResources))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.verticalResources.length);
        ɵɵadvance(2);
        ɵɵstyleProp("overflow-y", "auto");
        ɵɵattribute("aria-owns", ctx.matchOwned(ɵɵpipeBind1(20, 17, ctx.items)));
        ɵɵadvance(3);
        ɵɵclassProp("k-scheduler-table-auto", ctx.adaptiveSlotHeight);
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(25, 19, ctx.verticalResources))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(27, 21, ctx.items))("ngForTrackBy", ctx.itemIndex);
      }
    },
    dependencies: [NgIf, NgForOf, NgTemplateOutlet, NgClass, MonthSlotComponent, MonthViewItemComponent, NgStyle, FocusableDirective, HintContainerComponent, ResizeHintComponent, RepeatPipe, ResourceIteratorPipe, DatePipe, AsyncPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthViewRendererComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "month-view",
      providers: [MonthSlotService],
      template: `
        <table class="k-scheduler-layout k-scheduler-monthview">
            <tbody>
                <tr class="k-scheduler-head">
                    <td *ngIf="verticalResources.length">
                        <div class="k-scheduler-times" #timesHeader *ngIf="verticalResources.length">
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr>
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div class="k-scheduler-header" #header>
                            <div class="k-scheduler-header-wrap" #headerWrap>
                                <!-- Days of the weeks titles -->
                                <table class="k-scheduler-table" aria-hidden="true">
                                    <tbody>
                                        <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex">
                                            <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex"
                                                class="k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                                <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                                <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef" [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                            </th>
                                        </tr>
                                        <tr>
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex">
                                                <th *ngFor="let day of weeks[0]; trackBy: itemIndex" class="k-scheduler-cell k-heading-cell">
                                                    {{ day | kendoDate: 'EEEE' }}
                                                </th>
                                            </ng-container>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td *ngIf="verticalResources.length">
                        <div class="k-scheduler-times k-scheduler-resources" #times>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex">
                                        <tr>
                                            <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex">
                                                <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-slot-cell k-heading-cell" [ngClass]="{ 'k-last-resource': resourceIndex === verticalResources.length - 1 }">
                                                    <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                    <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                        [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                </th>
                                            </ng-container>
                                            <th class="k-slot-cell k-heading-cell k-empty-slot">
                                            </th>
                                        </tr>
                                        <tr *ngFor="let index of (numberOfWeeks - 1) | repeat; trackBy: itemIndex">
                                            <th class="k-slot-cell k-heading-cell k-empty-slot"></th>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div 
                            class="k-scheduler-content"
                            tabindex="0"
                            #content
                            role="group"
                            [attr.aria-owns]="matchOwned(items | async)"
                            [style.overflowY]="'auto'">
                            <!-- Main content -->
                            <table class="k-scheduler-table" [class.k-scheduler-table-auto]="adaptiveSlotHeight" #contentTable role="presentation">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex">
                                        <tr *ngFor="let week of weeks;  let rangeIndex = index; trackBy: itemIndex">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex">
                                                <td *ngFor="let day of week; let index = index; trackBy: itemIndex"
                                                    [monthSlot]="day"
                                                    [eventHeight]="eventHeight"
                                                    [eventsPerDay]="eventsPerDay"
                                                    [adaptiveSlotHeight]="adaptiveSlotHeight"
                                                    [monthDaySlotTemplateRef]="monthDaySlotTemplateRef"
                                                    [resourcesByIndex]="resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    [ngClass]="daySlotClass(day, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                    [title]="cellTitle(day)"
                                                    [class.k-selected]="isSlotSelected({
                                                        start: toPlainDate(day),
                                                        end: addDay(toPlainDate(day)),
                                                        isAllDay: true,
                                                        resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                    })"
                                                    class="k-scheduler-cell"
                                                    [class.k-other-month]="isDayInPreviousMonth(day) || isDayInNextMonth(day)"
                                                    >
                                                </td>
                                            </ng-container>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async; trackBy: itemIndex">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    monthViewItem
                                        [editable]="editable"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [eventTemplate]="eventTemplateRef"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngFor="let hint of dragHints; trackBy: itemIndex;"
                                        class="k-event-drag-hint"
                                        monthViewItem
                                            [ngStyle]="hint.style"
                                            [ngClass]="hint.class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [item]="hint.item"
                                            [resources]="hint.resources">
                                    </div>

                                    <div *ngFor="let hint of resizeHints; trackBy: itemIndex;"
                                        kendoResizeHint
                                            [hint]="hint"
                                            [ngClass]="hint.class"
                                            [format]="resizeHintFormat">
                                    </div>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `,
      standalone: true,
      imports: [NgIf, NgForOf, NgTemplateOutlet, NgClass, MonthSlotComponent, MonthViewItemComponent, NgStyle, FocusableDirective, HintContainerComponent, ResizeHintComponent, RepeatPipe, ResourceIteratorPipe, DatePipe, AsyncPipe]
    }]
  }], function() {
    return [{
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }, {
      type: MonthSlotService
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: PDFService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ScrollbarWidthService
    }];
  }, {
    monthDaySlotTemplate: [{
      type: Input
    }],
    highlightOngoingEvents: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    eventsPerDay: [{
      type: Input
    }],
    adaptiveSlotHeight: [{
      type: Input
    }],
    numberOfWeeks: [{
      type: Input
    }],
    newRange: [{
      type: Input
    }],
    dateRangeFn: [{
      type: Input
    }],
    eventElements: [{
      type: ViewChildren,
      args: [MonthViewItemComponent]
    }]
  });
})();
var MonthViewComponent = class _MonthViewComponent extends ConfigurationViewBase {
  intl;
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("monthViewTitle");
  }
  /**
   * The number of events to be rendered per day. Setting this property to 'auto'
   * will display all events in the respective slot
   * ([see example](slug:month_views_scheduler#setting-the-number-of-events-per-day)).
   * > When set to `'auto'` it will automatically set the `adaptiveSlotHeight` property to `true`.
   * > If set to `0` it will be normalized internally to `1`.
   * @default 2
   */
  set eventsPerDay(events) {
    this._eventsPerDay = !events ? 1 : events;
  }
  get eventsPerDay() {
    return this._eventsPerDay;
  }
  _eventsPerDay;
  /**
   * The height of the rendered events. Setting this property to 'auto' will
   * set the height of each event automatically based on its content
   * ([see example](slug:month_views_scheduler#configuring-the-height-of-the-scheduler-events)).
   * > When set to `'auto'` it will automatically set the `adaptiveSlotHeight` property to `true`.
   */
  eventHeight;
  /**
   * Increases the slot group (row) height when containing events up to the number of displayed events
   * and reduces its height if there are less events for that specific slot group (row)
   * ([see example](slug:month_views_scheduler#enabling-the-adaptive-slot-height-of-the-scheduler)).
   * @default false
   */
  adaptiveSlotHeight;
  /**
   * The long-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * @default '{0:Y}'
   */
  selectedDateFormat = "{0:Y}";
  /**
   * The short-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting.
   * @default '{0:y}'
   */
  selectedShortDateFormat = "{0:y}";
  monthDaySlotTemplate;
  /**
   * The invariant name for this view.
   * @default 'month'
   */
  name = "month";
  get viewEventHeight() {
    return isPresent4(this.eventHeight) ? this.eventHeight : this.schedulerOptions.eventHeight || DEFAULT_EVENT_HEIGHT;
  }
  constructor(localization, changeDetector, viewContext, viewState, intl) {
    super(localization, changeDetector, viewContext, viewState);
    this.intl = intl;
  }
  ngOnChanges(changes) {
    if (changes["eventHeight"] && changes["eventHeight"].currentValue === "auto" || changes["eventsPerDay"] && changes["eventsPerDay"].currentValue === "auto") {
      this.adaptiveSlotHeight = true;
    }
    if (changes["eventHeight"] && changes["eventHeight"].currentValue === "auto" && !this.eventsPerDay || changes["adaptiveSlotHeight"] && changes["adaptiveSlotHeight"].currentValue === true && !this.eventsPerDay) {
      this.eventsPerDay = 2;
    }
  }
  /**
   * @hidden
   */
  dateRange(date, weekStart) {
    const monthStart = firstDayOfMonth(getDate(date));
    const start = firstDayInWeek(monthStart, weekStart);
    const end = addDays(start, DAYS_IN_WEEK_COUNT * WEEKS_COUNT);
    const text = this.intl.format(this.selectedDateFormat, monthStart);
    const shortText = this.intl.format(this.selectedShortDateFormat, monthStart);
    return {
      start,
      end,
      text,
      shortText
    };
  }
  /**
   * @hidden
   */
  newRange(date, direction = 1) {
    return firstDayOfMonth(addMonths(date, direction));
  }
  static ɵfac = function MonthViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MonthViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MonthViewComponent,
    selectors: [["kendo-scheduler-month-view"]],
    contentQueries: function MonthViewComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MonthDaySlotTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthDaySlotTemplate = _t.first);
      }
    },
    inputs: {
      eventsPerDay: "eventsPerDay",
      eventHeight: "eventHeight",
      adaptiveSlotHeight: "adaptiveSlotHeight",
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _MonthViewComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], ["type", "month", 3, "eventHeight", "adaptiveSlotHeight", "eventsPerDay", "eventTemplate", "slotClass", "eventClass", "eventStyles", "groupHeaderTemplate", "monthDaySlotTemplate", "selectedDateFormat", "selectedShortDateFormat", "highlightOngoingEvents", "weekStart", "dateRangeFn", "newRange"]],
    template: function MonthViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, MonthViewComponent_ng_template_0_Template, 1, 15, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [MonthViewRendererComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-month-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => MonthViewComponent)
      }],
      template: `
        <ng-template #content>
            <month-view
                type="month"
                [eventHeight]="viewEventHeight"
                [adaptiveSlotHeight]="adaptiveSlotHeight"
                [eventsPerDay]="eventsPerDay"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [monthDaySlotTemplate]="monthDaySlotTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [weekStart]="viewWeekStart"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </month-view>
        </ng-template>
    `,
      standalone: true,
      imports: [MonthViewRendererComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }];
  }, {
    eventsPerDay: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    adaptiveSlotHeight: [{
      type: Input
    }],
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    monthDaySlotTemplate: [{
      type: ContentChild,
      args: [MonthDaySlotTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var MultiWeekViewComponent = class _MultiWeekViewComponent extends ConfigurationViewBase {
  intl;
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("multiWeekViewTitle");
  }
  /**
   * The height of the rendered events. Setting this property to `'auto'` will
   * set the height of each event automatically based on its content
   * ([see example](slug:multiweek_views_scheduler#configuring-the-height-of-the-scheduler-events)).
   * > When set to `'auto'` it will automatically set the `adaptiveSlotHeight` property to `true`.
   */
  eventHeight;
  /**
   * The number of events to be rendered per day. Setting this property to 'auto'
   * will display all events in the respective slot
   * ([see example](slug:multiweek_views_scheduler#setting-the-number-of-events-per-day)).
   * > When set to `'auto'` it will automatically set the `adaptiveSlotHeight` property to `true`.
   * > If set to `0` it will be normalized internally to `1`.
   * @default 2
   */
  set eventsPerDay(events) {
    this._eventsPerDay = !events ? 1 : events;
  }
  get eventsPerDay() {
    return this._eventsPerDay;
  }
  _eventsPerDay;
  /**
   * Increases the slot group (row) height when containing events up to the number of displayed events
   * and reduces its height if there are less events for that specific slot group (row)
   * ([see example](slug:multiweek_views_scheduler#enabling-the-adaptive-slot-height-of-the-scheduler)).
   * @default false
   */
  adaptiveSlotHeight;
  /**
   * The number of weeks to be rendered.
   * @default 6
   */
  numberOfWeeks = WEEKS_COUNT;
  /**
   * The long-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * @default '{0:D} - {1:D}'
   */
  selectedDateFormat = "{0:D} - {1:D}";
  /**
   * The short-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting.
   * @default '{0:d} - {1:d}'
   */
  selectedShortDateFormat = "{0:d} - {1:d}";
  multiWeekDaySlotTemplate;
  /**
   * The invariant name for this view (`multiWeek`).
   */
  name = "multiWeek";
  get viewEventHeight() {
    return isPresent4(this.eventHeight) ? this.eventHeight : this.schedulerOptions.eventHeight || DEFAULT_EVENT_HEIGHT;
  }
  constructor(localization, changeDetector, viewContext, viewState, intl) {
    super(localization, changeDetector, viewContext, viewState);
    this.intl = intl;
  }
  ngOnChanges(changes) {
    if (changes["eventHeight"] && changes["eventHeight"].currentValue === "auto" || changes["eventsPerDay"] && changes["eventsPerDay"].currentValue === "auto") {
      this.adaptiveSlotHeight = true;
    }
    if (changes["eventHeight"] && changes["eventHeight"].currentValue === "auto" && !this.eventsPerDay || changes["adaptiveSlotHeight"] && changes["adaptiveSlotHeight"].currentValue === true && !this.eventsPerDay) {
      this.eventsPerDay = 2;
    }
  }
  /**
   * @hidden
   */
  dateRange(date, weekStart) {
    const periodStart = getDate(date);
    const start = firstDayInWeek(periodStart, weekStart);
    const end = addDays(start, DAYS_IN_WEEK_COUNT * this.numberOfWeeks);
    const text = this.intl.format(this.selectedDateFormat, start, end);
    const shortText = this.intl.format(this.selectedShortDateFormat, start, end);
    return {
      start,
      end,
      text,
      shortText
    };
  }
  /**
   * @hidden
   */
  newRange(date, direction = 1) {
    return firstDayInWeek(addWeeks(date, this.numberOfWeeks * direction));
  }
  static ɵfac = function MultiWeekViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiWeekViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiWeekViewComponent,
    selectors: [["kendo-scheduler-multi-week-view"]],
    contentQueries: function MultiWeekViewComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MultiWeekDaySlotTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiWeekDaySlotTemplate = _t.first);
      }
    },
    inputs: {
      eventHeight: "eventHeight",
      eventsPerDay: "eventsPerDay",
      adaptiveSlotHeight: "adaptiveSlotHeight",
      numberOfWeeks: "numberOfWeeks",
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _MultiWeekViewComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], ["type", "multiWeek", 3, "eventHeight", "adaptiveSlotHeight", "eventsPerDay", "eventTemplate", "slotClass", "eventClass", "eventStyles", "groupHeaderTemplate", "monthDaySlotTemplate", "selectedDateFormat", "selectedShortDateFormat", "highlightOngoingEvents", "weekStart", "numberOfWeeks", "dateRangeFn", "newRange"]],
    template: function MultiWeekViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, MultiWeekViewComponent_ng_template_0_Template, 1, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [MonthViewRendererComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiWeekViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-multi-week-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => MultiWeekViewComponent)
      }],
      template: `
        <ng-template #content>
            <month-view
                type="multiWeek"
                [eventHeight]="viewEventHeight"
                [adaptiveSlotHeight]="adaptiveSlotHeight"
                [eventsPerDay]="eventsPerDay"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [monthDaySlotTemplate]="multiWeekDaySlotTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [weekStart]="viewWeekStart"
                [numberOfWeeks]="numberOfWeeks"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </month-view>
        </ng-template>
    `,
      standalone: true,
      imports: [MonthViewRendererComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }];
  }, {
    eventHeight: [{
      type: Input
    }],
    eventsPerDay: [{
      type: Input
    }],
    adaptiveSlotHeight: [{
      type: Input
    }],
    numberOfWeeks: [{
      type: Input
    }],
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    multiWeekDaySlotTemplate: [{
      type: ContentChild,
      args: [MultiWeekDaySlotTemplateDirective]
    }]
  });
})();
var EVENT_HEIGHT = "eventHeight";
var SHOW_WORK_HOURS = "showWorkHours";
var START_TIME = "startTime";
var END_TIME = "endTime";
var WORK_DAY_START = "workDayStart";
var WORK_DAY_END = "workDayEnd";
var WORK_WEEK_START = "workWeekStart";
var WORK_WEEK_END = "workWeekEnd";
var SLOT_DURATION = "slotDuration";
var SLOT_DIVISIONS = "slotDivisions";
var CURRENT_TIME_MARKER = "currentTimeMarker";
var HIGHLIGHT_ONGOING_EVENTS = "highlightOngoingEvents";
var DayTimeViewBase = class _DayTimeViewBase extends ConfigurationViewBase {
  /**
   * @hidden
   */
  timeSlotTemplate;
  /**
   * @hidden
   */
  dateHeaderTemplate;
  /**
   * @hidden
    */
  majorTimeHeaderTemplate;
  /**
   * @hidden
   */
  minorTimeHeaderTemplate;
  /**
   * If set to `true`, the view will be initially shown in the business-hours mode.
   * By default, the view is displayed in the full-day mode.
   * @default false
   */
  showWorkHours;
  /**
   * Specifies whether to display the footer of the Scheduler.
   */
  showFooter;
  /**
   * The height of the events.
   */
  eventHeight;
  /**
   * The start time of the view. The Scheduler displays events which start after the start time.
   * Accepts string values in the `HH:mm` format.
   */
  startTime;
  /**
   * The time to which the view will initially be scrolled.
   * Accepts string values in the `HH:mm` format or a JavaScript `Date`.
   */
  scrollTime;
  /**
   * The end time of the view. The Scheduler displays events which end before the end time.
   * Accepts string values in the `HH:mm` format.
   */
  endTime;
  /**
   * The start time of the view when `showWorkHours` is set to `true`.
   * Accepts string values in the `HH:mm` format.
   */
  workDayStart;
  /**
   * The end time of the view when `showWorkHours` is set to `true`.
   * Accepts string values in the `HH:mm` format.
   */
  workDayEnd;
  /**
   * The start of the work week.
   */
  workWeekStart;
  /**
   * The end of the work week.
   */
  workWeekEnd;
  /**
   * The duration (in minutes) of the time slots.
   */
  slotDuration;
  /**
   * The number of divisions of the time slots.
   */
  slotDivisions;
  /**
   * Specifies the settings for the current time marker of the Scheduler.
   */
  currentTimeMarker;
  /**
   * @hidden
   */
  get viewEventHeight() {
    return this.optionValue(EVENT_HEIGHT) || DEFAULT_EVENT_HEIGHT;
  }
  /**
   * @hidden
   */
  get shouldShowWorkHours() {
    return this.optionValue(SHOW_WORK_HOURS);
  }
  /**
   * @hidden
   */
  get viewStartTime() {
    return this.optionValue(START_TIME);
  }
  /**
   * @hidden
   */
  get viewEndTime() {
    return this.optionValue(END_TIME);
  }
  /**
   * @hidden
   */
  get viewWorkDayStart() {
    return this.optionValue(WORK_DAY_START);
  }
  /**
   * @hidden
   */
  get viewWorkDayEnd() {
    return this.optionValue(WORK_DAY_END);
  }
  /**
   * @hidden
   */
  get viewWorkWeekStart() {
    return this.optionValue(WORK_WEEK_START);
  }
  /**
   * @hidden
   */
  get viewWorkWeekEnd() {
    return this.optionValue(WORK_WEEK_END);
  }
  /**
   * @hidden
   */
  get viewSlotDuration() {
    return this.optionValue(SLOT_DURATION);
  }
  /**
   * @hidden
   */
  get viewSlotDivisions() {
    return this.optionValue(SLOT_DIVISIONS);
  }
  /**
   * @hidden
   */
  get viewCurrentTimeMarker() {
    return this.optionValue(CURRENT_TIME_MARKER);
  }
  /**
   * @hidden
   */
  get viewHighlightOngoingEvents() {
    return this.optionValue(HIGHLIGHT_ONGOING_EVENTS);
  }
  /**
   * @hidden
   */
  get viewScrollTime() {
    return this.optionValue("scrollTime");
  }
  /**
   * @hidden
   */
  get viewShowFooter() {
    return isPresent4(this.showFooter) ? this.showFooter : this.schedulerOptions.showFooter;
  }
  constructor(localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  optionValue(name) {
    return isPresent4(this[name]) ? this[name] : this.schedulerOptions[name];
  }
  static ɵfac = function DayTimeViewBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DayTimeViewBase)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DayTimeViewBase,
    contentQueries: function DayTimeViewBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TimeSlotTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DateHeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MajorTimeHeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MinorTimeHeaderTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timeSlotTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateHeaderTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.majorTimeHeaderTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.minorTimeHeaderTemplate = _t.first);
      }
    },
    inputs: {
      showWorkHours: "showWorkHours",
      showFooter: "showFooter",
      eventHeight: "eventHeight",
      startTime: "startTime",
      scrollTime: "scrollTime",
      endTime: "endTime",
      workDayStart: "workDayStart",
      workDayEnd: "workDayEnd",
      workWeekStart: "workWeekStart",
      workWeekEnd: "workWeekEnd",
      slotDuration: "slotDuration",
      slotDivisions: "slotDivisions",
      currentTimeMarker: "currentTimeMarker"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DayTimeViewBase, [{
    type: Directive
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    timeSlotTemplate: [{
      type: ContentChild,
      args: [TimeSlotTemplateDirective, {
        static: false
      }]
    }],
    dateHeaderTemplate: [{
      type: ContentChild,
      args: [DateHeaderTemplateDirective, {
        static: false
      }]
    }],
    majorTimeHeaderTemplate: [{
      type: ContentChild,
      args: [MajorTimeHeaderTemplateDirective, {
        static: false
      }]
    }],
    minorTimeHeaderTemplate: [{
      type: ContentChild,
      args: [MinorTimeHeaderTemplateDirective, {
        static: false
      }]
    }],
    showWorkHours: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    startTime: [{
      type: Input
    }],
    scrollTime: [{
      type: Input
    }],
    endTime: [{
      type: Input
    }],
    workDayStart: [{
      type: Input
    }],
    workDayEnd: [{
      type: Input
    }],
    workWeekStart: [{
      type: Input
    }],
    workWeekEnd: [{
      type: Input
    }],
    slotDuration: [{
      type: Input
    }],
    slotDivisions: [{
      type: Input
    }],
    currentTimeMarker: [{
      type: Input
    }]
  });
})();
var SLOT_FILL = "slotFill";
var ALL_DAY_SLOT = "allDaySlot";
var MultiDayViewBase = class _MultiDayViewBase extends DayTimeViewBase {
  /**
   * Numeric value between 0 and 1 that specifies what percentage of the slot should be filled by the events.
   *
   * @default 0.9
   */
  slotFill;
  /**
   * @hidden
   */
  get viewSlotFill() {
    return this.optionValue(SLOT_FILL);
  }
  /**
   * Toggles the all-day slot.
   * @default true
   */
  allDaySlot;
  /**
   * @hidden
   */
  get viewAllDaySlot() {
    return this.optionValue(ALL_DAY_SLOT);
  }
  constructor(localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  static ɵfac = function MultiDayViewBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiDayViewBase)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiDayViewBase,
    inputs: {
      slotFill: "slotFill",
      allDaySlot: "allDaySlot"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiDayViewBase, [{
    type: Directive
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    slotFill: [{
      type: Input
    }],
    allDaySlot: [{
      type: Input
    }]
  });
})();
var ViewFooterComponent = class _ViewFooterComponent {
  hostClasses = true;
  toolbarRole = "toolbar";
  sub;
  /**
   * @hidden
   * TODO: Drop in next MAJOR version
   */
  inlineJustifyContentStyle = "start";
  itemClick = new EventEmitter();
  items;
  constructor(viewState) {
    this.sub = viewState.toggleWorkHours.subscribe(() => this.itemClick.emit());
  }
  ngOnDestroy() {
    this.sub && this.sub.unsubscribe();
  }
  onItemClick(e, item) {
    e.preventDefault();
    this.itemClick.emit(item);
  }
  static ɵfac = function ViewFooterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewFooterComponent)(ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ViewFooterComponent,
    selectors: [["", "viewFooter", ""]],
    hostVars: 11,
    hostBindings: function ViewFooterComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.toolbarRole);
        ɵɵstyleProp("justify-content", ctx.inlineJustifyContentStyle);
        ɵɵclassProp("k-scheduler-footer", ctx.hostClasses)("k-toolbar", ctx.hostClasses)("k-toolbar-solid", ctx.hostClasses)("k-toolbar-md", ctx.hostClasses);
      }
    },
    inputs: {
      items: "items"
    },
    outputs: {
      itemClick: "itemClick"
    },
    attrs: _c362,
    decls: 2,
    vars: 1,
    consts: [[1, "k-scheduler-navigation"], ["type", "button", "kendoButton", "", "containerType", "footer", 3, "icon", "svgIcon", "ngClass", "kendoSchedulerFocusIndex", "click", 4, "ngFor", "ngForOf"], ["type", "button", "kendoButton", "", "containerType", "footer", 3, "click", "icon", "svgIcon", "ngClass", "kendoSchedulerFocusIndex"], [1, "k-button-text"]],
    template: function ViewFooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵtemplate(1, ViewFooterComponent_button_1_Template, 3, 5, "button", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.items);
      }
    },
    dependencies: [NgForOf, ButtonComponent, NgClass, FocusableDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewFooterComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[viewFooter]",
      template: `
        <span class="k-scheduler-navigation">
            <button
                *ngFor="let item of items"
                type="button"
                kendoButton
                [icon]="item.fontIcon"
                [svgIcon]="item.svgIcon"
                [ngClass]="item.cssClass"
                (click)="onItemClick($event, item)"
                [kendoSchedulerFocusIndex]="0"
                containerType='footer'>
                <span class="k-button-text">{{ item.text }}</span>
            </button>
        </span>
    `,
      standalone: true,
      imports: [NgForOf, ButtonComponent, NgClass, FocusableDirective]
    }]
  }], function() {
    return [{
      type: ViewStateService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-scheduler-footer"]
    }, {
      type: HostBinding,
      args: ["class.k-toolbar"]
    }, {
      type: HostBinding,
      args: ["class.k-toolbar-solid"]
    }, {
      type: HostBinding,
      args: ["class.k-toolbar-md"]
    }],
    toolbarRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    inlineJustifyContentStyle: [{
      type: HostBinding,
      args: ["style.justify-content"]
    }],
    itemClick: [{
      type: Output
    }],
    items: [{
      type: Input
    }]
  });
})();
var WorkHoursFooterDirective = class _WorkHoursFooterDirective {
  footer;
  localization;
  showWorkHours = false;
  footerItems = [{
    cssClass: "k-scheduler-fullday",
    fontIcon: "clock",
    svgIcon: clockIcon,
    text: ""
  }];
  constructor(footer, localization) {
    this.footer = footer;
    this.localization = localization;
  }
  ngOnInit() {
    this.toggleWorkHours();
    this.footer.items = this.footerItems;
  }
  ngOnChanges() {
    this.toggleWorkHours();
  }
  toggleWorkHours() {
    this.footerItems[0].text = this.showWorkHours ? this.localization.get("showFullDay") : this.localization.get("showWorkDay");
  }
  static ɵfac = function WorkHoursFooterDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WorkHoursFooterDirective)(ɵɵdirectiveInject(ViewFooterComponent), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _WorkHoursFooterDirective,
    selectors: [["", "kendoWorkHoursFooter", ""]],
    inputs: {
      showWorkHours: "showWorkHours"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WorkHoursFooterDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoWorkHoursFooter]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ViewFooterComponent
    }, {
      type: LocalizationService
    }];
  }, {
    showWorkHours: [{
      type: Input
    }]
  });
})();
var EVENTS_OFFSET = 10;
var MIN_EVENT_HEIGHT = 25;
var minHeightOverlaps = (top1, top2) => top1 <= top2 && top2 <= top1 + MIN_EVENT_HEIGHT;
var timeOffset = (slot, date, vertical = true) => {
  if (slot.start.getTime() <= date.getTime()) {
    return (vertical ? slot.height : slot.width) * ((date.getTime() - slot.start.getTime()) / (slot.end.getTime() - slot.start.getTime()));
  }
  return 0;
};
var columnIndexComparer = (a, b) => {
  const indexA = isNumber3(a.columnIndex) ? a.columnIndex : Number.MAX_VALUE;
  const indexB = isNumber3(b.columnIndex) ? b.columnIndex : Number.MAX_VALUE;
  if (indexA === indexB) {
    return a.item.startTime.getTime() - b.item.startTime.getTime();
  }
  return indexA - indexB;
};
function initTimeColumns(slotKeys, slotItems) {
  let columns = 0;
  let groupSlots = [];
  slotKeys.forEach((key) => {
    const {
      slot,
      events
    } = slotItems[key];
    const count = events.length;
    let groupEnd = true;
    events.sort(columnIndexComparer);
    columns = Math.max(count, columns);
    groupSlots.push(slot);
    for (let eventIdx = 0; eventIdx < count; eventIdx++) {
      const event2 = events[eventIdx];
      groupEnd = groupEnd && event2.item.endTime.getTime() <= slot.end.getTime();
      if (isNumber3(event2.columnIndex)) {
        continue;
      }
      event2.rect = {
        top: slot.rect.top + timeOffset(slot, event2.item.startTime)
      };
      event2.columnIndex = eventIdx;
      event2.lastColumn = true;
      for (let idx2 = 0, previousIdx = -1; idx2 < eventIdx; idx2++) {
        const current = events[idx2];
        if (current.columnIndex > previousIdx + 1) {
          event2.columnIndex = previousIdx + 1;
          event2.lastColumn = false;
          events.splice(eventIdx, 1);
          events.splice(event2.columnIndex, 0, event2);
          break;
        }
        if (!intersects(event2.item.startTime, event2.item.endTime, current.item.startTime, current.item.endTime) && !minHeightOverlaps(current.rect.top, event2.rect.top)) {
          event2.columnIndex = idx2;
          event2.lastColumn = !events.some((e) => e.columnIndex && idx2 < e.columnIndex && intersects(event2.item.startTime, event2.item.endTime, e.item.startTime, e.item.endTime));
          events.splice(eventIdx, 1);
          events.splice(idx2, 0, event2);
          break;
        }
        previousIdx = current.columnIndex;
        current.lastColumn = false;
      }
    }
    if (groupEnd) {
      groupSlots.forEach((item) => item.columns = columns);
      groupSlots = [];
      columns = 0;
    }
  });
  groupSlots.forEach((slot) => slot.columns = columns);
}
function findTimeRowIndex(events, event2) {
  if (event2.rowIndex !== void 0) {
    return event2.rowIndex;
  }
  for (let idx2 = 0; idx2 < events.length; idx2++) {
    const current = events[idx2];
    if (!current || !intersects(event2.item.startTime, event2.item.endTime, current.item.startTime, current.item.endTime)) {
      return idx2;
    }
  }
  return events.length;
}
function initHorizontalSlots(slots, items, rowHeight, eventHeight, getRowIndex) {
  const padding = slots[0].padding;
  if (!items.length) {
    return {
      height: rowHeight - padding
    };
  }
  items.forEach((item) => {
    item.rowIndex = void 0;
    item.rect = {
      height: eventHeight,
      width: 0
    };
  });
  const sorted = orderBy(items, [{
    field: "item.startTime",
    dir: "asc"
  }, {
    field: "item.endTime",
    dir: "desc"
  }]);
  const slotItems = {};
  sorted.forEach((event2) => slots.filter((slot) => intersects(event2.item.startTime, event2.item.endTime, slot.start, slot.end)).forEach((slot) => {
    const value2 = slotItems[slot.key] = slotItems[slot.key] || {
      rows: [],
      slot,
      events: []
    };
    event2.rowIndex = getRowIndex(value2.rows, event2);
    value2.rows[event2.rowIndex] = event2;
    value2.events.push(event2);
  }));
  const top = slots[0].top;
  let maxOffset = 0;
  Object.keys(slotItems).forEach((key) => {
    const events = slotItems[key].events;
    let slotOffset = 0;
    for (let idx2 = 0; idx2 < events.length; idx2++) {
      const event2 = events[idx2];
      if (event2) {
        event2.rect.top = top + event2.rowIndex * (EVENTS_OFFSET + event2.rect.height);
        slotOffset = Math.max(slotOffset, event2.rect.top - top + event2.rect.height);
      }
    }
    maxOffset = Math.max(slotOffset, maxOffset);
  });
  maxOffset += rowHeight - padding;
  return {
    height: maxOffset,
    slotItems
  };
}
function setHorizontalOffsets(slotItems, items, measureTime) {
  Object.keys(slotItems).forEach((key) => {
    const {
      slot,
      events
    } = slotItems[key];
    const rect = slot.rect;
    for (let idx2 = 0; idx2 < events.length; idx2++) {
      const event2 = events[idx2];
      if (event2) {
        if (!isNumber3(event2.rect.left)) {
          event2.rect.left = slot.rect.left + (measureTime ? timeOffset(slot, event2.item.startTime, false) : 0);
        }
        const slotOffset = measureTime && event2.item.endTime.getTime() < slot.end.getTime() ? timeOffset(slot, event2.item.endTime, false) : rect.width;
        event2.rect.width = slot.rect.left + slotOffset - event2.rect.left;
      }
    }
  });
  items.forEach((item) => {
    item.reflow();
  });
}
var SlotRange2 = class {
  index;
  get slots() {
    return this.slotMap.toArray();
  }
  get firstSlot() {
    return this.slotMap.first;
  }
  get lastSlot() {
    return this.slotMap.last;
  }
  get items() {
    return this.itemMap.toArray();
  }
  get rect() {
    const first = this.firstSlot.rect;
    const last3 = this.lastSlot.rect;
    return {
      left: first.left,
      top: first.top,
      width: last3.left - first.left + last3.width,
      height: last3.top - first.top + last3.height
    };
  }
  slotMap = new ItemMap();
  itemMap = new ItemMap();
  slotItems;
  get start() {
    const first = this.slotMap.first;
    if (!first) {
      return null;
    }
    return first.start;
  }
  get end() {
    const last3 = this.slotMap.last;
    if (!last3) {
      return null;
    }
    return last3.end;
  }
  get hasSlots() {
    return this.slotMap.count > 0;
  }
  get hasItems() {
    return this.itemMap.count > 0;
  }
  constructor(index) {
    this.index = index;
  }
  registerItem(component) {
    this.itemMap.addItem(component.item.index, component);
  }
  unregisterItem(component, id) {
    this.itemMap.removeItem(id.index, component);
  }
  registerSlot(slot) {
    this.slotMap.addItem(slot.id.index, slot);
  }
  unregisterSlot(slot) {
    this.slotMap.removeItem(slot.id.index, slot);
  }
  layout(options) {
    const items = this.items;
    if (!items.length) {
      return;
    }
    const fill = Math.max(Math.min(options.fill || 0.9, 1), 0.1);
    const sorted = orderBy(items, [{
      field: "item.startTime",
      dir: "asc"
    }, {
      field: "item.endTime",
      dir: "desc"
    }]);
    items.forEach((item, _index) => {
      item.rect = null;
      item.columnIndex = void 0;
    });
    const slotItems = {};
    const slots = this.slots;
    sorted.forEach((event2) => slots.filter((slot) => intersects(event2.item.startTime, event2.item.endTime, slot.start, slot.end)).forEach((slot) => {
      const value2 = slotItems[slot.key] = slotItems[slot.key] || {
        events: []
      };
      value2.slot = slot;
      value2.events.push(event2);
    }));
    const slotKeys = Object.keys(slotItems);
    initTimeColumns(slotKeys, slotItems);
    slotKeys.forEach((key) => {
      const {
        slot,
        events
      } = slotItems[key];
      const spacing = 2;
      const startOffset = 2;
      const slotRect = slot.rect;
      const slotLeft = slotRect.left;
      const columns = slot.columns;
      const slotWidth = slotRect.width * fill - (columns - 1) * spacing - startOffset;
      const origin = slotLeft + startOffset;
      const eventWidth = slotWidth / columns;
      const slotEnd = origin + slotWidth + (columns - 1) * spacing;
      events.forEach((event2) => {
        if (!isNumber3(event2.rect.left)) {
          event2.rect.left = origin + event2.columnIndex * (eventWidth + spacing);
          event2.rect.width = event2.lastColumn ? slotEnd - event2.rect.left : eventWidth;
          event2.origin = {
            left: slotLeft,
            right: slotLeft + slotRect.width
          };
        }
        const slotOffset = slot.end.getTime() <= event2.item.endTime.getTime() ? slotRect.height : timeOffset(slot, event2.item.endTime);
        event2.rect.height = slotRect.top + slotOffset - event2.rect.top;
      });
    });
    sorted.forEach((event2) => event2.reflow());
  }
  initDaySlots(rowHeight, eventHeight) {
    const slots = this.slots;
    if (!slots.length) {
      return;
    }
    const {
      height: height2,
      slotItems
    } = initHorizontalSlots(slots, this.items, rowHeight, eventHeight, findRowIndex);
    this.setSlotsHeight(height2);
    this.slotItems = slotItems;
  }
  setDayOffsets() {
    if (!this.itemMap.count || !this.slotItems) {
      return;
    }
    setHorizontalOffsets(this.slotItems, this.items);
    this.slotItems = null;
  }
  setSlotsHeight(height2) {
    this.firstSlot.height = height2;
  }
};
var DayTimeResourceGroup = class {
  index;
  dayRanges = [];
  timeRanges = [];
  slotItems;
  constructor(index) {
    this.index = index;
  }
  registerSlot(slot) {
    const range3 = this.slotRange(slot);
    range3.registerSlot(slot);
  }
  unregisterSlot(slot) {
    const range3 = this.slotRange(slot);
    range3.unregisterSlot(slot);
    if (!range3.hasSlots) {
      const ranges = this.slotRanges(slot);
      delete ranges[slot.id.rangeIndex];
    }
  }
  registerItem(component) {
    const range3 = this.itemRange(component);
    if (range3) {
      range3.registerItem(component);
      component.rangeIndex = range3.index;
      if (component.resourceIndex >= 0) {
        component.toggle(true);
      }
    } else {
      component.rangeIndex = void 0;
      component.toggle(false);
    }
  }
  unregisterItem(component, id) {
    if (component.rangeIndex !== void 0) {
      const ranges = component.item.isAllDay ? this.dayRanges : this.timeRanges;
      if (ranges[id.rangeIndex]) {
        ranges[id.rangeIndex].unregisterItem(component, id);
      }
      component.rangeIndex = void 0;
    }
  }
  forEachDateRange(callback) {
    for (let i = 0; i < this.dayRanges.length; i++) {
      callback(this.dayRanges[i]);
    }
  }
  forEachTimeRange(callback) {
    for (let i = 0; i < this.timeRanges.length; i++) {
      callback(this.timeRanges[i]);
    }
  }
  slotRange(slot) {
    const ranges = this.slotRanges(slot);
    const rangeIndex = slot.id.rangeIndex;
    if (!ranges[rangeIndex]) {
      ranges[rangeIndex] = new SlotRange2(rangeIndex);
    }
    return ranges[rangeIndex];
  }
  slotRanges(slot) {
    return slot.isDaySlot ? this.dayRanges : this.timeRanges;
  }
  initTimeSlots(rowHeight, eventHeight, resourceRowHeight) {
    const slots = this.slots;
    if (!slots.length) {
      return;
    }
    const {
      height: height2,
      slotItems
    } = initHorizontalSlots(slots, this.items, rowHeight, eventHeight, findTimeRowIndex);
    this.setSlotsHeight(Math.max(height2, resourceRowHeight));
    this.slotItems = slotItems;
  }
  setTimelineOffsets() {
    const items = this.items;
    if (!this.slotItems || !items.length) {
      return;
    }
    setHorizontalOffsets(this.slotItems, items, true);
    this.slotItems = null;
  }
  setSlotsHeight(height2) {
    this.timeRanges[0].setSlotsHeight(height2);
  }
  get items() {
    return this.timeRanges.reduce((acc, range3) => acc.concat(range3.items), []);
  }
  get slots() {
    return this.timeRanges.reduce((acc, range3) => acc.concat(range3.slots), []);
  }
  get hasSlots() {
    return Boolean(this.dayRanges.find((range3) => range3 && range3.hasSlots) || this.timeRanges.find((range3) => range3 && range3.hasSlots));
  }
  cleanRanges() {
    this.dayRanges = this.dayRanges.filter((r) => Boolean(r));
    this.timeRanges = this.timeRanges.filter((r) => Boolean(r));
  }
  itemRange(component) {
    const task = component.item;
    const ranges = task.isAllDay ? this.dayRanges : this.timeRanges;
    if (isNumber3(task.rangeIndex)) {
      return ranges[task.rangeIndex];
    }
    return ranges.find((r) => intersects(task.startTime, task.endTime, r.start, r.end));
  }
};
var DayTimeSlotService = class extends BaseSlotService {
  layoutDays(eventHeight = 25) {
    this.groups.forEach((group3) => group3.forEachDateRange((range3) => range3?.slots.forEach((slot) => {
      slot.element.nativeElement.style.height = "";
    })));
    const rowHeight = this.groups[0].dayRanges[0]?.slots[0].height;
    this.groups.forEach((group3) => {
      group3.forEachDateRange((range3) => range3.initDaySlots(rowHeight, eventHeight));
    });
    this.groups.forEach((group3) => {
      group3.forEachDateRange((range3) => range3.setDayOffsets());
    });
  }
  layoutTimeline(eventHeight, resourceRows) {
    this.groups.forEach((group3) => group3.forEachTimeRange((range3) => range3?.slots.forEach((slot) => {
      slot.element.nativeElement.style.height = "";
    })));
    const rowHeight = this.groups[0].timeRanges[0]?.slots[0].height;
    this.groups.forEach((group3, index) => {
      group3.initTimeSlots(rowHeight, eventHeight, resourceRows && resourceRows[index] ? resourceRows[index].nativeElement.children[0]?.children[0].offsetHeight : 0);
    });
    this.groups.forEach((group3) => group3.setTimelineOffsets());
  }
  layoutTimes(options) {
    this.groups.forEach((group3) => group3.forEachTimeRange((range3) => range3.layout(options)));
  }
  forEachDateRange(callback) {
    this.groups.forEach((group3, index) => {
      callback(group3.dayRanges[0], index);
    });
  }
  syncDateRanges() {
    let maxHeight = 0;
    this.groups.forEach((group3) => {
      const slot = group3.dayRanges[0]?.firstSlot;
      if (slot) {
        maxHeight = Math.max(slot.rect.height - slot.padding, maxHeight);
      }
    });
    this.groups.forEach((group3) => {
      group3.dayRanges[0]?.setSlotsHeight(maxHeight);
    });
    return maxHeight;
  }
  forEachGroup(callback) {
    this.groups.forEach(callback);
  }
  forEachSlot(callback) {
    this.groups.forEach((group3) => {
      group3.dayRanges.forEach((range3) => {
        range3?.slots.forEach((slot) => callback(slot));
      });
      group3.timeRanges.forEach((range3) => {
        range3?.slots.forEach((slot) => callback(slot));
      });
    });
  }
  createGroup(index) {
    return new DayTimeResourceGroup(index);
  }
  slotByIndex(slotIndex, allDay = false) {
    const [resourceIndex, rangeIndex, index] = slotIndex.split(":").map((part) => parseInt(part, 10));
    return this.groups[resourceIndex][allDay ? "dayRanges" : "timeRanges"][rangeIndex]?.slots[index];
  }
  slotByPosition(x, y, isDaySlot, includeDayRanges) {
    let range3;
    if (isDaySlot) {
      this.groups.find((group3) => {
        range3 = group3.dayRanges.find((r) => rectContainsX(r.rect, x, this.calculateScaleX()));
        return range3;
      });
      if (range3) {
        return range3.slots.find((slot) => rectContainsX(slot.rect, x, this.calculateScaleX()));
      }
    } else {
      this.groups.find((group3) => {
        if (includeDayRanges) {
          range3 = group3.dayRanges.find((r) => rectContains(r.rect, x, y, this.calculateScaleX()));
        }
        if (!range3) {
          range3 = group3.timeRanges.find((r) => rectContains(r.rect, x, y, this.calculateScaleX()));
        }
        return range3;
      });
      if (range3) {
        return range3.slots.find((slot) => rectContains(slot.rect, x, y, this.calculateScaleX()));
      }
    }
  }
  groupSlotByPosition(currentSlot, x, y) {
    const group3 = this.groups[currentSlot.id.resourceIndex];
    let range3;
    if (currentSlot.isDaySlot) {
      range3 = group3.dayRanges.find((r) => rectContains(r.rect, x, y, this.calculateScaleX()));
    } else {
      range3 = group3.timeRanges.find((r) => rectContains(r.rect, x, y, this.calculateScaleX()));
    }
    if (range3) {
      return range3.slots.find((slot) => rectContains(slot.rect, x, y, this.calculateScaleX()));
    }
  }
  dragRanges(currentSlot, offset2, timeRanges) {
    const start = new Date(currentSlot.start.getTime() - offset2.start);
    const end = new Date(currentSlot.start.getTime() + offset2.end);
    const group3 = this.groups[currentSlot.id.resourceIndex];
    let result;
    if (timeRanges) {
      const slotRanges = [];
      group3.timeRanges.forEach((range3) => {
        const slots = range3?.slots.filter((s) => intersects(start, end, s.start, s.end));
        if (slots.length) {
          slotRanges.push(slots);
        }
      });
      const lastRange = slotRanges[slotRanges.length - 1];
      result = [slotRanges[0][0], lastRange[lastRange.length - 1]];
    } else {
      result = group3.slotRange(currentSlot)?.slots.filter((s) => intersects(start, end, s.start, s.end));
    }
    return {
      start,
      end,
      ranges: [result]
    };
  }
  resizeRanges(currentSlot, task, resizeStart, offset2) {
    const group3 = this.groups[currentSlot.id.resourceIndex];
    const ranges = task.isAllDay ? group3.dayRanges : group3.timeRanges;
    const result = [];
    const startDate = task.start.toUTCDate();
    const endDate = task.end.toUTCDate();
    let start, end;
    if (resizeStart) {
      const startTime = currentSlot.start.getTime() + offset2.start;
      end = startDate.getTime() === endDate.getTime() ? this.findDateSlot(endDate, ranges, true).end : endDate;
      if (startTime >= endDate.getTime()) {
        if (task.isAllDay) {
          start = new Date(Math.min(dateWithTime(endDate, startDate).getTime(), endDate.getTime()));
        } else {
          start = this.findDateSlot(end, ranges).start;
        }
      } else if (offset2.start && task.isAllDay) {
        start = new Date(startTime);
      } else {
        start = new Date(currentSlot.start.getTime());
      }
    } else {
      start = startDate;
      if (currentSlot.start.getTime() <= start.getTime()) {
        if (task.isAllDay) {
          end = new Date(Math.max(dateWithTime(startDate, endDate).getTime(), startDate.getTime()));
        } else {
          end = this.findDateSlot(start, ranges, true).end;
        }
      } else if (offset2.end && task.isAllDay) {
        end = new Date(currentSlot.start.getTime() + offset2.end);
      } else {
        end = currentSlot.end;
      }
    }
    ranges.forEach((range3) => {
      const slots = range3.slots.filter((s) => intersects(start, end, s.start, s.end));
      if (slots.length) {
        result.push(slots);
      }
    });
    return {
      start,
      end,
      ranges: result
    };
  }
  timePosition(date, resourceIndex, vertical) {
    const group3 = this.groups[resourceIndex];
    const range3 = group3.timeRanges.find((r) => dateInRange2(date, r.start, r.end));
    if (!range3) {
      return;
    }
    const slot = range3.slots.find((s) => dateInRange2(date, s.start, s.end));
    if (slot) {
      const position = (vertical ? slot.height : slot.width) * ((date.getTime() - slot.start.getTime()) / (slot.end.getTime() - slot.start.getTime()));
      return vertical ? slot.rect.top + position : slot.rect.left + position;
    }
  }
  findDateSlot(date, ranges, excludeEnd) {
    let result;
    ranges.forEach((range3) => {
      const slots = excludeEnd ? range3.slots.filter((s) => intersects(date, date, s.start, s.end)) : range3.slots.filter((s) => dateInRange2(date, s.start, s.end));
      if (slots.length) {
        result = slots[0];
      }
    });
    return result;
  }
};
var isMultiDay = ({
  start,
  end
}) => {
  const startDate = start.stripTime();
  const endDate = end.stripTime();
  return startDate.getTime() !== endDate.getTime() && (endDate.getTime() !== end.getTime() || startDate.addDays(1).getTime() !== endDate.getTime());
};
var createTasks$2 = (periodStart, periodEnd, items, ranges) => {
  const tasks = [];
  const utcStart = toUTCDate(periodStart);
  const utcEnd = toUTCDate(periodEnd);
  for (let index = 0; index < items.length; index++) {
    const item = items[index];
    const multiDay = isMultiDay(item);
    const multipleRanges = multiDay && !item.event.isAllDay;
    const isAllDay = typeof item.event.isAllDay === "boolean" ? item.event.isAllDay : multiDay && !multipleRanges;
    const endTime = (isAllDay ? roundAllDayEnd(item) : item.end).toUTCDate();
    const startTime = (isAllDay ? item.start.stripTime() : item.start).toUTCDate();
    for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {
      const rangeStart = ranges[rangeIndex].start;
      const rangeEnd = ranges[rangeIndex].end;
      if (intersects(startTime, endTime, rangeStart, rangeEnd)) {
        const task = {
          index,
          isAllDay,
          startTime,
          endTime,
          rangeIndex: isAllDay ? 0 : rangeIndex,
          start: item.start,
          end: item.end,
          event: item.event
        };
        tasks.push(task);
        if (!multipleRanges) {
          task.head = utcEnd < endTime;
          task.tail = startTime < utcStart;
          break;
        } else {
          const nextRange = ranges[rangeIndex + 1];
          const previousRange = ranges[rangeIndex - 1];
          task.head = (nextRange ? nextRange.start : utcEnd) < endTime;
          task.tail = startTime < (previousRange ? previousRange.end : utcStart);
        }
      }
    }
  }
  return sortTasksByTime(tasks);
};
function createTimeSlots(intlService, {
  showWorkHours,
  startTime,
  endTime,
  workDayStart,
  workDayEnd,
  slotDivisions,
  slotDuration
}) {
  const startDate = intlService.parseDate(showWorkHours ? workDayStart : startTime);
  const start = toInvariantTime(startDate).getTime();
  const endDate = intlService.parseDate(showWorkHours ? workDayEnd : endTime);
  let end = toInvariantTime(endDate).getTime();
  if (end <= start) {
    end = toInvariantTime(MIDNIGHT_INVARIANT).getTime() + MS_PER_DAY2;
  }
  const slots = [];
  const duration2 = Math.round(slotDuration / slotDivisions * MS_PER_MINUTE3);
  let slotTime = start;
  let index = 0;
  while (slotTime < end) {
    slots.push({
      start: new Date(slotTime),
      end: new Date(slotTime + duration2),
      isMajor: index % slotDivisions === 0
    });
    index++;
    slotTime += duration2;
  }
  return slots;
}
var DayTimeViewItemComponent = class _DayTimeViewItemComponent extends BaseViewItem {
  intlService;
  localeId;
  caretAltLeftIcon = caretAltLeftIcon;
  caretAltRightIcon = caretAltRightIcon;
  caretAltUpIcon = caretAltUpIcon;
  caretAltDownIcon = caretAltDownIcon;
  arrowRotateCwIcon = arrowRotateCwIcon;
  arrowsNoRepeatIcon = arrowsNoRepeatIcon;
  xIcon = xIcon;
  vertical;
  isAllDay;
  get eventTime() {
    return this.intlService.format("{0:t}–{1:t}", toLocalDate(this.item.startTime), toLocalDate(this.item.endTime));
  }
  constructor(intlService, slotService, localization, focusService, element, renderer, localeId) {
    super(slotService, localization, focusService, element, renderer, localeId);
    this.intlService = intlService;
    this.localeId = localeId;
  }
  static ɵfac = function DayTimeViewItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DayTimeViewItemComponent)(ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(DayTimeSlotService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(FocusService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LOCALE_ID));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DayTimeViewItemComponent,
    selectors: [["", "dayTimeViewItem", ""]],
    inputs: {
      vertical: "vertical",
      isAllDay: "isAllDay"
    },
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c372,
    decls: 13,
    vars: 11,
    consts: [[1, "k-event-actions"], [3, "name", "svgIcon", 4, "ngIf"], ["name", "arrow-rotate-cw", 3, "svgIcon", 4, "ngIf"], ["name", "arrows-no-repeat", 3, "svgIcon", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], ["class", "k-link k-event-delete", "aria-hidden", "true", 4, "ngIf"], ["class", "k-event-top-actions", 4, "ngIf"], ["class", "k-event-bottom-actions", 4, "ngIf"], [3, "name", "svgIcon"], ["name", "arrow-rotate-cw", 3, "svgIcon"], ["name", "arrows-no-repeat", 3, "svgIcon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "k-event-template k-event-time", 4, "ngIf"], ["aria-hidden", "true", 1, "k-event-template"], [1, "k-event-template", "k-event-time"], ["aria-hidden", "true", 1, "k-link", "k-event-delete"], ["name", "x", 3, "svgIcon"], [1, "k-event-top-actions"], ["name", "caret-alt-up", 3, "svgIcon"], [1, "k-event-bottom-actions"], ["name", "caret-alt-down", 3, "svgIcon"], ["class", "k-resize-handle k-resize-n", 4, "ngIf"], ["class", "k-resize-handle k-resize-s", 4, "ngIf"], [1, "k-resize-handle", "k-resize-n"], [1, "k-resize-handle", "k-resize-s"], [1, "k-resize-handle", "k-resize-w"], [1, "k-resize-handle", "k-resize-e"]],
    template: function DayTimeViewItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵtemplate(1, DayTimeViewItemComponent_kendo_icon_wrapper_1_Template, 1, 2, "kendo-icon-wrapper", 1)(2, DayTimeViewItemComponent_kendo_icon_wrapper_2_Template, 1, 1, "kendo-icon-wrapper", 2)(3, DayTimeViewItemComponent_kendo_icon_wrapper_3_Template, 1, 1, "kendo-icon-wrapper", 3);
        ɵɵelementEnd();
        ɵɵtemplate(4, DayTimeViewItemComponent_ng_container_4_Template, 1, 6, "ng-container", 4)(5, DayTimeViewItemComponent_div_5_Template, 4, 3, "div", 5);
        ɵɵelementStart(6, "span", 0);
        ɵɵtemplate(7, DayTimeViewItemComponent_span_7_Template, 2, 2, "span", 6)(8, DayTimeViewItemComponent_kendo_icon_wrapper_8_Template, 1, 2, "kendo-icon-wrapper", 1);
        ɵɵelementEnd();
        ɵɵtemplate(9, DayTimeViewItemComponent_span_9_Template, 2, 1, "span", 7)(10, DayTimeViewItemComponent_span_10_Template, 2, 1, "span", 8)(11, DayTimeViewItemComponent_ng_container_11_Template, 3, 2, "ng-container", 5)(12, DayTimeViewItemComponent_ng_container_12_Template, 3, 0, "ng-container", 5);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.item.tail && !ctx.vertical);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isRecurrence);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isRecurrenceException);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.eventTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.eventTemplate);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.removable);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.item.head && !ctx.vertical);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.item.tail && ctx.vertical);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.item.head && ctx.vertical);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.resizable && ctx.vertical);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.resizable && !ctx.vertical);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DayTimeViewItemComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[dayTimeViewItem]",
      template: `
        <span class="k-event-actions">
            <kendo-icon-wrapper
                *ngIf="item.tail && !vertical"
                [name]="arrowIcons[0]"
                [svgIcon]="arrowSVGIcons[0]"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrence"
                name="arrow-rotate-cw"
                [svgIcon]="arrowRotateCwIcon"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrenceException"
                name="arrows-no-repeat"
                [svgIcon]="arrowsNoRepeatIcon"
                >
            </kendo-icon-wrapper>
        </span>
        <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
            [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: resources }">
        </ng-container>
        <div *ngIf="!eventTemplate" [attr.title]="eventTitle">
            <div class="k-event-template k-event-time" *ngIf="!isAllDay">{{ eventTime }}</div>
            <div class="k-event-template" aria-hidden="true">{{ item.event.title }}</div>
        </div>

        <span class="k-event-actions">
            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
            <kendo-icon-wrapper
                *ngIf="item.head && !vertical"
                [name]="arrowIcons[1]"
                [svgIcon]="arrowSVGIcons[1]"
                >
            </kendo-icon-wrapper>
        </span>

        <span class="k-event-top-actions" *ngIf="item.tail && vertical">
            <kendo-icon-wrapper name="caret-alt-up" [svgIcon]="caretAltUpIcon"></kendo-icon-wrapper>
        </span>

        <span class="k-event-bottom-actions" *ngIf="item.head && vertical">
            <kendo-icon-wrapper name="caret-alt-down" [svgIcon]="caretAltDownIcon"></kendo-icon-wrapper>
        </span>

        <ng-container *ngIf="resizable && vertical">
            <span class="k-resize-handle k-resize-n" *ngIf="!item.tail"></span>
            <span class="k-resize-handle k-resize-s" *ngIf="!item.head"></span>
        </ng-container>

        <ng-container *ngIf="resizable && !vertical">
            <span class="k-resize-handle k-resize-w"></span>
            <span class="k-resize-handle k-resize-e"></span>
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: IntlService
    }, {
      type: DayTimeSlotService
    }, {
      type: LocalizationService
    }, {
      type: FocusService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, {
    vertical: [{
      type: Input
    }],
    isAllDay: [{
      type: Input
    }]
  });
})();
var getStartDate = (date) => getDate(date);
var getEndDate = (start, numberOfDays) => getDate(addDays(start, numberOfDays || 1));
var getNextDate = (date, count, numberOfDays) => getDate(addDays(date, numberOfDays * count));
var DayTimeViewComponent = class _DayTimeViewComponent extends BaseView {
  changeDetector;
  timeSlotTemplate;
  dateHeaderTemplate;
  majorTimeHeaderTemplate;
  minorTimeHeaderTemplate;
  numberOfDays = 1;
  scrollTime;
  startTime = "00:00";
  endTime = "00:00";
  workDayStart = "08:00";
  workDayEnd = "17:00";
  workWeekStart = 1;
  workWeekEnd = 5;
  slotDuration = 60;
  slotDivisions = 2;
  showWorkHours = false;
  getStartDate = getStartDate;
  getEndDate = getEndDate;
  getNextDate = getNextDate;
  currentTimeMarker;
  highlightOngoingEvents;
  currentTimeElements;
  eventElements;
  currentTimeArrows;
  name;
  workDayStartTime;
  workDayEndTime;
  daySlots = [];
  timeSlots = [];
  resizeHintFormat = "t";
  showCurrentTime = false;
  get classNames() {
    return `k-scheduler-${this.name}view`;
  }
  get timeSlotTemplateRef() {
    return this.timeSlotTemplate || (this.schedulerTimeSlotTemplate || {}).templateRef;
  }
  get dateHeaderTemplateRef() {
    return this.dateHeaderTemplate || (this.schedulerDateHeaderTemplate || {}).templateRef;
  }
  get majorTimeHeaderTemplateRef() {
    return this.majorTimeHeaderTemplate || (this.schedulerMajorTimeHeaderTemplate || {}).templateRef;
  }
  get minorTimeHeaderTemplateRef() {
    return this.minorTimeHeaderTemplate || (this.schedulerMinorTimeHeaderTemplate || {}).templateRef;
  }
  schedulerTimeSlotTemplate;
  schedulerDateHeaderTemplate;
  schedulerMajorTimeHeaderTemplate;
  schedulerMinorTimeHeaderTemplate;
  currentTimeTimeout;
  ongoingEventsTimeout;
  currentDate;
  verticalTime = true;
  initialUpdate = true;
  constructor(changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, scrollBarWidthService) {
    super(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, changeDetector, scrollBarWidthService);
    this.changeDetector = changeDetector;
    this.updateCurrentTime = this.updateCurrentTime.bind(this);
    this.toggleOngoingClass = this.toggleOngoingClass.bind(this);
    this.updateOngoingEvents = this.updateOngoingEvents.bind(this);
  }
  ngOnChanges(changes) {
    if (changes.startTime || changes.endTime || changes.showWorkHours || changes.workDayStart || changes.workDayEnd || changes.workWeekStart || changes.workWeekEnd || changes.slotDivisions || changes.slotDuration) {
      this.timeSlots = this.createTimeSlots();
      this.initWorkDay();
      this.changes.next(null);
    }
    if (isChanged("currentTimeMarker", changes)) {
      this.showCurrentTime = this.enableCurrentTime();
    }
    if (isChanged("weekStart", changes)) {
      this.onSelectDate(this.selectedDate);
    }
    super.ngOnChanges(changes);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    clearTimeout(this.currentTimeTimeout);
    clearTimeout(this.ongoingEventsTimeout);
  }
  verticalItem(leafIndex, resourceIndex) {
    const data = this.verticalResources[resourceIndex].data || [];
    const resources = this.verticalResources;
    let result = 1;
    for (let idx2 = resourceIndex + 1; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return data[leafIndex / result % data.length];
  }
  timeSlotClass(slot, date, resourceIndex) {
    if (this.slotClass) {
      return this.slotClass({
        start: dateWithTime(date, slot.start),
        end: dateWithTime(date, slot.end),
        resources: this.resourcesByIndex(resourceIndex),
        isAllDay: false
      });
    }
  }
  toggleOngoingClass() {
    const now = this.currentTime();
    const cssClass = isPresent4(this.highlightOngoingEvents.cssClass) ? this.highlightOngoingEvents.cssClass : ONGOING_EVENT_CSS_CLASS;
    this.eventElements.forEach((event2) => {
      const isOngoing = dateInRange2(now, event2.item.start, event2.item.end);
      this.renderer[isOngoing ? "addClass" : "removeClass"](event2.nativeElement, cssClass);
    });
  }
  scrollToTime(time = this.scrollTime) {
    let date;
    if (typeof time === "string") {
      const scrollDate = this.intl.parseDate(time);
      if (!scrollDate) {
        return;
      }
      date = toUTCTime(this.daySlots[0].start, scrollDate);
    } else {
      date = toUTCDateTime2(time);
    }
    const position = this.slotService.timePosition(date, 0, this.verticalTime);
    if (isNumber3(position)) {
      const contentElement = this.content.nativeElement;
      contentElement[this.verticalTime ? "scrollTop" : "scrollLeft"] = this.localization.rtl && !this.verticalTime ? rtlScrollPosition(contentElement, position) : position;
    }
  }
  optionsChange(options) {
    this.schedulerTimeSlotTemplate = options.timeSlotTemplate;
    this.schedulerDateHeaderTemplate = options.dateHeaderTemplate;
    this.schedulerMajorTimeHeaderTemplate = options.majorTimeHeaderTemplate;
    this.schedulerMinorTimeHeaderTemplate = options.minorTimeHeaderTemplate;
    super.optionsChange(options);
  }
  updateView() {
    super.updateView();
    this.updateCurrentTime();
    this.updateOngoingEvents();
    if (this.initialUpdate) {
      this.scrollToTime();
      this.initialUpdate = false;
    }
  }
  enableCurrentTime() {
    if (!this.currentTimeMarker || this.currentTimeMarker.enabled === false || !this.selectedDate) {
      return false;
    }
    const dateRange = this.dateRange();
    this.currentDate = ZonedDate.fromLocalDate(this.currentTime(), this.currentTimeMarker.localTimezone !== false ? "" : this.timezone);
    const localTime = this.currentDate.toLocalDate();
    const invariantTime = toInvariantTime(localTime);
    const timeSlots = this.timeSlots;
    const inDateRange = dateInRange2(localTime, dateRange.start, dateRange.end);
    const inTimeRange = timeSlots.length && dateInRange2(invariantTime, timeSlots[0].start, timeSlots[timeSlots.length - 1].end);
    return inDateRange && inTimeRange;
  }
  currentTime() {
    return /* @__PURE__ */ new Date();
  }
  updateCurrentTime() {
    if (!isDocumentAvailable()) {
      return;
    }
    const enable = this.enableCurrentTime();
    if (enable !== this.showCurrentTime) {
      this.showCurrentTime = enable;
      this.changeDetector.detectChanges();
    }
    clearTimeout(this.currentTimeTimeout);
    if (enable) {
      this.zone.runOutsideAngular(() => {
        this.currentTimeTimeout = setTimeout(this.updateCurrentTime, this.currentTimeMarker.updateInterval || MS_PER_MINUTE3);
      });
      this.positionCurrentTime();
    }
  }
  updateOngoingEvents() {
    const disabled = !this.highlightOngoingEvents || this.highlightOngoingEvents.enabled === false;
    if (!isDocumentAvailable() || disabled) {
      return;
    }
    clearTimeout(this.ongoingEventsTimeout);
    this.zone.runOutsideAngular(() => {
      this.ongoingEventsTimeout = setTimeout(this.updateOngoingEvents, this.highlightOngoingEvents.updateInterval || MS_PER_MINUTE3);
    });
    this.toggleOngoingClass();
  }
  positionCurrentTime() {
    if (this.currentTimeElements && this.currentTimeElements.length) {
      const date = this.currentDate.toUTCDate();
      const currentTimeArrows = this.currentTimeArrows ? this.currentTimeArrows.toArray() : [];
      const arrowOffset = currentTimeArrows.length ? this.currentTimeArrowOffset() : 0;
      const arrowMid = currentTimeArrows.length ? currentTimeArrows[0].nativeElement.offsetHeight / 2 : 4;
      const tableWidth = this.contentTable.nativeElement.clientWidth;
      const tableHeight = this.contentTable.nativeElement.clientHeight;
      const vertical = this.verticalTime;
      this.currentTimeElements.forEach((element, index) => {
        const position = this.slotService.timePosition(date, index, vertical);
        if (position !== void 0) {
          const line = element.nativeElement;
          if (currentTimeArrows[index]) {
            const arrow = currentTimeArrows[index].nativeElement;
            const origin2 = vertical ? arrowOffset : position - arrowMid;
            setCoordinates(arrow, {
              top: vertical ? position - arrowMid : arrowOffset,
              left: origin2,
              right: origin2
            });
          }
          const origin = vertical ? 0 : position;
          setCoordinates(line, {
            top: vertical ? position : 0,
            left: origin,
            right: origin,
            width: vertical ? tableWidth : 1,
            height: vertical ? 1 : tableHeight
          });
        }
      });
    }
  }
  bindEvents() {
    super.bindEvents();
    this.zone.runOutsideAngular(() => {
      this.subs.add(fromClick(this.headerWrap.nativeElement).subscribe((e) => this.onHeaderClick(e)));
      this.subs.add(fromEvent(this.headerWrap.nativeElement, "contextmenu").subscribe((e) => this.onClick(e)));
      this.subs.add(fromDoubleClick(this.headerWrap.nativeElement).subscribe((e) => this.onClick(e, "dblclick")));
    });
  }
  onHeaderClick(e) {
    this.onClick(e);
    if (this.daySlots.length <= 1) {
      return;
    }
    const daySlotIndex = e.target.getAttribute("data-dayslot-index");
    if (daySlotIndex) {
      const slot = this.daySlots[parseInt(daySlotIndex, 10)];
      this.zone.run(() => {
        this.viewState.navigateTo({
          viewName: "day",
          date: slot.start
        });
      });
    }
  }
  slotByIndex(slotIndex, args) {
    return this.slotService.slotByIndex(slotIndex, args.target.hasAttribute("data-day-slot"));
  }
  onSelectDate(date) {
    this.selectedDate = date;
    this.daySlots = this.createDaySlots();
    this.showCurrentTime = this.enableCurrentTime();
    this.viewState.notifyDateRange(this.dateRange());
  }
  onAction(e) {
    const now = getDate(this.selectedDate);
    if (e.type === "next") {
      const next = this.getNextDate(now, 1, this.numberOfDays);
      if (this.isInRange(next)) {
        this.viewState.notifyNextDate(next);
      }
    }
    if (e.type === "prev") {
      const next = this.getNextDate(now, -1, this.numberOfDays);
      if (this.isInRange(next)) {
        this.viewState.notifyNextDate(next);
      }
    }
    if (e.type === "scroll-time") {
      this.scrollToTime(e.time);
    }
  }
  dateRange(date = this.selectedDate) {
    const start = this.getStartDate(date);
    const end = this.getEndDate(start, this.numberOfDays);
    const rangeEnd = this.getEndDate(start, this.numberOfDays - 1);
    const text = this.intl.format(this.selectedDateFormat, start, rangeEnd);
    const shortText = this.intl.format(this.selectedShortDateFormat, start, rangeEnd);
    return {
      start,
      end,
      text,
      shortText
    };
  }
  createDaySlots() {
    let current = this.getStartDate(this.selectedDate);
    const end = this.getEndDate(current, this.numberOfDays);
    const dates = [];
    while (current < end) {
      const next = addDays(current, 1);
      dates.push({
        start: current,
        end: next
      });
      current = next;
    }
    return dates;
  }
  createTimeSlots() {
    return createTimeSlots(this.intl, {
      showWorkHours: this.showWorkHours,
      startTime: this.startTime,
      endTime: this.endTime,
      workDayStart: this.workDayStart,
      workDayEnd: this.workDayEnd,
      slotDivisions: this.slotDivisions,
      slotDuration: this.slotDuration
    });
  }
  initWorkDay() {
    const startDate = this.intl.parseDate(this.workDayStart);
    this.workDayStartTime = toInvariantTime(startDate);
    const endDate = this.intl.parseDate(this.workDayEnd);
    if (endDate <= startDate) {
      this.workDayEndTime = addDays(MIDNIGHT_INVARIANT, 1);
    } else {
      this.workDayEndTime = toInvariantTime(endDate);
    }
  }
  slotByPosition(x, y, container) {
    const isDaySlot = container ? hasClasses(container.parentNode, "k-scheduler-header-wrap") : y < 0;
    return this.slotService.slotByPosition(x, y, isDaySlot, Boolean(this.verticalResources.length));
  }
  slotFields(slot) {
    const fields = super.slotFields(slot);
    if (slot.isDaySlot) {
      fields.isAllDay = true;
    } else {
      fields.start = this.convertDate(slot.start);
      fields.end = this.convertDate(slot.end);
    }
    return fields;
  }
  static ɵfac = function DayTimeViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DayTimeViewComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(DayTimeSlotService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ScrollbarWidthService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DayTimeViewComponent,
    selectors: [["kendo-day-time-view"]],
    viewQuery: function DayTimeViewComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c382, 5);
        ɵɵviewQuery(DayTimeViewItemComponent, 5);
        ɵɵviewQuery(_c39, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.currentTimeElements = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.eventElements = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.currentTimeArrows = _t);
      }
    },
    inputs: {
      timeSlotTemplate: "timeSlotTemplate",
      dateHeaderTemplate: "dateHeaderTemplate",
      majorTimeHeaderTemplate: "majorTimeHeaderTemplate",
      minorTimeHeaderTemplate: "minorTimeHeaderTemplate",
      numberOfDays: "numberOfDays",
      scrollTime: "scrollTime",
      startTime: "startTime",
      endTime: "endTime",
      workDayStart: "workDayStart",
      workDayEnd: "workDayEnd",
      workWeekStart: "workWeekStart",
      workWeekEnd: "workWeekEnd",
      slotDuration: "slotDuration",
      slotDivisions: "slotDivisions",
      showWorkHours: "showWorkHours",
      getStartDate: "getStartDate",
      getEndDate: "getEndDate",
      getNextDate: "getNextDate",
      currentTimeMarker: "currentTimeMarker",
      highlightOngoingEvents: "highlightOngoingEvents"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 0,
    vars: 0,
    template: function DayTimeViewComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DayTimeViewComponent, [{
    type: Component,
    args: [{
      selector: "kendo-day-time-view",
      template: ""
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }, {
      type: DayTimeSlotService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: PDFService
    }, {
      type: LocalizationService
    }, {
      type: ScrollbarWidthService
    }];
  }, {
    timeSlotTemplate: [{
      type: Input
    }],
    dateHeaderTemplate: [{
      type: Input
    }],
    majorTimeHeaderTemplate: [{
      type: Input
    }],
    minorTimeHeaderTemplate: [{
      type: Input
    }],
    numberOfDays: [{
      type: Input
    }],
    scrollTime: [{
      type: Input
    }],
    startTime: [{
      type: Input
    }],
    endTime: [{
      type: Input
    }],
    workDayStart: [{
      type: Input
    }],
    workDayEnd: [{
      type: Input
    }],
    workWeekStart: [{
      type: Input
    }],
    workWeekEnd: [{
      type: Input
    }],
    slotDuration: [{
      type: Input
    }],
    slotDivisions: [{
      type: Input
    }],
    showWorkHours: [{
      type: Input
    }],
    getStartDate: [{
      type: Input
    }],
    getEndDate: [{
      type: Input
    }],
    getNextDate: [{
      type: Input
    }],
    currentTimeMarker: [{
      type: Input
    }],
    highlightOngoingEvents: [{
      type: Input
    }],
    currentTimeElements: [{
      type: ViewChildren,
      args: ["currentTimeMarker"]
    }],
    eventElements: [{
      type: ViewChildren,
      args: [DayTimeViewItemComponent]
    }],
    currentTimeArrows: [{
      type: ViewChildren,
      args: ["currentTimeArrow"]
    }]
  });
})();
var TimeSlotDirective = class _TimeSlotDirective extends BaseSlotDirective {
  invariantStart;
  invariantEnd;
  workDayStart;
  workDayEnd;
  workWeekStart;
  workWeekEnd;
  date;
  get nonWorkHour() {
    const date = this.date.getDay();
    return this.invariantStart < this.workDayStart || this.workDayEnd < this.invariantEnd || !isWorkWeekDay(date, this.workWeekStart, this.workWeekEnd);
  }
  isDaySlot = false;
  get startLocalTime() {
    if (!this.date || !this.invariantStart) {
      return null;
    }
    return dateWithTime(this.date, this.invariantStart);
  }
  get endLocalTime() {
    if (!this.date || !this.invariantEnd) {
      return null;
    }
    return dateWithTime(this.date, this.invariantEnd);
  }
  get start() {
    if (!this.date || !this.invariantStart) {
      return null;
    }
    return toUTCTime(this.date, this.invariantStart);
  }
  get end() {
    if (!this.date || !this.invariantEnd) {
      return null;
    }
    const localEnd = toUTCTime(this.date, this.invariantEnd);
    if (INVARIANT_END.getTime() <= this.invariantEnd.getTime()) {
      return addUTCDays(localEnd, 1);
    }
    return localEnd;
  }
  constructor(element, slotService, localization) {
    super(element, slotService, localization);
  }
  static ɵfac = function TimeSlotDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimeSlotDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DayTimeSlotService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimeSlotDirective,
    selectors: [["", "timeSlot", ""]],
    hostVars: 2,
    hostBindings: function TimeSlotDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-nonwork-hour", ctx.nonWorkHour);
      }
    },
    inputs: {
      invariantStart: "invariantStart",
      invariantEnd: "invariantEnd",
      workDayStart: "workDayStart",
      workDayEnd: "workDayEnd",
      workWeekStart: "workWeekStart",
      workWeekEnd: "workWeekEnd",
      date: "date"
    },
    exportAs: ["timeSlot"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSlotDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "[timeSlot]",
      exportAs: "timeSlot",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DayTimeSlotService
    }, {
      type: LocalizationService
    }];
  }, {
    invariantStart: [{
      type: Input
    }],
    invariantEnd: [{
      type: Input
    }],
    workDayStart: [{
      type: Input
    }],
    workDayEnd: [{
      type: Input
    }],
    workWeekStart: [{
      type: Input
    }],
    workWeekEnd: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    nonWorkHour: [{
      type: HostBinding,
      args: ["class.k-nonwork-hour"]
    }]
  });
})();
var DaySlotDirective = class _DaySlotDirective extends BaseSlotDirective {
  set start(value2) {
    this.startDate = value2;
  }
  get start() {
    if (!this.startDate) {
      return null;
    }
    return toUTCDate(this.startDate);
  }
  set end(value2) {
    this.endDate = value2;
  }
  get end() {
    if (!this.endDate) {
      return null;
    }
    return toUTCDate(this.endDate);
  }
  get daySlot() {
    return true;
  }
  isDaySlot = true;
  startDate;
  endDate;
  constructor(element, slotService, localization) {
    super(element, slotService, localization);
  }
  static ɵfac = function DaySlotDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DaySlotDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DayTimeSlotService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DaySlotDirective,
    selectors: [["", "daySlot", ""]],
    hostVars: 1,
    hostBindings: function DaySlotDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("data-day-slot", ctx.daySlot);
      }
    },
    inputs: {
      start: "start",
      end: "end"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DaySlotDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "[daySlot]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DayTimeSlotService
    }, {
      type: LocalizationService
    }];
  }, {
    start: [{
      type: Input
    }],
    end: [{
      type: Input
    }],
    daySlot: [{
      type: HostBinding,
      args: ["attr.data-day-slot"]
    }]
  });
})();
var MultiDayViewRendererComponent = class _MultiDayViewRendererComponent extends DayTimeViewComponent {
  allDaySlot;
  name = "day";
  slotFill;
  allDaySlotTemplate;
  allDayEventTemplate;
  dayCells;
  headerHintContainer;
  dateFormat = {
    skeleton: "MEd"
  };
  allDayResizeHintFormat = {
    skeleton: "Md"
  };
  allDayItems = new BehaviorSubject(null);
  get allDaySlotTemplateRef() {
    return this.allDaySlotTemplate || (this.schedulerAllDaySlotTemplate || {}).templateRef;
  }
  get allDayEventTemplateRef() {
    return this.allDayEventTemplate || (this.schedulerAllDayEventTemplate || {}).templateRef;
  }
  get allDayMessage() {
    return this.localization.get("allDay");
  }
  get allDayResizeHint() {
    return this.resizing && this.resizing.task.isAllDay;
  }
  get allDayDragHint() {
    return this.dragging && this.dragging.slot.isDaySlot;
  }
  schedulerAllDaySlotTemplate;
  schedulerAllDayEventTemplate;
  dragContainers;
  constructor(localization, viewContext, viewState, intl, slotService, zone, renderer, element, changeDetector, pdfService, scrollbarWidthService) {
    super(changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, scrollbarWidthService);
  }
  optionsChange(changes) {
    this.schedulerAllDaySlotTemplate = changes.allDaySlotTemplate;
    this.schedulerAllDayEventTemplate = changes.allDayEventTemplate;
    super.optionsChange(changes);
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes.slotFill) {
      this.changes.next(null);
    }
    if (anyChanged(["startTime", "endTime", "showWorkHours", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "allDaySlot"], changes)) {
      this.viewRangeChange.next(null);
    }
    if (isChanged(
      "numberOfDays",
      changes,
      true
      /* skipFirstChange */
    ) || isChanged("weekStart", changes)) {
      this.daySlots = this.createDaySlots();
      this.viewState.notifyDateRange(this.dateRange());
    }
  }
  horizontalColspan(resourceIndex) {
    const resources = this.horizontalResources;
    let result = this.daySlots.length;
    for (let idx2 = resourceIndex + 1; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return result;
  }
  verticalRowspan(resourceIndex) {
    const resources = this.verticalResources;
    let result = this.timeSlots.length + 1;
    for (let idx2 = resourceIndex + 1; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return result;
  }
  allDaySlotClass(slot, resourceIndex) {
    if (this.slotClass) {
      return this.slotClass({
        start: slot.start,
        end: slot.end,
        resources: this.resourcesByIndex(resourceIndex),
        isAllDay: true
      });
    }
  }
  createTasks(items, dateRange) {
    const startTimeSlot = this.timeSlots[0];
    const endTimeSlot = this.timeSlots[this.timeSlots.length - 1].end;
    const nextDateEnd = !(endTimeSlot.getHours() || endTimeSlot.getMinutes());
    const ranges = this.daySlots.map((daySlot) => ({
      start: toUTCTime(daySlot.start, startTimeSlot.start),
      end: nextDateEnd ? toUTCDate(daySlot.end) : toUTCTime(daySlot.start, endTimeSlot)
    }));
    return createTasks$2(dateRange.start, dateRange.end, items, ranges);
  }
  onTasksChange() {
    this.items.next(this.tasks.filter((task) => !task.isAllDay));
    this.allDayItems.next(this.tasks.filter((task) => task.isAllDay));
  }
  reflow() {
    const slotService = this.slotService;
    if (!this.verticalResources.length) {
      this.updateContentHeight();
      this.syncTables();
    }
    this.slotService.containerSize = this.content.nativeElement.clientWidth;
    slotService.layoutDays(this.eventHeight);
    this.updateContentHeight();
    this.syncTables();
    if (this.dayCells.length) {
      const cells = this.dayCells.toArray();
      if (this.verticalResources.length) {
        slotService.forEachDateRange((range3, index) => {
          const slot = range3.firstSlot;
          cells[index].nativeElement.style.height = `${slot.rect.height - slot.padding}px`;
        });
      } else {
        const size = slotService.syncDateRanges();
        cells[0].nativeElement.style.height = `${size}px`;
      }
    }
    slotService.layoutTimes({
      fill: this.slotFill
    });
    this.syncTables();
  }
  dragHorizontal(slot) {
    return slot.isDaySlot;
  }
  updateHintContainer() {
    if (this.headerHintContainer) {
      this.headerHintContainer.detectChanges();
    }
    super.updateHintContainer();
  }
  onRelease(args) {
    super.onRelease(args);
    this.dragContainers = null;
  }
  updateDragContainer(args) {
    if (!this.dragContainers) {
      this.dragContainers = this.containers;
    }
    const container = this.dragContainers.find((c) => {
      const offset2 = c.offset;
      return offset2.top <= args.pageY && args.pageY <= offset2.top + offset2.height;
    }) || {};
    this.container = container.element;
    this.containerOffset = container.offset;
  }
  containerByPosition({
    x,
    y
  }) {
    return this.containers.find((c) => {
      const offset2 = c.offset;
      return offset2.top <= y && y <= offset2.top + offset2.height && offset2.left <= x && x <= offset2.left + offset2.width;
    });
  }
  get containers() {
    const header = this.headerWrap.nativeElement.children[1];
    const content2 = this.content.nativeElement;
    return [{
      element: content2,
      offset: elementOffset(content2)
    }, {
      element: header,
      offset: elementOffset(header)
    }];
  }
  scrollContainer(callback, args) {
    clearInterval(this.scrollInterval);
    if (this.container && this.container === this.content.nativeElement) {
      super.scrollContainer(callback, args);
    }
  }
  dragRanges(slot) {
    const task = this.dragging.task;
    if (slot.isDaySlot && !task.isAllDay) {
      return {
        ranges: [[slot]],
        start: dateWithTime(slot.start, task.start.toUTCDate()),
        end: dateWithTime(slot.start, task.end.toUTCDate()),
        isAllDay: true
      };
    }
    const allDayToTime = task.isAllDay && !slot.isDaySlot;
    const result = this.slotService.dragRanges(slot, allDayToTime ? {
      start: 0,
      end: 0
    } : this.dragging.offset);
    if (allDayToTime) {
      result.end = slot.end;
    }
    result.isAllDay = this.draggedIsAllDay(task, slot);
    return result;
  }
  dragHintEventStyleArgs() {
    return {
      event: this.dragging.task.event,
      resources: this.dragging.resourceItems,
      isAllDay: Boolean(this.allDayDragHint)
    };
  }
  draggedIsAllDay(task, slot) {
    return Boolean(slot.isDaySlot && (task.event.isAllDay || !isMultiDay(task)));
  }
  dragHintSize(firstSlot, lastSlot) {
    let width2, height2;
    if (firstSlot.isDaySlot) {
      width2 = toPx(lastSlot.rect.left - firstSlot.rect.left + lastSlot.rect.width);
      height2 = toPx(firstSlot.height);
    } else {
      width2 = toPx(firstSlot.rect.width * 0.9);
      height2 = toPx(this.dragging.task.isAllDay ? firstSlot.rect.height : lastSlot.rect.top - firstSlot.rect.top + lastSlot.rect.height);
    }
    return {
      width: width2,
      height: height2
    };
  }
  currentTimeArrowOffset() {
    if (this.verticalResources.length) {
      const el = this.times.nativeElement.querySelector(".k-scheduler-times-all-day");
      const timesEl = this.times.nativeElement;
      return this.localization.rtl ? timesEl.offsetWidth - el.offsetWidth : el.offsetLeft;
    }
    return 0;
  }
  isMiddleSlot(index) {
    return index + 1 < this.timeSlots.length && !this.timeSlots[index + 1].isMajor;
  }
  static ɵfac = function MultiDayViewRendererComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiDayViewRendererComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(DayTimeSlotService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ScrollbarWidthService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiDayViewRendererComponent,
    selectors: [["multi-day-view"]],
    viewQuery: function MultiDayViewRendererComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c40, 5);
        ɵɵviewQuery(_c41, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerHintContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dayCells = _t);
      }
    },
    inputs: {
      allDaySlot: "allDaySlot",
      name: "name",
      slotFill: "slotFill",
      allDaySlotTemplate: "allDaySlotTemplate",
      allDayEventTemplate: "allDayEventTemplate"
    },
    features: [ɵɵProvidersFeature([DayTimeSlotService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 50,
    vars: 31,
    consts: [["timesHeader", ""], ["header", ""], ["headerWrap", ""], ["times", ""], ["timesTable", ""], ["content", ""], ["contentTable", ""], ["hintContainer", ""], ["allDayCell", ""], ["headerHintContainer", ""], ["currentTimeArrow", ""], ["currentTimeMarker", ""], ["timeSlot", "timeSlot"], ["role", "presentation", 1, "k-scheduler-layout", 3, "ngClass"], [1, "k-scheduler-head"], [1, "k-scheduler-times"], ["aria-hidden", "true", 1, "k-scheduler-table"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-scheduler-cell", "k-heading-cell"], [4, "ngIf"], [1, "k-scheduler-header"], [1, "k-scheduler-header-wrap"], [1, "k-scheduler-date-group"], [3, "position", 4, "ngIf"], [1, "k-scheduler-body"], ["role", "group", "tabindex", "0", 1, "k-scheduler-content"], ["role", "presentation", 1, "k-scheduler-table"], [1, "k-scheduler-times-all-day", "k-scheduler-cell", "k-heading-cell"], ["class", "k-scheduler-cell k-heading-cell", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "k-link k-nav-day", 4, "ngIf"], [1, "k-link", "k-nav-day"], ["aria-hidden", "true", 1, "k-scheduler-table", "k-scheduler-header-all-day"], ["daySlot", "", "class", "k-scheduler-cell", 3, "start", "end", "id", "k-selected", "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["daySlot", "", 1, "k-scheduler-cell", 3, "start", "end", "id", "ngClass"], ["role", "button", "dayTimeViewItem", "", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "isAllDay", "editable", "eventTemplate", "item", "index", "rangeIndex", "resources", "resourceIndex", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "button", "dayTimeViewItem", "", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "isAllDay", "editable", "eventTemplate", "item", "index", "rangeIndex", "resources", "resourceIndex"], ["class", "k-event-drag-hint", "dayTimeViewItem", "", 3, "isAllDay", "ngStyle", "ngClass", "dragHint", "eventTemplate", "item", "resources", 4, "ngIf"], ["kendoResizeHint", "", 3, "hint", "ngClass", "format", 4, "ngIf"], ["dayTimeViewItem", "", 1, "k-event-drag-hint", 3, "isAllDay", "ngStyle", "ngClass", "dragHint", "eventTemplate", "item", "resources"], ["kendoResizeHint", "", 3, "hint", "ngClass", "format"], ["class", "k-current-time k-current-time-arrow-right", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-current-time", "k-current-time-arrow-right"], ["class", "k-scheduler-times-all-day k-scheduler-cell k-heading-cell", 4, "ngIf"], ["class", "k-scheduler-cell k-slot-cell k-heading-cell", 4, "ngIf"], [1, "k-scheduler-cell", "k-slot-cell", "k-heading-cell"], ["class", "k-scheduler-cell k-heading-cell", 3, "ngClass", 4, "ngIf"], [1, "k-scheduler-cell", "k-heading-cell", 3, "ngClass"], ["class", "k-current-time", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-current-time"], ["class", "k-scheduler-header-all-day", 4, "ngIf"], [3, "k-middle-row", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-scheduler-header-all-day"], ["daySlot", "", 3, "start", "end", "k-selected", "id", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["daySlot", "", 3, "start", "end", "id"], ["timeSlot", "", "class", "k-scheduler-cell", 3, "ngClass", "date", "invariantStart", "invariantEnd", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "id", "k-selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["timeSlot", "", 1, "k-scheduler-cell", 3, "ngClass", "date", "invariantStart", "invariantEnd", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "id"], ["role", "button", "dayTimeViewItem", "", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "editable", "vertical", "eventTemplate", "item", "index", "rangeIndex", "resources", "resourceIndex", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "button", "dayTimeViewItem", "", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "editable", "vertical", "eventTemplate", "item", "index", "rangeIndex", "resources", "resourceIndex"], ["class", "k-event-drag-hint", "role", "button", "dayTimeViewItem", "", 3, "isAllDay", "ngStyle", "ngClass", "dragHint", "eventTemplate", "resources", "item", 4, "ngIf"], ["role", "button", "dayTimeViewItem", "", 1, "k-event-drag-hint", 3, "isAllDay", "ngStyle", "ngClass", "dragHint", "eventTemplate", "resources", "item"], ["kendoResizeHint", "", 3, "hint", "ngClass", "format", 4, "ngFor", "ngForOf", "ngForTrackBy"]],
    template: function MultiDayViewRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "table", 13)(1, "tbody")(2, "tr", 14)(3, "td")(4, "div", 15, 0)(6, "table", 16)(7, "tbody");
        ɵɵtemplate(8, MultiDayViewRendererComponent_tr_8_Template, 2, 0, "tr", 17);
        ɵɵelementStart(9, "tr");
        ɵɵelement(10, "th", 18);
        ɵɵelementEnd();
        ɵɵtemplate(11, MultiDayViewRendererComponent_tr_11_Template, 4, 1, "tr", 19);
        ɵɵelementEnd()()()();
        ɵɵelementStart(12, "td")(13, "div", 20, 1)(15, "div", 21, 2)(17, "table", 16)(18, "tbody");
        ɵɵtemplate(19, MultiDayViewRendererComponent_tr_19_Template, 3, 5, "tr", 17);
        ɵɵelementStart(20, "tr", 22);
        ɵɵtemplate(21, MultiDayViewRendererComponent_ng_container_21_Template, 2, 2, "ng-container", 17);
        ɵɵpipe(22, "resourceIterator");
        ɵɵelementEnd()()();
        ɵɵtemplate(23, MultiDayViewRendererComponent_div_23_Template, 11, 10, "div", 23);
        ɵɵelementEnd()()()();
        ɵɵelementStart(24, "tr", 24)(25, "td")(26, "div", 15, 3);
        ɵɵtemplate(28, MultiDayViewRendererComponent_ng_container_28_Template, 3, 4, "ng-container", 19);
        ɵɵelementStart(29, "table", 16, 4)(31, "tbody");
        ɵɵtemplate(32, MultiDayViewRendererComponent_ng_container_32_Template, 3, 3, "ng-container", 17);
        ɵɵpipe(33, "resourceIterator");
        ɵɵelementEnd()()()();
        ɵɵelementStart(34, "td")(35, "div", 25, 5);
        ɵɵpipe(37, "async");
        ɵɵtemplate(38, MultiDayViewRendererComponent_ng_container_38_Template, 3, 4, "ng-container", 19);
        ɵɵelementStart(39, "table", 26, 6)(41, "tbody");
        ɵɵtemplate(42, MultiDayViewRendererComponent_ng_container_42_Template, 3, 3, "ng-container", 17);
        ɵɵpipe(43, "resourceIterator");
        ɵɵelementEnd()();
        ɵɵtemplate(44, MultiDayViewRendererComponent_ng_container_44_Template, 2, 2, "ng-container", 17);
        ɵɵpipe(45, "async");
        ɵɵtemplate(46, MultiDayViewRendererComponent_ng_container_46_Template, 3, 4, "ng-container", 19);
        ɵɵelementStart(47, "kendo-hint-container", null, 7);
        ɵɵtemplate(49, MultiDayViewRendererComponent_ng_template_49_Template, 2, 2, "ng-template");
        ɵɵelementEnd()()()()()();
      }
      if (rf & 2) {
        ɵɵproperty("ngClass", ctx.classNames);
        ɵɵadvance(8);
        ɵɵproperty("ngForOf", ctx.horizontalResources)("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance();
        ɵɵstyleProp("height", "auto");
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.allDaySlot && !ctx.verticalResources.length);
        ɵɵadvance(8);
        ɵɵproperty("ngForOf", ctx.horizontalResources)("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(22, 21, ctx.horizontalResources))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.allDaySlot && !ctx.verticalResources.length);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.showCurrentTime);
        ɵɵadvance(4);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(33, 23, ctx.verticalResources))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(3);
        ɵɵattribute("aria-owns", ctx.matchOwned(ɵɵpipeBind1(37, 25, ctx.items)));
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.showCurrentTime);
        ɵɵadvance(4);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(43, 27, ctx.verticalResources))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(45, 29, ctx.items))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.verticalResources.length);
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, DaySlotDirective, DayTimeViewItemComponent, NgStyle, FocusableDirective, HintContainerComponent, ResizeHintComponent, TimeSlotDirective, ResourceIteratorPipe, DatePipe, AsyncPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiDayViewRendererComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "multi-day-view",
      providers: [DayTimeSlotService],
      template: `
        <table class="k-scheduler-layout" role="presentation" [ngClass]="classNames">
            <tbody>
                <tr class="k-scheduler-head">
                    <td>
                        <div class="k-scheduler-times" #timesHeader>
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr *ngFor="let resource of horizontalResources; trackBy: itemIndex;">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                    <tr [style.height]="'auto'">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                    <tr *ngIf="allDaySlot && !verticalResources.length">
                                        <th class="k-scheduler-times-all-day k-scheduler-cell k-heading-cell" #allDayCell>{{ allDayMessage }}</th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div class="k-scheduler-header" #header>
                            <div class="k-scheduler-header-wrap" #headerWrap>
                                <table class="k-scheduler-table" aria-hidden="true">
                                    <tbody>
                                        <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex;">
                                            <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex;"
                                                class="k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                                <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                                <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef" [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                            </th>
                                        </tr>
                                        <tr class="k-scheduler-date-group">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;">
                                                <th *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex" class="k-scheduler-cell k-heading-cell">
                                                    <span *ngIf="!dateHeaderTemplateRef" class="k-link k-nav-day" [attr.data-dayslot-index]="index">{{ slot.start | kendoDate: dateFormat }}</span>
                                                    <ng-container *ngIf="dateHeaderTemplateRef" [ngTemplateOutlet]="dateHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }"></ng-container>
                                                </th>
                                            </ng-container>
                                        </tr>
                                    </tbody>
                                </table>
                                <div [style.position]="'relative'" *ngIf="allDaySlot && !verticalResources.length">
                                    <table class="k-scheduler-table k-scheduler-header-all-day" aria-hidden="true">
                                        <tbody>
                                            <tr>
                                                <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let resourceIndex = index; trackBy: itemIndex;">
                                                    <td *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex"
                                                        daySlot
                                                        [start]="slot.start"
                                                        [end]="slot.end"
                                                        [id]="{ resourceIndex: resourceIndex, rangeIndex: 0, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDate(slot.start),
                                                            end: toPlainDate(slot.end),
                                                            isAllDay: true,
                                                            resources: resourcesByIndex(resourceIndex)
                                                        })"
                                                        [ngClass]="allDaySlotClass(slot, resourceIndex)"
                                                        class="k-scheduler-cell">
                                                        <ng-container *ngIf="allDaySlotTemplateRef" [ngTemplateOutlet]="allDaySlotTemplateRef"
                                                            [ngTemplateOutletContext]="{ date: slot.start, resources: resourcesByIndex(resourceIndex) }"></ng-container>
                                                    </td>
                                                </ng-container>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <ng-container *ngFor="let item of allDayItems | async; trackBy: itemIndex;">
                                        <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                            [ngClass]="getEventClasses(item, itemResource.resources, true)"
                                            [ngStyle]="getEventStyles(item, itemResource, true)"
                                            role="button"
                                            [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                            [id]="item.elementId + '_' + itemResource.leafIdx"
                                            dayTimeViewItem
                                                [isAllDay]="true"
                                                [editable]="editable"
                                                [eventTemplate]="allDayEventTemplateRef"
                                                [item]="item"
                                                [index]="item.index"
                                                [rangeIndex]="item.rangeIndex"
                                                [resources]="itemResource.resources"
                                                [resourceIndex]="itemResource.leafIdx">
                                        </div>
                                    </ng-container>
                                    <kendo-hint-container #headerHintContainer>
                                        <ng-template>
                                            <div *ngIf="dragHints.length && allDayDragHint"
                                                class="k-event-drag-hint"
                                                dayTimeViewItem
                                                    [isAllDay]="true"
                                                    [ngStyle]="dragHints[0].style"
                                                    [ngClass]="dragHints[0].class"
                                                    [dragHint]="true"
                                                    [eventTemplate]="eventTemplateRef"
                                                    [item]="dragHints[0].item"
                                                    [resources]="dragHints[0].resources">
                                            </div>

                                            <div *ngIf="resizeHints.length && allDayResizeHint"
                                                kendoResizeHint
                                                    [hint]="resizeHints[0]"
                                                    [ngClass]="resizeHints[0].class"
                                                    [format]="allDayResizeHintFormat">
                                            </div>
                                        </ng-template>
                                    </kendo-hint-container>
                                </div>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div class="k-scheduler-times" #times>
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of verticalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeArrow class="k-current-time k-current-time-arrow-right">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex;">
                                        <tr *ngIf="verticalResources.length">
                                            <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex;">
                                                <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-scheduler-cell k-slot-cell k-heading-cell">
                                                    <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                    <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                        [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                </th>
                                            </ng-container>
                                            <th *ngIf="allDaySlot" class="k-scheduler-times-all-day k-scheduler-cell k-heading-cell" #allDayCell>{{ allDayMessage }}</th>
                                        </tr>
                                        <tr *ngFor="let slot of timeSlots; let timeSlotIndex = index;trackBy: itemIndex">
                                            <th *ngIf="slot.isMajor" [ngClass]="{ 'k-slot-cell': slotDivisions === 1 }" class="k-scheduler-cell k-heading-cell">
                                                <ng-container *ngIf="!majorTimeHeaderTemplateRef">{{ slot.start | kendoDate: 't' }}</ng-container>
                                                <ng-container *ngIf="majorTimeHeaderTemplateRef" [ngTemplateOutlet]="majorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }"></ng-container>
                                            </th>
                                            <th *ngIf="!slot.isMajor" [ngClass]="{ 'k-slot-cell': timeSlotIndex % slotDivisions === slotDivisions - 1 }" class="k-scheduler-cell k-heading-cell">
                                                <ng-container *ngIf="minorTimeHeaderTemplateRef" [ngTemplateOutlet]="minorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }">
                                                </ng-container>
                                            </th>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div
                            class="k-scheduler-content" 
                            #content
                            role="group"
                            tabindex="0"
                            [attr.aria-owns]="matchOwned(items | async)">
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of verticalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeMarker class="k-current-time">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #contentTable role="presentation">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex;">
                                        <tr class="k-scheduler-header-all-day" *ngIf="allDaySlot && verticalResources.length">
                                            <td *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex"
                                                daySlot
                                                [start]="slot.start"
                                                [end]="slot.end"
                                                [class.k-selected]="isSlotSelected({
                                                    start: toPlainDate(slot.start),
                                                    end: toPlainDate(slot.end),
                                                    isAllDay: true,
                                                    resources: resourcesByIndex(verticalIndex)
                                                })"
                                                [id]="{ resourceIndex: verticalIndex, rangeIndex: 0, index: index }">
                                                <ng-container *ngIf="allDaySlotTemplateRef" [ngTemplateOutlet]="allDaySlotTemplateRef"
                                                    [ngTemplateOutletContext]="{ date: slot.start, resources: resourcesByIndex(verticalIndex) }"></ng-container>
                                            </td>
                                        </tr>
                                        <tr *ngFor="let slot of timeSlots; index as index; trackBy: itemIndex" [class.k-middle-row]="isMiddleSlot(index)">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex;">
                                                <td *ngFor="let daySlot of daySlots; index as rangeIndex; trackBy: itemIndex"
                                                    [ngClass]="timeSlotClass(slot, daySlot.start, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    timeSlot #timeSlot="timeSlot"
                                                        [date]="daySlot.start"
                                                        [invariantStart]="slot.start"
                                                        [invariantEnd]="slot.end"
                                                        [workDayStart]="workDayStartTime"
                                                        [workDayEnd]="workDayEndTime"
                                                        [workWeekStart]="workWeekStart"
                                                        [workWeekEnd]="workWeekEnd"
                                                        [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDateTime(daySlot.start, slot.start),
                                                            end: toPlainDateTime(daySlot.start, slot.end),
                                                            isAllDay: false,
                                                            resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                        })"
                                                        class="k-scheduler-cell"
                                                >
                                                    <ng-container *ngIf="timeSlotTemplateRef" [ngTemplateOutlet]="timeSlotTemplateRef"
                                                        [ngTemplateOutletContext]="{ date: timeSlot.startLocalTime, resources: resourcesByIndex(timeSlot.id.resourceIndex) }">
                                                    </ng-container>
                                                </td>
                                            </ng-container>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async; trackBy: itemIndex;">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    dayTimeViewItem
                                        [editable]="editable"
                                        [vertical]="true"
                                        [eventTemplate]="eventTemplateRef"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <ng-container *ngIf="verticalResources.length">
                                <ng-container *ngFor="let item of allDayItems | async; trackBy: itemIndex;">
                                    <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                        [ngClass]="getEventClasses(item, itemResource.resources, true)"
                                        [ngStyle]="getEventStyles(item, itemResource, true)"
                                        role="button"
                                        [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                        [id]="item.elementId + '_' + itemResource.leafIdx"
                                        dayTimeViewItem
                                            [isAllDay]="true"
                                            [editable]="editable"
                                            [eventTemplate]="allDayEventTemplateRef"
                                            [item]="item"
                                            [index]="item.index"
                                            [rangeIndex]="item.rangeIndex"
                                            [resources]="itemResource.resources"
                                            [resourceIndex]="itemResource.leafIdx">
                                    </div>
                                </ng-container>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngIf="dragHints.length && (!allDayDragHint || verticalResources.length)"
                                        class="k-event-drag-hint"
                                        role="button"
                                        dayTimeViewItem
                                            [isAllDay]="allDayDragHint"
                                            [ngStyle]="dragHints[0].style"
                                            [ngClass]="dragHints[0].class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [resources]="dragHints[0].resources"
                                            [item]="dragHints[0].item">
                                    </div>

                                    <ng-container *ngIf="resizeHints.length && (!allDayResizeHint || verticalResources.length)">
                                        <div *ngFor="let hint of resizeHints; trackBy: itemIndex;"
                                            kendoResizeHint
                                                [hint]="hint"
                                                [ngClass]="hint.class"
                                                [format]="allDayResizeHint ? allDayResizeHintFormat : resizeHintFormat">
                                        </div>
                                    </ng-container>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `,
      standalone: true,
      imports: [NgClass, NgForOf, NgIf, NgTemplateOutlet, DaySlotDirective, DayTimeViewItemComponent, NgStyle, FocusableDirective, HintContainerComponent, ResizeHintComponent, TimeSlotDirective, ResourceIteratorPipe, DatePipe, AsyncPipe]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }, {
      type: DayTimeSlotService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: PDFService
    }, {
      type: ScrollbarWidthService
    }];
  }, {
    allDaySlot: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    slotFill: [{
      type: Input
    }],
    allDaySlotTemplate: [{
      type: Input
    }],
    allDayEventTemplate: [{
      type: Input
    }],
    dayCells: [{
      type: ViewChildren,
      args: ["allDayCell"]
    }],
    headerHintContainer: [{
      type: ViewChild,
      args: ["headerHintContainer", {
        static: false
      }]
    }]
  });
})();
var DayViewComponent = class _DayViewComponent extends MultiDayViewBase {
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("dayViewTitle");
  }
  /**
   * The long-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * @default '{0:D}'
   */
  set selectedDateFormat(value2) {
    this._selectedDateFormat = value2;
  }
  get selectedDateFormat() {
    return this._selectedDateFormat;
  }
  /**
   * The short-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * @default '{0:d}'
   */
  set selectedShortDateFormat(value2) {
    this._selectedShortDateFormat = value2;
  }
  get selectedShortDateFormat() {
    return this._selectedShortDateFormat;
  }
  /**
   * @hidden
   */
  allDaySlotTemplate;
  /**
   * @hidden
   */
  allDayEventTemplate;
  /**
   * The invariant name for this view.
   * @default 'day'
   */
  name = "day";
  _selectedDateFormat = "{0:D}";
  _selectedShortDateFormat = "{0:d}";
  constructor(localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  static ɵfac = function DayViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DayViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DayViewComponent,
    selectors: [["kendo-scheduler-day-view"]],
    contentQueries: function DayViewComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, AllDaySlotTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, AllDayEventTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allDaySlotTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allDayEventTemplate = _t.first);
      }
    },
    inputs: {
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _DayViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], [3, "name", "allDaySlot", "eventHeight", "currentTimeMarker", "highlightOngoingEvents", "showWorkHours", "scrollTime", "startTime", "endTime", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "slotDuration", "slotDivisions", "slotFill", "slotClass", "eventClass", "eventStyles", "allDaySlotTemplate", "allDayEventTemplate", "eventTemplate", "groupHeaderTemplate", "timeSlotTemplate", "minorTimeHeaderTemplate", "majorTimeHeaderTemplate", "dateHeaderTemplate", "selectedDateFormat", "selectedShortDateFormat"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "showWorkHours", "itemClick", 4, "ngIf"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "itemClick", "showWorkHours"]],
    template: function DayViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, DayViewComponent_ng_template_0_Template, 2, 30, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DayViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-day-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => DayViewComponent)
      }],
      template: `
        <ng-template #content>
            <multi-day-view
                [name]="name"
                [allDaySlot]="viewAllDaySlot"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
      standalone: true,
      imports: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    allDaySlotTemplate: [{
      type: ContentChild,
      args: [AllDaySlotTemplateDirective, {
        static: false
      }]
    }],
    allDayEventTemplate: [{
      type: ContentChild,
      args: [AllDayEventTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var MultiDayViewComponent = class _MultiDayViewComponent extends DayViewComponent {
  /**
   * The long-date format for displaying the
   * selected date in the Scheduler toolbar.
   * Defaults to `{0:D} - {1:D}` for multiple days and `{0:D}` for a single day
   * ([more information](slug:parsingandformatting_intl#toc-date-formatting)).
   * @default '{0:D} - {1:D}'
   */
  set selectedDateFormat(value2) {
    this.dateFormat = value2;
  }
  get selectedDateFormat() {
    return this.dateFormat || this.defaultDateFormat;
  }
  /**
   * The short date format for displaying the
   * selected date in the Scheduler toolbar.
   * Defaults to `{0:d} - {1:d}` for multiple days and `{0:d}` for a single day
   * ([more information](slug:parsingandformatting_intl#toc-date-formatting)).
   * @default '{0:d} - {1:d}'
   */
  set selectedShortDateFormat(value2) {
    this.shortDateFormat = value2;
  }
  get selectedShortDateFormat() {
    return this.shortDateFormat || this.defaultShortDateFormat;
  }
  /**
   * Specifies the number of days that the view will render.
   * @default 1
   */
  numberOfDays = 1;
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("multiDayViewTitle");
  }
  /**
   * The invariant name for this view.
   * @default 'multi-day'
   */
  name = "multiDay";
  get defaultDateFormat() {
    return this.numberOfDays === 1 ? "{0:D}" : "{0:D} - {1:D}";
  }
  get defaultShortDateFormat() {
    return this.numberOfDays === 1 ? "{0:d}" : "{0:d} - {1:d}";
  }
  dateFormat;
  shortDateFormat;
  constructor(localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  static ɵfac = function MultiDayViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiDayViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiDayViewComponent,
    selectors: [["kendo-scheduler-multi-day-view"]],
    inputs: {
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat",
      numberOfDays: "numberOfDays"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _MultiDayViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], ["viewName", "day", 3, "allDaySlot", "name", "numberOfDays", "eventHeight", "currentTimeMarker", "highlightOngoingEvents", "showWorkHours", "scrollTime", "startTime", "endTime", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "slotDuration", "slotDivisions", "slotFill", "slotClass", "eventClass", "eventStyles", "allDaySlotTemplate", "allDayEventTemplate", "eventTemplate", "groupHeaderTemplate", "timeSlotTemplate", "minorTimeHeaderTemplate", "majorTimeHeaderTemplate", "dateHeaderTemplate", "selectedDateFormat", "selectedShortDateFormat"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "showWorkHours", "itemClick", 4, "ngIf"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "itemClick", "showWorkHours"]],
    template: function MultiDayViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, MultiDayViewComponent_ng_template_0_Template, 2, 31, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiDayViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-multi-day-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => MultiDayViewComponent)
      }],
      template: `
        <ng-template #content>
            <multi-day-view
                viewName="day"
                [allDaySlot]="allDaySlot"
                [name]="name"
                [numberOfDays]="numberOfDays"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
      standalone: true,
      imports: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    numberOfDays: [{
      type: Input
    }]
  });
})();
var WeekViewComponent = class _WeekViewComponent extends MultiDayViewBase {
  intl;
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("weekViewTitle");
  }
  /**
   * The long-date format for displaying the
   * selected date in the Scheduler toolbar.
   * Defaults to `{0:D} - {1:D}`,
   * where `0` is the start and `1` is the end date
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting).
   * @default '{0:D} - {1:D}'
   */
  selectedDateFormat = "{0:D} - {1:D}";
  /**
   * The short date format for displaying the
   * selected date in the Scheduler toolbar.
   * Defaults to `{0:d} - {1:d}`,
   * where `0` is the start and `1` is the end date
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting).
   * @default '{0:d} - {1:d}'
   */
  selectedShortDateFormat = "{0:d} - {1:d}";
  /**
   * @hidden
   */
  allDaySlotTemplate;
  /**
   * @hidden
   */
  allDayEventTemplate;
  /**
   * The invariant name for this view.
   * @default 'week'
   */
  name = "week";
  constructor(intl, localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
    this.intl = intl;
    this.getStartDate = this.getStartDate.bind(this);
  }
  /**
   * @hidden
   */
  getStartDate(selectedDate) {
    return firstDayInWeek(getDate(selectedDate), this.viewWeekStart);
  }
  static ɵfac = function WeekViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WeekViewComponent)(ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _WeekViewComponent,
    selectors: [["kendo-scheduler-week-view"]],
    contentQueries: function WeekViewComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, AllDaySlotTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, AllDayEventTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allDaySlotTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allDayEventTemplate = _t.first);
      }
    },
    inputs: {
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _WeekViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], [3, "name", "allDaySlot", "numberOfDays", "getStartDate", "eventHeight", "currentTimeMarker", "highlightOngoingEvents", "showWorkHours", "scrollTime", "startTime", "endTime", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "weekStart", "slotDuration", "slotDivisions", "slotFill", "slotClass", "eventClass", "eventStyles", "allDaySlotTemplate", "allDayEventTemplate", "eventTemplate", "groupHeaderTemplate", "timeSlotTemplate", "minorTimeHeaderTemplate", "majorTimeHeaderTemplate", "dateHeaderTemplate", "selectedDateFormat", "selectedShortDateFormat"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "showWorkHours", "itemClick", 4, "ngIf"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "itemClick", "showWorkHours"]],
    template: function WeekViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, WeekViewComponent_ng_template_0_Template, 2, 33, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WeekViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-week-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => WeekViewComponent)
      }],
      template: `
        <ng-template #content>
            <multi-day-view
                [name]="name"
                [allDaySlot]="viewAllDaySlot"
                [numberOfDays]="7"
                [getStartDate]="getStartDate"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [weekStart]="viewWeekStart"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
      standalone: true,
      imports: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
    }]
  }], function() {
    return [{
      type: IntlService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    allDaySlotTemplate: [{
      type: ContentChild,
      args: [AllDaySlotTemplateDirective, {
        static: false
      }]
    }],
    allDayEventTemplate: [{
      type: ContentChild,
      args: [AllDayEventTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var DAYS_IN_WEEK = 7;
var WorkWeekViewComponent = class _WorkWeekViewComponent extends WeekViewComponent {
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("workWeekViewTitle");
  }
  /**
   * The invariant name for this view.
   * @default 'workWeek'
   */
  name = "workWeek";
  /**
   * @hidden
   */
  get numberOfDays() {
    if (this.viewWorkWeekStart > this.viewWorkWeekEnd) {
      return DAYS_IN_WEEK - this.viewWorkWeekStart + this.viewWorkWeekEnd + 1;
    }
    return this.viewWorkWeekEnd - this.viewWorkWeekStart + 1;
  }
  constructor(intl, localization, changeDetector, viewContext, viewState) {
    super(intl, localization, changeDetector, viewContext, viewState);
    this.getNextDate = this.getNextDate.bind(this);
  }
  /**
   * @hidden
   */
  getStartDate(selectedDate) {
    return firstDayInWeek(getDate(selectedDate), this.viewWorkWeekStart);
  }
  /**
   * @hidden
   */
  getNextDate(date, count, _numberOfDays) {
    return getDate(addDays(date, DAYS_IN_WEEK * count));
  }
  static ɵfac = function WorkWeekViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WorkWeekViewComponent)(ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _WorkWeekViewComponent,
    selectors: [["kendo-scheduler-work-week-view"]],
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _WorkWeekViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], ["viewName", "workWeekview", 3, "allDaySlot", "name", "numberOfDays", "getStartDate", "getNextDate", "eventHeight", "currentTimeMarker", "highlightOngoingEvents", "showWorkHours", "scrollTime", "startTime", "endTime", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "slotDuration", "slotDivisions", "slotFill", "slotClass", "eventClass", "eventStyles", "allDaySlotTemplate", "allDayEventTemplate", "eventTemplate", "groupHeaderTemplate", "timeSlotTemplate", "minorTimeHeaderTemplate", "majorTimeHeaderTemplate", "dateHeaderTemplate", "selectedDateFormat", "selectedShortDateFormat"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "showWorkHours", "itemClick", 4, "ngIf"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "itemClick", "showWorkHours"]],
    template: function WorkWeekViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, WorkWeekViewComponent_ng_template_0_Template, 2, 33, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WorkWeekViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-work-week-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => WorkWeekViewComponent)
      }],
      template: `
        <ng-template #content>
            <multi-day-view
                viewName="workWeekview"
                [allDaySlot]="viewAllDaySlot"
                [name]="name"
                [numberOfDays]="numberOfDays"
                [getStartDate]="getStartDate"
                [getNextDate]="getNextDate"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
      standalone: true,
      imports: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
    }]
  }], function() {
    return [{
      type: IntlService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, null);
})();
var COLUMN_WIDTH = "columnWidth";
var TimelineBase = class _TimelineBase extends DayTimeViewBase {
  /**
   * Specifies the columns width.
   */
  columnWidth;
  /**
   * @hidden
   */
  get viewColumnWidth() {
    return this.optionValue(COLUMN_WIDTH);
  }
  constructor(localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  static ɵfac = function TimelineBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineBase)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimelineBase,
    inputs: {
      columnWidth: "columnWidth"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineBase, [{
    type: Directive
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    columnWidth: [{
      type: Input
    }]
  });
})();
var createTasks$1 = (periodStart, periodEnd, items) => {
  const tasks = [];
  const utcStart = toUTCDate(periodStart);
  const utcEnd = toUTCDate(periodEnd);
  for (let index = 0; index < items.length; index++) {
    const item = items[index];
    const event2 = item.event;
    const task = {
      index,
      start: item.start,
      end: item.end,
      event: event2,
      isAllDay: false
    };
    const endTime = event2.isAllDay ? roundAllDayEnd(item) : task.end;
    const startTime = event2.isAllDay ? task.start.stripTime() : task.start;
    task.startTime = startTime.toUTCDate();
    task.endTime = endTime.toUTCDate();
    if (intersects(task.startTime, task.endTime, utcStart, utcEnd)) {
      tasks.push(task);
      task.head = task.endTime > utcEnd;
      task.tail = task.startTime < utcStart;
    }
  }
  return tasks;
};
var SortPipe = class _SortPipe {
  transform(value2, ..._args) {
    return value2.sort((item1, item2) => item1.startTime.getTime() - item2.startTime.getTime());
  }
  static ɵfac = function SortPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SortPipe)();
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "sort",
    type: _SortPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SortPipe, [{
    type: Pipe,
    args: [{
      // eslint-disable-next-line @angular-eslint/pipe-prefix
      name: "sort",
      standalone: true
    }]
  }], null, null);
})();
var TimelineMultiDayViewComponent = class _TimelineMultiDayViewComponent extends DayTimeViewComponent {
  name = "timeline";
  columnWidth = 100;
  viewName = "timeline";
  verticalResourceRows;
  get classNames() {
    return `k-scheduler-${this.viewName}-view`;
  }
  headerTable;
  get contentWidthPercentage() {
    const expectedWidth = this.columnWidth * this.slotsCount;
    const percentage = expectedWidth / this.contentWidth * 100;
    return Math.max(percentage, 100);
  }
  verticalTime = false;
  contentWidth;
  constructor(localization, changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, scrollBarWidthService) {
    super(changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, scrollBarWidthService);
  }
  ngOnChanges(changes) {
    if (changes.columnWidth) {
      this.changes.next(null);
    }
    super.ngOnChanges(changes);
  }
  reflow() {
    if (!isDocumentAvailable()) {
      return;
    }
    const slotService = this.slotService;
    this.updateContentHeight();
    slotService.containerSize = this.content.nativeElement.scrollWidth;
    this.contentWidth = this.content.nativeElement.getBoundingClientRect().width;
    this.cdr.detectChanges();
    const verticalResourceRows = this.verticalResources.length ? this.verticalResourceRows.toArray() : [];
    slotService.layoutTimeline(this.eventHeight, verticalResourceRows);
    if (verticalResourceRows.length) {
      slotService.forEachGroup((group3, index) => {
        verticalResourceRows[index].nativeElement.style.height = `${group3.timeRanges[0].slots[0].height}px`;
      });
    }
    this.syncTables();
  }
  get allEventsMessage() {
    return this.localization.get("allEvents");
  }
  get slotsCount() {
    const resources = this.horizontalResources;
    let result = this.daySlots.length * this.timeSlots.length;
    for (let idx2 = 0; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return result;
  }
  timeColspan(index) {
    if (this.minorTimeHeaderTemplateRef) {
      return 1;
    }
    const timeSlots = this.timeSlots.length;
    const remainder = timeSlots % this.slotDivisions;
    return remainder === 0 || index < timeSlots - remainder ? this.slotDivisions : 1;
  }
  horizontalColspan(resourceIndex) {
    const resources = this.horizontalResources;
    let result = this.daySlots.length * this.timeSlots.length;
    for (let idx2 = resourceIndex + 1; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return result;
  }
  verticalRowspan(resourceIndex) {
    const resources = this.verticalResources;
    let result = 1;
    for (let idx2 = resourceIndex + 1; idx2 < resources.length; idx2++) {
      result *= (resources[idx2].data || []).length || 1;
    }
    return result;
  }
  handleScroll() {
    this.headerWrap.nativeElement.scrollLeft = this.content.nativeElement.scrollLeft;
  }
  createTasks(items, dateRange) {
    return createTasks$1(dateRange.start, dateRange.end, items);
  }
  onTasksChange() {
    this.items.next(this.tasks);
  }
  dragRanges(slot) {
    return this.slotService.dragRanges(slot, this.dragging.offset, true);
  }
  dragHintSize(firstSlot, lastSlot) {
    return {
      width: toPx(lastSlot.rect.left - firstSlot.rect.left + lastSlot.rect.width),
      height: toPx(firstSlot.height)
    };
  }
  updateResizeHints(ranges, start, end) {
    const last3 = ranges[ranges.length - 1];
    super.updateResizeHints([[ranges[0][0], last3[last3.length - 1]]], start, end);
  }
  pdfWidth() {
    const contentWidth = this.content.nativeElement.scrollWidth;
    const timesWidth = this.times.nativeElement.offsetWidth;
    return contentWidth + timesWidth;
  }
  currentTimeArrowOffset() {
    return this.headerWrap.nativeElement.querySelector("tr:last-child").offsetTop;
  }
  static ɵfac = function TimelineMultiDayViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineMultiDayViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(DayTimeSlotService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ScrollbarWidthService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineMultiDayViewComponent,
    selectors: [["timeline-multi-day-view"]],
    viewQuery: function TimelineMultiDayViewComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c45, 5);
        ɵɵviewQuery(_c46, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTable = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.verticalResourceRows = _t);
      }
    },
    inputs: {
      name: "name",
      columnWidth: "columnWidth",
      viewName: "viewName"
    },
    features: [ɵɵProvidersFeature([DayTimeSlotService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 55,
    vars: 36,
    consts: [["timesHeader", ""], ["header", ""], ["headerWrap", ""], ["headerTable", ""], ["times", ""], ["timesTable", ""], ["content", ""], ["contentTable", ""], ["hintContainer", ""], ["currentTimeArrow", ""], ["titleCell", ""], ["verticalResourceRows", ""], ["currentTimeMarker", ""], ["timeSlot", "timeSlot"], [1, "k-scheduler-layout", 3, "ngClass"], [1, "k-scheduler-head"], [1, "k-scheduler-times"], ["aria-hidden", "true", 1, "k-scheduler-table"], [1, "k-scheduler-cell", "k-heading-cell"], [1, "k-slot-cell", "k-scheduler-cell", "k-heading-cell"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-scheduler-header"], [1, "k-scheduler-header-wrap"], [4, "ngIf"], [1, "k-scheduler-date-group"], [1, "k-scheduler-body"], ["role", "group", "tabindex", "0", 1, "k-scheduler-content", 3, "scroll"], ["role", "presentation", 1, "k-scheduler-table"], ["class", "k-current-time k-current-time-arrow-down", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-current-time", "k-current-time-arrow-down"], ["class", "k-slot-cell k-scheduler-cell k-heading-cell", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-scheduler-cell", "k-heading-cell", "k-slot-cell"], ["class", "k-link k-nav-day", 4, "ngIf"], [1, "k-link", "k-nav-day"], ["class", "k-scheduler-cell k-heading-cell", 4, "ngIf"], ["class", "k-scheduler-cell k-heading-cell", 3, "ngStyle", 4, "ngIf"], [1, "k-scheduler-cell", "k-heading-cell", 3, "ngStyle"], ["rowspan", "1", 1, "k-scheduler-cell", "k-heading-cell"], ["class", "k-slot-cell k-scheduler-cell k-heading-cell", 4, "ngIf"], ["class", "k-current-time", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "k-current-time"], ["timeSlot", "", "selectableSlot", "", "class", "k-scheduler-cell", 3, "ngClass", "date", "invariantStart", "invariantEnd", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "id", "k-selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["timeSlot", "", "selectableSlot", "", 1, "k-scheduler-cell", 3, "ngClass", "date", "invariantStart", "invariantEnd", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "id"], ["role", "button", "dayTimeViewItem", "", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "editable", "item", "index", "rangeIndex", "eventTemplate", "resources", "resourceIndex", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "button", "dayTimeViewItem", "", 3, "ngClass", "ngStyle", "kendoSchedulerFocusIndex", "id", "editable", "item", "index", "rangeIndex", "eventTemplate", "resources", "resourceIndex"], ["class", "k-event-drag-hint", "dayTimeViewItem", "", 3, "ngStyle", "ngClass", "dragHint", "eventTemplate", "item", "resources", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoResizeHint", "", 3, "hint", "ngClass", "format", 4, "ngIf"], ["dayTimeViewItem", "", 1, "k-event-drag-hint", 3, "ngStyle", "ngClass", "dragHint", "eventTemplate", "item", "resources"], ["kendoResizeHint", "", 3, "hint", "ngClass", "format"]],
    template: function TimelineMultiDayViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "table", 14)(1, "tbody")(2, "tr", 15)(3, "td")(4, "div", 16, 0)(6, "table", 17)(7, "tbody")(8, "tr");
        ɵɵelement(9, "th", 18);
        ɵɵelementEnd();
        ɵɵelementStart(10, "tr");
        ɵɵelement(11, "th", 19);
        ɵɵelementEnd();
        ɵɵtemplate(12, TimelineMultiDayViewComponent_tr_12_Template, 2, 0, "tr", 20);
        ɵɵelementEnd()()()();
        ɵɵelementStart(13, "td")(14, "div", 21, 1)(16, "div", 22, 2);
        ɵɵtemplate(18, TimelineMultiDayViewComponent_ng_container_18_Template, 3, 4, "ng-container", 23);
        ɵɵelementStart(19, "table", 17, 3)(21, "tbody");
        ɵɵtemplate(22, TimelineMultiDayViewComponent_tr_22_Template, 3, 5, "tr", 20);
        ɵɵelementStart(23, "tr", 24);
        ɵɵtemplate(24, TimelineMultiDayViewComponent_ng_container_24_Template, 2, 2, "ng-container", 20);
        ɵɵpipe(25, "resourceIterator");
        ɵɵelementEnd();
        ɵɵelementStart(26, "tr");
        ɵɵtemplate(27, TimelineMultiDayViewComponent_ng_container_27_Template, 2, 2, "ng-container", 20);
        ɵɵpipe(28, "resourceIterator");
        ɵɵelementEnd()()()()()()();
        ɵɵelementStart(29, "tr", 25)(30, "td")(31, "div", 16, 4)(33, "table", 17, 5)(35, "tbody");
        ɵɵtemplate(36, TimelineMultiDayViewComponent_tr_36_Template, 4, 1, "tr", 23)(37, TimelineMultiDayViewComponent_ng_container_37_Template, 3, 4, "ng-container", 23);
        ɵɵelementEnd()()()();
        ɵɵelementStart(38, "td")(39, "div", 26, 6);
        ɵɵpipe(41, "async");
        ɵɵpipe(42, "sort");
        ɵɵlistener("scroll", function TimelineMultiDayViewComponent_Template_div_scroll_39_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleScroll());
        });
        ɵɵtemplate(43, TimelineMultiDayViewComponent_ng_container_43_Template, 3, 4, "ng-container", 23);
        ɵɵelementStart(44, "table", 27, 7)(46, "tbody");
        ɵɵtemplate(47, TimelineMultiDayViewComponent_tr_47_Template, 3, 4, "tr", 20);
        ɵɵpipe(48, "resourceIterator");
        ɵɵelementEnd()();
        ɵɵtemplate(49, TimelineMultiDayViewComponent_ng_container_49_Template, 2, 2, "ng-container", 20);
        ɵɵpipe(50, "async");
        ɵɵpipe(51, "sort");
        ɵɵelementStart(52, "kendo-hint-container", null, 8);
        ɵɵtemplate(54, TimelineMultiDayViewComponent_ng_template_54_Template, 2, 3, "ng-template");
        ɵɵelementEnd()()()()()();
      }
      if (rf & 2) {
        ɵɵproperty("ngClass", ctx.classNames);
        ɵɵadvance(12);
        ɵɵproperty("ngForOf", ctx.horizontalResources)("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(6);
        ɵɵproperty("ngIf", ctx.showCurrentTime);
        ɵɵadvance();
        ɵɵstyleProp("width", ctx.contentWidthPercentage, "%");
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.horizontalResources)("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(25, 22, ctx.horizontalResources))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(28, 24, ctx.horizontalResources))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(9);
        ɵɵproperty("ngIf", !ctx.verticalResources.length);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.verticalResources.length);
        ɵɵadvance(2);
        ɵɵattribute("aria-owns", ctx.matchOwned(ɵɵpipeBind1(42, 28, ɵɵpipeBind1(41, 26, ctx.items))));
        ɵɵadvance(4);
        ɵɵproperty("ngIf", ctx.showCurrentTime);
        ɵɵadvance();
        ɵɵstyleProp("width", ctx.contentWidthPercentage, "%");
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(48, 30, ctx.verticalResources))("ngForTrackBy", ctx.itemIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(51, 34, ɵɵpipeBind1(50, 32, ctx.items)))("ngForTrackBy", ctx.itemIndex);
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, TimeSlotDirective, DayTimeViewItemComponent, FocusableDirective, HintContainerComponent, ResizeHintComponent, ResourceIteratorPipe, DatePipe, AsyncPipe, SortPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineMultiDayViewComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "timeline-multi-day-view",
      providers: [DayTimeSlotService],
      template: `
        <table class="k-scheduler-layout" [ngClass]="classNames">
            <tbody>
                <tr class="k-scheduler-head">
                    <td>
                        <div class="k-scheduler-times" #timesHeader>
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr><th class="k-scheduler-cell k-heading-cell"></th></tr>
                                    <tr><th class="k-slot-cell k-scheduler-cell k-heading-cell"></th></tr>
                                    <tr *ngFor="let resource of horizontalResources; trackBy: itemIndex;">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                    <div class="k-scheduler-header" #header >
                        <div class="k-scheduler-header-wrap" #headerWrap>
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeArrow class="k-current-time k-current-time-arrow-down">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #headerTable aria-hidden="true" [style.width.%]="contentWidthPercentage">
                                <tbody>
                                    <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex;">
                                        <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex;"
                                            class="k-slot-cell k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                            <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                            <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                        </th>
                                    </tr>
                                    <tr class="k-scheduler-date-group">
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let index = index; trackBy: itemIndex;">
                                                <th [attr.colspan]="timeSlots.length" class="k-scheduler-cell k-heading-cell k-slot-cell">
                                                    <span *ngIf="!dateHeaderTemplateRef" class="k-link k-nav-day" [attr.data-dayslot-index]="index">{{ daySlot.start | kendoDate: 'm'}}</span>
                                                    <ng-container *ngIf="dateHeaderTemplateRef" [ngTemplateOutlet]="dateHeaderTemplateRef" [ngTemplateOutletContext]="{ date: daySlot.start }"></ng-container>
                                                </th>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                    <tr>
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let resourceIndex = index; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let rangeIndex = index; trackBy: itemIndex;">
                                                <ng-container *ngFor="let timeSlot of timeSlots; let index = index; trackBy: itemIndex;">
                                                    <th *ngIf="timeSlot.isMajor" [attr.colspan]="timeColspan(index)" class="k-scheduler-cell k-heading-cell">
                                                        <ng-container *ngIf="!majorTimeHeaderTemplateRef">{{ timeSlot.start | kendoDate: 't' }}</ng-container>
                                                        <ng-container *ngIf="majorTimeHeaderTemplateRef" [ngTemplateOutlet]="majorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: timeSlot.start }"></ng-container>
                                                    </th>
                                                    <th
                                                        *ngIf="!timeSlot.isMajor && minorTimeHeaderTemplateRef"
                                                        [ngStyle]="{'border-left-color': 'transparent', 'border-right-color': 'transparent'}"
                                                        class="k-scheduler-cell k-heading-cell"
                                                    >
                                                        <ng-container [ngTemplateOutlet]="minorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: timeSlot.start }">
                                                        </ng-container>
                                                    </th>
                                                </ng-container>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div class="k-scheduler-times" #times>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <tr *ngIf="!verticalResources.length">
                                        <th rowspan="1" #titleCell class="k-scheduler-cell k-heading-cell">
                                            {{ allEventsMessage }}
                                        </th>
                                    </tr>
                                    <ng-container *ngIf="verticalResources.length">
                                        <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex;">
                                            <tr #verticalResourceRows>
                                                <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex;">
                                                    <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-slot-cell k-scheduler-cell k-heading-cell">
                                                        <div>
                                                            <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                            <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                                [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                        </div>
                                                    </th>
                                                </ng-container>
                                            </tr>
                                        </ng-container>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div
                            class="k-scheduler-content"
                            #content
                            role="group"
                            tabindex="0"
                            (scroll)="handleScroll()"
                            [attr.aria-owns]="matchOwned(items | async | sort)">
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;"
                                    class="k-current-time" #currentTimeMarker>
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #contentTable role="presentation" [style.width.%]="contentWidthPercentage">
                                <tbody>
                                    <tr *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex;">
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let rangeIndex = index; trackBy: itemIndex;">
                                                <td *ngFor="let slot of timeSlots; let index = index; trackBy: itemIndex;"
                                                        [ngClass]="timeSlotClass(slot, daySlot.start, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                        timeSlot #timeSlot="timeSlot"
                                                        [date]="daySlot.start"
                                                        [invariantStart]="slot.start"
                                                        [invariantEnd]="slot.end"
                                                        [workDayStart]="workDayStartTime"
                                                        [workDayEnd]="workDayEndTime"
                                                        [workWeekStart]="workWeekStart"
                                                        [workWeekEnd]="workWeekEnd"
                                                        selectableSlot
                                                        [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDateTime(daySlot.start, slot.start),
                                                            end: toPlainDateTime(daySlot.start, slot.end),
                                                            isAllDay: false,
                                                            resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                        })"
                                                        class="k-scheduler-cell"
                                                >
                                                    <ng-container *ngIf="timeSlotTemplateRef" [ngTemplateOutlet]="timeSlotTemplateRef"
                                                        [ngTemplateOutletContext]="{ date: timeSlot.startLocalTime, resources: resourcesByIndex(timeSlot.id.resourceIndex ) }">
                                                    </ng-container>
                                                </td>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async | sort; trackBy: itemIndex;">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    dayTimeViewItem
                                        [editable]="editable"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [eventTemplate]="eventTemplateRef"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngFor="let hint of dragHints; trackBy: itemIndex;"
                                        class="k-event-drag-hint"
                                        dayTimeViewItem
                                            [ngStyle]="hint.style"
                                            [ngClass]="hint.class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [item]="hint.item"
                                            [resources]="hint.resources">
                                    </div>
                                    <div *ngIf="resizeHints && resizeHints.length"
                                        kendoResizeHint
                                        [hint]="resizeHints[0]"
                                        [ngClass]="resizeHints[0].class"
                                        [format]="resizeHintFormat">
                                    </div>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `,
      standalone: true,
      imports: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, TimeSlotDirective, DayTimeViewItemComponent, FocusableDirective, HintContainerComponent, ResizeHintComponent, ResourceIteratorPipe, DatePipe, AsyncPipe, SortPipe]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }, {
      type: DayTimeSlotService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: PDFService
    }, {
      type: ScrollbarWidthService
    }];
  }, {
    name: [{
      type: Input
    }],
    columnWidth: [{
      type: Input
    }],
    viewName: [{
      type: Input
    }],
    verticalResourceRows: [{
      type: ViewChildren,
      args: ["verticalResourceRows"]
    }],
    headerTable: [{
      type: ViewChild,
      args: ["headerTable"]
    }]
  });
})();
var TimelineMonthViewComponent = class _TimelineMonthViewComponent extends TimelineBase {
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("timelineMonthViewTitle");
  }
  /**
   * The long-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * > Note: If [numberOfMonths](#toc-numberofmonths) > 1, the default format value shows a range - `'{0:Y} - {1:Y}'`, where `0` is the start and `1` is the end date.
   * @default '{0:Y}'
   */
  set selectedDateFormat(format) {
    this._selectedDateFormat = format;
  }
  get selectedDateFormat() {
    if (this._selectedDateFormat) {
      return this._selectedDateFormat;
    }
    return this.numberOfMonths && this.numberOfMonths > 1 ? "{0:Y} - {1:Y}" : "{0:Y}";
  }
  _selectedDateFormat;
  /**
   * The short-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * > Note: If [numberOfMonths](#toc-numberofmonths) > 1, the default format value shows a range - `'{0:y} - {1:y}'`, where `0` is the start and `1` is the end date.
   * @default '{0:y}'
   */
  set selectedShortDateFormat(format) {
    this._selectedShortDateFormat = format;
  }
  get selectedShortDateFormat() {
    if (this._selectedShortDateFormat) {
      return this._selectedShortDateFormat;
    }
    return this.numberOfMonths && this.numberOfMonths > 1 ? "{0:y} - {1:y}" : "{0:y}";
  }
  _selectedShortDateFormat;
  /**
   * Specifies the number of months that the view will render.
   * > Normalized to `1` if the provided value is <= 0.
   * @default 1
   */
  set numberOfMonths(months) {
    this._numberOfMonths = months > 0 ? months : 1;
  }
  get numberOfMonths() {
    return this._numberOfMonths;
  }
  _numberOfMonths = 1;
  /**
   * The invariant name for this view.
   * @default 'timelineMonth'
   */
  name = "timelineMonth";
  /**
   * @hidden
   */
  getStartDate = (selectedDate) => {
    return firstDayOfMonth(getDate(selectedDate));
  };
  /**
   * @hidden
   */
  getEndDate = (selectedDate) => {
    return addMonths(this.getStartDate(selectedDate), this.numberOfMonths);
  };
  /**
   * @hidden
   */
  getNextDate = (date, count) => {
    return addMonths(date, count);
  };
  constructor(localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  static ɵfac = function TimelineMonthViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineMonthViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineMonthViewComponent,
    selectors: [["kendo-scheduler-timeline-month-view"]],
    inputs: {
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat",
      numberOfMonths: "numberOfMonths"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _TimelineMonthViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], ["viewName", "timeline-month", 3, "name", "getNextDate", "getStartDate", "getEndDate", "eventHeight", "columnWidth", "currentTimeMarker", "highlightOngoingEvents", "showWorkHours", "scrollTime", "startTime", "endTime", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "slotDuration", "slotDivisions", "slotClass", "eventClass", "eventStyles", "eventTemplate", "groupHeaderTemplate", "timeSlotTemplate", "dateHeaderTemplate", "majorTimeHeaderTemplate", "minorTimeHeaderTemplate", "selectedDateFormat", "selectedShortDateFormat"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "showWorkHours", "itemClick", 4, "ngIf"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "itemClick", "showWorkHours"]],
    template: function TimelineMonthViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, TimelineMonthViewComponent_ng_template_0_Template, 2, 30, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineMonthViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-timeline-month-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => TimelineMonthViewComponent)
      }],
      template: `
        <ng-template #content>
            <timeline-multi-day-view
                viewName="timeline-month"
                [name]="name"
                [getNextDate]="getNextDate"
                [getStartDate]="getStartDate"
                [getEndDate]="getEndDate"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
      standalone: true,
      imports: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    numberOfMonths: [{
      type: Input
    }]
  });
})();
var TimelineViewComponent = class _TimelineViewComponent extends TimelineBase {
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("timelineViewTitle");
  }
  /**
   * The long-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * > Note: If [numberOfDays](#toc-numberofdays) > 1, the default format value shows a range - `'{0:D} - {1:D}'`, where `0` is the start and `1` is the end date.
   * @default '{0:D}'
   */
  set selectedDateFormat(format) {
    this._selectedDateFormat = format;
  }
  get selectedDateFormat() {
    if (this._selectedDateFormat) {
      return this._selectedDateFormat;
    }
    return this.numberOfDays && this.numberOfDays > 1 ? "{0:D} - {1:D}" : "{0:D}";
  }
  _selectedDateFormat;
  /**
   * The short-date format for displaying the
   * selected date in the Scheduler toolbar.
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * > Note: If [numberOfDays](#toc-numberofdays) > 1, the default format value shows a range - `'{0:d} - {1:d}'`, where `0` is the start and `1` is the end date.
   * @default '{0:d}'
   */
  set selectedShortDateFormat(format) {
    this._selectedShortDateFormat = format;
  }
  get selectedShortDateFormat() {
    if (this._selectedShortDateFormat) {
      return this._selectedShortDateFormat;
    }
    return this.numberOfDays && this.numberOfDays > 1 ? "{0:d} - {1:d}" : "{0:d}";
  }
  _selectedShortDateFormat;
  /**
   * Specifies the number of days that the view will render.
   * > Normalized to `1` if the provided value is <= 0.
   * @default 1
   */
  set numberOfDays(days) {
    this._numberOfDays = days > 0 ? days : 1;
  }
  get numberOfDays() {
    return this._numberOfDays;
  }
  _numberOfDays = 1;
  /**
   * The invariant name for this view.
   * @default 'timeline'
   */
  name = "timeline";
  constructor(localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  static ɵfac = function TimelineViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineViewComponent,
    selectors: [["kendo-scheduler-timeline-view"]],
    inputs: {
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat",
      numberOfDays: "numberOfDays"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _TimelineViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], [3, "name", "numberOfDays", "eventHeight", "columnWidth", "currentTimeMarker", "highlightOngoingEvents", "showWorkHours", "scrollTime", "startTime", "endTime", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "slotDuration", "slotDivisions", "slotClass", "eventClass", "eventStyles", "eventTemplate", "groupHeaderTemplate", "timeSlotTemplate", "majorTimeHeaderTemplate", "minorTimeHeaderTemplate", "dateHeaderTemplate", "selectedDateFormat", "selectedShortDateFormat"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "showWorkHours", "itemClick", 4, "ngIf"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "itemClick", "showWorkHours"]],
    template: function TimelineViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, TimelineViewComponent_ng_template_0_Template, 2, 28, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-timeline-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => TimelineViewComponent)
      }],
      template: `
        <ng-template #content>
            <timeline-multi-day-view
                [name]="name"
                [numberOfDays]="numberOfDays"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
      standalone: true,
      imports: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    numberOfDays: [{
      type: Input
    }]
  });
})();
var TimelineWeekViewComponent = class _TimelineWeekViewComponent extends TimelineBase {
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("timelineWeekViewTitle");
  }
  /**
   * The long-date format that will be used for displaying the
   * selected date in the Scheduler toolbar.
   * Defaults to `{0:D} - {1:D}`
   * where `0` is the start and `1` is the end date
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * @default '{0:D} - {1:D}'
   */
  selectedDateFormat = "{0:D} - {1:D}";
  /**
   * The short date format that will be used for displaying the
   * selected date in the Scheduler toolbar.
   * Defaults to `{0:d} - {1:d}`
   * where `0` is the start and `1` is the end date
   * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
   * @default '{0:d} - {1:d}'
   */
  selectedShortDateFormat = "{0:d} - {1:d}";
  /**
  * Specifies the number of weeks that the view will render.
  * @default 1
  */
  set numberOfWeeks(weeks) {
    this._numberOfWeeks = weeks > 0 ? weeks : 1;
  }
  get numberOfWeeks() {
    return this._numberOfWeeks;
  }
  _numberOfWeeks = 1;
  /**
   * The invariant name for this view.
   * @default 'timelineWeek'
   */
  name = "timelineWeek";
  constructor(_intl, localization, changeDetector, viewContext, viewState) {
    super(localization, changeDetector, viewContext, viewState);
  }
  /**
   * @hidden
   */
  getStartDate = (selectedDate) => {
    return firstDayInWeek(getDate(selectedDate), this.viewWeekStart);
  };
  static ɵfac = function TimelineWeekViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TimelineWeekViewComponent)(ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimelineWeekViewComponent,
    selectors: [["kendo-scheduler-timeline-week-view"]],
    inputs: {
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat",
      numberOfWeeks: "numberOfWeeks"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _TimelineWeekViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], ["viewName", "timeline-week", 3, "name", "numberOfDays", "getStartDate", "eventHeight", "columnWidth", "currentTimeMarker", "highlightOngoingEvents", "showWorkHours", "scrollTime", "startTime", "endTime", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "weekStart", "slotDuration", "slotDivisions", "slotClass", "eventClass", "eventStyles", "eventTemplate", "groupHeaderTemplate", "timeSlotTemplate", "dateHeaderTemplate", "majorTimeHeaderTemplate", "minorTimeHeaderTemplate", "selectedDateFormat", "selectedShortDateFormat"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "showWorkHours", "itemClick", 4, "ngIf"], ["viewFooter", "", "kendoWorkHoursFooter", "", 3, "itemClick", "showWorkHours"]],
    template: function TimelineWeekViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, TimelineWeekViewComponent_ng_template_0_Template, 2, 30, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineWeekViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-timeline-week-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => TimelineWeekViewComponent)
      }],
      template: `
        <ng-template #content>
            <timeline-multi-day-view
                viewName="timeline-week"
                [name]="name"
                [numberOfDays]="7 * numberOfWeeks"
                [getStartDate]="getStartDate"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [weekStart]="viewWeekStart"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
      standalone: true,
      imports: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
    }]
  }], function() {
    return [{
      type: IntlService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }];
  }, {
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    numberOfWeeks: [{
      type: Input
    }]
  });
})();
var createTasks = (periodStart, periodEnd, items, ranges) => {
  const tasks = [];
  const utcStart = toUTCDateTime2(periodStart);
  const utcEnd = toUTCDateTime2(periodEnd);
  for (let index = 0; index < items.length; index++) {
    const item = items[index];
    const data = {};
    const startTime = item.start.toUTCDate();
    const end = item.end;
    const endTime = (item.end.getTime() !== end.getTime() ? end.addDays(1) : end).toUTCDate();
    if (intersects(startTime, endTime, utcStart, utcEnd)) {
      for (let rangeIdx = 0; rangeIdx < ranges.length; rangeIdx++) {
        const range3 = ranges[rangeIdx];
        const rangeStart = toUTCDate(range3);
        const rangeEnd = toUTCDate(addDays(range3, 1));
        if (intersects(startTime, endTime, rangeStart, rangeEnd)) {
          const task = {
            index,
            startTime: startTime > rangeStart ? startTime : rangeStart,
            endTime: endTime < rangeEnd ? endTime : rangeEnd,
            start: item.start,
            end: item.end,
            event: item.event,
            isAllDay: item.event.isAllDay,
            rangeIndex: rangeIdx,
            data
          };
          task.head = endTime > rangeEnd && startTime > rangeStart;
          task.tail = startTime < rangeStart && endTime < rangeEnd;
          task.mid = endTime > rangeEnd && startTime < rangeStart;
          task.isMultiDay = task.head || task.mid || task.tail;
          tasks.push(task);
        }
      }
    }
  }
  return sortTasksByTime(tasks);
};
var noop2 = (_) => {
};
var yearEnd = (year) => new Date(year, 11, 31, 23, 59, 59, 999);
var yearStart = (year) => new Date(year, 0, 1, 0, 0, 0, 0);
var today = new Date(Date.now());
var getDateAttribute = (element) => element?.querySelector("span>span[date]")?.getAttribute("date");
var YearViewInternalComponent = class _YearViewInternalComponent extends BaseView {
  localization;
  focusService;
  intl;
  localeId;
  /**
   * Calculates the next or previous range to be displayed
   */
  newRange;
  /**
   * Determines the displayed date range and formats the selected date
   */
  dateRangeFn;
  calendar;
  tooltip;
  get arrowIcons() {
    return !this.localization.rtl ? ["caret-alt-left", "caret-alt-right"] : ["caret-alt-right", "caret-alt-left"];
  }
  get arrowSVGIcons() {
    return !this.localization.rtl ? [this.caretAltLeftIcon, this.caretAltRightIcon] : [this.caretAltRightIcon, this.caretAltLeftIcon];
  }
  caretAltLeftIcon = caretAltLeftIcon;
  caretAltRightIcon = caretAltRightIcon;
  eventsPerSelectedDay = [];
  days = [];
  focusedDate;
  currentTd;
  tds = [];
  isTooltipClicked = false;
  constructor(localization, focusService, intl, viewContext, viewState, zone, renderer, pdfService, element, slotService, scrollBarWidthService, changeDetector, localeId) {
    super(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, changeDetector, scrollBarWidthService);
    this.localization = localization;
    this.focusService = focusService;
    this.intl = intl;
    this.localeId = localeId;
  }
  ngAfterViewInit() {
    this.updateTds();
    super.ngAfterViewInit();
    this.focusedDate = new Date(this.selectedDate.getFullYear(), today.getMonth(), today.getDate());
  }
  getSlotClass(date) {
    if (this.slotClass) {
      return this.slotClass({
        start: date,
        end: addDays(date, 1),
        events: this.eventsPerDay(date)
      });
    }
  }
  getEventClasses(item, resources, isAllDay) {
    if (this.eventClass) {
      return this.eventClass({
        event: item.event,
        resources,
        isAllDay
      });
    }
  }
  onBlur() {
    if (!this.isTooltipClicked) {
      this.tooltip.hide();
    }
    this.isTooltipClicked = false;
  }
  getDate(element) {
    return new Date(getDateAttribute(element.nativeElement));
  }
  eventTitle(event2) {
    const startTime = toLocalDate(event2.startTime);
    const endTime = toLocalDate(event2.endTime);
    const time = formatEventTime(startTime, endTime, event2.isAllDay, this.localeId);
    return `${time}, ${event2.event.title}`;
  }
  onClick(event2) {
    if (event2.target.tagName === "SPAN") {
      const clickedDate = getDateAttribute(event2.target.closest("td.k-calendar-td"));
      if (clickedDate === getDateAttribute(this.currentTd)) {
        this.tooltip.show(this.currentTd);
      }
    } else {
      this.tooltip.hide();
    }
  }
  onMouseDown() {
    this.isTooltipClicked = true;
  }
  onKeydown(event2) {
    if (event2.key === "Backspace" || event2.key === "Delete") {
      this.tooltip.hide();
    }
    if (event2.key === "Enter" && !this.tooltip.popupRef) {
      this.tooltip.show(this.currentTd);
      return;
    }
    if (event2.key === "Enter" && this.tooltip.popupRef && getDateAttribute(this.currentTd) === this.calendar.focusedDate.toString()) {
      this.navigateToDay(new Date(getDateAttribute(this.currentTd)));
    }
  }
  navigateToDay(date) {
    this.tooltip.hide();
    this.zone.run(() => {
      this.viewState.navigateTo({
        viewName: "day",
        date: new Date(date)
      });
    });
  }
  eventsPerDay(date) {
    return this.tasksPerDay(date)?.map((task) => task.event) || [];
  }
  tasksPerDay(date) {
    if (this.resources?.length > 0) {
      return this.tasks?.filter((event2) => event2.resources.length > 0 && event2.startTime.getUTCDate() === date.getDate() && event2.startTime.getUTCMonth() === date.getMonth());
    } else {
      return this.tasks?.filter((event2) => event2.startTime.getUTCDate() === date.getDate() && event2.startTime.getUTCMonth() === date.getMonth());
    }
  }
  onValueChange(date) {
    this.eventsPerSelectedDay = this.tasksPerDay(date);
    this.currentTd = this.tds.find((td2) => getDateAttribute(td2) === date.toString());
    if (this.tooltip.popupRef) {
      this.tooltip.hide();
    }
  }
  hasEvent(date) {
    return this.tasksPerDay(date).length > 0;
  }
  createPDFElement() {
    const element = this.element.nativeElement.cloneNode(true);
    element.style.width = `${this.element.nativeElement.offsetWidth}px`;
    element.querySelector(".k-scheduler-layout").style.height = "auto";
    this.pdfService.elementReady.emit({
      element
    });
  }
  onSelectDate(date) {
    const year = date.getFullYear();
    const start = yearStart(year);
    this.focusedDate = new Date(year, start.getMonth(), today.getDate());
    this.selectedDate = start;
    const dateRange = this.dateRange(date);
    this.viewState.notifyDateRange(dateRange);
    this.days = this.createDaySlots(dateRange);
    if (this.calendar) {
      this.calendar.min = start;
      this.calendar.max = yearEnd(start.getFullYear());
      this.zone.onStable.pipe(take(1)).subscribe(() => this.updateTds());
    }
  }
  onAction(e) {
    const now = this.selectedDate;
    if (e.type === "next" || e.type === "prev") {
      const offset2 = e.type === "next" ? 1 : -1;
      const next = addYears(now, offset2);
      this.viewState.notifyNextDate(next);
      this.calendar.min = next;
      this.calendar.max = yearEnd(next.getFullYear());
      this.focusedDate = new Date(next.getFullYear(), today.getMonth(), today.getDate());
    }
  }
  createTasks(items, dateRange) {
    this.days = this.createDaySlots(dateRange);
    return createTasks(dateRange.start, dateRange.end, items, this.days);
  }
  reflow() {
    this.updateContentHeight();
    const content2 = this.content.nativeElement;
    if (this.contentHeight === "auto") {
      content2.style.overflow = "visible";
    }
    if (this.contentHeight === "auto") {
      content2.style.overflow = "";
    }
  }
  dateRange(date = this.selectedDate) {
    return this.dateRangeFn(date);
  }
  onTasksChange() {
    this.items.next(this.tasks);
  }
  slotByIndex = (slotIndex, args) => noop2(slotIndex);
  dragHintSize = (startSlot, endSlot) => noop2(startSlot);
  dragRanges = (slot) => noop2(slot);
  slotByPosition = (x, y, container) => noop2(x);
  createDaySlots({
    start
  }) {
    const days = [];
    const monthsPerYear = 12;
    let date = start;
    for (let idx2 = 0; idx2 < monthsPerYear; idx2++) {
      const monthTotalDays = this.getLastDayOfMonth(date.getFullYear(), date.getMonth());
      for (let dayIdx = 0; dayIdx < monthTotalDays; dayIdx++) {
        days.push(date);
        const nextDay = addDays(date, 1);
        date = nextDay;
      }
    }
    return days;
  }
  getLastDayOfMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  }
  cachedTds = [];
  updateTds() {
    this.cachedTds.forEach((td2) => {
      this.renderer.setAttribute(td2, "class", "k-calendar-td");
    });
    this.cachedTds = [];
    this.tds = Array.from(this.calendar.element.nativeElement.querySelectorAll(".k-calendar-td:not(.k-empty)"));
    if (this.calendar.value instanceof Date && this.calendar.value.getFullYear() === this.calendar.min?.getFullYear()) {
      this.currentTd = this.tds.find((td2) => getDateAttribute(td2) === this.calendar.value.toString());
    }
    if (this.slotClass) {
      this.tds.forEach((td2) => {
        const date = toUTCDate(new Date(getDateAttribute(td2)));
        const userClass = this.getSlotClass(date);
        if (userClass) {
          this.renderer.addClass(td2, userClass);
          this.cachedTds.push(td2);
        }
      });
    }
  }
  static ɵfac = function YearViewInternalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _YearViewInternalComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(FocusService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MonthSlotService), ɵɵdirectiveInject(ScrollbarWidthService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LOCALE_ID));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _YearViewInternalComponent,
    selectors: [["year-view-internal"]],
    viewQuery: function YearViewInternalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(MultiViewCalendarComponent, 5);
        ɵɵviewQuery(TooltipDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.calendar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltip = _t.first);
      }
    },
    inputs: {
      newRange: "newRange",
      dateRangeFn: "dateRangeFn"
    },
    features: [ɵɵProvidersFeature([MonthSlotService]), ɵɵInheritDefinitionFeature],
    decls: 7,
    vars: 9,
    consts: [["content", ""], ["template", ""], [1, "k-scheduler-layout", "k-scheduler-layout-flex", "k-scheduler-yearview"], [1, "k-scheduler-body"], ["kendoTooltip", "", "filter", ".k-calendar-td", "showOn", "none", "position", "right", "tooltipContentClass", "k-scheduler-tooltip", 3, "valueChange", "blur", "showOtherMonthDays", "showCalendarHeader", "showViewHeader", "views", "focusedDate", "tooltipTemplate", "tooltipWidth", "collision"], ["kendoCalendarMonthCellTemplate", ""], [4, "ngIf"], ["class", "k-day-indicator", 4, "ngIf"], [1, "k-day-indicator"], [1, "k-tooltip-title", "k-text-center", 3, "click", "mousedown"], [1, "k-month"], [1, "k-link", "k-day", "k-text-primary"], [1, "k-tooltip-events-container", 3, "mousedown"], [1, "k-tooltip-events"], ["class", "k-tooltip-event k-event", 3, "title", "ngClass", "ngStyle", 4, "ngFor", "ngForOf"], ["class", "k-no-data k-text-center", 4, "ngIf"], [1, "k-tooltip-event", "k-event", 3, "title", "ngClass", "ngStyle"], [3, "name", "svgIcon", 4, "ngIf"], [1, "k-event-title", "k-text-ellipsis"], [1, "k-spacer"], ["class", "k-event-time", 4, "ngIf"], [3, "name", "svgIcon"], [1, "k-event-time"], [1, "k-no-data", "k-text-center"]],
    template: function YearViewInternalComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2, 0)(2, "div", 3)(3, "kendo-multiviewcalendar", 4);
        ɵɵlistener("valueChange", function YearViewInternalComponent_Template_kendo_multiviewcalendar_valueChange_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onValueChange($event));
        })("blur", function YearViewInternalComponent_Template_kendo_multiviewcalendar_blur_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        });
        ɵɵtemplate(4, YearViewInternalComponent_ng_template_4_Template, 2, 2, "ng-template", 5);
        ɵɵelementEnd()()();
        ɵɵtemplate(5, YearViewInternalComponent_ng_template_5_Template, 9, 4, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const template_r8 = ɵɵreference(6);
        ɵɵadvance(3);
        ɵɵproperty("showOtherMonthDays", false)("showCalendarHeader", false)("showViewHeader", true)("views", 12)("focusedDate", ctx.focusedDate)("tooltipTemplate", template_r8)("tooltipWidth", 220)("collision", ɵɵpureFunction0(8, _c48));
      }
    },
    dependencies: [MultiViewCalendarComponent, TooltipDirective, MonthCellTemplateDirective, NgIf, NgForOf, NgClass, NgStyle, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearViewInternalComponent, [{
    type: Component,
    args: [{
      selector: "year-view-internal",
      providers: [MonthSlotService],
      template: `
        <div #content class="k-scheduler-layout k-scheduler-layout-flex k-scheduler-yearview">
            <div class="k-scheduler-body">
                <kendo-multiviewcalendar
                    [showOtherMonthDays]="false"
                    [showCalendarHeader]="false"
                    [showViewHeader]="true"
                    [views]="12"
                    [focusedDate]="focusedDate"
                    kendoTooltip
                    filter=".k-calendar-td"
                    showOn="none"
                    [tooltipTemplate]="template"
                    position="right"
                    tooltipContentClass="k-scheduler-tooltip"
                    [tooltipWidth]="220"
                    [collision]="{ horizontal: 'flip', vertical: 'flip' }"
                    (valueChange)="onValueChange($event)"
                    (blur)="onBlur()"
                >
                    <ng-template kendoCalendarMonthCellTemplate let-date let-context="cellContext">
                        <span *ngIf="!context.isOtherMonth" [attr.date]="date">{{ date.getDate() }}</span>
                        <span *ngIf="!context.isOtherMonth && hasEvent(date)" class="k-day-indicator"></span>
                    </ng-template>
                </kendo-multiviewcalendar>
            </div>
        </div>
        <ng-template #template let-anchor>
            <div
                class="k-tooltip-title k-text-center"
                (click)="navigateToDay(getDate(anchor))"
                (mousedown)="onMouseDown()"
            >
                <div class="k-month">{{ intl.formatDate(getDate(anchor), 'MMM') }}</div>
                <div class="k-link k-day k-text-primary">{{ intl.formatDate(getDate(anchor), 'dd') }}</div>
            </div>
            <div class="k-tooltip-events-container" (mousedown)="onMouseDown()">
                <div class="k-tooltip-events">
                    <div
                        *ngFor="let event of eventsPerSelectedDay"
                        class="k-tooltip-event k-event"
                        [title]="eventTitle(event)"
                        [ngClass]="getEventClasses(event, event.resources)"
                        [ngStyle]="getEventStyles(event, event.resources[0], event.isAllDay)"
                    >
                        <kendo-icon-wrapper
                            *ngIf="event.tail || event.mid"
                            [name]="arrowIcons[0]"
                            [svgIcon]="arrowSVGIcons[0]"
                        >
                        </kendo-icon-wrapper>
                        <div class="k-event-title k-text-ellipsis">{{ event.event.title }}</div>
                        <span class="k-spacer"></span>
                        <span
                            class="k-event-time"
                            *ngIf="(event.isMultiDay && event.head && !event.isAllDay) || !event.isMultiDay"
                            >{{ intl.formatDate(event.start, 't') }}</span
                        >
                        <kendo-icon-wrapper
                            *ngIf="event.head || event.mid"
                            [name]="arrowIcons[1]"
                            [svgIcon]="arrowSVGIcons[1]"
                        >
                        </kendo-icon-wrapper>
                    </div>
                </div>
            </div>
            <div *ngIf="eventsPerSelectedDay.length === 0" class="k-no-data k-text-center">
                {{ localization.get('yearViewNoEvents') }}
            </div>
        </ng-template>
    `,
      standalone: true,
      imports: [MultiViewCalendarComponent, TooltipDirective, MonthCellTemplateDirective, NgIf, NgForOf, NgClass, NgStyle, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: FocusService
    }, {
      type: IntlService
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: PDFService
    }, {
      type: ElementRef
    }, {
      type: MonthSlotService
    }, {
      type: ScrollbarWidthService
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, {
    newRange: [{
      type: Input
    }],
    dateRangeFn: [{
      type: Input
    }],
    calendar: [{
      type: ViewChild,
      args: [MultiViewCalendarComponent]
    }],
    tooltip: [{
      type: ViewChild,
      args: [TooltipDirective]
    }]
  });
})();
var YearViewComponent = class _YearViewComponent extends ConfigurationViewBase {
  intl;
  /**
   * The long-date format for displaying the
   * selected year in the Scheduler toolbar.
   * For more information, see [Parsing and Formatting Dates and Numbers]({% slug parsingandformatting_intl %}#toc-date-formatting).
   * @default '{0:yyy}'
   */
  selectedDateFormat = "{0:yyy}";
  /**
   * The short-date format for displaying the
   * selected year in the Scheduler toolbar.
   * For more information, see [Parsing and Formatting Dates and Numbers]({% slug parsingandformatting_intl %}#toc-date-formatting).
   * @default '{0:yyy}'
   */
  selectedShortDateFormat = "{0:yyy}";
  /**
   * @hidden
   */
  get title() {
    return this.localization.get("yearViewTitle");
  }
  /**
   * @hidden
   */
  highlightOngoingEvents;
  /**
   * The invariant name for this view.
   * @default 'year'
   */
  name = "year";
  constructor(localization, changeDetector, viewContext, viewState, intl) {
    super(localization, changeDetector, viewContext, viewState);
    this.intl = intl;
  }
  /**
   * @hidden
   */
  dateRange(date) {
    const year = date.getFullYear();
    const start = yearStart(year);
    const end = yearEnd(year);
    const text = this.intl.format(this.selectedDateFormat, start);
    const shortText = this.intl.format(this.selectedShortDateFormat, start);
    return {
      start,
      end,
      text,
      shortText
    };
  }
  /**
   * @hidden
   */
  newRange(date, direction = 1) {
    return new Date(addYears(date, direction));
  }
  static ɵfac = function YearViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _YearViewComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewContextService), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(IntlService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _YearViewComponent,
    selectors: [["kendo-scheduler-year-view"]],
    inputs: {
      selectedDateFormat: "selectedDateFormat",
      selectedShortDateFormat: "selectedShortDateFormat",
      highlightOngoingEvents: "highlightOngoingEvents"
    },
    features: [ɵɵProvidersFeature([{
      provide: SchedulerView,
      useExisting: forwardRef(() => _YearViewComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 0,
    consts: [["content", ""], [3, "selectedDateFormat", "selectedShortDateFormat", "slotClass", "eventClass", "eventStyles", "dateRangeFn", "newRange"]],
    template: function YearViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, YearViewComponent_ng_template_0_Template, 1, 7, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
    },
    dependencies: [YearViewInternalComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-scheduler-year-view",
      providers: [{
        provide: SchedulerView,
        useExisting: forwardRef(() => YearViewComponent)
      }],
      template: `
        <ng-template #content>
            <year-view-internal
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </year-view-internal>
        </ng-template>
    `,
      standalone: true,
      imports: [YearViewInternalComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewContextService
    }, {
      type: ViewStateService
    }, {
      type: IntlService
    }];
  }, {
    selectedDateFormat: [{
      type: Input
    }],
    selectedShortDateFormat: [{
      type: Input
    }],
    highlightOngoingEvents: [{
      type: Input
    }]
  });
})();
var isRecurrenceMaster = (ev) => !!(ev.id && ev.recurrenceRule);
var LocalEditService = class {
  scheduler;
  localDataChangesService;
  get fields() {
    return this.scheduler.modelFields;
  }
  get hasLocalData() {
    return isPresent4(this.localDataChangesService.data);
  }
  get data() {
    if (this.hasLocalData) {
      return this.localDataChangesService.data;
    }
    return this.scheduler.events;
  }
  constructor(scheduler, localDataChangesService) {
    this.scheduler = scheduler;
    this.localDataChangesService = localDataChangesService;
  }
  create(item) {
    const idField = this.fields.id;
    const id = getField(item, idField);
    if (!isPresent4(id)) {
      setField(item, idField, this.nextId());
    }
    this.data.push(item);
    this.dataChanged();
  }
  createException(item, value2) {
    const exception = this.buildException(value2);
    this.removeOccurrenceInternal(item);
    this.create(exception);
  }
  update(item, value2) {
    assignValues(item, value2);
    this.dataChanged();
  }
  remove(item) {
    const idField = this.fields.id;
    const itemId = getField(item, idField);
    const data = this.data;
    for (let idx2 = 0; idx2 < data.length; idx2++) {
      if (itemId === getField(data[idx2], idField)) {
        data.splice(idx2, 1);
        break;
      }
    }
    this.dataChanged();
  }
  removeSeries(item) {
    const event2 = readEvent(item, this.fields);
    const isHead = isRecurrenceMaster(event2);
    this.removeItemAndExceptions(isHead ? event2.id : event2.recurrenceId);
    this.dataChanged();
  }
  removeOccurrence(item) {
    this.removeOccurrenceInternal(item);
    this.dataChanged();
  }
  findRecurrenceMaster(item) {
    const fields = this.scheduler.modelFields;
    const event2 = readEvent(item, fields);
    const headId = isRecurrenceMaster(event2) ? event2.id : event2.recurrenceId;
    return this.data.find((dataItem) => getField(dataItem, fields.id) === headId);
  }
  isRecurring(event2) {
    return isRecurring(event2, this.scheduler.modelFields);
  }
  isException(event2) {
    return isException2(event2, this.scheduler.modelFields);
  }
  nextId() {
    return guid();
  }
  buildException(item) {
    const fields = this.fields;
    const head = this.findRecurrenceMaster(item);
    if (!head) {
      if (isDevMode()) {
        throw new Error("Unable to find recurrence head for event. Please check that recurrenceId is set and refers to an existing event.");
      }
      return;
    }
    const exception = clone(item);
    setField(exception, fields.id, this.nextId());
    setField(exception, fields.recurrenceId, getField(head, fields.id));
    setField(exception, fields.recurrenceRule, null);
    return exception;
  }
  removeItemAndExceptions(itemId) {
    const data = this.data;
    const fields = this.scheduler.modelFields;
    for (let idx2 = data.length - 1; idx2 >= 0; idx2--) {
      if (itemId === getField(data[idx2], fields.recurrenceId) || itemId === getField(data[idx2], fields.id)) {
        data.splice(idx2, 1);
      }
    }
  }
  removeOccurrenceInternal(item) {
    const fields = this.fields;
    const head = this.findRecurrenceMaster(item);
    const exceptionDate = getField(item, fields.start);
    const currentExceptions = getField(head, fields.recurrenceExceptions) || [];
    setField(head, fields.recurrenceExceptions, [...currentExceptions, exceptionDate]);
  }
  dataChanged() {
    if (this.hasLocalData) {
      this.localDataChangesService.changes.emit();
    }
  }
};
var markAllAsTouched = (control) => {
  control.markAsTouched();
  if (control.hasOwnProperty("controls")) {
    const controls = control.controls;
    for (const inner in controls) {
      if (controls.hasOwnProperty(inner)) {
        markAllAsTouched(controls[inner]);
      }
    }
  }
};
function diff(obj1, obj2, fields) {
  for (let idx2 = 0; idx2 < fields.length; idx2++) {
    const field = fields[idx2];
    if (!areEqual(getField(obj1, field), getField(obj2, field))) {
      return true;
    }
  }
  return false;
}
function areEqual(value1, value2) {
  if (value1 && value1.getTime && value2 && value2.getTime) {
    return value1.getTime() === value2.getTime();
  } else if (Array.isArray(value1)) {
    if (!Array.isArray(value2) || value1.length !== value2.length) {
      return false;
    }
    for (let idx2 = 0; idx2 < value1.length; idx2++) {
      if (value1[idx2] !== value2[idx2]) {
        return false;
      }
    }
    return true;
  }
  return value1 == value2;
}
var DATE_ACCESSORS = ["getFullYear", "getMonth", "getDate", "getHours", "getMinutes", "getSeconds", "getMilliseconds"];
function seriesDate(head, occurrence, current, field) {
  const values = [];
  const headDate = getField(head, field);
  const occurrenceDate = getField(occurrence, field);
  const currentDate = getField(current, field);
  DATE_ACCESSORS.forEach((accessor) => {
    values.push(occurrenceDate[accessor]() === currentDate[accessor]() ? headDate[accessor]() : currentDate[accessor]());
  });
  return new Date(...values);
}
function updateRecurrenceRule(valueSrc, valueGoal) {
  const rrule = parseRule({
    recurrenceRule: valueSrc.recurrenceRule
  });
  if (!valueSrc.recurrenceRule.includes("WKST")) {
    rrule.weekStart = void 0;
  }
  if (valueSrc.start?.getDate() !== valueGoal.start?.getDate()) {
    if (rrule.byYearDay?.length > 0) {
      const itemIndex = rrule.byYearDay.findIndex((yearDay) => yearDay === valueSrc.start?.getDate());
      if (itemIndex !== -1) {
        rrule.byYearDay[itemIndex] = valueGoal.start?.getDate();
      }
    }
    if (rrule.byMonthDay?.length > 0) {
      const itemIndex = rrule.byMonthDay.findIndex((monthDay) => monthDay === valueSrc.start?.getDate());
      if (itemIndex !== -1) {
        rrule.byMonthDay[itemIndex] = valueGoal.start?.getDate();
      }
    }
  }
  if (valueSrc.start?.getDay() !== valueGoal.start?.getDay() && rrule.byWeekDay?.length > 0) {
    const itemIndex = rrule.byWeekDay.findIndex((weekDayRule) => weekDayRule.day === valueSrc.start?.getDay());
    if (itemIndex !== -1) {
      rrule.byWeekDay[itemIndex].day = valueGoal.start?.getDay();
    }
  }
  if (valueSrc.start?.getMonth() !== valueGoal.start?.getMonth() && rrule.byMonth?.length > 0) {
    const itemIndex = rrule.byMonth.findIndex((month) => month === valueSrc.start?.getMonth());
    if (itemIndex !== -1) {
      rrule.byMonth[itemIndex] = valueGoal.start?.getMonth();
    }
  }
  return serializeRule(rrule);
}
var EditingDirectiveBase = class _EditingDirectiveBase {
  scheduler;
  localDataChangesService;
  dialogsService;
  focusService;
  /**
   * Fires before the editing directive renders the **Add** dialog.
   */
  add = new EventEmitter();
  /**
   * Fires before the editing directive renders the **Edit** dialog.
   */
  edit = new EventEmitter();
  /**
   * The edit service that will handle the editing operations.
   */
  set editService(value2) {
    this.userEditService = value2;
  }
  get editService() {
    return this.userEditService || this.defaultEditService;
  }
  defaultTitle = "No title";
  subscriptions;
  defaultEditService;
  userEditService;
  constructor(scheduler, localDataChangesService, dialogsService, focusService) {
    this.scheduler = scheduler;
    this.localDataChangesService = localDataChangesService;
    this.dialogsService = dialogsService;
    this.focusService = focusService;
    this.defaultEditService = this.createDefaultService();
    this.scheduler.editable = true;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscriptions = merge(this.scheduler.slotDblClick, this.scheduler.create).subscribe(this.addHandler.bind(this));
    this.subscriptions.add(this.scheduler.removeConfirmed.subscribe(this.removeHandler.bind(this)));
    this.subscriptions.add(this.scheduler.cancel.subscribe(this.cancelHandler.bind(this)));
    this.subscriptions.add(this.scheduler.resizeEndConfirmed.subscribe(this.resizeEndHandler.bind(this)));
    this.subscriptions.add(this.scheduler.dragEndConfirmed.subscribe(this.dragEndHandler.bind(this)));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  createDefaultService() {
    return new LocalEditService(this.scheduler, this.localDataChangesService);
  }
  addHandler(args) {
    this.closeEditor();
    if (!this.isEnabled("add")) {
      return;
    }
    const fields = this.scheduler.modelFields;
    const dataItem = {};
    setField(dataItem, fields.start, args.start);
    setField(dataItem, fields.end, args.end);
    setField(dataItem, fields.isAllDay, args.isAllDay);
    setField(dataItem, fields.title, args.title);
    const resources = groupResources(this.scheduler.group, this.scheduler.resources);
    const slotResources = args.resources;
    for (let idx2 = 0; idx2 < resources.length; idx2++) {
      const resource = resources[idx2];
      const value2 = getField(slotResources[idx2], resource.valueField);
      setField(dataItem, resource.field, resource.multiple ? [value2] : value2);
    }
    const addArgs = new AddEvent(this.scheduler, {
      dataItem
    });
    this.add.emit(addArgs);
    if (!addArgs.isDefaultPrevented()) {
      this.scheduler.addEvent(this.createModel({
        action: "add",
        isNew: true,
        dataItem,
        sender: this.scheduler
      }));
    }
  }
  removeHandler({
    dataItem
  }) {
    if (!this.isEnabled("remove")) {
      return;
    }
    if (this.editService.isRecurring(dataItem)) {
      this.dialogsService.openRecurringConfirmationDialog(CrudOperation.Remove).subscribe((editMode) => {
        if (editMode !== void 0) {
          this.handleRemove(dataItem, editMode);
          this.focusService.focusContent();
        }
      });
    } else {
      this.dialogsService.openRemoveConfirmationDialog().subscribe((shouldRemove) => {
        if (shouldRemove) {
          this.handleRemove(dataItem, EditMode.Event);
          this.focusService.focusContent();
        }
      });
    }
  }
  cancelHandler() {
    this.closeEditor();
  }
  closeEditor() {
    this.scheduler.closeEvent();
  }
  handleUpdate(item, value2, mode) {
    const svc = this.editService;
    if (mode === EditMode.Occurrence) {
      svc.isException(item) ? svc.update(item, value2) : svc.createException(item, value2);
    } else {
      svc.update(item, value2);
    }
  }
  handleRemove(item, mode) {
    const svc = this.editService;
    if (mode === EditMode.Series) {
      svc.removeSeries(item);
    } else if (mode === EditMode.Occurrence) {
      svc.isException(item) ? svc.remove(item) : svc.removeOccurrence(item);
    } else {
      svc.remove(item);
    }
  }
  resizeEndHandler({
    event: event2,
    start,
    end
  }) {
    if (areEqual(start, event2.start) && areEqual(end, event2.end)) {
      return;
    }
    const dataItem = event2.dataItem;
    const fields = this.scheduler.modelFields;
    let value2 = {};
    setField(value2, fields.start, start);
    setField(value2, fields.end, end);
    if (this.editService.isRecurring(dataItem)) {
      this.dialogsService.openRecurringConfirmationDialog(CrudOperation.Edit).subscribe((result) => {
        let target = dataItem;
        if (result === EditMode.Series) {
          target = this.editService.findRecurrenceMaster(dataItem);
          setField(value2, fields.start, seriesDate(target, dataItem, value2, fields.start));
          setField(value2, fields.end, seriesDate(target, dataItem, value2, fields.end));
        } else if (result !== void 0) {
          value2 = assignValues(clone(dataItem), value2);
        }
        this.handleUpdate(target, value2, result);
      });
    } else {
      this.editService.update(dataItem, value2);
    }
  }
  dragEndHandler({
    event: {
      dataItem
    },
    start,
    end,
    resources,
    isAllDay
  }) {
    const modelFields = this.scheduler.modelFields;
    const resourceFields = groupResources(this.scheduler.group, this.scheduler.resources).map((r) => r.field);
    const fields = [modelFields.start, modelFields.end, modelFields.isAllDay].concat(resourceFields);
    let value2 = clone(resources);
    setField(value2, modelFields.start, start);
    setField(value2, modelFields.end, end);
    setField(value2, modelFields.isAllDay, isAllDay);
    if (!diff(dataItem, value2, fields)) {
      return;
    }
    if (this.editService.isRecurring(dataItem)) {
      this.dialogsService.openRecurringConfirmationDialog(CrudOperation.Edit).subscribe((result) => {
        let target = dataItem;
        if (result === EditMode.Series) {
          target = this.editService.findRecurrenceMaster(dataItem);
          if (dataItem.recurrenceRule) {
            const newRecurrenceRule = updateRecurrenceRule(dataItem, value2);
            if (newRecurrenceRule !== dataItem?.recurrenceRule) {
              setField(value2, modelFields.recurrenceRule, newRecurrenceRule);
            }
          }
          setField(value2, modelFields.start, seriesDate(target, dataItem, value2, modelFields.start));
          setField(value2, modelFields.end, seriesDate(target, dataItem, value2, modelFields.end));
        } else if (result !== void 0) {
          value2 = assignValues(clone(dataItem), value2);
        }
        this.handleUpdate(target, value2, result);
      });
    } else {
      this.editService.update(dataItem, value2);
    }
  }
  isEnabled(action) {
    const editable = this.scheduler.editable;
    return editable && editable[action] !== false;
  }
  static ɵfac = function EditingDirectiveBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditingDirectiveBase)(ɵɵdirectiveInject(SchedulerComponent), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(DialogsService), ɵɵdirectiveInject(FocusService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EditingDirectiveBase,
    inputs: {
      editService: "editService"
    },
    outputs: {
      add: "add",
      edit: "edit"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditingDirectiveBase, [{
    type: Directive
  }], function() {
    return [{
      type: SchedulerComponent
    }, {
      type: LocalDataChangesService
    }, {
      type: DialogsService
    }, {
      type: FocusService
    }];
  }, {
    add: [{
      type: Output
    }],
    edit: [{
      type: Output
    }],
    editService: [{
      type: Input
    }]
  });
})();
var ReactiveEditingDirective = class _ReactiveEditingDirective extends EditingDirectiveBase {
  scheduler;
  localDataChangesService;
  dialogsService;
  /**
   * The function that creates the `FormGroup` for the edited model.
   */
  createFormGroup;
  constructor(scheduler, localDataChangesService, dialogsService, focusService) {
    super(scheduler, localDataChangesService, dialogsService, focusService);
    this.scheduler = scheduler;
    this.localDataChangesService = localDataChangesService;
    this.dialogsService = dialogsService;
  }
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.scheduler.eventDblClick.subscribe(this.editHandler.bind(this)));
    this.subscriptions.add(this.scheduler.save.subscribe(this.saveHandler.bind(this)));
  }
  editHandler(args) {
    if (!this.isEnabled("edit")) {
      return;
    }
    const editArgs = new EditEvent(this.scheduler, {
      dataItem: args.event.dataItem,
      event: args.event
    });
    this.edit.emit(editArgs);
    if (editArgs.isDefaultPrevented()) {
      return;
    }
    let dataItem = args.event.dataItem;
    if (this.editService.isRecurring(dataItem)) {
      this.dialogsService.openRecurringConfirmationDialog(CrudOperation.Edit).pipe(filter((mode) => mode !== void 0)).subscribe((mode) => {
        if (mode === EditMode.Series) {
          dataItem = this.editService.findRecurrenceMaster(dataItem);
        }
        const group3 = this.createModel({
          action: "edit",
          isNew: false,
          mode,
          dataItem,
          sender: this.scheduler
        });
        this.scheduler.editEvent(dataItem, {
          group: group3,
          mode
        });
      });
    } else {
      const group3 = this.createModel({
        action: "edit",
        isNew: false,
        mode: EditMode.Event,
        dataItem,
        sender: this.scheduler
      });
      this.scheduler.editEvent(dataItem, {
        group: group3
      });
    }
  }
  saveHandler(args) {
    if (this.isFormValid(args)) {
      const formValue = args.formGroup.getRawValue();
      if (args.isNew) {
        this.editService.create(formValue);
      } else {
        this.handleUpdate(args.dataItem, formValue, args.mode);
      }
    }
    this.closeEditor();
  }
  createModel(args) {
    return this.createFormGroup(args);
  }
  isFormValid({
    formGroup,
    isNew
  }) {
    if (formGroup.valid) {
      return true;
    }
    if (!formGroup.dirty && !isNew) {
      return false;
    }
    markAllAsTouched(formGroup);
    return false;
  }
  static ɵfac = function ReactiveEditingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReactiveEditingDirective)(ɵɵdirectiveInject(SchedulerComponent), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(DialogsService), ɵɵdirectiveInject(FocusService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ReactiveEditingDirective,
    selectors: [["", "kendoSchedulerReactiveEditing", ""]],
    inputs: {
      createFormGroup: [0, "kendoSchedulerReactiveEditing", "createFormGroup"]
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSchedulerReactiveEditing]",
      standalone: true
    }]
  }], function() {
    return [{
      type: SchedulerComponent
    }, {
      type: LocalDataChangesService
    }, {
      type: DialogsService
    }, {
      type: FocusService
    }];
  }, {
    createFormGroup: [{
      type: Input,
      args: ["kendoSchedulerReactiveEditing"]
    }]
  });
})();
var isContentWrapper = (element) => hasClasses(element, "k-scheduler-content");
var CALENDAR_TAG = "KENDO-CALENDAR-HORIZONTAL";
var ShortcutsDirective = class _ShortcutsDirective {
  scheduler;
  domEvents;
  focusService;
  zone;
  changeDetector;
  viewState;
  dialogsService;
  shortcuts = [{
    match: (e) => e.keyCode === Keys.KeyC && noModifiers(e),
    action: (e) => {
      const scheduler = this.scheduler;
      const hours = (/* @__PURE__ */ new Date()).getHours();
      const selected = scheduler.selectedDate;
      const start = new Date(selected.getFullYear(), selected.getMonth(), selected.getDate(), hours + 1);
      const end = new Date(selected.getFullYear(), selected.getMonth(), selected.getDate(), hours + 2);
      let firstResource;
      if (scheduler.group) {
        const resources = scheduler.resources || [];
        const group3 = scheduler.group || {};
        const grouped = groupResources(group3, resources);
        if (grouped.length > 0) {
          firstResource = grouped[0].data[0];
        }
      }
      scheduler.create.emit({
        start: ZonedDate.fromLocalDate(start, scheduler.timezone).toLocalDate(),
        end: ZonedDate.fromLocalDate(end, scheduler.timezone).toLocalDate(),
        isAllDay: false,
        resources: [firstResource],
        originalEvent: e,
        sender: scheduler
      });
    }
  }, {
    match: (e) => e.keyCode >= Keys.Digit1 && e.keyCode <= Keys.Digit9 && withModifiers(e, Modifiers.AltKey),
    action: (e) => {
      const scheduler = this.scheduler;
      const viewIndex = e.keyCode - Keys.Digit0 - 1;
      const views = scheduler.views.toArray();
      const view2 = views[viewIndex];
      if (view2) {
        this.zone.run(() => {
          const prevented = scheduler.onNavigationAction({
            type: "view-change",
            view: view2
          });
          if (!prevented) {
            this.changeDetector.markForCheck();
            this.focusWait();
          }
        });
      }
    }
  }, {
    match: (e) => e.keyCode === Keys.F10 && noModifiers(e),
    action: (e) => {
      this.zone.run(() => {
        e.preventDefault();
        this.scheduler.onNavigationAction({
          type: "focus-toolbar"
        });
        this.focusWait();
      });
    }
  }, {
    match: (e) => e.keyCode === Keys.KeyT && noModifiers(e),
    action: () => {
      this.zone.run(() => {
        this.scheduler.onNavigationAction({
          type: "today"
        });
        this.focusWait();
      });
    }
  }, {
    match: (e) => e.keyCode === Keys.KeyB && noModifiers(e),
    action: () => {
      this.zone.run(() => {
        this.scheduler.onNavigationAction({
          type: "toggle-business-hours"
        });
        this.focusWait();
      });
    }
  }, {
    match: (e) => (e.keyCode === Keys.ArrowLeft || e.keyCode === Keys.ArrowRight) && withModifiers(e, Modifiers.ShiftKey),
    action: (e) => {
      const type = e.keyCode === Keys.ArrowLeft ? "prev" : "next";
      this.zone.run(() => {
        this.scheduler.onNavigationAction({
          type
        });
        this.focusWait();
      });
    }
  }, {
    match: (e) => (e.keyCode === Keys.ArrowUp || e.keyCode === Keys.ArrowLeft) && noModifiers(e) && !isContentWrapper(e.target),
    action: (e) => {
      if (e.target.tagName === CALENDAR_TAG) {
        return;
      }
      if (this.isInToolbarTemplate(e.target)) {
        return;
      }
      const prevented = this.scheduler.onNavigationAction({
        type: "focus-prev"
      });
      if (!prevented) {
        const item = this.focusService.activeItem;
        const isFirstEvent = item.containerType === "content" && item.element.nativeElement.matches(":first-of-type");
        const isUpArrow = e.keyCode === Keys.ArrowUp;
        isFirstEvent && isUpArrow ? this.focusService.focusToolbar() : this.focusService.focusNext({
          offset: -1
        });
        e.preventDefault();
      }
    }
  }, {
    match: (e) => (e.keyCode === Keys.ArrowDown || e.keyCode === Keys.ArrowRight) && noModifiers(e) && !isContentWrapper(e.target),
    action: (e) => {
      if (e.target.tagName === CALENDAR_TAG) {
        return;
      }
      if (this.isInToolbarTemplate(e.target)) {
        return;
      }
      const prevented = this.scheduler.onNavigationAction({
        type: "focus-next"
      });
      if (!prevented) {
        const isInToolbar = this.focusService.activeItem.containerType === "toolbar";
        const offset2 = 1;
        if (e.keyCode === Keys.ArrowDown && isInToolbar) {
          const focusableElementsArray = Array.from(this.focusService.focusableItems);
          const firstFocusableContentElementIndex = focusableElementsArray.findIndex((item) => item.containerType === "content");
          if (firstFocusableContentElementIndex > -1) {
            this.focusService.focusByIndex(firstFocusableContentElementIndex);
            e.preventDefault();
            return;
          }
        }
        this.focusService.focusNext({
          offset: offset2
        });
        e.preventDefault();
      }
    }
  }];
  taskShortcuts = [{
    match: (e) => (e.keyCode === Keys.Delete || e.keyCode === Keys.Backspace) && noModifiers(e),
    action: (e, event2) => {
      this.viewState.emitEvent("remove", {
        event: event2,
        dataItem: event2.dataItem
      });
      e.preventDefault();
    }
  }, {
    match: (e) => e.keyCode === Keys.Enter && noModifiers(e),
    action: (e, event2) => {
      this.viewState.emitEvent("eventDblClick", {
        type: "dblclick",
        event: event2,
        originalEvent: e
      });
      e.preventDefault();
    }
  }];
  subs = new Subscription();
  constructor(scheduler, domEvents, focusService, zone, changeDetector, viewState, dialogsService) {
    this.scheduler = scheduler;
    this.domEvents = domEvents;
    this.focusService = focusService;
    this.zone = zone;
    this.changeDetector = changeDetector;
    this.viewState = viewState;
    this.dialogsService = dialogsService;
    this.subs.add(this.domEvents.keydown.subscribe((e) => this.onKeydown(e)));
    this.subs.add(this.scheduler.eventKeydown.subscribe((e) => this.onEventKeydown(e)));
  }
  onKeydown(e) {
    const match = this.shortcuts.find((shortcut) => shortcut.match(e));
    if (match && !this.dialogsService.isOpen) {
      match.action(e);
    }
  }
  onEventKeydown(e) {
    const match = this.taskShortcuts.find((shortcut) => shortcut.match(e.originalEvent));
    if (match && !this.dialogsService.isOpen) {
      match.action(e.originalEvent, e.event);
    }
  }
  focusWait() {
    this.viewState.layoutEnd.pipe(take(1)).subscribe(() => this.focusService.focus());
  }
  isInToolbarTemplate(element) {
    const isInToolbar = element.closest(".k-scheduler-toolbar");
    const isInBuiltInElement = element.closest(".k-toolbar-group") || element.closest(".k-scheduler-views") || element.closest(".k-views-dropdown");
    return isInToolbar && !isInBuiltInElement;
  }
  static ɵfac = function ShortcutsDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ShortcutsDirective)(ɵɵdirectiveInject(SchedulerComponent), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(FocusService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewStateService), ɵɵdirectiveInject(DialogsService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ShortcutsDirective,
    selectors: [["kendo-scheduler"]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ShortcutsDirective, [{
    type: Directive,
    args: [{
      selector: "kendo-scheduler",
      standalone: true
    }]
  }], function() {
    return [{
      type: SchedulerComponent
    }, {
      type: DomEventsService
    }, {
      type: FocusService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewStateService
    }, {
      type: DialogsService
    }];
  }, null);
})();
var KENDO_SCHEDULERPDF = [PDFComponent, PDFCommandDirective];
var KENDO_SCHEDULER = [
  SchedulerComponent,
  SchedulerCustomMessagesComponent,
  SchedulerViewDirective,
  DataBindingDirective,
  SlotSelectableDirective,
  PDFComponent,
  PDFCommandDirective,
  ShortcutsDirective,
  // views
  AgendaViewComponent,
  DayViewComponent,
  MonthViewComponent,
  MultiDayViewComponent,
  MultiWeekViewComponent,
  TimelineMonthViewComponent,
  TimelineViewComponent,
  TimelineWeekViewComponent,
  WeekViewComponent,
  WorkWeekViewComponent,
  YearViewComponent,
  // editing
  ReactiveEditingDirective,
  RecurrenceEditorComponent,
  TimeZoneEditorComponent,
  // toolbar
  ToolbarNavigationComponent,
  ToolbarTemplateDirective,
  ToolbarViewSelectorComponent,
  // templates
  AgendaDateTemplateDirective,
  AgendaTimeTemplateDirective,
  AllDayEventTemplateDirective,
  AllDaySlotTemplateDirective,
  DateHeaderTemplateDirective,
  EventTemplateDirective,
  EditDialogTemplateDirective,
  GroupHeaderTemplateDirective,
  MajorTimeHeaderTemplateDirective,
  MinorTimeHeaderTemplateDirective,
  MonthDaySlotTemplateDirective,
  MultiWeekDaySlotTemplateDirective,
  TimeSlotTemplateDirective
];
var SchedulerModule = class _SchedulerModule {
  static ɵfac = function SchedulerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SchedulerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _SchedulerModule,
    imports: [SchedulerComponent, SchedulerCustomMessagesComponent, SchedulerViewDirective, DataBindingDirective, SlotSelectableDirective, PDFComponent, PDFCommandDirective, ShortcutsDirective, AgendaViewComponent, DayViewComponent, MonthViewComponent, MultiDayViewComponent, MultiWeekViewComponent, TimelineMonthViewComponent, TimelineViewComponent, TimelineWeekViewComponent, WeekViewComponent, WorkWeekViewComponent, YearViewComponent, ReactiveEditingDirective, RecurrenceEditorComponent, TimeZoneEditorComponent, ToolbarNavigationComponent, ToolbarTemplateDirective, ToolbarViewSelectorComponent, AgendaDateTemplateDirective, AgendaTimeTemplateDirective, AllDayEventTemplateDirective, AllDaySlotTemplateDirective, DateHeaderTemplateDirective, EventTemplateDirective, EditDialogTemplateDirective, GroupHeaderTemplateDirective, MajorTimeHeaderTemplateDirective, MinorTimeHeaderTemplateDirective, MonthDaySlotTemplateDirective, MultiWeekDaySlotTemplateDirective, TimeSlotTemplateDirective],
    exports: [SchedulerComponent, SchedulerCustomMessagesComponent, SchedulerViewDirective, DataBindingDirective, SlotSelectableDirective, PDFComponent, PDFCommandDirective, ShortcutsDirective, AgendaViewComponent, DayViewComponent, MonthViewComponent, MultiDayViewComponent, MultiWeekViewComponent, TimelineMonthViewComponent, TimelineViewComponent, TimelineWeekViewComponent, WeekViewComponent, WorkWeekViewComponent, YearViewComponent, ReactiveEditingDirective, RecurrenceEditorComponent, TimeZoneEditorComponent, ToolbarNavigationComponent, ToolbarTemplateDirective, ToolbarViewSelectorComponent, AgendaDateTemplateDirective, AgendaTimeTemplateDirective, AllDayEventTemplateDirective, AllDaySlotTemplateDirective, DateHeaderTemplateDirective, EventTemplateDirective, EditDialogTemplateDirective, GroupHeaderTemplateDirective, MajorTimeHeaderTemplateDirective, MinorTimeHeaderTemplateDirective, MonthDaySlotTemplateDirective, MultiWeekDaySlotTemplateDirective, TimeSlotTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      ToolbarService,
      ViewContextService,
      ViewStateService,
      EditService,
      IconsService,
      PopupService,
      ResizeBatchService,
      // DateInputsModule providers
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      NavigationService,
      TimePickerDOMService,
      HoursService,
      MinutesService,
      SecondsService,
      MillisecondsService,
      DayPeriodService,
      // DropDownsModule providers
      DialogContainerService,
      DialogService,
      WindowService,
      WindowContainerService
    ],
    imports: [SchedulerComponent, PDFCommandDirective, AgendaViewComponent, DayViewComponent, MonthViewComponent, MultiDayViewComponent, MultiWeekViewComponent, TimelineMonthViewComponent, TimelineViewComponent, TimelineWeekViewComponent, WeekViewComponent, WorkWeekViewComponent, YearViewComponent, RecurrenceEditorComponent, TimeZoneEditorComponent, ToolbarNavigationComponent, ToolbarViewSelectorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchedulerModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_SCHEDULER],
      exports: [...KENDO_SCHEDULER],
      providers: [
        ToolbarService,
        ViewContextService,
        ViewStateService,
        EditService,
        IconsService,
        PopupService,
        ResizeBatchService,
        // DateInputsModule providers
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        NavigationService,
        TimePickerDOMService,
        HoursService,
        MinutesService,
        SecondsService,
        MillisecondsService,
        DayPeriodService,
        // DropDownsModule providers
        DialogContainerService,
        DialogService,
        WindowService,
        WindowContainerService
      ]
    }]
  }], null, null);
})();
var RecurrenceEditorCustomMessagesComponent = class _RecurrenceEditorCustomMessagesComponent extends Messages$1 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function RecurrenceEditorCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecurrenceEditorCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RecurrenceEditorCustomMessagesComponent,
    selectors: [["kendo-recurrence-editor-messages"]],
    features: [ɵɵProvidersFeature([{
      provide: Messages$1,
      useExisting: forwardRef(() => _RecurrenceEditorCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function RecurrenceEditorCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecurrenceEditorCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages$1,
        useExisting: forwardRef(() => RecurrenceEditorCustomMessagesComponent)
      }],
      selector: "kendo-recurrence-editor-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DATE_FORMATS2 = ["yyyyMMddTHHmmssSSSXXX", "yyyyMMddTHHmmssXXX", "yyyyMMddTHHmmss", "yyyyMMddTHHmm", "yyyyMMddTHH", "yyyyMMdd"];
var BaseEditService = class {
  /**
   * The model field map that will be used during the reading and updating of data items.
   */
  fields;
  /**
   * An observable stream with the current events.
   */
  events;
  /**
   * An array of the currently loaded events which is populated by the derived class.
   */
  data = [];
  /**
   * The source subject for the `events` observable.
   */
  source = new BehaviorSubject([]);
  createdItems = [];
  updatedItems = [];
  deletedItems = [];
  getId;
  getRecurrenceId;
  getRecurrenceRule;
  getRecurrenceExceptions;
  getStart;
  setId;
  setRecurrenceRule;
  setRecurrenceExceptions;
  setRecurrenceId;
  /**
   * Initializes the base edit service.
   *
   * @param fields - A field map that will be used for reading and modifying model objects. Defaults to the [`SchedulerEvent`]({% slug api_scheduler_schedulerevent %}) fields.
   */
  constructor(fields) {
    this.events = this.source.asObservable();
    this.fields = __spreadValues(__spreadValues({}, defaultModelFields), fields);
    this.getId = getter2(this.fields.id);
    this.getRecurrenceId = getter2(this.fields.recurrenceId);
    this.getRecurrenceRule = getter2(this.fields.recurrenceRule);
    this.getRecurrenceExceptions = getter2(this.fields.recurrenceExceptions);
    this.getStart = getter2(this.fields.start);
    this.setId = setter2(this.fields.id);
    this.setRecurrenceRule = setter2(this.fields.recurrenceRule);
    this.setRecurrenceExceptions = setter2(this.fields.recurrenceExceptions);
    this.setRecurrenceId = setter2(this.fields.recurrenceId);
  }
  create(event2) {
    this.logCreate(event2);
    this.saveChanges();
  }
  /*
   * Creates an exception to a recurring series.
   *
   * The `createException` method performs the following operations:
   * * Adds the start date of the event to the `recurrenceExceptions` of the master event (recurrence head).
   * * Creates a new event that stores the recurrence exception itself.
   */
  createException(event2, value2) {
    const exception = this.buildException(value2);
    this.logRemoveOccurrence(event2);
    this.logCreate(exception);
    this.saveChanges();
  }
  update(event2, value2) {
    this.assignValues(event2, value2);
    this.logUpdate(event2);
    this.saveChanges();
  }
  remove(event2) {
    this.logRemove(event2);
    this.saveChanges();
  }
  removeSeries(event2) {
    const id = this.getId(event2);
    const recurrenceId = this.getRecurrenceId(event2);
    const isHead = this.isRecurrenceHead(event2);
    this.removeItemAndExceptions(isHead ? id : recurrenceId);
    this.saveChanges();
  }
  removeOccurrence(event2) {
    this.logRemoveOccurrence(event2);
    this.saveChanges();
  }
  /**
   * Returns the master recurring event for a specified recurring event.
   *
   * @param event - An event from the recurrence series.
   * @returns the master recurring event for the series.
   */
  findRecurrenceMaster(event2) {
    const id = this.getId(event2);
    const recurrenceId = this.getRecurrenceId(event2);
    const headId = this.isRecurrenceHead(event2) ? id : recurrenceId;
    const index = this.itemIndex(headId, this.data);
    return this.data[index];
  }
  /**
   * Checks if the event is part of the recurrence series.
   *
   * @param event - The event that will be checked.
   * @returns `true` if the event is an occurrence, an exception, or a master event. Otherwise, returns `false`.
   */
  isRecurring(event2) {
    return isRecurring(event2, this.fields);
  }
  /**
   * Checks if the event is a recurrence exception.
   *
   * @param event - The event that will be checked.
   * @returns `true` if the event is a unique event which belongs to a recurrence series. Otherwise, returns `false`.
   */
  isException(event2) {
    return isException2(event2, this.fields);
  }
  /**
   * Returns a Boolean value which indicates if the event is new.
   * If the `ID` field is defined, the default implementation returns `true`.
   * Can be overridden to implement different conditions.
   *
   * @param event - The event that will be checked.
   */
  isNew(event2) {
    const id = this.getId(event2);
    return !isPresent4(id);
  }
  /**
   * Returns the next `ID` that will be used for new events.
   * The default implementation returns `undefined`.
   */
  nextId() {
    return void 0;
  }
  /**
   * Copies values to the target model instance.
   * To copy the top-level fields, the base implementation uses
   * [`Object.assign`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).
   * To copy nested fields, override `assignValues` and handle the model-specific cases.
   *
   * @param target - The target object that will receive the field values.
   * @param source - The source object from which the fields will be read.
   */
  assignValues(target, source) {
    cloneTo(source, target);
  }
  /**
   * Clones an existing model object.
   * To copy the top-level model fields, the base creates an empty object and calls [`assignValues`](#toc-assignvalues).
   * To create models of the correct type, override `cloneEvent`.
   *
   * @param event - The model instance to copy.
   * @returns TEvent - The new model instance.
   */
  cloneEvent(event2) {
    const result = {};
    this.assignValues(result, event2);
    return result;
  }
  /**
   * A utility method which parses recurrence exception dates in an ISO format.
   *
   * @example
   * ```ts-no-run
   *   const exdates = '20180614T060000Z;20180615T060000Z';
   *   const result = super.parseExceptions(exdates);
   *
   *   // console.log(result);
   *   // Array [ Date 2018-06-14T03:00:00.000Z, Date 2018-06-15T03:00:00.000Z ]
   * ```
   *
   * @param value - A comma-separated list of ISO-formatted dates.
   * @returns Date[] - The recurrence exceptions as local dates.
   */
  parseExceptions(value2) {
    if (!isPresent4(value2) || value2 === "") {
      return [];
    }
    return value2.split(";").map((ex) => parseDate(ex, DATE_FORMATS2) || void 0);
  }
  /**
   * A utility method which serializes recurrence exception dates in an ISO format.
   *
   * @example
   * ```ts-no-run
   *   const exdates = [ new Date(2018, 5, 14, 3, 0, 0), new Date(2018, 5, 15, 3, 0, 0) ];
   *   const result = super.serializeExceptions(exdates);
   *
   *   // console.log(result);
   *   // '20180614T060000Z;20180615T060000Z'
   * ```
   *
   * @param value - An array of `Date` instances.
   * @returns string - A comma-separated list of ISO-formatted dates.
   */
  serializeExceptions(exceptions) {
    if (!exceptions || exceptions.length === 0) {
      return "";
    }
    return exceptions.map((date) => formatDate(toLocalDate(date), "yyyyMMddTHHmmss") + "Z").join(";");
  }
  reset() {
    this.data = [];
    this.deletedItems = [];
    this.updatedItems = [];
    this.createdItems = [];
  }
  itemIndex(id, items) {
    for (let idx2 = 0; idx2 < items.length; idx2++) {
      if (this.getId(items[idx2]) === id) {
        return idx2;
      }
    }
    return -1;
  }
  buildException(item) {
    const fields = this.fields;
    const head = this.findRecurrenceMaster(item);
    const copy = this.cloneEvent(item);
    assignField(copy, head, fields.id);
    this.setId(copy, this.nextId());
    this.setRecurrenceRule(copy, void 0);
    this.setRecurrenceId(copy, this.getId(head));
    return copy;
  }
  isRecurrenceHead(item) {
    const id = this.getId(item);
    const recurrenceRule = this.getRecurrenceRule(item);
    return !!(id && recurrenceRule);
  }
  logCreate(item) {
    this.data = [...this.data, item];
    this.source.next(this.data);
    this.createdItems.push(item);
  }
  logUpdate(item) {
    const id = this.getId(item);
    if (!this.isNew(item)) {
      const index = this.itemIndex(id, this.updatedItems);
      if (index !== -1) {
        this.updatedItems.splice(index, 1, item);
      } else {
        this.updatedItems.push(item);
      }
    } else {
      const index = this.createdItems.indexOf(item);
      this.createdItems.splice(index, 1, item);
    }
  }
  logRemove(item) {
    const id = this.getId(item);
    let index = this.itemIndex(id, this.data);
    this.data = this.data.filter((_, i) => i !== index);
    this.source.next(this.data);
    index = this.itemIndex(id, this.createdItems);
    if (index >= 0) {
      this.createdItems.splice(index, 1);
    } else {
      this.deletedItems.push(item);
    }
    index = this.itemIndex(id, this.updatedItems);
    if (index >= 0) {
      this.updatedItems.splice(index, 1);
    }
  }
  logRemoveOccurrence(event2) {
    const head = this.findRecurrenceMaster(event2);
    const exceptionDate = this.getStart(event2);
    const currentExceptions = this.getRecurrenceExceptions(head) || [];
    this.setRecurrenceExceptions(head, [...currentExceptions, exceptionDate]);
    this.logUpdate(head);
  }
  removeItemAndExceptions(itemId) {
    this.deletedItems = this.deletedItems.concat(this.data.filter((ev) => this.getRecurrenceId(ev) === itemId || this.getId(ev) === itemId));
  }
  hasChanges() {
    return this.deletedItems.length + this.updatedItems.length + this.createdItems.length > 0;
  }
  saveChanges() {
    if (!this.hasChanges()) {
      return;
    }
    this.save(this.createdItems, this.updatedItems, this.deletedItems);
    this.reset();
  }
};
var PDFModule = class _PDFModule {
  static ɵfac = function PDFModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PDFModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PDFModule,
    imports: [PDFComponent, PDFCommandDirective],
    exports: [PDFComponent, PDFCommandDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [PDFCommandDirective]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_SCHEDULERPDF],
      exports: [...KENDO_SCHEDULERPDF],
      providers: [IconsService]
    }]
  }], null, null);
})();
export {
  AddEvent,
  AgendaDateTemplateDirective,
  AgendaTimeTemplateDirective,
  AgendaViewComponent,
  AllDayEventTemplateDirective,
  AllDaySlotTemplateDirective,
  BaseEditService,
  CancelEvent,
  CrudOperation,
  DataBindingDirective,
  DateChangeEvent,
  DateHeaderTemplateDirective,
  DaySlotDirective,
  DayTimeSlotService,
  DayTimeViewItemComponent,
  DayViewComponent,
  DragEndEvent,
  DragEvent,
  DragStartEvent,
  EditDialogComponent,
  EditDialogTemplateDirective,
  EditEvent,
  EditEventBase,
  EditMode,
  EndRuleRadioButtonDirective,
  EventClickEvent,
  EventKeydownEvent,
  EventTemplateDirective,
  FocusService,
  FocusableDirective,
  GroupHeaderTemplateDirective,
  HintContainerComponent,
  IsSlotSelectedArgs,
  KENDO_SCHEDULER,
  KENDO_SCHEDULERPDF,
  LoadingComponent,
  LocalizedMessagesDirective3 as LocalizedMessagesDirective,
  MajorTimeHeaderTemplateDirective,
  MinorTimeHeaderTemplateDirective,
  MonthDaySlotTemplateDirective,
  MonthViewComponent,
  MultiDayViewComponent,
  MultiWeekDaySlotTemplateDirective,
  MultiWeekViewComponent,
  MultipleResourceEditorComponent,
  NavigateEvent,
  PDFCommandDirective,
  PDFComponent,
  PDFExportEvent,
  PDFModule,
  PDFService,
  ReactiveEditingDirective,
  RecurrenceEditorComponent,
  RecurrenceEditorCustomMessagesComponent,
  RecurrenceEditorLocalizedMessagesDirective,
  RecurrenceEndRuleEditorComponent,
  RecurrenceFrequencyEditorComponent,
  RecurrenceIntervalEditorComponent,
  RecurrenceMonthlyYearlyEditorComponent,
  RecurrenceWeekdayRuleEditorComponent,
  RemoveEvent,
  RepeatOnRadioButtonDirective,
  RepeatPipe,
  ResizeEndEvent,
  ResizeEvent,
  ResizeHintComponent,
  ResizeStartEvent,
  ResourceIteratorPipe,
  SaveEvent,
  SchedulerComponent,
  SchedulerCustomMessagesComponent,
  SchedulerDateTimePickerComponent,
  SchedulerModule,
  SchedulerView,
  SchedulerViewDirective,
  ShortcutsDirective,
  SingleResourceEditorComponent,
  SlotClickEvent,
  SlotDragEndEvent,
  SlotDragEvent,
  SlotDragStartEvent,
  SlotSelectableDirective,
  SortPipe,
  TimeSlotDirective,
  TimeSlotTemplateDirective,
  TimeZoneEditorComponent,
  TimelineBase,
  TimelineMonthViewComponent,
  TimelineMultiDayViewComponent,
  TimelineViewComponent,
  TimelineWeekViewComponent,
  ToolbarNavigationComponent,
  ToolbarService,
  ToolbarTemplateDirective,
  ToolbarViewSelectorComponent,
  VIEW_EVENT_MAP,
  ViewContextService,
  ViewFooterComponent,
  ViewStateService,
  WeekViewComponent,
  WorkHoursFooterDirective,
  WorkWeekViewComponent,
  YearViewComponent,
  YearViewInternalComponent
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@progress_kendo-angular-scheduler.js.map
